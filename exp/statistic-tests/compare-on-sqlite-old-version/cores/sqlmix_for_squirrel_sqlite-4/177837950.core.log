GNU gdb (Ubuntu 9.2-0ubuntu1~20.04.1) 9.2
Copyright (C) 2020 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type "show copying" and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
    <http://www.gnu.org/software/gdb/documentation/>.

For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from /root/sqlite_driver_fast...
(gdb) Starting program: /root/sqlite_driver_fast < "/root/out/default/crashes/id:000124,sig:06,src:021692+004609,time:3839059,execs:745722,op:merge.so,pos:0"
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
SQL: [;PRAGMA vdbe_trace=on;]
VDBE Trace:
   0 Init             0    1    0               00 Start at 1
   1 Expire           0    0    0               00 
   2 Halt             0    0    0               00 
SQL: [SELECT x'616263'
;]
VDBE Trace:
   0 Init             0    1    0               00 Start at 1
   1 Explain          1    0    0 SCAN CONSTANT ROW 00 
   2 Blob             3    1    0 abc           00 r[1]=abc (len=3)
REG[1] =  tx3[616263|abc]
   3 ResultRow        1    1    0               00 output=r[1]
REG[1] =  tx3[616263|abc]
   4 Halt             0    0    0               00 
SQL: [;
;SELECT char(0x4d) LIKE char(0x306d);]
VDBE Trace:
   0 Init             0    5    0               00 Start at 5
   5 Integer       12397    5    0               00 r[5]=12397
REG[5] =  i:12397
   6 Function0        1    5    3 char(-1)      01 r[3]=func(r[5])
REG[5] =  i:12397
REG[3] =   z3[...](8)
   7 Integer         77    6    0               00 r[6]=77
REG[6] =  i:77
   8 Function0        1    6    4 char(-1)      01 r[4]=func(r[6])
REG[6] =  i:77
REG[4] =   z1[M](8)
   9 Function0        3    3    2 like(2)       02 r[2]=func(r[3..4])
REG[3] =   z3[...](8)
REG[4] =   z1[M](8)
REG[2] =  i:0
  10 Goto             0    1    0               00 
   1 Explain          1    0    0 SCAN CONSTANT ROW 00 
   2 Copy             2    1    0               00 r[1]=r[2]
REG[1] =  i:0
   3 ResultRow        1    1    0               00 output=r[1]
REG[1] =  i:0
   4 Halt             0    0    0               00 
VDBE Trace:
   0 Init             0   13    0               00 Start at 13
  13 Transaction      0    0    0 0             00 usesStmtJournal=0
  14 Goto             0    1    0               00 
   1 Noop             1    7    0               00 
   2 OpenRead         0    1    0 5             00 root=1 iDb=0; sqlite_master
   3 Explain          3    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   12    0               00 
  12 Halt             0    0    0               00 
SQL: [;CREATE TABLE blue(red);]
VDBE Trace:
   0 Init             0   28    0               00 Start at 28
  28 Transaction      0    1    0 0             01 usesStmtJournal=0
  29 Goto             0    1    0               00 
   1 ReadCookie       0    3    2               00 
REG[3] =  i:0
   2 If               3    5    0               00 
REG[3] =  i:0
   3 SetCookie        0    2    4               00 
   4 SetCookie        0    5    1               00 
   5 CreateBtree      0    2    1               00 r[2]=root iDb=0 flags=1
REG[2] =  i:2
   6 OpenWrite        0    1    0 5             00 root=1 iDb=0
   7 NewRowid         0    1    0               00 r[1]=rowid
REG[1] =  i:1
   8 Blob             6    3    0              00 r[3]= (len=6)
REG[3] =  tx6[060000000000|......]
   9 Insert           0    3    1               08 intkey=r[1] data=r[3]
REG[3] =  tx6[060000000000|......]
REG[1] =  i:1
  10 Close            0    0    0               00 
  11 Close            0    0    0               00 
  12 Null             0    4    5               00 r[4..5]=NULL
REG[4] =  NULL
  13 OpenWrite        1    1    0 5             00 root=1 iDb=0; sqlite_master
  14 Explain         14    0    0 SEARCH TABLE sqlite_master USING INTEGER PRIMARY KEY (rowid=?) 00 
  15 SeekRowid        1   17    1               00 intkey=r[1]
REG[1] =  i:1
  16 Rowid            1    5    0               00 r[5]=rowid
REG[5] =  i:1
  17 IsNull           5   25    0               00 if r[5]==NULL goto 25
REG[5] =  i:1
  18 String8          0    6    0 table         00 r[6]='table'
REG[6] =   t5[table](8)
  19 String8          0    7    0 blue          00 r[7]='blue'
REG[7] =   t4[blue](8)
  20 String8          0    8    0 blue          00 r[8]='blue'
REG[8] =   t4[blue](8)
  21 Copy             2    9    0               00 r[9]=r[2]
REG[9] =  i:2
  22 String8          0   10    0 CREATE TABLE blue(red) 00 r[10]='CREATE TABLE blue(red)'
REG[10] =   t22[CREATE TABLE blue(red)](8)
  23 MakeRecord       6    5    4 BBBDB         00 r[4]=mkrec(r[6..10])
REG[6] =   t5[table](8)
REG[7] =   t4[blue](8)
REG[8] =   t4[blue](8)
REG[9] =  i:2
REG[10] =   t22[CREATE TABLE blue(red)](8)
REG[4] =  sx42[0617151501397461626C65626C7565626C7565024352454154|.....9tableblueblue.CREAT]
  24 Insert           1    4    5               00 intkey=r[5] data=r[4]
REG[4] =  sx42[0617151501397461626C65626C7565626C7565024352454154|.....9tableblueblue.CREAT]
REG[5] =  i:1
  25 SetCookie        0    1    1               00 
  26 ParseSchema      0    0    0 tbl_name='blue' AND type!='trigger' 00 
VDBE Trace:
   0 Init             0   17    0               00 Start at 17
  17 Transaction      0    0    1 0             00 usesStmtJournal=0
  18 String8          0    2    0 blue          00 r[2]='blue'
REG[2] =   t4[blue](8)
  19 String8          0    3    0 trigger       00 r[3]='trigger'
REG[3] =   t7[trigger](8)
  20 Goto             0    1    0               00 
   1 Noop             1    7    0               00 
   2 OpenRead         0    1    0 5             00 root=1 iDb=0; sqlite_master
   3 Explain          3    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   16    0               00 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s4[blue](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t4[blue](8)
REG[1] =   s4[blue](8)
   7 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[table](8)
   8 Eq               3   15    1 (BINARY)      52 if r[1]==r[3] goto 15
REG[3] =   t7[trigger](8)
REG[1] =   s5[table](8)
   9 Column           0    0    4               00 r[4]=sqlite_master.type
REG[4] =   s5[table](8)
  10 Column           0    1    5               00 r[5]=sqlite_master.name
REG[5] =   s4[blue](8)
  11 Column           0    2    6               00 r[6]=sqlite_master.tbl_name
REG[6] =   s4[blue](8)
  12 Column           0    3    7               00 r[7]=sqlite_master.rootpage
REG[7] =  i:2
  13 Column           0    4    8               00 r[8]=sqlite_master.sql
REG[8] =   s22[CREATE TABLE blue(red)](8)
  14 ResultRow        4    5    0               00 output=r[4..8]
REG[4] =   s5[table](8)
REG[5] =   s4[blue](8)
REG[6] =   s4[blue](8)
REG[7] =  i:2
REG[8] =   s22[CREATE TABLE blue(red)](8)
  15 Next             0    5    0               01 
  16 Halt             0    0    0               00 
  27 Halt             0    0    0               00 
SQL: [SELECT typeof(CAST(123 AS text))
;]
VDBE Trace:
   0 Init             0    5    0               00 Start at 5
   5 Integer        123    3    0               00 r[3]=123
REG[3] =  i:123
   6 Cast             3   66    0               00 affinity(r[3])
REG[3] =  i:123
   7 Function0        1    3    2 typeof(1)     01 r[2]=func(r[3])
REG[3] =   s3[123](8)
REG[2] =   t4[text](8)
   8 Goto             0    1    0               00 
   1 Explain          1    0    0 SCAN CONSTANT ROW 00 
   2 Copy             2    1    0               00 r[1]=r[2]
REG[1] =   t4[text](8)
   3 ResultRow        1    1    0               00 output=r[1]
REG[1] =   t4[text](8)
   4 Halt             0    0    0               00 
SQL: [SELECT typeof(CAST(123 AS integer))
;]
VDBE Trace:
   0 Init             0    5    0               00 Start at 5
   5 Integer        123    3    0               00 r[3]=123
REG[3] =  i:123
   6 Cast             3   68    0               00 affinity(r[3])
REG[3] =  i:123
   7 Function0        1    3    2 typeof(1)     01 r[2]=func(r[3])
REG[3] =  i:123
REG[2] =   t7[integer](8)
   8 Goto             0    1    0               00 
   1 Explain          1    0    0 SCAN CONSTANT ROW 00 
   2 Copy             2    1    0               00 r[1]=r[2]
REG[1] =   t7[integer](8)
   3 ResultRow        1    1    0               00 output=r[1]
REG[1] =   t7[integer](8)
   4 Halt             0    0    0               00 
SQL: [;INSERT INTO blue VALUES(1);]
VDBE Trace:
   0 Init             0    7    0               00 Start at 7
   7 Transaction      0    1    1 0             01 usesStmtJournal=0
   8 Goto             0    1    0               00 
   1 OpenWrite        0    2    0 1             00 root=2 iDb=0; blue
   2 NewRowid         0    1    0               00 r[1]=rowid
REG[1] =  i:1
   3 Integer          1    2    0               00 r[2]=1
REG[2] =  i:1
   4 MakeRecord       2    1    3               00 r[3]=mkrec(r[2])
REG[3] =  sx2[0209|..]
   5 Insert           0    3    1 blue          39 intkey=r[1] data=r[3]
REG[3] =  sx2[0209|..]
REG[1] =  i:1
   6 Halt             0    0    0               00 
SQL: [;
;SELECT (SELECT DISTINCT sum(red) OVER() FROM blue ORDER BY 1), red FROM blue 
  ORDER BY 1;]
VDBE Trace:
   0 Init             0   77    0               00 Start at 77
  77 Transaction      0    0    1 0             01 usesStmtJournal=0
  78 Goto             0    1    0               00 
   1 SorterOpen       2    4    0 k(1,B)        00 
   2 OpenRead         0    2    0 1             00 root=2 iDb=0; blue
   3 Explain          3    0    0 SCAN TABLE blue 00 
   4 Rewind           0   68    0               00 
   5 Column           0    0    2               00 r[2]=blue.red
REG[2] =  i:1
   6 Integer         63    4    0               00 r[4]=63; return address
REG[4] =  i:63
   7 Once             0   63    0               00 
   8 Explain          8    0    0 SCALAR SUBQUERY 1 00 
   9 Null             0    5    5               00 r[5..5]=NULL; Init subquery result
REG[5] =  NULL
  10 Null             0    6    0               00 r[6]=NULL
REG[6] =  NULL
  11 Null             0    8    0               00 r[8]=NULL
REG[8] =  NULL
  12 OpenEphemeral    3    2    0               00 nColumn=2
  13 OpenDup          4    3    0               00 
  14 OpenDup          5    3    0               00 
  15 OpenDup          6    3    0               00 
  16 InitCoroutine   10   26   17               00 
  26 Noop             8    3    0               00 
  27 Integer          1   13    0               00 r[13]=1; LIMIT counter
REG[13] =  i:1
  28 SorterOpen       9    1    0 k(1,B)        00 
  29 Integer          0   15    0               00 r[15]=0; clear abort flag
REG[15] =  i:0
  30 Null             0   18   18               00 r[18..18]=NULL
REG[18] =  NULL
  31 Gosub           17   61    0               00 
REG[17] =  i:31
  61 Integer          0   14    0               00 r[14]=0; indicate accumulator empty
REG[14] =  i:0
  62 Return          17    0    0               00 
REG[17] =  i:31
  32 Explain         32    8    0 SCAN SUBQUERY 3 00 
  33 InitCoroutine   10    0   17               00 
  34 Yield           10   40    0               00 next row of 
REG[10] =  i:16
REG[10] =  i:34
  17 Explain         17    8    0 CO-ROUTINE 3  00 
  18 OpenRead         1    2    0 1             00 root=2 iDb=0; blue
  19 Explain         19   17    0 SCAN TABLE blue 00 
  20 Rewind           1   25    0               00 
  21 Column           1    0   11               00 r[11]=blue.red
REG[11] =  i:1
  22 Column           1    0   12               00 r[12]=blue.red
REG[12] =  i:1
  23 Yield           10    0    0               00 
REG[10] =  i:34
REG[10] =  i:23
  35 Explain         35    8    0 USE TEMP B-TREE FOR DISTINCT 00 
  36 SCopy            9   20    0               00 r[20]=r[9]
REG[20] =  undefined
  37 MakeRecord      20    1   21               00 r[21]=mkrec(r[20])

Program received signal SIGABRT, Aborted.
__GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:50
(gdb) #0  __GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:50
#1  0x00007f7cf6d7a859 in __GI_abort () at abort.c:79
#2  0x00007f7cf6d7a729 in __assert_fail_base (fmt=0x7f7cf6f10588 "%s%s%s:%u: %s%sAssertion `%s' failed.\n%n", assertion=0x222142 "memIsValid(pRec)", file=0x2291f4 "sqlite3.c", line=86917, function=<optimized out>)
    at assert.c:92
#3  0x00007f7cf6d8bfd6 in __GI___assert_fail (assertion=0x222142 "memIsValid(pRec)", file=0x2291f4 "sqlite3.c", line=86917, function=0x216a86 "int sqlite3VdbeExec(Vdbe *)") at assert.c:101
#4  0x00000000003d3831 in sqlite3VdbeExec (p=0x15ae6d0) at sqlite3.c:86917
#5  0x000000000041ba74 in sqlite3Step (p=0x15ae6d0) at sqlite3.c:82300
#6  0x0000000000293d5d in sqlite3_step (pStmt=0x15ae6d0) at sqlite3.c:82365
#7  0x0000000000258a39 in main (argc=1, argv=0x7ffdc61fa9f8) at target.cc:139
(gdb) quit
A debugging session is active.

	Inferior 1 [process 44447] will be killed.

Quit anyway? (y or n) [answered Y; input not from terminal]
