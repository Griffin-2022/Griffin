GNU gdb (Ubuntu 9.2-0ubuntu1~20.04.1) 9.2
Copyright (C) 2020 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type "show copying" and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
    <http://www.gnu.org/software/gdb/documentation/>.

For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from /root/sqlite_driver_fast...
(gdb) Starting program: /root/sqlite_driver_fast < "/root/out/default/crashes/id:000267,sig:06,src:025206+004607,time:11780542,execs:2952397,op:merge.so,pos:0"
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
SQL: [;PRAGMA vdbe_trace=on;]
VDBE Trace:
   0 Init             0    1    0               00 Start at 1
   1 Expire           0    0    0               00 
   2 Halt             0    0    0               00 
SQL: [;INSERT INTO blue VALUES(1), (2), (3);]
VDBE Trace:
   0 Init             0   17    0               00 Start at 17
  17 Transaction      0    1    1 0             01 usesStmtJournal=0
  18 Goto             0    1    0               00 
   1 InitCoroutine    3   10    2               00 
  10 OpenWrite        0    2    0 1             00 root=2 iDb=0; blue
  11 Yield            3   16    0               00 
REG[3] =  i:1
REG[3] =  i:11
   2 Explain          2    0    0 SCAN 3 CONSTANT ROWS 00 
   3 Integer          1    2    0               00 r[2]=1
REG[2] =  i:1
   4 Yield            3    0    0               00 
REG[3] =  i:11
REG[3] =  i:4
  12 NewRowid         0    1    0               00 r[1]=rowid
REG[1] =  i:1
  13 MakeRecord       2    1    4               00 r[4]=mkrec(r[2])
REG[4] =  sx2[0209|..]
  14 Insert           0    4    1 blue          39 intkey=r[1] data=r[4]
REG[4] =  sx2[0209|..]
REG[1] =  i:1
  15 Goto             0   11    0               00 
  11 Yield            3   16    0               00 
REG[3] =  i:4
REG[3] =  i:11
   5 Integer          2    2    0               00 r[2]=2
REG[2] =  i:2
   6 Yield            3    0    0               00 
REG[3] =  i:11
REG[3] =  i:6
  12 NewRowid         0    1    0               00 r[1]=rowid
REG[1] =  i:2
  13 MakeRecord       2    1    4               00 r[4]=mkrec(r[2])
REG[4] =  sx3[020102|...]
  14 Insert           0    4    1 blue          39 intkey=r[1] data=r[4]
REG[4] =  sx3[020102|...]
REG[1] =  i:2
  15 Goto             0   11    0               00 
  11 Yield            3   16    0               00 
REG[3] =  i:6
REG[3] =  i:11
   7 Integer          3    2    0               00 r[2]=3
REG[2] =  i:3
   8 Yield            3    0    0               00 
REG[3] =  i:11
REG[3] =  i:8
  12 NewRowid         0    1    0               00 r[1]=rowid
REG[1] =  i:3
  13 MakeRecord       2    1    4               00 r[4]=mkrec(r[2])
REG[4] =  sx3[020103|...]
  14 Insert           0    4    1 blue          39 intkey=r[1] data=r[4]
REG[4] =  sx3[020103|...]
REG[1] =  i:3
  15 Goto             0   11    0               00 
  11 Yield            3   16    0               00 
REG[3] =  i:8
REG[3] =  i:11
   9 EndCoroutine     3    0    0               00 
REG[3] =  i:11
  16 Halt             0    0    0               00 
SQL: [;
;DROP TABLE IF EXISTS t4;]
VDBE Trace:
   0 Init             0    2    0               00 Start at 2
   2 Transaction      0    0    1 0             01 usesStmtJournal=0
   3 Goto             0    1    0               00 
   1 Halt             0    0    0               00 
SQL: [;CREATE UNIQUE INDEX green ON blue(red,abs(red),red);]
VDBE Trace:
   0 Init             0   40    0               00 Start at 40
  40 Transaction      0    1    1 0             01 usesStmtJournal=1
  41 Goto             0    1    0               00 
   1 Noop             0   39    0               00 
   2 CreateBtree      0    1    2               00 r[1]=root iDb=0 flags=2
REG[1] =  i:3
   3 OpenWrite        0    1    0 5             00 root=1 iDb=0; sqlite_master
   4 NewRowid         0    2    0               00 r[2]=rowid
REG[2] =  i:2
   5 String8          0    3    0 index         00 r[3]='index'
REG[3] =   t5[index](8)
   6 String8          0    4    0 green         00 r[4]='green'
REG[4] =   t5[green](8)
   7 String8          0    5    0 blue          00 r[5]='blue'
REG[5] =   t4[blue](8)
   8 Copy             1    6    0               00 r[6]=r[1]
REG[6] =  i:3
   9 String8          0    7    0 CREATE UNIQUE INDEX green ON blue(red,abs(red),red) 00 r[7]='CREATE UNIQUE INDEX green ON blue(red,abs(red),red)'
REG[7] =   t51[CREATE UNIQUE INDEX green](8)
  10 MakeRecord       3    5    8 BBBDB         00 r[8]=mkrec(r[3..7])
REG[3] =   t5[index](8)
REG[4] =   t5[green](8)
REG[5] =   t4[blue](8)
REG[6] =  i:3
REG[7] =   t51[CREATE UNIQUE INDEX green](8)
REG[8] =  sx72[061717150173696E646578677265656E626C75650343524541|.....sindexgreenblue.CREA]
  11 Insert           0    8    2               18 intkey=r[2] data=r[8]
REG[8] =  sx72[061717150173696E646578677265656E626C75650343524541|.....sindexgreenblue.CREA]
REG[2] =  i:2
  12 SorterOpen       3    0    3 k(4,,,,)      00 
  13 OpenRead         1    2    0 1             00 root=2 iDb=0; blue
  14 Rewind           1   23    0               00 
  15 Column           1    0   10               00 r[10]=blue.red
REG[10] =  i:1
  16 Column           1    0   14               00 r[14]=blue.red
REG[14] =  i:1
  17 PureFunc0        0   14   11 abs(1)        01 
REG[14] =  i:1
REG[11] =  i:1
  18 Column           1    0   12               00 r[12]=blue.red
REG[12] =  i:1
  19 Rowid            1   13    0               00 r[13]=rowid
REG[13] =  i:1
  20 MakeRecord      10    4    9               00 r[9]=mkrec(r[10..13])
REG[9] =  sx5[0509090909|.....]
  21 SorterInsert     3    9    0               00 key=r[9]
REG[9] =  sx5[0509090909|.....]
  22 Next             1   15    0               00 
  15 Column           1    0   10               00 r[10]=blue.red
REG[10] =  i:2
  16 Column           1    0   14               00 r[14]=blue.red
REG[14] =  i:2
  17 PureFunc         0   14   11 abs(1)        01 
REG[14] =  i:2
REG[11] =  i:2
  18 Column           1    0   12               00 r[12]=blue.red
REG[12] =  i:2
  19 Rowid            1   13    0               00 r[13]=rowid
REG[13] =  i:2
  20 MakeRecord      10    4    9               00 r[9]=mkrec(r[10..13])
REG[9] =  sx9[050101010102020202|.........]
  21 SorterInsert     3    9    0               00 key=r[9]
REG[9] =  sx9[050101010102020202|.........]
  22 Next             1   15    0               00 
  15 Column           1    0   10               00 r[10]=blue.red
REG[10] =  i:3
  16 Column           1    0   14               00 r[14]=blue.red
REG[14] =  i:3
  17 PureFunc         0   14   11 abs(1)        01 
REG[14] =  i:3
REG[11] =  i:3
  18 Column           1    0   12               00 r[12]=blue.red
REG[12] =  i:3
  19 Rowid            1   13    0               00 r[13]=rowid
REG[13] =  i:3
  20 MakeRecord      10    4    9               00 r[9]=mkrec(r[10..13])
REG[9] =  sx9[050101010103030303|.........]
  21 SorterInsert     3    9    0               00 key=r[9]
REG[9] =  sx9[050101010103030303|.........]
  22 Next             1   15    0               00 
  23 OpenWrite        2    1    0 k(4,,,,)      11 root=1 iDb=0
  24 SorterSort       3   33    0               00 
  25 Goto             0   29    0               00 
  29 SorterData       3    9    2               00 r[9]=data
  30 SeekEnd          2    0    0               00 
  31 IdxInsert        2    9    0               10 key=r[9]
REG[9] =  sx5[0509090909|.....]
  32 SorterNext       3   26    0               00 
  26 Abortable        0    0    0               00 
  27 SorterCompare    3   25    9 3             00 if key(3)!=trim(r[9],3) goto 25
  25 Goto             0   29    0               00 
  29 SorterData       3    9    2               00 r[9]=data
  30 SeekEnd          2    0    0               00 
  31 IdxInsert        2    9    0               10 key=r[9]
REG[9] =  sx9[050101010102020202|.........]
  32 SorterNext       3   26    0               00 
  26 Abortable        0    0    0               00 
  27 SorterCompare    3   25    9 3             00 if key(3)!=trim(r[9],3) goto 25
  25 Goto             0   29    0               00 
  29 SorterData       3    9    2               00 r[9]=data
  30 SeekEnd          2    0    0               00 
  31 IdxInsert        2    9    0               10 key=r[9]
REG[9] =  sx9[050101010103030303|.........]
  32 SorterNext       3   26    0               00 
  33 Close            1    0    0               00 
  34 Close            2    0    0               00 
  35 Close            3    0    0               00 
  36 SetCookie        0    1    2               00 
  37 ParseSchema      0    0    0 name='green' AND type='index' 00 
VDBE Trace:
   0 Init             0   17    0               00 Start at 17
  17 Transaction      0    0    2 0             00 usesStmtJournal=0
  18 String8          0    2    0 green         00 r[2]='green'
REG[2] =   t5[green](8)
  19 String8          0    3    0 index         00 r[3]='index'
REG[3] =   t5[index](8)
  20 Goto             0    1    0               00 
   1 Noop             1    7    0               00 
   2 OpenRead         0    1    0 5             00 root=1 iDb=0; sqlite_master
   3 Explain          3    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   16    0               00 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s4[blue](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t5[green](8)
REG[1] =   s4[blue](8)
  15 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s5[green](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t5[green](8)
REG[1] =   s5[green](8)
   7 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[index](8)
   8 Ne               3   15    1 (BINARY)      52 if r[1]!=r[3] goto 15
REG[3] =   t5[index](8)
REG[1] =   s5[index](8)
   9 Column           0    0    4               00 r[4]=sqlite_master.type
REG[4] =   s5[index](8)
  10 Column           0    1    5               00 r[5]=sqlite_master.name
REG[5] =   s5[green](8)
  11 Column           0    2    6               00 r[6]=sqlite_master.tbl_name
REG[6] =   s4[blue](8)
  12 Column           0    3    7               00 r[7]=sqlite_master.rootpage
REG[7] =  i:3
  13 Column           0    4    8               00 r[8]=sqlite_master.sql
REG[8] =   s51[CREATE UNIQUE INDEX green](8)
  14 ResultRow        4    5    0               00 output=r[4..8]
REG[4] =   s5[index](8)
REG[5] =   s5[green](8)
REG[6] =   s4[blue](8)
REG[7] =  i:3
REG[8] =   s51[CREATE UNIQUE INDEX green](8)
  15 Next             0    5    0               01 
  16 Halt             0    0    0               00 
  38 Expire           0    1    0               00 
  39 Halt             0    0    0               00 
SQL: [;PRAGMA integrity_check;]
VDBE Trace:
   0 Init             0   78   75               00 Start at 78
  78 Transaction      0    0    2 0             01 usesStmtJournal=0
  79 Transaction      1    0    0 0             01 usesStmtJournal=0
  80 Goto             0    1    0               00 
   1 Integer         99    1    0               00 r[1]=99
REG[1] =  i:99
   2 IntegrityCk      2    3    1 [2,3,1]       00 
   3 IsNull           2    9    0               00 if r[2]==NULL goto 9
REG[2] =  NULL
   9 OpenRead         1    2    0 1             00 root=2 iDb=0; blue
  10 OpenRead         2    3    0 k(4,,,,)      00 root=3 iDb=0; green
  11 Integer          0    7    0               00 r[7]=0
REG[7] =  i:0
  12 Integer          0    8    0               00 r[8]=0
REG[8] =  i:0
  13 Rewind           1   41    0               00 
  14 AddImm           7    1    0               00 r[7]=r[7]+1
REG[7] =  i:0
  15 Column           1    0    3               80 r[3]=
REG[3] =  i:1
  16 Column           1    0   10               00 r[10]=blue.red
REG[10] =  i:1
  17 Column           1    0   14               00 r[14]=blue.red
REG[14] =  i:1
  18 PureFunc0        0   14   11 abs(1)        01 
REG[14] =  i:1
REG[11] =  i:1
  19 Column           1    0   12               00 r[12]=blue.red
REG[12] =  i:1
  20 Rowid            1   13    0               00 r[13]=rowid
REG[13] =  i:1
  21 AddImm           8    1    0               00 r[8]=r[8]+1
REG[8] =  i:0
  22 Found            2   32   10 4             00 key=r[10..13]
REG[10] =  i:1
REG[11] =  i:1
REG[12] =  i:1
REG[13] =  i:1
  32 IsNull          10   40    0               00 if r[10]==NULL goto 40
REG[10] =  i:1
  33 IsNull          11   40    0               00 if r[11]==NULL goto 40
REG[11] =  i:1
  34 IsNull          12   40    0               00 if r[12]==NULL goto 40
REG[12] =  i:1
  35 Next             2   37    0               00 
  37 IdxGT            2   40   10 3             00 key=r[10..12]
REG[10] =  i:1
REG[11] =  i:1
REG[12] =  i:1
  40 Next             1   14    0               00 
  14 AddImm           7    1    0               00 r[7]=r[7]+1
REG[7] =  i:1
  15 Column           1    0    3               80 r[3]=
REG[3] =  i:2
  16 Column           1    0   10               00 r[10]=blue.red
REG[10] =  i:2
  17 Column           1    0   14               00 r[14]=blue.red
REG[14] =  i:2
  18 PureFunc         0   14   11 abs(1)        01 
REG[14] =  i:2
REG[11] =  i:2
  19 Column           1    0   12               00 r[12]=blue.red
REG[12] =  i:2
  20 Rowid            1   13    0               00 r[13]=rowid
REG[13] =  i:2
  21 AddImm           8    1    0               00 r[8]=r[8]+1
REG[8] =  i:1
  22 Found            2   32   10 4             00 key=r[10..13]
REG[10] =  i:2
REG[11] =  i:2
REG[12] =  i:2
REG[13] =  i:2
  32 IsNull          10   40    0               00 if r[10]==NULL goto 40
REG[10] =  i:2
  33 IsNull          11   40    0               00 if r[11]==NULL goto 40
REG[11] =  i:2
  34 IsNull          12   40    0               00 if r[12]==NULL goto 40
REG[12] =  i:2
  35 Next             2   37    0               00 
  37 IdxGT            2   40   10 3             00 key=r[10..12]
REG[10] =  i:2
REG[11] =  i:2
REG[12] =  i:2
  40 Next             1   14    0               00 
  14 AddImm           7    1    0               00 r[7]=r[7]+1
REG[7] =  i:2
  15 Column           1    0    3               80 r[3]=
REG[3] =  i:3
  16 Column           1    0   10               00 r[10]=blue.red
REG[10] =  i:3
  17 Column           1    0   14               00 r[14]=blue.red
REG[14] =  i:3
  18 PureFunc         0   14   11 abs(1)        01 
REG[14] =  i:3
REG[11] =  i:3
  19 Column           1    0   12               00 r[12]=blue.red
REG[12] =  i:3
  20 Rowid            1   13    0               00 r[13]=rowid
REG[13] =  i:3
  21 AddImm           8    1    0               00 r[8]=r[8]+1
REG[8] =  i:2
  22 Found            2   32   10 4             00 key=r[10..13]
REG[10] =  i:3
REG[11] =  i:3
REG[12] =  i:3
REG[13] =  i:3
  32 IsNull          10   40    0               00 if r[10]==NULL goto 40
REG[10] =  i:3
  33 IsNull          11   40    0               00 if r[11]==NULL goto 40
REG[11] =  i:3
  34 IsNull          12   40    0               00 if r[12]==NULL goto 40
REG[12] =  i:3
  35 Next             2   37    0               00 
  36 Goto             0   40    0               00 
  40 Next             1   14    0               00 
  41 String8          0    2    0 wrong # of entries in index  00 r[2]='wrong # of entries in index '
REG[2] =   t28[wrong # of entries in ind](8)
  42 Count            2    3    0               00 r[3]=count()
REG[3] =  i:3
  43 Eq               8   49    3               90 if r[3]==r[8] goto 49
REG[8] =  i:3
REG[3] =  i:3
  49 OpenRead         1    1    0 5             00 root=1 iDb=0; sqlite_master
  50 Integer          0    7    0               00 r[7]=0
REG[7] =  i:0
  51 Rewind           1   55    0               00 
  52 AddImm           7    1    0               00 r[7]=r[7]+1
REG[7] =  i:0
  53 Column           1    4    3               80 r[3]=
REG[3] =   s22[CREATE TABLE blue(red)](8)
  54 Next             1   52    0               00 
  52 AddImm           7    1    0               00 r[7]=r[7]+1
REG[7] =  i:1
  53 Column           1    4    3               80 r[3]=
REG[3] =   s51[CREATE UNIQUE INDEX green](8)
  54 Next             1   52    0               00 
  55 String8          0    2    0 wrong # of entries in index  00 r[2]='wrong # of entries in index '
REG[2] =   t28[wrong # of entries in ind](8)
  56 IntegrityCk      2    1    1 [1]           01 
  57 IsNull           2   63    0               00 if r[2]==NULL goto 63
REG[2] =  NULL
  63 OpenRead         1    1    1 5             00 root=1 iDb=1; sqlite_temp_master
  64 Integer          0    7    0               00 r[7]=0
REG[7] =  i:0
  65 Rewind           1   69    0               00 
  69 String8          0    2    0 wrong # of entries in index  00 r[2]='wrong # of entries in index '
REG[2] =   t28[wrong # of entries in ind](8)
  70 AddImm           1  -99    0               00 r[1]=r[1]+-99
REG[1] =  i:99
  71 IfNotZero        1   74    0               00 if r[1]!=0 then r[1]--, goto 74
REG[1] =  i:0
  72 String8          0    3    0 ok            00 r[3]='ok'
REG[3] =   t2[ok](8)
  73 ResultRow        3    1    0               00 output=r[3]
REG[3] =   t2[ok](8)
  74 Halt             0    0    0               00 
SQL: [;
;VALUES(2),(count(*)OVER());]
VDBE Trace:
   0 Init             0    1    0               00 Start at 1
   1 Explain          1    0    0 SCAN 2 CONSTANT ROWS 00 
   2 Integer          2    1    0               00 r[1]=2
REG[1] =  i:2
   3 ResultRow        1    1    0               00 output=r[1]
REG[1] =  i:2
   4 Copy             0    1    0               00 r[1]=r[0]
REG[1] =  undefined
   5 ResultRow        1    1    0               00 output=r[1]

Program received signal SIGABRT, Aborted.
__GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:50
(gdb) #0  __GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:50
#1  0x00007f580fda0859 in __GI_abort () at abort.c:79
#2  0x00007f580fda0729 in __assert_fail_base (fmt=0x7f580ff36588 "%s%s%s:%u: %s%sAssertion `%s' failed.\n%n", assertion=0x216ab9 "memIsValid(&pMem[i])", file=0x2291f4 "sqlite3.c", line=85404, function=<optimized out>)
    at assert.c:92
#3  0x00007f580fdb1fd6 in __GI___assert_fail (assertion=0x216ab9 "memIsValid(&pMem[i])", file=0x2291f4 "sqlite3.c", line=85404, function=0x216a86 "int sqlite3VdbeExec(Vdbe *)") at assert.c:101
#4  0x00000000003cd341 in sqlite3VdbeExec (p=0x1da5830) at sqlite3.c:85404
#5  0x000000000041ba74 in sqlite3Step (p=0x1da5830) at sqlite3.c:82300
#6  0x0000000000293d5d in sqlite3_step (pStmt=0x1da5830) at sqlite3.c:82365
#7  0x0000000000258a39 in main (argc=1, argv=0x7ffe5c7193f8) at target.cc:139
(gdb) quit
A debugging session is active.

	Inferior 1 [process 45582] will be killed.

Quit anyway? (y or n) [answered Y; input not from terminal]
