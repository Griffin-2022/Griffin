GNU gdb (Ubuntu 9.2-0ubuntu1~20.04.1) 9.2
Copyright (C) 2020 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type "show copying" and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
    <http://www.gnu.org/software/gdb/documentation/>.

For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from /root/sqlite_driver_fast...
(gdb) Starting program: /root/sqlite_driver_fast < "/root/out/default/crashes/id:000069,sig:06,src:018177+017193,time:22220559,execs:4555085,op:merge.so,pos:0"
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
parser: [[[CREATE TABLE t1(x, CHECK (x COLLATE mycollate IN ('one', 'two', 'three')));PRAGMA mmap_size = 1000000 ;;
ROLLBACK;SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;PRAGMA integrity_check ;;
SELECT x-x FROM t1;;
SELECT x<x FROM t1;;
SELECT x=x FROM t1;;
PRAGMA foreign_keys = ON;;
SELECT (x+x)*x FROM t1;SELECT name, rootpage, sql FROM "temp".sqlite_temp_master ORDER BY rowid;PRAGMA temp.cache_size = 1;;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;;
SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;;
SELECT x, x
   FROM t1
  WHERE (x = 'A/B' OR
           ((x > 'A/B/') AND (x < 'A/B0')))
    AND x IS NOT NULL;;
SELECT x==1 OR x=2 FROM t1;;
CREATE INDEX t1_content ON t1(x ASC,  x DESC) ;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
CREATE INDEX docid ON t1(x DESC, x ASC) ;;
UPDATE t1 SET x=1;COMMIT;SELECT x, x FROM t1 WHERE x = 1 AND x IN (2, 4, 5) ORDER BY x ASC, x ASC;;
UPDATE t1 SET x=1, x=63;SELECT * FROM t1 INNER JOIN t1 AS x;;
CREATE INDEX c0content ON t1(x ASC,  x ASC) ;;
UPDATE t1 SET x=1, x=64;;
CREATE INDEX t1_segments ON t1(x ASC,  x DESC) ;;
SELECT x, x FROM t1 WHERE x = 3 AND x IN (2, 4, 5) ORDER BY x DESC, x ASC;SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE name='docid' AND type='index' ORDER BY rowid;;
UPDATE t1 SET x=32, x=3;;
UPDATE t1 SET x=25, x=11;;
SELECT coalesce(not x,99) FROM t1;;
SELECT coalesce(x IS NULL AND x=5,99) FROM t1;;
SELECT 5 not between x and x FROM t1;SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE name='docid' AND type='index' ORDER BY rowid;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
UPDATE t1 SET x=NULL, x=3;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1_content' AND type!='trigger' ORDER BY rowid;;
CREATE UNIQUE INDEX blockid ON t1(x ASC);;
SELECT coalesce(x&x,99) FROM t1;;
SELECT 1%0 FROM t1;;
SELECT coalesce(x>>x,99) FROM t1;CREATE TABLE block(t1_segdir);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;
SELECT
    SrcWord, t1.x
    FROM 
      (SELECT 'FACTORING' AS SrcWord UNION SELECT 'SWIMMING' AS SrcWord )
    LEFT JOIN 
      t1
    WHERE t1.x= (
      SELECT BeginningId FROM (
        SELECT SrcWord, B.x as BeginningId, B.x || E.x As Connected
        FROM t1 B LEFT JOIN t1 E ON B.x=E.x
        WHERE Connected=SrcWord LIMIT 1
      )
    )
;;
INSERT INTO t1(x) VALUES(10);;
SELECT * FROM block;;
SELECT x IS x FROM t1;;
SELECT x+x FROM t1;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;
SELECT ( 
      SELECT x FROM (
        SELECT * FROM t1 WHERE x=out.x ORDER BY x LIMIT 10 OFFSET 1
      ) WHERE x=out.x
    ) FROM t1 AS out;;
SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;;
UPDATE t1 SET x=-9223372036854775807, x=-2;;
UPDATE t1 SET x=-9223372036854775808, x=0;;
UPDATE t1 SET x=9223372036854775807, x=0;;
UPDATE t1 SET x=9223372036854775807, x=-1;;
CREATE INDEX level ON t1(x ASC,  x ASC) ;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
UPDATE t1 SET x=-3037000500, x=-3037000500;PRAGMA journal_mode = DELETE;;
SELECT x NOT LIKE x FROM t1;;
SELECT x-x FROM t1;;
VACUUM;;
UPDATE t1 SET x=1e300, x=1e300;;
SELECT x notnull FROM t1;;
UPDATE t1 SET x='0.0', x='abc';;
UPDATE t1 SET x='abxyzzycy', x='A%CX';;
UPDATE t1 SET x='abc', x='aáˆ´_c';;
UPDATE t1 SET x='abcdefg', x='a*[^def]g';;
UPDATE t1 SET x='ABC', x='A[^A-D]C';;
UPDATE t1 SET x='ABC', x='A[^]B]C';;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;SELECT x FROM t1 WHERE x<10 AND x>8 ORDER BY x;SELECT typeof(00000009223372036854775807);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;PRAGMA max_page_count = 100;VACUUM ;SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 388
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: [[[CREATE TABLE x(type text,name text,tbl_name text,rootpage int,sql text)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 388
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP ID]
parser: Input 'ID' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 190
parser: Shift 'ID', pending reduce 335
parser: Return. Stack=[create_table LP nm ID]
parser: Input 'COMMA' with pending reduce 335
parser: Reduce 335 [typename ::= ID|STRING], go to state 190.
parser: ... then shift 'typename', go to state 390
parser: Reduce 334 [typetoken ::= typename], go to state 190.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 376
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 150
parser: Reduce 330 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 190
parser: Shift 'ID', pending reduce 335
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'COMMA' with pending reduce 335
parser: Reduce 335 [typename ::= ID|STRING], go to state 190.
parser: ... then shift 'typename', go to state 390
parser: Reduce 334 [typetoken ::= typename], go to state 190.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 383
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 151
parser: Reduce 329 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 190
parser: Shift 'ID', pending reduce 335
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'COMMA' with pending reduce 335
parser: Reduce 335 [typename ::= ID|STRING], go to state 190.
parser: ... then shift 'typename', go to state 390
parser: Reduce 334 [typetoken ::= typename], go to state 190.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 383
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 151
parser: Reduce 329 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 190
parser: Shift 'ID', pending reduce 335
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'COMMA' with pending reduce 335
parser: Reduce 335 [typename ::= ID|STRING], go to state 190.
parser: ... then shift 'typename', go to state 390
parser: Reduce 334 [typetoken ::= typename], go to state 190.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 383
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 151
parser: Reduce 329 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 190
parser: Shift 'ID', pending reduce 335
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'RP' with pending reduce 335
parser: Reduce 335 [typename ::= ID|STRING], go to state 190.
parser: ... then shift 'typename', go to state 390
parser: Reduce 334 [typetoken ::= typename], go to state 190.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 383
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 151
parser: Reduce 329 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Reduce 60 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 538
parser: Shift 'RP', go to state 361
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 361
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 328
parser: Reduce 328 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'FROM' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'DOT' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Shift 'DOT', go to state 245
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID' in state 245
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'ORDER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 245.
parser: ... then shift 'nm', pending reduce 109
parser: Reduce 109 [dbnm ::= DOT nm], go to state 349.
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[CREATE TABLE x(type text,name text,tbl_name text,rootpage int,sql text)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 388
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP ID]
parser: Input 'ID' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 190
parser: Shift 'ID', pending reduce 335
parser: Return. Stack=[create_table LP nm ID]
parser: Input 'COMMA' with pending reduce 335
parser: Reduce 335 [typename ::= ID|STRING], go to state 190.
parser: ... then shift 'typename', go to state 390
parser: Reduce 334 [typetoken ::= typename], go to state 190.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 376
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 150
parser: Reduce 330 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 190
parser: Shift 'ID', pending reduce 335
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'COMMA' with pending reduce 335
parser: Reduce 335 [typename ::= ID|STRING], go to state 190.
parser: ... then shift 'typename', go to state 390
parser: Reduce 334 [typetoken ::= typename], go to state 190.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 383
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 151
parser: Reduce 329 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 190
parser: Shift 'ID', pending reduce 335
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'COMMA' with pending reduce 335
parser: Reduce 335 [typename ::= ID|STRING], go to state 190.
parser: ... then shift 'typename', go to state 390
parser: Reduce 334 [typetoken ::= typename], go to state 190.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 383
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 151
parser: Reduce 329 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 190
parser: Shift 'ID', pending reduce 335
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'COMMA' with pending reduce 335
parser: Reduce 335 [typename ::= ID|STRING], go to state 190.
parser: ... then shift 'typename', go to state 390
parser: Reduce 334 [typetoken ::= typename], go to state 190.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 383
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 151
parser: Reduce 329 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 190
parser: Shift 'ID', pending reduce 335
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'RP' with pending reduce 335
parser: Reduce 335 [typename ::= ID|STRING], go to state 190.
parser: ... then shift 'typename', go to state 390
parser: Reduce 334 [typetoken ::= typename], go to state 190.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 383
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 151
parser: Reduce 329 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Reduce 60 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 538
parser: Shift 'RP', go to state 361
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 361
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 328
parser: Reduce 328 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP ID]
parser: Input 'COMMA' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 190
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 376
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 150
parser: Reduce 330 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'CHECK' in state 34
parser: Shift 'CHECK', go to state 468
parser: Return. Stack=[create_table LP columnlist COMMA CHECK]
parser: Input 'LP' in state 468
parser: Shift 'LP', go to state 88
parser: Return. Stack=[create_table LP columnlist COMMA CHECK LP]
parser: Input 'ID' in state 88
parser: Shift 'ID', go to state 416
parser: Return. Stack=[create_table LP columnlist COMMA CHECK LP ID]
parser: Input 'COLLATE' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 88.
parser: ... then shift 'expr', go to state 45
parser: Shift 'COLLATE', go to state 415
parser: Return. Stack=[create_table LP columnlist COMMA CHECK LP expr COLLATE]
parser: Input 'ID' in state 415
parser: Shift 'ID', pending reduce 171
parser: Return. Stack=[create_table LP columnlist COMMA CHECK LP expr COLLATE ID]
parser: Input 'IN' with pending reduce 171
parser: Reduce 171 [expr ::= expr COLLATE ID|STRING], go to state 88.
parser: ... then shift 'expr', go to state 45
parser: Shift 'IN', pending reduce 200
parser: Return. Stack=[create_table LP columnlist COMMA CHECK LP expr IN]
parser: Input 'LP' with pending reduce 200
parser: Reduce 200 [in_op ::= IN], go to state 45.
parser: ... then shift 'in_op', go to state 209
parser: Shift 'LP', go to state 3
parser: Return. Stack=[create_table LP columnlist COMMA CHECK LP expr in_op LP]
parser: Input 'STRING' in state 3
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[create_table LP columnlist COMMA CHECK LP expr in_op LP STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 3.
parser: ... then shift 'term', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 3.
parser: ... then shift 'nexprlist', go to state 517
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[create_table LP columnlist COMMA CHECK LP expr in_op LP nexprlist COMMA]
parser: Input 'STRING' in state 107
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[create_table LP columnlist COMMA CHECK LP expr in_op LP nexprlist COMMA STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 3.
parser: ... then shift 'nexprlist', go to state 517
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[create_table LP columnlist COMMA CHECK LP expr in_op LP nexprlist COMMA]
parser: Input 'STRING' in state 107
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[create_table LP columnlist COMMA CHECK LP expr in_op LP nexprlist COMMA STRING]
parser: Input 'RP' in state 537
parser: Reduce 168 [term ::= STRING], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 3.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 3.
parser: ... then shift 'exprlist', go to state 519
parser: Shift 'RP', pending reduce 202
parser: Return. Stack=[create_table LP columnlist COMMA CHECK LP expr in_op LP exprlist RP]
parser: Input 'RP' with pending reduce 202
parser: Reduce 202 [expr ::= expr in_op LP exprlist RP], go to state 88.
parser: ... then shift 'expr', go to state 45
parser: Shift 'RP', go to state 326
parser: Return. Stack=[create_table LP columnlist COMMA CHECK LP expr RP]
parser: Input 'RP' in state 326
parser: Reduce 68 [onconf ::=].
parser: ... then shift 'onconf', pending reduce 65
parser: Reduce 65 [tcons ::= CHECK LP expr RP onconf], go to state 34.
parser: ... then shift 'tcons', go to state 278
parser: Reduce 341 [conslist_opt ::= COMMA conslist], go to state 362.
parser: ... then shift 'conslist_opt', go to state 538
parser: Shift 'RP', go to state 361
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 361
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: [[[UPDATE 'main'.sqlite_master SET type='table', name='t1', tbl_name='t1', rootpage=#2, sql='CREATE TABLE t1(x, CHECK (x COLLATE mycollate IN (''one'', ''two'', ''three'')))' WHERE rowid=#1]]]
parser: Input 'UPDATE' in state 0
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'UPDATE', go to state 299
parser: Return. Stack=[with UPDATE]
parser: Input 'STRING' in state 299
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', go to state 165
parser: Shift 'STRING', pending reduce 332
parser: Return. Stack=[with UPDATE orconf STRING]
parser: Input 'DOT' with pending reduce 332
parser: Reduce 332 [nm ::= STRING], go to state 165.
parser: ... then shift 'nm', go to state 393
parser: Shift 'DOT', go to state 218
parser: Return. Stack=[with UPDATE orconf nm DOT]
parser: Input 'ID' in state 218
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf nm DOT ID]
parser: Input 'SET' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 218.
parser: ... then shift 'nm', go to state 429
parser: Reduce 113 [xfullname ::= nm DOT nm], go to state 165.
parser: ... then shift 'xfullname', go to state 271
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 428
parser: Shift 'SET', go to state 153
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET]
parser: Input 'ID' in state 153
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 153.
parser: ... then shift 'nm', go to state 442
parser: Shift 'EQ', go to state 84
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ]
parser: Input 'STRING' in state 84
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 84.
parser: ... then shift 'term', go to state 58
parser: Reduce 148 [setlist ::= nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'VARIABLE' in state 86
parser: Shift 'VARIABLE', pending reduce 170
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ VARIABLE]
parser: Input 'COMMA' with pending reduce 170
parser: Reduce 170 [expr ::= VARIABLE], go to state 86.
parser: ... then shift 'expr', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'WHERE' in state 537
parser: Reduce 168 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 416
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr EQ]
parser: Input 'VARIABLE' in state 117
parser: Shift 'VARIABLE', pending reduce 170
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr EQ VARIABLE]
parser: Input 'SEMI' with pending reduce 170
parser: Reduce 170 [expr ::= VARIABLE], go to state 117.
parser: ... then shift 'expr', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 270.
parser: ... then shift 'where_opt', pending reduce 145
parser: Reduce 145 [cmd ::= with UPDATE orconf xfullname indexed_opt SET setlist where_opt], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Input '$' with pending reduce 321
parser: Reduce 321 [ecmd ::= cmdx SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 317 [input ::= cmdlist], go to state 0.
parser: ... then shift 'input', pending reduce -2
parser: Accept!
parser: ... then shift 'create_table_args', pending reduce 328
parser: Reduce 328 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'FROM' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'STRING' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'STRING', pending reduce 332
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix STRING]
parser: Input 'DOT' with pending reduce 332
parser: Reduce 332 [nm ::= STRING], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Shift 'DOT', go to state 245
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID' in state 245
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 245.
parser: ... then shift 'nm', pending reduce 109
parser: Reduce 109 [dbnm ::= DOT nm], go to state 349.
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[SELECT distinct selcollist from WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND' in state 537
parser: Reduce 168 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'AND', go to state 120
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID' in state 120
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'NE' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Shift 'NE', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr NE]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr NE STRING]
parser: Input 'ORDER' in state 537
parser: Reduce 168 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Reduce 179 [expr ::= expr AND expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[CREATE TABLE t1(x, CHECK (x COLLATE mycollate IN ('one', 'two', 'three')))]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 388
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP ID]
parser: Input 'COMMA' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 190
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 376
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 150
parser: Reduce 330 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'CHECK' in state 34
parser: Shift 'CHECK', go to state 468
parser: Return. Stack=[create_table LP columnlist COMMA CHECK]
parser: Input 'LP' in state 468
parser: Shift 'LP', go to state 88
parser: Return. Stack=[create_table LP columnlist COMMA CHECK LP]
parser: Input 'ID' in state 88
parser: Shift 'ID', go to state 416
parser: Return. Stack=[create_table LP columnlist COMMA CHECK LP ID]
parser: Input 'COLLATE' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 88.
parser: ... then shift 'expr', go to state 45
parser: Shift 'COLLATE', go to state 415
parser: Return. Stack=[create_table LP columnlist COMMA CHECK LP expr COLLATE]
parser: Input 'ID' in state 415
parser: Shift 'ID', pending reduce 171
parser: Return. Stack=[create_table LP columnlist COMMA CHECK LP expr COLLATE ID]
parser: Input 'IN' with pending reduce 171
parser: Reduce 171 [expr ::= expr COLLATE ID|STRING], go to state 88.
parser: ... then shift 'expr', go to state 45
parser: Shift 'IN', pending reduce 200
parser: Return. Stack=[create_table LP columnlist COMMA CHECK LP expr IN]
parser: Input 'LP' with pending reduce 200
parser: Reduce 200 [in_op ::= IN], go to state 45.
parser: ... then shift 'in_op', go to state 209
parser: Shift 'LP', go to state 3
parser: Return. Stack=[create_table LP columnlist COMMA CHECK LP expr in_op LP]
parser: Input 'STRING' in state 3
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[create_table LP columnlist COMMA CHECK LP expr in_op LP STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 3.
parser: ... then shift 'term', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 3.
parser: ... then shift 'nexprlist', go to state 517
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[create_table LP columnlist COMMA CHECK LP expr in_op LP nexprlist COMMA]
parser: Input 'STRING' in state 107
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[create_table LP columnlist COMMA CHECK LP expr in_op LP nexprlist COMMA STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 3.
parser: ... then shift 'nexprlist', go to state 517
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[create_table LP columnlist COMMA CHECK LP expr in_op LP nexprlist COMMA]
parser: Input 'STRING' in state 107
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[create_table LP columnlist COMMA CHECK LP expr in_op LP nexprlist COMMA STRING]
parser: Input 'RP' in state 537
parser: Reduce 168 [term ::= STRING], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 3.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 3.
parser: ... then shift 'exprlist', go to state 519
parser: Shift 'RP', pending reduce 202
parser: Return. Stack=[create_table LP columnlist COMMA CHECK LP expr in_op LP exprlist RP]
parser: Input 'RP' with pending reduce 202
parser: Reduce 202 [expr ::= expr in_op LP exprlist RP], go to state 88.
parser: ... then shift 'expr', go to state 45
parser: Shift 'RP', go to state 326
parser: Return. Stack=[create_table LP columnlist COMMA CHECK LP expr RP]
parser: Input 'RP' in state 326
parser: Reduce 68 [onconf ::=].
parser: ... then shift 'onconf', pending reduce 65
parser: Reduce 65 [tcons ::= CHECK LP expr RP onconf], go to state 34.
parser: ... then shift 'tcons', go to state 278
parser: Reduce 341 [conslist_opt ::= COMMA conslist], go to state 362.
parser: ... then shift 'conslist_opt', go to state 538
parser: Shift 'RP', go to state 361
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 361
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 328
parser: Reduce 328 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[PRAGMA mmap_size = 1000000 ;;
ROLLBACK;SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;PRAGMA integrity_check ;;
SELECT x-x FROM t1;;
SELECT x<x FROM t1;;
SELECT x=x FROM t1;;
PRAGMA foreign_keys = ON;;
SELECT (x+x)*x FROM t1;SELECT name, rootpage, sql FROM "temp".sqlite_temp_master ORDER BY rowid;PRAGMA temp.cache_size = 1;;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;;
SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;;
SELECT x, x
   FROM t1
  WHERE (x = 'A/B' OR
           ((x > 'A/B/') AND (x < 'A/B0')))
    AND x IS NOT NULL;;
SELECT x==1 OR x=2 FROM t1;;
CREATE INDEX t1_content ON t1(x ASC,  x DESC) ;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
CREATE INDEX docid ON t1(x DESC, x ASC) ;;
UPDATE t1 SET x=1;COMMIT;SELECT x, x FROM t1 WHERE x = 1 AND x IN (2, 4, 5) ORDER BY x ASC, x ASC;;
UPDATE t1 SET x=1, x=63;SELECT * FROM t1 INNER JOIN t1 AS x;;
CREATE INDEX c0content ON t1(x ASC,  x ASC) ;;
UPDATE t1 SET x=1, x=64;;
CREATE INDEX t1_segments ON t1(x ASC,  x DESC) ;;
SELECT x, x FROM t1 WHERE x = 3 AND x IN (2, 4, 5) ORDER BY x DESC, x ASC;SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE name='docid' AND type='index' ORDER BY rowid;;
UPDATE t1 SET x=32, x=3;;
UPDATE t1 SET x=25, x=11;;
SELECT coalesce(not x,99) FROM t1;;
SELECT coalesce(x IS NULL AND x=5,99) FROM t1;;
SELECT 5 not between x and x FROM t1;SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE name='docid' AND type='index' ORDER BY rowid;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
UPDATE t1 SET x=NULL, x=3;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1_content' AND type!='trigger' ORDER BY rowid;;
CREATE UNIQUE INDEX blockid ON t1(x ASC);;
SELECT coalesce(x&x,99) FROM t1;;
SELECT 1%0 FROM t1;;
SELECT coalesce(x>>x,99) FROM t1;CREATE TABLE block(t1_segdir);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;
SELECT
    SrcWord, t1.x
    FROM 
      (SELECT 'FACTORING' AS SrcWord UNION SELECT 'SWIMMING' AS SrcWord )
    LEFT JOIN 
      t1
    WHERE t1.x= (
      SELECT BeginningId FROM (
        SELECT SrcWord, B.x as BeginningId, B.x || E.x As Connected
        FROM t1 B LEFT JOIN t1 E ON B.x=E.x
        WHERE Connected=SrcWord LIMIT 1
      )
    )
;;
INSERT INTO t1(x) VALUES(10);;
SELECT * FROM block;;
SELECT x IS x FROM t1;;
SELECT x+x FROM t1;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;
SELECT ( 
      SELECT x FROM (
        SELECT * FROM t1 WHERE x=out.x ORDER BY x LIMIT 10 OFFSET 1
      ) WHERE x=out.x
    ) FROM t1 AS out;;
SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;;
UPDATE t1 SET x=-9223372036854775807, x=-2;;
UPDATE t1 SET x=-9223372036854775808, x=0;;
UPDATE t1 SET x=9223372036854775807, x=0;;
UPDATE t1 SET x=9223372036854775807, x=-1;;
CREATE INDEX level ON t1(x ASC,  x ASC) ;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
UPDATE t1 SET x=-3037000500, x=-3037000500;PRAGMA journal_mode = DELETE;;
SELECT x NOT LIKE x FROM t1;;
SELECT x-x FROM t1;;
VACUUM;;
UPDATE t1 SET x=1e300, x=1e300;;
SELECT x notnull FROM t1;;
UPDATE t1 SET x='0.0', x='abc';;
UPDATE t1 SET x='abxyzzycy', x='A%CX';;
UPDATE t1 SET x='abc', x='aáˆ´_c';;
UPDATE t1 SET x='abcdefg', x='a*[^def]g';;
UPDATE t1 SET x='ABC', x='A[^A-D]C';;
UPDATE t1 SET x='ABC', x='A[^]B]C';;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;SELECT x FROM t1 WHERE x<10 AND x>8 ORDER BY x;SELECT typeof(00000009223372036854775807);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;PRAGMA max_page_count = 100;VACUUM ;SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;]]]
parser: Input 'PRAGMA' in state 0
parser: Shift 'PRAGMA', go to state 215
parser: Return. Stack=[PRAGMA]
parser: Input 'ID' in state 215
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[PRAGMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 215.
parser: ... then shift 'nm', go to state 295
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 392
parser: Shift 'EQ', go to state 31
parser: Return. Stack=[PRAGMA nm dbnm EQ]
parser: Input 'INTEGER' in state 31
parser: Shift 'INTEGER', pending reduce 359
parser: Return. Stack=[PRAGMA nm dbnm EQ INTEGER]
parser: Input 'SEMI' with pending reduce 359
parser: Reduce 359 [plus_num ::= INTEGER|FLOAT], go to state 31.
parser: ... then shift 'plus_num', pending reduce 234
parser: Reduce 234 [cmd ::= PRAGMA nm dbnm EQ nmnum], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[;
ROLLBACK;SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;PRAGMA integrity_check ;;
SELECT x-x FROM t1;;
SELECT x<x FROM t1;;
SELECT x=x FROM t1;;
PRAGMA foreign_keys = ON;;
SELECT (x+x)*x FROM t1;SELECT name, rootpage, sql FROM "temp".sqlite_temp_master ORDER BY rowid;PRAGMA temp.cache_size = 1;;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;;
SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;;
SELECT x, x
   FROM t1
  WHERE (x = 'A/B' OR
           ((x > 'A/B/') AND (x < 'A/B0')))
    AND x IS NOT NULL;;
SELECT x==1 OR x=2 FROM t1;;
CREATE INDEX t1_content ON t1(x ASC,  x DESC) ;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
CREATE INDEX docid ON t1(x DESC, x ASC) ;;
UPDATE t1 SET x=1;COMMIT;SELECT x, x FROM t1 WHERE x = 1 AND x IN (2, 4, 5) ORDER BY x ASC, x ASC;;
UPDATE t1 SET x=1, x=63;SELECT * FROM t1 INNER JOIN t1 AS x;;
CREATE INDEX c0content ON t1(x ASC,  x ASC) ;;
UPDATE t1 SET x=1, x=64;;
CREATE INDEX t1_segments ON t1(x ASC,  x DESC) ;;
SELECT x, x FROM t1 WHERE x = 3 AND x IN (2, 4, 5) ORDER BY x DESC, x ASC;SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE name='docid' AND type='index' ORDER BY rowid;;
UPDATE t1 SET x=32, x=3;;
UPDATE t1 SET x=25, x=11;;
SELECT coalesce(not x,99) FROM t1;;
SELECT coalesce(x IS NULL AND x=5,99) FROM t1;;
SELECT 5 not between x and x FROM t1;SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE name='docid' AND type='index' ORDER BY rowid;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
UPDATE t1 SET x=NULL, x=3;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1_content' AND type!='trigger' ORDER BY rowid;;
CREATE UNIQUE INDEX blockid ON t1(x ASC);;
SELECT coalesce(x&x,99) FROM t1;;
SELECT 1%0 FROM t1;;
SELECT coalesce(x>>x,99) FROM t1;CREATE TABLE block(t1_segdir);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;
SELECT
    SrcWord, t1.x
    FROM 
      (SELECT 'FACTORING' AS SrcWord UNION SELECT 'SWIMMING' AS SrcWord )
    LEFT JOIN 
      t1
    WHERE t1.x= (
      SELECT BeginningId FROM (
        SELECT SrcWord, B.x as BeginningId, B.x || E.x As Connected
        FROM t1 B LEFT JOIN t1 E ON B.x=E.x
        WHERE Connected=SrcWord LIMIT 1
      )
    )
;;
INSERT INTO t1(x) VALUES(10);;
SELECT * FROM block;;
SELECT x IS x FROM t1;;
SELECT x+x FROM t1;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;
SELECT ( 
      SELECT x FROM (
        SELECT * FROM t1 WHERE x=out.x ORDER BY x LIMIT 10 OFFSET 1
      ) WHERE x=out.x
    ) FROM t1 AS out;;
SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;;
UPDATE t1 SET x=-9223372036854775807, x=-2;;
UPDATE t1 SET x=-9223372036854775808, x=0;;
UPDATE t1 SET x=9223372036854775807, x=0;;
UPDATE t1 SET x=9223372036854775807, x=-1;;
CREATE INDEX level ON t1(x ASC,  x ASC) ;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
UPDATE t1 SET x=-3037000500, x=-3037000500;PRAGMA journal_mode = DELETE;;
SELECT x NOT LIKE x FROM t1;;
SELECT x-x FROM t1;;
VACUUM;;
UPDATE t1 SET x=1e300, x=1e300;;
SELECT x notnull FROM t1;;
UPDATE t1 SET x='0.0', x='abc';;
UPDATE t1 SET x='abxyzzycy', x='A%CX';;
UPDATE t1 SET x='abc', x='aáˆ´_c';;
UPDATE t1 SET x='abcdefg', x='a*[^def]g';;
UPDATE t1 SET x='ABC', x='A[^A-D]C';;
UPDATE t1 SET x='ABC', x='A[^]B]C';;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;SELECT x FROM t1 WHERE x<10 AND x>8 ORDER BY x;SELECT typeof(00000009223372036854775807);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;PRAGMA max_page_count = 100;VACUUM ;SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'ROLLBACK' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'ROLLBACK', go to state 365
parser: Return. Stack=[ecmd ROLLBACK]
parser: Input 'SEMI' in state 365
parser: Reduce 323 [trans_opt ::=].
parser: ... then shift 'trans_opt', go to state 539
parser: Reduce 9 [cmd ::= ROLLBACK trans_opt], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
parser: [[[SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;PRAGMA integrity_check ;;
SELECT x-x FROM t1;;
SELECT x<x FROM t1;;
SELECT x=x FROM t1;;
PRAGMA foreign_keys = ON;;
SELECT (x+x)*x FROM t1;SELECT name, rootpage, sql FROM "temp".sqlite_temp_master ORDER BY rowid;PRAGMA temp.cache_size = 1;;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;;
SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;;
SELECT x, x
   FROM t1
  WHERE (x = 'A/B' OR
           ((x > 'A/B/') AND (x < 'A/B0')))
    AND x IS NOT NULL;;
SELECT x==1 OR x=2 FROM t1;;
CREATE INDEX t1_content ON t1(x ASC,  x DESC) ;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
CREATE INDEX docid ON t1(x DESC, x ASC) ;;
UPDATE t1 SET x=1;COMMIT;SELECT x, x FROM t1 WHERE x = 1 AND x IN (2, 4, 5) ORDER BY x ASC, x ASC;;
UPDATE t1 SET x=1, x=63;SELECT * FROM t1 INNER JOIN t1 AS x;;
CREATE INDEX c0content ON t1(x ASC,  x ASC) ;;
UPDATE t1 SET x=1, x=64;;
CREATE INDEX t1_segments ON t1(x ASC,  x DESC) ;;
SELECT x, x FROM t1 WHERE x = 3 AND x IN (2, 4, 5) ORDER BY x DESC, x ASC;SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE name='docid' AND type='index' ORDER BY rowid;;
UPDATE t1 SET x=32, x=3;;
UPDATE t1 SET x=25, x=11;;
SELECT coalesce(not x,99) FROM t1;;
SELECT coalesce(x IS NULL AND x=5,99) FROM t1;;
SELECT 5 not between x and x FROM t1;SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE name='docid' AND type='index' ORDER BY rowid;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
UPDATE t1 SET x=NULL, x=3;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1_content' AND type!='trigger' ORDER BY rowid;;
CREATE UNIQUE INDEX blockid ON t1(x ASC);;
SELECT coalesce(x&x,99) FROM t1;;
SELECT 1%0 FROM t1;;
SELECT coalesce(x>>x,99) FROM t1;CREATE TABLE block(t1_segdir);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;
SELECT
    SrcWord, t1.x
    FROM 
      (SELECT 'FACTORING' AS SrcWord UNION SELECT 'SWIMMING' AS SrcWord )
    LEFT JOIN 
      t1
    WHERE t1.x= (
      SELECT BeginningId FROM (
        SELECT SrcWord, B.x as BeginningId, B.x || E.x As Connected
        FROM t1 B LEFT JOIN t1 E ON B.x=E.x
        WHERE Connected=SrcWord LIMIT 1
      )
    )
;;
INSERT INTO t1(x) VALUES(10);;
SELECT * FROM block;;
SELECT x IS x FROM t1;;
SELECT x+x FROM t1;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;
SELECT ( 
      SELECT x FROM (
        SELECT * FROM t1 WHERE x=out.x ORDER BY x LIMIT 10 OFFSET 1
      ) WHERE x=out.x
    ) FROM t1 AS out;;
SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;;
UPDATE t1 SET x=-9223372036854775807, x=-2;;
UPDATE t1 SET x=-9223372036854775808, x=0;;
UPDATE t1 SET x=9223372036854775807, x=0;;
UPDATE t1 SET x=9223372036854775807, x=-1;;
CREATE INDEX level ON t1(x ASC,  x ASC) ;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
UPDATE t1 SET x=-3037000500, x=-3037000500;PRAGMA journal_mode = DELETE;;
SELECT x NOT LIKE x FROM t1;;
SELECT x-x FROM t1;;
VACUUM;;
UPDATE t1 SET x=1e300, x=1e300;;
SELECT x notnull FROM t1;;
UPDATE t1 SET x='0.0', x='abc';;
UPDATE t1 SET x='abxyzzycy', x='A%CX';;
UPDATE t1 SET x='abc', x='aáˆ´_c';;
UPDATE t1 SET x='abcdefg', x='a*[^def]g';;
UPDATE t1 SET x='ABC', x='A[^A-D]C';;
UPDATE t1 SET x='ABC', x='A[^]B]C';;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;SELECT x FROM t1 WHERE x<10 AND x>8 ORDER BY x;SELECT typeof(00000009223372036854775807);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;PRAGMA max_page_count = 100;VACUUM ;SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'FROM' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'DOT' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Shift 'DOT', go to state 245
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID' in state 245
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'ORDER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 245.
parser: ... then shift 'nm', pending reduce 109
parser: Reduce 109 [dbnm ::= DOT nm], go to state 349.
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[PRAGMA integrity_check ;;
SELECT x-x FROM t1;;
SELECT x<x FROM t1;;
SELECT x=x FROM t1;;
PRAGMA foreign_keys = ON;;
SELECT (x+x)*x FROM t1;SELECT name, rootpage, sql FROM "temp".sqlite_temp_master ORDER BY rowid;PRAGMA temp.cache_size = 1;;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;;
SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;;
SELECT x, x
   FROM t1
  WHERE (x = 'A/B' OR
           ((x > 'A/B/') AND (x < 'A/B0')))
    AND x IS NOT NULL;;
SELECT x==1 OR x=2 FROM t1;;
CREATE INDEX t1_content ON t1(x ASC,  x DESC) ;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
CREATE INDEX docid ON t1(x DESC, x ASC) ;;
UPDATE t1 SET x=1;COMMIT;SELECT x, x FROM t1 WHERE x = 1 AND x IN (2, 4, 5) ORDER BY x ASC, x ASC;;
UPDATE t1 SET x=1, x=63;SELECT * FROM t1 INNER JOIN t1 AS x;;
CREATE INDEX c0content ON t1(x ASC,  x ASC) ;;
UPDATE t1 SET x=1, x=64;;
CREATE INDEX t1_segments ON t1(x ASC,  x DESC) ;;
SELECT x, x FROM t1 WHERE x = 3 AND x IN (2, 4, 5) ORDER BY x DESC, x ASC;SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE name='docid' AND type='index' ORDER BY rowid;;
UPDATE t1 SET x=32, x=3;;
UPDATE t1 SET x=25, x=11;;
SELECT coalesce(not x,99) FROM t1;;
SELECT coalesce(x IS NULL AND x=5,99) FROM t1;;
SELECT 5 not between x and x FROM t1;SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE name='docid' AND type='index' ORDER BY rowid;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
UPDATE t1 SET x=NULL, x=3;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1_content' AND type!='trigger' ORDER BY rowid;;
CREATE UNIQUE INDEX blockid ON t1(x ASC);;
SELECT coalesce(x&x,99) FROM t1;;
SELECT 1%0 FROM t1;;
SELECT coalesce(x>>x,99) FROM t1;CREATE TABLE block(t1_segdir);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;
SELECT
    SrcWord, t1.x
    FROM 
      (SELECT 'FACTORING' AS SrcWord UNION SELECT 'SWIMMING' AS SrcWord )
    LEFT JOIN 
      t1
    WHERE t1.x= (
      SELECT BeginningId FROM (
        SELECT SrcWord, B.x as BeginningId, B.x || E.x As Connected
        FROM t1 B LEFT JOIN t1 E ON B.x=E.x
        WHERE Connected=SrcWord LIMIT 1
      )
    )
;;
INSERT INTO t1(x) VALUES(10);;
SELECT * FROM block;;
SELECT x IS x FROM t1;;
SELECT x+x FROM t1;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;
SELECT ( 
      SELECT x FROM (
        SELECT * FROM t1 WHERE x=out.x ORDER BY x LIMIT 10 OFFSET 1
      ) WHERE x=out.x
    ) FROM t1 AS out;;
SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;;
UPDATE t1 SET x=-9223372036854775807, x=-2;;
UPDATE t1 SET x=-9223372036854775808, x=0;;
UPDATE t1 SET x=9223372036854775807, x=0;;
UPDATE t1 SET x=9223372036854775807, x=-1;;
CREATE INDEX level ON t1(x ASC,  x ASC) ;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
UPDATE t1 SET x=-3037000500, x=-3037000500;PRAGMA journal_mode = DELETE;;
SELECT x NOT LIKE x FROM t1;;
SELECT x-x FROM t1;;
VACUUM;;
UPDATE t1 SET x=1e300, x=1e300;;
SELECT x notnull FROM t1;;
UPDATE t1 SET x='0.0', x='abc';;
UPDATE t1 SET x='abxyzzycy', x='A%CX';;
UPDATE t1 SET x='abc', x='aáˆ´_c';;
UPDATE t1 SET x='abcdefg', x='a*[^def]g';;
UPDATE t1 SET x='ABC', x='A[^A-D]C';;
UPDATE t1 SET x='ABC', x='A[^]B]C';;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;SELECT x FROM t1 WHERE x<10 AND x>8 ORDER BY x;SELECT typeof(00000009223372036854775807);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;PRAGMA max_page_count = 100;VACUUM ;SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;]]]
parser: Input 'PRAGMA' in state 0
parser: Shift 'PRAGMA', go to state 215
parser: Return. Stack=[PRAGMA]
parser: Input 'ID' in state 215
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[PRAGMA ID]
parser: Input 'SEMI' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 215.
parser: ... then shift 'nm', go to state 295
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 392
parser: Reduce 233 [cmd ::= PRAGMA nm dbnm], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[;
SELECT x-x FROM t1;;
SELECT x<x FROM t1;;
SELECT x=x FROM t1;;
PRAGMA foreign_keys = ON;;
SELECT (x+x)*x FROM t1;SELECT name, rootpage, sql FROM "temp".sqlite_temp_master ORDER BY rowid;PRAGMA temp.cache_size = 1;;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;;
SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;;
SELECT x, x
   FROM t1
  WHERE (x = 'A/B' OR
           ((x > 'A/B/') AND (x < 'A/B0')))
    AND x IS NOT NULL;;
SELECT x==1 OR x=2 FROM t1;;
CREATE INDEX t1_content ON t1(x ASC,  x DESC) ;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
CREATE INDEX docid ON t1(x DESC, x ASC) ;;
UPDATE t1 SET x=1;COMMIT;SELECT x, x FROM t1 WHERE x = 1 AND x IN (2, 4, 5) ORDER BY x ASC, x ASC;;
UPDATE t1 SET x=1, x=63;SELECT * FROM t1 INNER JOIN t1 AS x;;
CREATE INDEX c0content ON t1(x ASC,  x ASC) ;;
UPDATE t1 SET x=1, x=64;;
CREATE INDEX t1_segments ON t1(x ASC,  x DESC) ;;
SELECT x, x FROM t1 WHERE x = 3 AND x IN (2, 4, 5) ORDER BY x DESC, x ASC;SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE name='docid' AND type='index' ORDER BY rowid;;
UPDATE t1 SET x=32, x=3;;
UPDATE t1 SET x=25, x=11;;
SELECT coalesce(not x,99) FROM t1;;
SELECT coalesce(x IS NULL AND x=5,99) FROM t1;;
SELECT 5 not between x and x FROM t1;SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE name='docid' AND type='index' ORDER BY rowid;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
UPDATE t1 SET x=NULL, x=3;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1_content' AND type!='trigger' ORDER BY rowid;;
CREATE UNIQUE INDEX blockid ON t1(x ASC);;
SELECT coalesce(x&x,99) FROM t1;;
SELECT 1%0 FROM t1;;
SELECT coalesce(x>>x,99) FROM t1;CREATE TABLE block(t1_segdir);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;
SELECT
    SrcWord, t1.x
    FROM 
      (SELECT 'FACTORING' AS SrcWord UNION SELECT 'SWIMMING' AS SrcWord )
    LEFT JOIN 
      t1
    WHERE t1.x= (
      SELECT BeginningId FROM (
        SELECT SrcWord, B.x as BeginningId, B.x || E.x As Connected
        FROM t1 B LEFT JOIN t1 E ON B.x=E.x
        WHERE Connected=SrcWord LIMIT 1
      )
    )
;;
INSERT INTO t1(x) VALUES(10);;
SELECT * FROM block;;
SELECT x IS x FROM t1;;
SELECT x+x FROM t1;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;
SELECT ( 
      SELECT x FROM (
        SELECT * FROM t1 WHERE x=out.x ORDER BY x LIMIT 10 OFFSET 1
      ) WHERE x=out.x
    ) FROM t1 AS out;;
SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;;
UPDATE t1 SET x=-9223372036854775807, x=-2;;
UPDATE t1 SET x=-9223372036854775808, x=0;;
UPDATE t1 SET x=9223372036854775807, x=0;;
UPDATE t1 SET x=9223372036854775807, x=-1;;
CREATE INDEX level ON t1(x ASC,  x ASC) ;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
UPDATE t1 SET x=-3037000500, x=-3037000500;PRAGMA journal_mode = DELETE;;
SELECT x NOT LIKE x FROM t1;;
SELECT x-x FROM t1;;
VACUUM;;
UPDATE t1 SET x=1e300, x=1e300;;
SELECT x notnull FROM t1;;
UPDATE t1 SET x='0.0', x='abc';;
UPDATE t1 SET x='abxyzzycy', x='A%CX';;
UPDATE t1 SET x='abc', x='aáˆ´_c';;
UPDATE t1 SET x='abcdefg', x='a*[^def]g';;
UPDATE t1 SET x='ABC', x='A[^A-D]C';;
UPDATE t1 SET x='ABC', x='A[^]B]C';;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;SELECT x FROM t1 WHERE x<10 AND x>8 ORDER BY x;SELECT typeof(00000009223372036854775807);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;PRAGMA max_page_count = 100;VACUUM ;SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'SELECT' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[ecmd SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt ID]
parser: Input 'MINUS' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Shift 'MINUS', go to state 115
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt expr MINUS]
parser: Input 'ID' in state 115
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt expr MINUS ID]
parser: Input 'FROM' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 115.
parser: ... then shift 'expr', go to state 132
parser: Reduce 184 [expr ::= expr PLUS|MINUS expr], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[ecmd SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'SEMI' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 1.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 1.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
parser: [[[;
SELECT x<x FROM t1;;
SELECT x=x FROM t1;;
PRAGMA foreign_keys = ON;;
SELECT (x+x)*x FROM t1;SELECT name, rootpage, sql FROM "temp".sqlite_temp_master ORDER BY rowid;PRAGMA temp.cache_size = 1;;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;;
SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;;
SELECT x, x
   FROM t1
  WHERE (x = 'A/B' OR
           ((x > 'A/B/') AND (x < 'A/B0')))
    AND x IS NOT NULL;;
SELECT x==1 OR x=2 FROM t1;;
CREATE INDEX t1_content ON t1(x ASC,  x DESC) ;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
CREATE INDEX docid ON t1(x DESC, x ASC) ;;
UPDATE t1 SET x=1;COMMIT;SELECT x, x FROM t1 WHERE x = 1 AND x IN (2, 4, 5) ORDER BY x ASC, x ASC;;
UPDATE t1 SET x=1, x=63;SELECT * FROM t1 INNER JOIN t1 AS x;;
CREATE INDEX c0content ON t1(x ASC,  x ASC) ;;
UPDATE t1 SET x=1, x=64;;
CREATE INDEX t1_segments ON t1(x ASC,  x DESC) ;;
SELECT x, x FROM t1 WHERE x = 3 AND x IN (2, 4, 5) ORDER BY x DESC, x ASC;SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE name='docid' AND type='index' ORDER BY rowid;;
UPDATE t1 SET x=32, x=3;;
UPDATE t1 SET x=25, x=11;;
SELECT coalesce(not x,99) FROM t1;;
SELECT coalesce(x IS NULL AND x=5,99) FROM t1;;
SELECT 5 not between x and x FROM t1;SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE name='docid' AND type='index' ORDER BY rowid;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
UPDATE t1 SET x=NULL, x=3;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1_content' AND type!='trigger' ORDER BY rowid;;
CREATE UNIQUE INDEX blockid ON t1(x ASC);;
SELECT coalesce(x&x,99) FROM t1;;
SELECT 1%0 FROM t1;;
SELECT coalesce(x>>x,99) FROM t1;CREATE TABLE block(t1_segdir);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;
SELECT
    SrcWord, t1.x
    FROM 
      (SELECT 'FACTORING' AS SrcWord UNION SELECT 'SWIMMING' AS SrcWord )
    LEFT JOIN 
      t1
    WHERE t1.x= (
      SELECT BeginningId FROM (
        SELECT SrcWord, B.x as BeginningId, B.x || E.x As Connected
        FROM t1 B LEFT JOIN t1 E ON B.x=E.x
        WHERE Connected=SrcWord LIMIT 1
      )
    )
;;
INSERT INTO t1(x) VALUES(10);;
SELECT * FROM block;;
SELECT x IS x FROM t1;;
SELECT x+x FROM t1;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;
SELECT ( 
      SELECT x FROM (
        SELECT * FROM t1 WHERE x=out.x ORDER BY x LIMIT 10 OFFSET 1
      ) WHERE x=out.x
    ) FROM t1 AS out;;
SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;;
UPDATE t1 SET x=-9223372036854775807, x=-2;;
UPDATE t1 SET x=-9223372036854775808, x=0;;
UPDATE t1 SET x=9223372036854775807, x=0;;
UPDATE t1 SET x=9223372036854775807, x=-1;;
CREATE INDEX level ON t1(x ASC,  x ASC) ;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
UPDATE t1 SET x=-3037000500, x=-3037000500;PRAGMA journal_mode = DELETE;;
SELECT x NOT LIKE x FROM t1;;
SELECT x-x FROM t1;;
VACUUM;;
UPDATE t1 SET x=1e300, x=1e300;;
SELECT x notnull FROM t1;;
UPDATE t1 SET x='0.0', x='abc';;
UPDATE t1 SET x='abxyzzycy', x='A%CX';;
UPDATE t1 SET x='abc', x='aáˆ´_c';;
UPDATE t1 SET x='abcdefg', x='a*[^def]g';;
UPDATE t1 SET x='ABC', x='A[^A-D]C';;
UPDATE t1 SET x='ABC', x='A[^]B]C';;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;SELECT x FROM t1 WHERE x<10 AND x>8 ORDER BY x;SELECT typeof(00000009223372036854775807);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;PRAGMA max_page_count = 100;VACUUM ;SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'SELECT' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[ecmd SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt ID]
parser: Input 'LT' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Shift 'LT', go to state 118
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt expr LT]
parser: Input 'ID' in state 118
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt expr LT ID]
parser: Input 'FROM' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 118.
parser: ... then shift 'expr', go to state 130
parser: Reduce 181 [expr ::= expr LT|GT|GE|LE expr], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[ecmd SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'SEMI' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 1.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 1.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
parser: [[[;
SELECT x=x FROM t1;;
PRAGMA foreign_keys = ON;;
SELECT (x+x)*x FROM t1;SELECT name, rootpage, sql FROM "temp".sqlite_temp_master ORDER BY rowid;PRAGMA temp.cache_size = 1;;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;;
SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;;
SELECT x, x
   FROM t1
  WHERE (x = 'A/B' OR
           ((x > 'A/B/') AND (x < 'A/B0')))
    AND x IS NOT NULL;;
SELECT x==1 OR x=2 FROM t1;;
CREATE INDEX t1_content ON t1(x ASC,  x DESC) ;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
CREATE INDEX docid ON t1(x DESC, x ASC) ;;
UPDATE t1 SET x=1;COMMIT;SELECT x, x FROM t1 WHERE x = 1 AND x IN (2, 4, 5) ORDER BY x ASC, x ASC;;
UPDATE t1 SET x=1, x=63;SELECT * FROM t1 INNER JOIN t1 AS x;;
CREATE INDEX c0content ON t1(x ASC,  x ASC) ;;
UPDATE t1 SET x=1, x=64;;
CREATE INDEX t1_segments ON t1(x ASC,  x DESC) ;;
SELECT x, x FROM t1 WHERE x = 3 AND x IN (2, 4, 5) ORDER BY x DESC, x ASC;SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE name='docid' AND type='index' ORDER BY rowid;;
UPDATE t1 SET x=32, x=3;;
UPDATE t1 SET x=25, x=11;;
SELECT coalesce(not x,99) FROM t1;;
SELECT coalesce(x IS NULL AND x=5,99) FROM t1;;
SELECT 5 not between x and x FROM t1;SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE name='docid' AND type='index' ORDER BY rowid;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
UPDATE t1 SET x=NULL, x=3;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1_content' AND type!='trigger' ORDER BY rowid;;
CREATE UNIQUE INDEX blockid ON t1(x ASC);;
SELECT coalesce(x&x,99) FROM t1;;
SELECT 1%0 FROM t1;;
SELECT coalesce(x>>x,99) FROM t1;CREATE TABLE block(t1_segdir);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;
SELECT
    SrcWord, t1.x
    FROM 
      (SELECT 'FACTORING' AS SrcWord UNION SELECT 'SWIMMING' AS SrcWord )
    LEFT JOIN 
      t1
    WHERE t1.x= (
      SELECT BeginningId FROM (
        SELECT SrcWord, B.x as BeginningId, B.x || E.x As Connected
        FROM t1 B LEFT JOIN t1 E ON B.x=E.x
        WHERE Connected=SrcWord LIMIT 1
      )
    )
;;
INSERT INTO t1(x) VALUES(10);;
SELECT * FROM block;;
SELECT x IS x FROM t1;;
SELECT x+x FROM t1;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;
SELECT ( 
      SELECT x FROM (
        SELECT * FROM t1 WHERE x=out.x ORDER BY x LIMIT 10 OFFSET 1
      ) WHERE x=out.x
    ) FROM t1 AS out;;
SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;;
UPDATE t1 SET x=-9223372036854775807, x=-2;;
UPDATE t1 SET x=-9223372036854775808, x=0;;
UPDATE t1 SET x=9223372036854775807, x=0;;
UPDATE t1 SET x=9223372036854775807, x=-1;;
CREATE INDEX level ON t1(x ASC,  x ASC) ;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
UPDATE t1 SET x=-3037000500, x=-3037000500;PRAGMA journal_mode = DELETE;;
SELECT x NOT LIKE x FROM t1;;
SELECT x-x FROM t1;;
VACUUM;;
UPDATE t1 SET x=1e300, x=1e300;;
SELECT x notnull FROM t1;;
UPDATE t1 SET x='0.0', x='abc';;
UPDATE t1 SET x='abxyzzycy', x='A%CX';;
UPDATE t1 SET x='abc', x='aáˆ´_c';;
UPDATE t1 SET x='abcdefg', x='a*[^def]g';;
UPDATE t1 SET x='ABC', x='A[^A-D]C';;
UPDATE t1 SET x='ABC', x='A[^]B]C';;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;SELECT x FROM t1 WHERE x<10 AND x>8 ORDER BY x;SELECT typeof(00000009223372036854775807);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;PRAGMA max_page_count = 100;VACUUM ;SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'SELECT' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[ecmd SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt expr EQ]
parser: Input 'ID' in state 117
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt expr EQ ID]
parser: Input 'FROM' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 117.
parser: ... then shift 'expr', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[ecmd SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'SEMI' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 1.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 1.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
parser: [[[;
PRAGMA foreign_keys = ON;;
SELECT (x+x)*x FROM t1;SELECT name, rootpage, sql FROM "temp".sqlite_temp_master ORDER BY rowid;PRAGMA temp.cache_size = 1;;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;;
SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;;
SELECT x, x
   FROM t1
  WHERE (x = 'A/B' OR
           ((x > 'A/B/') AND (x < 'A/B0')))
    AND x IS NOT NULL;;
SELECT x==1 OR x=2 FROM t1;;
CREATE INDEX t1_content ON t1(x ASC,  x DESC) ;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
CREATE INDEX docid ON t1(x DESC, x ASC) ;;
UPDATE t1 SET x=1;COMMIT;SELECT x, x FROM t1 WHERE x = 1 AND x IN (2, 4, 5) ORDER BY x ASC, x ASC;;
UPDATE t1 SET x=1, x=63;SELECT * FROM t1 INNER JOIN t1 AS x;;
CREATE INDEX c0content ON t1(x ASC,  x ASC) ;;
UPDATE t1 SET x=1, x=64;;
CREATE INDEX t1_segments ON t1(x ASC,  x DESC) ;;
SELECT x, x FROM t1 WHERE x = 3 AND x IN (2, 4, 5) ORDER BY x DESC, x ASC;SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE name='docid' AND type='index' ORDER BY rowid;;
UPDATE t1 SET x=32, x=3;;
UPDATE t1 SET x=25, x=11;;
SELECT coalesce(not x,99) FROM t1;;
SELECT coalesce(x IS NULL AND x=5,99) FROM t1;;
SELECT 5 not between x and x FROM t1;SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE name='docid' AND type='index' ORDER BY rowid;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
UPDATE t1 SET x=NULL, x=3;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1_content' AND type!='trigger' ORDER BY rowid;;
CREATE UNIQUE INDEX blockid ON t1(x ASC);;
SELECT coalesce(x&x,99) FROM t1;;
SELECT 1%0 FROM t1;;
SELECT coalesce(x>>x,99) FROM t1;CREATE TABLE block(t1_segdir);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;
SELECT
    SrcWord, t1.x
    FROM 
      (SELECT 'FACTORING' AS SrcWord UNION SELECT 'SWIMMING' AS SrcWord )
    LEFT JOIN 
      t1
    WHERE t1.x= (
      SELECT BeginningId FROM (
        SELECT SrcWord, B.x as BeginningId, B.x || E.x As Connected
        FROM t1 B LEFT JOIN t1 E ON B.x=E.x
        WHERE Connected=SrcWord LIMIT 1
      )
    )
;;
INSERT INTO t1(x) VALUES(10);;
SELECT * FROM block;;
SELECT x IS x FROM t1;;
SELECT x+x FROM t1;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;
SELECT ( 
      SELECT x FROM (
        SELECT * FROM t1 WHERE x=out.x ORDER BY x LIMIT 10 OFFSET 1
      ) WHERE x=out.x
    ) FROM t1 AS out;;
SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;;
UPDATE t1 SET x=-9223372036854775807, x=-2;;
UPDATE t1 SET x=-9223372036854775808, x=0;;
UPDATE t1 SET x=9223372036854775807, x=0;;
UPDATE t1 SET x=9223372036854775807, x=-1;;
CREATE INDEX level ON t1(x ASC,  x ASC) ;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
UPDATE t1 SET x=-3037000500, x=-3037000500;PRAGMA journal_mode = DELETE;;
SELECT x NOT LIKE x FROM t1;;
SELECT x-x FROM t1;;
VACUUM;;
UPDATE t1 SET x=1e300, x=1e300;;
SELECT x notnull FROM t1;;
UPDATE t1 SET x='0.0', x='abc';;
UPDATE t1 SET x='abxyzzycy', x='A%CX';;
UPDATE t1 SET x='abc', x='aáˆ´_c';;
UPDATE t1 SET x='abcdefg', x='a*[^def]g';;
UPDATE t1 SET x='ABC', x='A[^A-D]C';;
UPDATE t1 SET x='ABC', x='A[^]B]C';;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;SELECT x FROM t1 WHERE x<10 AND x>8 ORDER BY x;SELECT typeof(00000009223372036854775807);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;PRAGMA max_page_count = 100;VACUUM ;SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'PRAGMA' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'PRAGMA', go to state 215
parser: Return. Stack=[ecmd PRAGMA]
parser: Input 'ID' in state 215
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd PRAGMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 215.
parser: ... then shift 'nm', go to state 295
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 392
parser: Shift 'EQ', go to state 31
parser: Return. Stack=[ecmd PRAGMA nm dbnm EQ]
parser: Input 'ON' in state 31
parser: Shift 'ON', pending reduce 356
parser: Return. Stack=[ecmd PRAGMA nm dbnm EQ ON]
parser: Input 'SEMI' with pending reduce 356
parser: Reduce 356 [nmnum ::= ON], go to state 31.
parser: ... then shift 'nmnum', pending reduce 234
parser: Reduce 234 [cmd ::= PRAGMA nm dbnm EQ nmnum], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
parser: [[[;
SELECT (x+x)*x FROM t1;SELECT name, rootpage, sql FROM "temp".sqlite_temp_master ORDER BY rowid;PRAGMA temp.cache_size = 1;;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;;
SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;;
SELECT x, x
   FROM t1
  WHERE (x = 'A/B' OR
           ((x > 'A/B/') AND (x < 'A/B0')))
    AND x IS NOT NULL;;
SELECT x==1 OR x=2 FROM t1;;
CREATE INDEX t1_content ON t1(x ASC,  x DESC) ;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
CREATE INDEX docid ON t1(x DESC, x ASC) ;;
UPDATE t1 SET x=1;COMMIT;SELECT x, x FROM t1 WHERE x = 1 AND x IN (2, 4, 5) ORDER BY x ASC, x ASC;;
UPDATE t1 SET x=1, x=63;SELECT * FROM t1 INNER JOIN t1 AS x;;
CREATE INDEX c0content ON t1(x ASC,  x ASC) ;;
UPDATE t1 SET x=1, x=64;;
CREATE INDEX t1_segments ON t1(x ASC,  x DESC) ;;
SELECT x, x FROM t1 WHERE x = 3 AND x IN (2, 4, 5) ORDER BY x DESC, x ASC;SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE name='docid' AND type='index' ORDER BY rowid;;
UPDATE t1 SET x=32, x=3;;
UPDATE t1 SET x=25, x=11;;
SELECT coalesce(not x,99) FROM t1;;
SELECT coalesce(x IS NULL AND x=5,99) FROM t1;;
SELECT 5 not between x and x FROM t1;SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE name='docid' AND type='index' ORDER BY rowid;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
UPDATE t1 SET x=NULL, x=3;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1_content' AND type!='trigger' ORDER BY rowid;;
CREATE UNIQUE INDEX blockid ON t1(x ASC);;
SELECT coalesce(x&x,99) FROM t1;;
SELECT 1%0 FROM t1;;
SELECT coalesce(x>>x,99) FROM t1;CREATE TABLE block(t1_segdir);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;
SELECT
    SrcWord, t1.x
    FROM 
      (SELECT 'FACTORING' AS SrcWord UNION SELECT 'SWIMMING' AS SrcWord )
    LEFT JOIN 
      t1
    WHERE t1.x= (
      SELECT BeginningId FROM (
        SELECT SrcWord, B.x as BeginningId, B.x || E.x As Connected
        FROM t1 B LEFT JOIN t1 E ON B.x=E.x
        WHERE Connected=SrcWord LIMIT 1
      )
    )
;;
INSERT INTO t1(x) VALUES(10);;
SELECT * FROM block;;
SELECT x IS x FROM t1;;
SELECT x+x FROM t1;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;
SELECT ( 
      SELECT x FROM (
        SELECT * FROM t1 WHERE x=out.x ORDER BY x LIMIT 10 OFFSET 1
      ) WHERE x=out.x
    ) FROM t1 AS out;;
SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;;
UPDATE t1 SET x=-9223372036854775807, x=-2;;
UPDATE t1 SET x=-9223372036854775808, x=0;;
UPDATE t1 SET x=9223372036854775807, x=0;;
UPDATE t1 SET x=9223372036854775807, x=-1;;
CREATE INDEX level ON t1(x ASC,  x ASC) ;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
UPDATE t1 SET x=-3037000500, x=-3037000500;PRAGMA journal_mode = DELETE;;
SELECT x NOT LIKE x FROM t1;;
SELECT x-x FROM t1;;
VACUUM;;
UPDATE t1 SET x=1e300, x=1e300;;
SELECT x notnull FROM t1;;
UPDATE t1 SET x='0.0', x='abc';;
UPDATE t1 SET x='abxyzzycy', x='A%CX';;
UPDATE t1 SET x='abc', x='aáˆ´_c';;
UPDATE t1 SET x='abcdefg', x='a*[^def]g';;
UPDATE t1 SET x='ABC', x='A[^A-D]C';;
UPDATE t1 SET x='ABC', x='A[^]B]C';;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;SELECT x FROM t1 WHERE x<10 AND x>8 ORDER BY x;SELECT typeof(00000009223372036854775807);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;PRAGMA max_page_count = 100;VACUUM ;SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'SELECT' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[ecmd SELECT]
parser: Input 'LP' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'LP', go to state 4
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt LP]
parser: Input 'ID' in state 4
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt LP ID]
parser: Input 'PLUS' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 4.
parser: ... then shift 'expr', go to state 50
parser: Shift 'PLUS', go to state 115
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt LP expr PLUS]
parser: Input 'ID' in state 115
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt LP expr PLUS ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 115.
parser: ... then shift 'expr', go to state 132
parser: Reduce 184 [expr ::= expr PLUS|MINUS expr], go to state 4.
parser: ... then shift 'expr', go to state 50
parser: Shift 'RP', pending reduce 162
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt LP expr RP]
parser: Input 'STAR' with pending reduce 162
parser: Reduce 162 [expr ::= LP expr RP], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Shift 'STAR', go to state 114
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt expr STAR]
parser: Input 'ID' in state 114
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt expr STAR ID]
parser: Input 'FROM' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 114.
parser: ... then shift 'expr', go to state 145
parser: Reduce 185 [expr ::= expr STAR|SLASH|REM expr], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[ecmd SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'SEMI' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 1.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 1.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
parser: [[[SELECT name, rootpage, sql FROM "temp".sqlite_temp_master ORDER BY rowid;PRAGMA temp.cache_size = 1;;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;;
SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;;
SELECT x, x
   FROM t1
  WHERE (x = 'A/B' OR
           ((x > 'A/B/') AND (x < 'A/B0')))
    AND x IS NOT NULL;;
SELECT x==1 OR x=2 FROM t1;;
CREATE INDEX t1_content ON t1(x ASC,  x DESC) ;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
CREATE INDEX docid ON t1(x DESC, x ASC) ;;
UPDATE t1 SET x=1;COMMIT;SELECT x, x FROM t1 WHERE x = 1 AND x IN (2, 4, 5) ORDER BY x ASC, x ASC;;
UPDATE t1 SET x=1, x=63;SELECT * FROM t1 INNER JOIN t1 AS x;;
CREATE INDEX c0content ON t1(x ASC,  x ASC) ;;
UPDATE t1 SET x=1, x=64;;
CREATE INDEX t1_segments ON t1(x ASC,  x DESC) ;;
SELECT x, x FROM t1 WHERE x = 3 AND x IN (2, 4, 5) ORDER BY x DESC, x ASC;SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE name='docid' AND type='index' ORDER BY rowid;;
UPDATE t1 SET x=32, x=3;;
UPDATE t1 SET x=25, x=11;;
SELECT coalesce(not x,99) FROM t1;;
SELECT coalesce(x IS NULL AND x=5,99) FROM t1;;
SELECT 5 not between x and x FROM t1;SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE name='docid' AND type='index' ORDER BY rowid;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
UPDATE t1 SET x=NULL, x=3;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1_content' AND type!='trigger' ORDER BY rowid;;
CREATE UNIQUE INDEX blockid ON t1(x ASC);;
SELECT coalesce(x&x,99) FROM t1;;
SELECT 1%0 FROM t1;;
SELECT coalesce(x>>x,99) FROM t1;CREATE TABLE block(t1_segdir);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;
SELECT
    SrcWord, t1.x
    FROM 
      (SELECT 'FACTORING' AS SrcWord UNION SELECT 'SWIMMING' AS SrcWord )
    LEFT JOIN 
      t1
    WHERE t1.x= (
      SELECT BeginningId FROM (
        SELECT SrcWord, B.x as BeginningId, B.x || E.x As Connected
        FROM t1 B LEFT JOIN t1 E ON B.x=E.x
        WHERE Connected=SrcWord LIMIT 1
      )
    )
;;
INSERT INTO t1(x) VALUES(10);;
SELECT * FROM block;;
SELECT x IS x FROM t1;;
SELECT x+x FROM t1;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;
SELECT ( 
      SELECT x FROM (
        SELECT * FROM t1 WHERE x=out.x ORDER BY x LIMIT 10 OFFSET 1
      ) WHERE x=out.x
    ) FROM t1 AS out;;
SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;;
UPDATE t1 SET x=-9223372036854775807, x=-2;;
UPDATE t1 SET x=-9223372036854775808, x=0;;
UPDATE t1 SET x=9223372036854775807, x=0;;
UPDATE t1 SET x=9223372036854775807, x=-1;;
CREATE INDEX level ON t1(x ASC,  x ASC) ;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
UPDATE t1 SET x=-3037000500, x=-3037000500;PRAGMA journal_mode = DELETE;;
SELECT x NOT LIKE x FROM t1;;
SELECT x-x FROM t1;;
VACUUM;;
UPDATE t1 SET x=1e300, x=1e300;;
SELECT x notnull FROM t1;;
UPDATE t1 SET x='0.0', x='abc';;
UPDATE t1 SET x='abxyzzycy', x='A%CX';;
UPDATE t1 SET x='abc', x='aáˆ´_c';;
UPDATE t1 SET x='abcdefg', x='a*[^def]g';;
UPDATE t1 SET x='ABC', x='A[^A-D]C';;
UPDATE t1 SET x='ABC', x='A[^]B]C';;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;SELECT x FROM t1 WHERE x<10 AND x>8 ORDER BY x;SELECT typeof(00000009223372036854775807);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;PRAGMA max_page_count = 100;VACUUM ;SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'FROM' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'DOT' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Shift 'DOT', go to state 245
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID' in state 245
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'ORDER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 245.
parser: ... then shift 'nm', pending reduce 109
parser: Reduce 109 [dbnm ::= DOT nm], go to state 349.
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[PRAGMA temp.cache_size = 1;;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;;
SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;;
SELECT x, x
   FROM t1
  WHERE (x = 'A/B' OR
           ((x > 'A/B/') AND (x < 'A/B0')))
    AND x IS NOT NULL;;
SELECT x==1 OR x=2 FROM t1;;
CREATE INDEX t1_content ON t1(x ASC,  x DESC) ;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
CREATE INDEX docid ON t1(x DESC, x ASC) ;;
UPDATE t1 SET x=1;COMMIT;SELECT x, x FROM t1 WHERE x = 1 AND x IN (2, 4, 5) ORDER BY x ASC, x ASC;;
UPDATE t1 SET x=1, x=63;SELECT * FROM t1 INNER JOIN t1 AS x;;
CREATE INDEX c0content ON t1(x ASC,  x ASC) ;;
UPDATE t1 SET x=1, x=64;;
CREATE INDEX t1_segments ON t1(x ASC,  x DESC) ;;
SELECT x, x FROM t1 WHERE x = 3 AND x IN (2, 4, 5) ORDER BY x DESC, x ASC;SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE name='docid' AND type='index' ORDER BY rowid;;
UPDATE t1 SET x=32, x=3;;
UPDATE t1 SET x=25, x=11;;
SELECT coalesce(not x,99) FROM t1;;
SELECT coalesce(x IS NULL AND x=5,99) FROM t1;;
SELECT 5 not between x and x FROM t1;SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE name='docid' AND type='index' ORDER BY rowid;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
UPDATE t1 SET x=NULL, x=3;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1_content' AND type!='trigger' ORDER BY rowid;;
CREATE UNIQUE INDEX blockid ON t1(x ASC);;
SELECT coalesce(x&x,99) FROM t1;;
SELECT 1%0 FROM t1;;
SELECT coalesce(x>>x,99) FROM t1;CREATE TABLE block(t1_segdir);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;
SELECT
    SrcWord, t1.x
    FROM 
      (SELECT 'FACTORING' AS SrcWord UNION SELECT 'SWIMMING' AS SrcWord )
    LEFT JOIN 
      t1
    WHERE t1.x= (
      SELECT BeginningId FROM (
        SELECT SrcWord, B.x as BeginningId, B.x || E.x As Connected
        FROM t1 B LEFT JOIN t1 E ON B.x=E.x
        WHERE Connected=SrcWord LIMIT 1
      )
    )
;;
INSERT INTO t1(x) VALUES(10);;
SELECT * FROM block;;
SELECT x IS x FROM t1;;
SELECT x+x FROM t1;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;
SELECT ( 
      SELECT x FROM (
        SELECT * FROM t1 WHERE x=out.x ORDER BY x LIMIT 10 OFFSET 1
      ) WHERE x=out.x
    ) FROM t1 AS out;;
SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;;
UPDATE t1 SET x=-9223372036854775807, x=-2;;
UPDATE t1 SET x=-9223372036854775808, x=0;;
UPDATE t1 SET x=9223372036854775807, x=0;;
UPDATE t1 SET x=9223372036854775807, x=-1;;
CREATE INDEX level ON t1(x ASC,  x ASC) ;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
UPDATE t1 SET x=-3037000500, x=-3037000500;PRAGMA journal_mode = DELETE;;
SELECT x NOT LIKE x FROM t1;;
SELECT x-x FROM t1;;
VACUUM;;
UPDATE t1 SET x=1e300, x=1e300;;
SELECT x notnull FROM t1;;
UPDATE t1 SET x='0.0', x='abc';;
UPDATE t1 SET x='abxyzzycy', x='A%CX';;
UPDATE t1 SET x='abc', x='aáˆ´_c';;
UPDATE t1 SET x='abcdefg', x='a*[^def]g';;
UPDATE t1 SET x='ABC', x='A[^A-D]C';;
UPDATE t1 SET x='ABC', x='A[^]B]C';;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;SELECT x FROM t1 WHERE x<10 AND x>8 ORDER BY x;SELECT typeof(00000009223372036854775807);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;PRAGMA max_page_count = 100;VACUUM ;SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;]]]
parser: Input 'PRAGMA' in state 0
parser: Shift 'PRAGMA', go to state 215
parser: Return. Stack=[PRAGMA]
parser: Input 'TEMP' in state 215
parser: FALLBACK TEMP => ID
parser: Shift 'TEMP', pending reduce 331
parser: Return. Stack=[PRAGMA TEMP]
parser: Input 'DOT' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 215.
parser: ... then shift 'nm', go to state 295
parser: Shift 'DOT', go to state 245
parser: Return. Stack=[PRAGMA nm DOT]
parser: Input 'ID' in state 245
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[PRAGMA nm DOT ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 245.
parser: ... then shift 'nm', pending reduce 109
parser: Reduce 109 [dbnm ::= DOT nm], go to state 295.
parser: ... then shift 'dbnm', go to state 392
parser: Shift 'EQ', go to state 31
parser: Return. Stack=[PRAGMA nm dbnm EQ]
parser: Input 'INTEGER' in state 31
parser: Shift 'INTEGER', pending reduce 359
parser: Return. Stack=[PRAGMA nm dbnm EQ INTEGER]
parser: Input 'SEMI' with pending reduce 359
parser: Reduce 359 [plus_num ::= INTEGER|FLOAT], go to state 31.
parser: ... then shift 'plus_num', pending reduce 234
parser: Reduce 234 [cmd ::= PRAGMA nm dbnm EQ nmnum], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;;
SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;;
SELECT x, x
   FROM t1
  WHERE (x = 'A/B' OR
           ((x > 'A/B/') AND (x < 'A/B0')))
    AND x IS NOT NULL;;
SELECT x==1 OR x=2 FROM t1;;
CREATE INDEX t1_content ON t1(x ASC,  x DESC) ;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
CREATE INDEX docid ON t1(x DESC, x ASC) ;;
UPDATE t1 SET x=1;COMMIT;SELECT x, x FROM t1 WHERE x = 1 AND x IN (2, 4, 5) ORDER BY x ASC, x ASC;;
UPDATE t1 SET x=1, x=63;SELECT * FROM t1 INNER JOIN t1 AS x;;
CREATE INDEX c0content ON t1(x ASC,  x ASC) ;;
UPDATE t1 SET x=1, x=64;;
CREATE INDEX t1_segments ON t1(x ASC,  x DESC) ;;
SELECT x, x FROM t1 WHERE x = 3 AND x IN (2, 4, 5) ORDER BY x DESC, x ASC;SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE name='docid' AND type='index' ORDER BY rowid;;
UPDATE t1 SET x=32, x=3;;
UPDATE t1 SET x=25, x=11;;
SELECT coalesce(not x,99) FROM t1;;
SELECT coalesce(x IS NULL AND x=5,99) FROM t1;;
SELECT 5 not between x and x FROM t1;SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE name='docid' AND type='index' ORDER BY rowid;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
UPDATE t1 SET x=NULL, x=3;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1_content' AND type!='trigger' ORDER BY rowid;;
CREATE UNIQUE INDEX blockid ON t1(x ASC);;
SELECT coalesce(x&x,99) FROM t1;;
SELECT 1%0 FROM t1;;
SELECT coalesce(x>>x,99) FROM t1;CREATE TABLE block(t1_segdir);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;
SELECT
    SrcWord, t1.x
    FROM 
      (SELECT 'FACTORING' AS SrcWord UNION SELECT 'SWIMMING' AS SrcWord )
    LEFT JOIN 
      t1
    WHERE t1.x= (
      SELECT BeginningId FROM (
        SELECT SrcWord, B.x as BeginningId, B.x || E.x As Connected
        FROM t1 B LEFT JOIN t1 E ON B.x=E.x
        WHERE Connected=SrcWord LIMIT 1
      )
    )
;;
INSERT INTO t1(x) VALUES(10);;
SELECT * FROM block;;
SELECT x IS x FROM t1;;
SELECT x+x FROM t1;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;
SELECT ( 
      SELECT x FROM (
        SELECT * FROM t1 WHERE x=out.x ORDER BY x LIMIT 10 OFFSET 1
      ) WHERE x=out.x
    ) FROM t1 AS out;;
SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;;
UPDATE t1 SET x=-9223372036854775807, x=-2;;
UPDATE t1 SET x=-9223372036854775808, x=0;;
UPDATE t1 SET x=9223372036854775807, x=0;;
UPDATE t1 SET x=9223372036854775807, x=-1;;
CREATE INDEX level ON t1(x ASC,  x ASC) ;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
UPDATE t1 SET x=-3037000500, x=-3037000500;PRAGMA journal_mode = DELETE;;
SELECT x NOT LIKE x FROM t1;;
SELECT x-x FROM t1;;
VACUUM;;
UPDATE t1 SET x=1e300, x=1e300;;
SELECT x notnull FROM t1;;
UPDATE t1 SET x='0.0', x='abc';;
UPDATE t1 SET x='abxyzzycy', x='A%CX';;
UPDATE t1 SET x='abc', x='aáˆ´_c';;
UPDATE t1 SET x='abcdefg', x='a*[^def]g';;
UPDATE t1 SET x='ABC', x='A[^A-D]C';;
UPDATE t1 SET x='ABC', x='A[^]B]C';;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;SELECT x FROM t1 WHERE x<10 AND x>8 ORDER BY x;SELECT typeof(00000009223372036854775807);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;PRAGMA max_page_count = 100;VACUUM ;SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'SEMI' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[ecmd SEMI]
parser: Input 'SELECT' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 1.
parser: ... then shift 'ecmd', pending reduce 318
parser: Reduce 318 [cmdlist ::= cmdlist ecmd], go to state 0.
parser: ... then shift 'cmdlist', go to state 1
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[cmdlist SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[cmdlist SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[cmdlist SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID]
parser: Input 'FROM' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[cmdlist SELECT distinct selcollist FROM]
parser: Input 'STRING' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'STRING', pending reduce 332
parser: Return. Stack=[cmdlist SELECT distinct selcollist FROM stl_prefix STRING]
parser: Input 'DOT' with pending reduce 332
parser: Reduce 332 [nm ::= STRING], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Shift 'DOT', go to state 245
parser: Return. Stack=[cmdlist SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID' in state 245
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[cmdlist SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 245.
parser: ... then shift 'nm', pending reduce 109
parser: Reduce 109 [dbnm ::= DOT nm], go to state 349.
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 416
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND' in state 537
parser: Reduce 168 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'AND', go to state 120
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID' in state 120
parser: Shift 'ID', go to state 416
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'NE' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Shift 'NE', go to state 117
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr AND expr NE]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr AND expr NE STRING]
parser: Input 'ORDER' in state 537
parser: Reduce 168 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Reduce 179 [expr ::= expr AND expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[cmdlist SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[cmdlist SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[cmdlist SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 1.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 1.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdlist cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping cmdlist
parser: [[[SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;;
SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;;
SELECT x, x
   FROM t1
  WHERE (x = 'A/B' OR
           ((x > 'A/B/') AND (x < 'A/B0')))
    AND x IS NOT NULL;;
SELECT x==1 OR x=2 FROM t1;;
CREATE INDEX t1_content ON t1(x ASC,  x DESC) ;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
CREATE INDEX docid ON t1(x DESC, x ASC) ;;
UPDATE t1 SET x=1;COMMIT;SELECT x, x FROM t1 WHERE x = 1 AND x IN (2, 4, 5) ORDER BY x ASC, x ASC;;
UPDATE t1 SET x=1, x=63;SELECT * FROM t1 INNER JOIN t1 AS x;;
CREATE INDEX c0content ON t1(x ASC,  x ASC) ;;
UPDATE t1 SET x=1, x=64;;
CREATE INDEX t1_segments ON t1(x ASC,  x DESC) ;;
SELECT x, x FROM t1 WHERE x = 3 AND x IN (2, 4, 5) ORDER BY x DESC, x ASC;SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE name='docid' AND type='index' ORDER BY rowid;;
UPDATE t1 SET x=32, x=3;;
UPDATE t1 SET x=25, x=11;;
SELECT coalesce(not x,99) FROM t1;;
SELECT coalesce(x IS NULL AND x=5,99) FROM t1;;
SELECT 5 not between x and x FROM t1;SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE name='docid' AND type='index' ORDER BY rowid;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
UPDATE t1 SET x=NULL, x=3;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1_content' AND type!='trigger' ORDER BY rowid;;
CREATE UNIQUE INDEX blockid ON t1(x ASC);;
SELECT coalesce(x&x,99) FROM t1;;
SELECT 1%0 FROM t1;;
SELECT coalesce(x>>x,99) FROM t1;CREATE TABLE block(t1_segdir);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;
SELECT
    SrcWord, t1.x
    FROM 
      (SELECT 'FACTORING' AS SrcWord UNION SELECT 'SWIMMING' AS SrcWord )
    LEFT JOIN 
      t1
    WHERE t1.x= (
      SELECT BeginningId FROM (
        SELECT SrcWord, B.x as BeginningId, B.x || E.x As Connected
        FROM t1 B LEFT JOIN t1 E ON B.x=E.x
        WHERE Connected=SrcWord LIMIT 1
      )
    )
;;
INSERT INTO t1(x) VALUES(10);;
SELECT * FROM block;;
SELECT x IS x FROM t1;;
SELECT x+x FROM t1;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;
SELECT ( 
      SELECT x FROM (
        SELECT * FROM t1 WHERE x=out.x ORDER BY x LIMIT 10 OFFSET 1
      ) WHERE x=out.x
    ) FROM t1 AS out;;
SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;;
UPDATE t1 SET x=-9223372036854775807, x=-2;;
UPDATE t1 SET x=-9223372036854775808, x=0;;
UPDATE t1 SET x=9223372036854775807, x=0;;
UPDATE t1 SET x=9223372036854775807, x=-1;;
CREATE INDEX level ON t1(x ASC,  x ASC) ;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
UPDATE t1 SET x=-3037000500, x=-3037000500;PRAGMA journal_mode = DELETE;;
SELECT x NOT LIKE x FROM t1;;
SELECT x-x FROM t1;;
VACUUM;;
UPDATE t1 SET x=1e300, x=1e300;;
SELECT x notnull FROM t1;;
UPDATE t1 SET x='0.0', x='abc';;
UPDATE t1 SET x='abxyzzycy', x='A%CX';;
UPDATE t1 SET x='abc', x='aáˆ´_c';;
UPDATE t1 SET x='abcdefg', x='a*[^def]g';;
UPDATE t1 SET x='ABC', x='A[^A-D]C';;
UPDATE t1 SET x='ABC', x='A[^]B]C';;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;SELECT x FROM t1 WHERE x<10 AND x>8 ORDER BY x;SELECT typeof(00000009223372036854775807);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;PRAGMA max_page_count = 100;VACUUM ;SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'FROM' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'STRING' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'STRING', pending reduce 332
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix STRING]
parser: Input 'DOT' with pending reduce 332
parser: Reduce 332 [nm ::= STRING], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Shift 'DOT', go to state 245
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID' in state 245
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 245.
parser: ... then shift 'nm', pending reduce 109
parser: Reduce 109 [dbnm ::= DOT nm], go to state 349.
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[SELECT distinct selcollist from WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND' in state 537
parser: Reduce 168 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'AND', go to state 120
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID' in state 120
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'NE' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Shift 'NE', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr NE]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr NE STRING]
parser: Input 'ORDER' in state 537
parser: Reduce 168 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Reduce 179 [expr ::= expr AND expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[;
SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;;
SELECT x, x
   FROM t1
  WHERE (x = 'A/B' OR
           ((x > 'A/B/') AND (x < 'A/B0')))
    AND x IS NOT NULL;;
SELECT x==1 OR x=2 FROM t1;;
CREATE INDEX t1_content ON t1(x ASC,  x DESC) ;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
CREATE INDEX docid ON t1(x DESC, x ASC) ;;
UPDATE t1 SET x=1;COMMIT;SELECT x, x FROM t1 WHERE x = 1 AND x IN (2, 4, 5) ORDER BY x ASC, x ASC;;
UPDATE t1 SET x=1, x=63;SELECT * FROM t1 INNER JOIN t1 AS x;;
CREATE INDEX c0content ON t1(x ASC,  x ASC) ;;
UPDATE t1 SET x=1, x=64;;
CREATE INDEX t1_segments ON t1(x ASC,  x DESC) ;;
SELECT x, x FROM t1 WHERE x = 3 AND x IN (2, 4, 5) ORDER BY x DESC, x ASC;SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE name='docid' AND type='index' ORDER BY rowid;;
UPDATE t1 SET x=32, x=3;;
UPDATE t1 SET x=25, x=11;;
SELECT coalesce(not x,99) FROM t1;;
SELECT coalesce(x IS NULL AND x=5,99) FROM t1;;
SELECT 5 not between x and x FROM t1;SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE name='docid' AND type='index' ORDER BY rowid;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
UPDATE t1 SET x=NULL, x=3;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1_content' AND type!='trigger' ORDER BY rowid;;
CREATE UNIQUE INDEX blockid ON t1(x ASC);;
SELECT coalesce(x&x,99) FROM t1;;
SELECT 1%0 FROM t1;;
SELECT coalesce(x>>x,99) FROM t1;CREATE TABLE block(t1_segdir);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;
SELECT
    SrcWord, t1.x
    FROM 
      (SELECT 'FACTORING' AS SrcWord UNION SELECT 'SWIMMING' AS SrcWord )
    LEFT JOIN 
      t1
    WHERE t1.x= (
      SELECT BeginningId FROM (
        SELECT SrcWord, B.x as BeginningId, B.x || E.x As Connected
        FROM t1 B LEFT JOIN t1 E ON B.x=E.x
        WHERE Connected=SrcWord LIMIT 1
      )
    )
;;
INSERT INTO t1(x) VALUES(10);;
SELECT * FROM block;;
SELECT x IS x FROM t1;;
SELECT x+x FROM t1;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;
SELECT ( 
      SELECT x FROM (
        SELECT * FROM t1 WHERE x=out.x ORDER BY x LIMIT 10 OFFSET 1
      ) WHERE x=out.x
    ) FROM t1 AS out;;
SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;;
UPDATE t1 SET x=-9223372036854775807, x=-2;;
UPDATE t1 SET x=-9223372036854775808, x=0;;
UPDATE t1 SET x=9223372036854775807, x=0;;
UPDATE t1 SET x=9223372036854775807, x=-1;;
CREATE INDEX level ON t1(x ASC,  x ASC) ;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
UPDATE t1 SET x=-3037000500, x=-3037000500;PRAGMA journal_mode = DELETE;;
SELECT x NOT LIKE x FROM t1;;
SELECT x-x FROM t1;;
VACUUM;;
UPDATE t1 SET x=1e300, x=1e300;;
SELECT x notnull FROM t1;;
UPDATE t1 SET x='0.0', x='abc';;
UPDATE t1 SET x='abxyzzycy', x='A%CX';;
UPDATE t1 SET x='abc', x='aáˆ´_c';;
UPDATE t1 SET x='abcdefg', x='a*[^def]g';;
UPDATE t1 SET x='ABC', x='A[^A-D]C';;
UPDATE t1 SET x='ABC', x='A[^]B]C';;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;SELECT x FROM t1 WHERE x<10 AND x>8 ORDER BY x;SELECT typeof(00000009223372036854775807);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;PRAGMA max_page_count = 100;VACUUM ;SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'SELECT' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[ecmd SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[ecmd SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[ecmd SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt ID]
parser: Input 'FROM' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[ecmd SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'DOT' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Shift 'DOT', go to state 245
parser: Return. Stack=[ecmd SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID' in state 245
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'ORDER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 245.
parser: ... then shift 'nm', pending reduce 109
parser: Reduce 109 [dbnm ::= DOT nm], go to state 349.
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[ecmd SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[ecmd SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 1.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 1.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
parser: [[[;
SELECT x, x
   FROM t1
  WHERE (x = 'A/B' OR
           ((x > 'A/B/') AND (x < 'A/B0')))
    AND x IS NOT NULL;;
SELECT x==1 OR x=2 FROM t1;;
CREATE INDEX t1_content ON t1(x ASC,  x DESC) ;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
CREATE INDEX docid ON t1(x DESC, x ASC) ;;
UPDATE t1 SET x=1;COMMIT;SELECT x, x FROM t1 WHERE x = 1 AND x IN (2, 4, 5) ORDER BY x ASC, x ASC;;
UPDATE t1 SET x=1, x=63;SELECT * FROM t1 INNER JOIN t1 AS x;;
CREATE INDEX c0content ON t1(x ASC,  x ASC) ;;
UPDATE t1 SET x=1, x=64;;
CREATE INDEX t1_segments ON t1(x ASC,  x DESC) ;;
SELECT x, x FROM t1 WHERE x = 3 AND x IN (2, 4, 5) ORDER BY x DESC, x ASC;SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE name='docid' AND type='index' ORDER BY rowid;;
UPDATE t1 SET x=32, x=3;;
UPDATE t1 SET x=25, x=11;;
SELECT coalesce(not x,99) FROM t1;;
SELECT coalesce(x IS NULL AND x=5,99) FROM t1;;
SELECT 5 not between x and x FROM t1;SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE name='docid' AND type='index' ORDER BY rowid;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
UPDATE t1 SET x=NULL, x=3;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1_content' AND type!='trigger' ORDER BY rowid;;
CREATE UNIQUE INDEX blockid ON t1(x ASC);;
SELECT coalesce(x&x,99) FROM t1;;
SELECT 1%0 FROM t1;;
SELECT coalesce(x>>x,99) FROM t1;CREATE TABLE block(t1_segdir);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;
SELECT
    SrcWord, t1.x
    FROM 
      (SELECT 'FACTORING' AS SrcWord UNION SELECT 'SWIMMING' AS SrcWord )
    LEFT JOIN 
      t1
    WHERE t1.x= (
      SELECT BeginningId FROM (
        SELECT SrcWord, B.x as BeginningId, B.x || E.x As Connected
        FROM t1 B LEFT JOIN t1 E ON B.x=E.x
        WHERE Connected=SrcWord LIMIT 1
      )
    )
;;
INSERT INTO t1(x) VALUES(10);;
SELECT * FROM block;;
SELECT x IS x FROM t1;;
SELECT x+x FROM t1;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;
SELECT ( 
      SELECT x FROM (
        SELECT * FROM t1 WHERE x=out.x ORDER BY x LIMIT 10 OFFSET 1
      ) WHERE x=out.x
    ) FROM t1 AS out;;
SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;;
UPDATE t1 SET x=-9223372036854775807, x=-2;;
UPDATE t1 SET x=-9223372036854775808, x=0;;
UPDATE t1 SET x=9223372036854775807, x=0;;
UPDATE t1 SET x=9223372036854775807, x=-1;;
CREATE INDEX level ON t1(x ASC,  x ASC) ;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
UPDATE t1 SET x=-3037000500, x=-3037000500;PRAGMA journal_mode = DELETE;;
SELECT x NOT LIKE x FROM t1;;
SELECT x-x FROM t1;;
VACUUM;;
UPDATE t1 SET x=1e300, x=1e300;;
SELECT x notnull FROM t1;;
UPDATE t1 SET x='0.0', x='abc';;
UPDATE t1 SET x='abxyzzycy', x='A%CX';;
UPDATE t1 SET x='abc', x='aáˆ´_c';;
UPDATE t1 SET x='abcdefg', x='a*[^def]g';;
UPDATE t1 SET x='ABC', x='A[^A-D]C';;
UPDATE t1 SET x='ABC', x='A[^]B]C';;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;SELECT x FROM t1 WHERE x<10 AND x>8 ORDER BY x;SELECT typeof(00000009223372036854775807);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;PRAGMA max_page_count = 100;VACUUM ;SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'SELECT' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[ecmd SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[ecmd SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt ID]
parser: Input 'FROM' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[ecmd SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE]
parser: Input 'LP' in state 93
parser: Shift 'LP', go to state 4
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE LP]
parser: Input 'ID' in state 4
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE LP ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 4.
parser: ... then shift 'expr', go to state 50
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE LP expr EQ]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE LP expr EQ STRING]
parser: Input 'OR' in state 537
parser: Reduce 168 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 4.
parser: ... then shift 'expr', go to state 50
parser: Shift 'OR', go to state 119
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE LP expr OR]
parser: Input 'LP' in state 119
parser: Shift 'LP', go to state 4
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE LP expr OR LP]
parser: Input 'LP' in state 4
parser: Shift 'LP', go to state 4
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE LP expr OR LP LP]
parser: Input 'ID' in state 4
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE LP expr OR LP LP ID]
parser: Input 'GT' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 4.
parser: ... then shift 'expr', go to state 50
parser: Shift 'GT', go to state 118
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE LP expr OR LP LP expr GT]
parser: Input 'STRING' in state 118
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE LP expr OR LP LP expr GT STRING]
parser: Input 'RP' in state 537
parser: Reduce 168 [term ::= STRING], go to state 118.
parser: ... then shift 'term', go to state 130
parser: Reduce 181 [expr ::= expr LT|GT|GE|LE expr], go to state 4.
parser: ... then shift 'expr', go to state 50
parser: Shift 'RP', pending reduce 162
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE LP expr OR LP LP expr RP]
parser: Input 'AND' with pending reduce 162
parser: Reduce 162 [expr ::= LP expr RP], go to state 4.
parser: ... then shift 'expr', go to state 50
parser: Shift 'AND', go to state 120
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE LP expr OR LP expr AND]
parser: Input 'LP' in state 120
parser: Shift 'LP', go to state 4
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE LP expr OR LP expr AND LP]
parser: Input 'ID' in state 4
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE LP expr OR LP expr AND LP ID]
parser: Input 'LT' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 4.
parser: ... then shift 'expr', go to state 50
parser: Shift 'LT', go to state 118
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE LP expr OR LP expr AND LP expr LT]
parser: Input 'STRING' in state 118
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE LP expr OR LP expr AND LP expr LT STRING]
parser: Input 'RP' in state 537
parser: Reduce 168 [term ::= STRING], go to state 118.
parser: ... then shift 'term', go to state 130
parser: Reduce 181 [expr ::= expr LT|GT|GE|LE expr], go to state 4.
parser: ... then shift 'expr', go to state 50
parser: Shift 'RP', pending reduce 162
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE LP expr OR LP expr AND LP expr RP]
parser: Input 'RP' with pending reduce 162
parser: Reduce 162 [expr ::= LP expr RP], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Reduce 179 [expr ::= expr AND expr], go to state 4.
parser: ... then shift 'expr', go to state 50
parser: Shift 'RP', pending reduce 162
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE LP expr OR LP expr RP]
parser: Input 'RP' with pending reduce 162
parser: Reduce 162 [expr ::= LP expr RP], go to state 119.
parser: ... then shift 'expr', go to state 74
parser: Reduce 180 [expr ::= expr OR expr], go to state 4.
parser: ... then shift 'expr', go to state 50
parser: Shift 'RP', pending reduce 162
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE LP expr RP]
parser: Input 'AND' with pending reduce 162
parser: Reduce 162 [expr ::= LP expr RP], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'AND', go to state 120
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID' in state 120
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'IS' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Shift 'IS', go to state 110
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr AND expr IS]
parser: Input 'NOT' in state 110
parser: Shift 'NOT', go to state 97
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr AND expr IS NOT]
parser: Input 'NULL' in state 97
parser: Shift 'NULL', pending reduce 167
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr AND expr IS NOT NULL]
parser: Input 'SEMI' with pending reduce 167
parser: Reduce 167 [term ::= NULL|FLOAT|BLOB], go to state 97.
parser: ... then shift 'term', go to state 125
parser: Reduce 193 [expr ::= expr IS NOT expr], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Reduce 179 [expr ::= expr AND expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 1.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 1.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
parser: [[[;
SELECT x==1 OR x=2 FROM t1;;
CREATE INDEX t1_content ON t1(x ASC,  x DESC) ;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
CREATE INDEX docid ON t1(x DESC, x ASC) ;;
UPDATE t1 SET x=1;COMMIT;SELECT x, x FROM t1 WHERE x = 1 AND x IN (2, 4, 5) ORDER BY x ASC, x ASC;;
UPDATE t1 SET x=1, x=63;SELECT * FROM t1 INNER JOIN t1 AS x;;
CREATE INDEX c0content ON t1(x ASC,  x ASC) ;;
UPDATE t1 SET x=1, x=64;;
CREATE INDEX t1_segments ON t1(x ASC,  x DESC) ;;
SELECT x, x FROM t1 WHERE x = 3 AND x IN (2, 4, 5) ORDER BY x DESC, x ASC;SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE name='docid' AND type='index' ORDER BY rowid;;
UPDATE t1 SET x=32, x=3;;
UPDATE t1 SET x=25, x=11;;
SELECT coalesce(not x,99) FROM t1;;
SELECT coalesce(x IS NULL AND x=5,99) FROM t1;;
SELECT 5 not between x and x FROM t1;SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE name='docid' AND type='index' ORDER BY rowid;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
UPDATE t1 SET x=NULL, x=3;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1_content' AND type!='trigger' ORDER BY rowid;;
CREATE UNIQUE INDEX blockid ON t1(x ASC);;
SELECT coalesce(x&x,99) FROM t1;;
SELECT 1%0 FROM t1;;
SELECT coalesce(x>>x,99) FROM t1;CREATE TABLE block(t1_segdir);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;
SELECT
    SrcWord, t1.x
    FROM 
      (SELECT 'FACTORING' AS SrcWord UNION SELECT 'SWIMMING' AS SrcWord )
    LEFT JOIN 
      t1
    WHERE t1.x= (
      SELECT BeginningId FROM (
        SELECT SrcWord, B.x as BeginningId, B.x || E.x As Connected
        FROM t1 B LEFT JOIN t1 E ON B.x=E.x
        WHERE Connected=SrcWord LIMIT 1
      )
    )
;;
INSERT INTO t1(x) VALUES(10);;
SELECT * FROM block;;
SELECT x IS x FROM t1;;
SELECT x+x FROM t1;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;
SELECT ( 
      SELECT x FROM (
        SELECT * FROM t1 WHERE x=out.x ORDER BY x LIMIT 10 OFFSET 1
      ) WHERE x=out.x
    ) FROM t1 AS out;;
SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;;
UPDATE t1 SET x=-9223372036854775807, x=-2;;
UPDATE t1 SET x=-9223372036854775808, x=0;;
UPDATE t1 SET x=9223372036854775807, x=0;;
UPDATE t1 SET x=9223372036854775807, x=-1;;
CREATE INDEX level ON t1(x ASC,  x ASC) ;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
UPDATE t1 SET x=-3037000500, x=-3037000500;PRAGMA journal_mode = DELETE;;
SELECT x NOT LIKE x FROM t1;;
SELECT x-x FROM t1;;
VACUUM;;
UPDATE t1 SET x=1e300, x=1e300;;
SELECT x notnull FROM t1;;
UPDATE t1 SET x='0.0', x='abc';;
UPDATE t1 SET x='abxyzzycy', x='A%CX';;
UPDATE t1 SET x='abc', x='aáˆ´_c';;
UPDATE t1 SET x='abcdefg', x='a*[^def]g';;
UPDATE t1 SET x='ABC', x='A[^A-D]C';;
UPDATE t1 SET x='ABC', x='A[^]B]C';;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;SELECT x FROM t1 WHERE x<10 AND x>8 ORDER BY x;SELECT typeof(00000009223372036854775807);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;PRAGMA max_page_count = 100;VACUUM ;SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'SELECT' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[ecmd SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt expr EQ]
parser: Input 'INTEGER' in state 117
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt expr EQ INTEGER]
parser: Input 'OR' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Shift 'OR', go to state 119
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt expr OR]
parser: Input 'ID' in state 119
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt expr OR ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 119.
parser: ... then shift 'expr', go to state 74
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt expr OR expr EQ]
parser: Input 'INTEGER' in state 117
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt expr OR expr EQ INTEGER]
parser: Input 'FROM' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 119.
parser: ... then shift 'expr', go to state 74
parser: Reduce 180 [expr ::= expr OR expr], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[ecmd SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'SEMI' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 1.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 1.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
parser: [[[;
CREATE INDEX t1_content ON t1(x ASC,  x DESC) ;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
CREATE INDEX docid ON t1(x DESC, x ASC) ;;
UPDATE t1 SET x=1;COMMIT;SELECT x, x FROM t1 WHERE x = 1 AND x IN (2, 4, 5) ORDER BY x ASC, x ASC;;
UPDATE t1 SET x=1, x=63;SELECT * FROM t1 INNER JOIN t1 AS x;;
CREATE INDEX c0content ON t1(x ASC,  x ASC) ;;
UPDATE t1 SET x=1, x=64;;
CREATE INDEX t1_segments ON t1(x ASC,  x DESC) ;;
SELECT x, x FROM t1 WHERE x = 3 AND x IN (2, 4, 5) ORDER BY x DESC, x ASC;SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE name='docid' AND type='index' ORDER BY rowid;;
UPDATE t1 SET x=32, x=3;;
UPDATE t1 SET x=25, x=11;;
SELECT coalesce(not x,99) FROM t1;;
SELECT coalesce(x IS NULL AND x=5,99) FROM t1;;
SELECT 5 not between x and x FROM t1;SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE name='docid' AND type='index' ORDER BY rowid;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
UPDATE t1 SET x=NULL, x=3;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1_content' AND type!='trigger' ORDER BY rowid;;
CREATE UNIQUE INDEX blockid ON t1(x ASC);;
SELECT coalesce(x&x,99) FROM t1;;
SELECT 1%0 FROM t1;;
SELECT coalesce(x>>x,99) FROM t1;CREATE TABLE block(t1_segdir);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;
SELECT
    SrcWord, t1.x
    FROM 
      (SELECT 'FACTORING' AS SrcWord UNION SELECT 'SWIMMING' AS SrcWord )
    LEFT JOIN 
      t1
    WHERE t1.x= (
      SELECT BeginningId FROM (
        SELECT SrcWord, B.x as BeginningId, B.x || E.x As Connected
        FROM t1 B LEFT JOIN t1 E ON B.x=E.x
        WHERE Connected=SrcWord LIMIT 1
      )
    )
;;
INSERT INTO t1(x) VALUES(10);;
SELECT * FROM block;;
SELECT x IS x FROM t1;;
SELECT x+x FROM t1;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;
SELECT ( 
      SELECT x FROM (
        SELECT * FROM t1 WHERE x=out.x ORDER BY x LIMIT 10 OFFSET 1
      ) WHERE x=out.x
    ) FROM t1 AS out;;
SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;;
UPDATE t1 SET x=-9223372036854775807, x=-2;;
UPDATE t1 SET x=-9223372036854775808, x=0;;
UPDATE t1 SET x=9223372036854775807, x=0;;
UPDATE t1 SET x=9223372036854775807, x=-1;;
CREATE INDEX level ON t1(x ASC,  x ASC) ;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
UPDATE t1 SET x=-3037000500, x=-3037000500;PRAGMA journal_mode = DELETE;;
SELECT x NOT LIKE x FROM t1;;
SELECT x-x FROM t1;;
VACUUM;;
UPDATE t1 SET x=1e300, x=1e300;;
SELECT x notnull FROM t1;;
UPDATE t1 SET x='0.0', x='abc';;
UPDATE t1 SET x='abxyzzycy', x='A%CX';;
UPDATE t1 SET x='abc', x='aáˆ´_c';;
UPDATE t1 SET x='abcdefg', x='a*[^def]g';;
UPDATE t1 SET x='ABC', x='A[^A-D]C';;
UPDATE t1 SET x='ABC', x='A[^]B]C';;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;SELECT x FROM t1 WHERE x<10 AND x>8 ORDER BY x;SELECT typeof(00000009223372036854775807);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;PRAGMA max_page_count = 100;VACUUM ;SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'CREATE' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[ecmd CREATE]
parser: Input 'INDEX' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 1.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 221 [uniqueflag ::=].
parser: ... then shift 'uniqueflag', go to state 453
parser: Shift 'INDEX', go to state 315
parser: Return. Stack=[ecmd createkw uniqueflag INDEX]
parser: Input 'ID' in state 315
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 225
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd createkw uniqueflag INDEX ifnotexists ID]
parser: Input 'ON' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 225.
parser: ... then shift 'nm', go to state 314
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 452
parser: Shift 'ON', go to state 224
parser: Return. Stack=[ecmd createkw uniqueflag INDEX ifnotexists nm dbnm ON]
parser: Input 'ID' in state 224
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd createkw uniqueflag INDEX ifnotexists nm dbnm ON ID]
parser: Input 'LP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 224.
parser: ... then shift 'nm', go to state 451
parser: Shift 'LP', go to state 18
parser: Return. Stack=[ecmd createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP]
parser: Input 'ID' in state 18
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP ID]
parser: Input 'ASC' in state 416
parser: FALLBACK ASC => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 18.
parser: ... then shift 'expr', go to state 13
parser: Shift 'ASC', pending reduce 131
parser: Return. Stack=[ecmd createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP expr ASC]
parser: Input 'COMMA' with pending reduce 131
parser: Reduce 131 [sortorder ::= ASC], go to state 13.
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 18.
parser: ... then shift 'sortlist', go to state 400
parser: Shift 'COMMA', go to state 95
parser: Return. Stack=[ecmd createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist COMMA]
parser: Input 'ID' in state 95
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist COMMA ID]
parser: Input 'DESC' in state 416
parser: FALLBACK DESC => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 95.
parser: ... then shift 'expr', go to state 14
parser: Shift 'DESC', pending reduce 132
parser: Return. Stack=[ecmd createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist COMMA expr DESC]
parser: Input 'RP' with pending reduce 132
parser: Reduce 132 [sortorder ::= DESC], go to state 14.
parser: ... then shift 'sortorder', pending reduce 129
parser: Reduce 129 [sortlist ::= sortlist COMMA expr sortorder], go to state 18.
parser: ... then shift 'sortlist', go to state 400
parser: Shift 'RP', go to state 313
parser: Return. Stack=[ecmd createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP]
parser: Input 'SEMI' in state 313
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', pending reduce 219
parser: Reduce 219 [cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt], go to state 1.
parser: [[[INSERT INTO 'main'.sqlite_master VALUES('index','t1_content','t1',#1,'CREATE INDEX t1_content ON t1(x ASC,  x DESC) ');]]]
parser: Input 'INSERT' in state 0
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'INSERT', go to state 311
parser: Return. Stack=[with INSERT]
parser: Input 'INTO' in state 311
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', pending reduce 156
parser: Reduce 156 [insert_cmd ::= INSERT orconf], go to state 219.
parser: ... then shift 'insert_cmd', go to state 427
parser: Shift 'INTO', go to state 164
parser: Return. Stack=[with insert_cmd INTO]
parser: Input 'STRING' in state 164
parser: Shift 'STRING', pending reduce 332
parser: Return. Stack=[with insert_cmd INTO STRING]
parser: Input 'DOT' with pending reduce 332
parser: Reduce 332 [nm ::= STRING], go to state 164.
parser: ... then shift 'nm', go to state 393
parser: Shift 'DOT', go to state 218
parser: Return. Stack=[with insert_cmd INTO nm DOT]
parser: Input 'ID' in state 218
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with insert_cmd INTO nm DOT ID]
parser: Input 'VALUES' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 218.
parser: ... then shift 'nm', go to state 429
parser: Reduce 113 [xfullname ::= nm DOT nm], go to state 164.
parser: ... then shift 'xfullname', go to state 298
parser: Reduce 158 [idlist_opt ::=].
parser: ... then shift 'idlist_opt', go to state 35
parser: Shift 'VALUES', go to state 526
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES]
parser: Input 'LP' in state 526
parser: Shift 'LP', go to state 28
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP]
parser: Input 'STRING' in state 28
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 28.
parser: ... then shift 'term', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'STRING' in state 107
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'STRING' in state 107
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'VARIABLE' in state 107
parser: Shift 'VARIABLE', pending reduce 170
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA VARIABLE]
parser: Input 'COMMA' with pending reduce 170
parser: Reduce 170 [expr ::= VARIABLE], go to state 107.
parser: ... then shift 'expr', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'STRING' in state 107
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA STRING]
parser: Input 'RP' in state 537
parser: Reduce 168 [term ::= STRING], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'RP', pending reduce 89
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist RP]
parser: Input 'SEMI' with pending reduce 89
parser: Reduce 89 [values ::= VALUES LP nexprlist RP], go to state 35.
parser: ... then shift 'values', go to state 532
parser: Reduce 348 [oneselect ::= values], go to state 35.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 35.
parser: ... then shift 'select', go to state 297
parser: Reduce 152 [upsert ::=].
parser: ... then shift 'upsert', pending reduce 150
parser: Reduce 150 [cmd ::= with insert_cmd INTO xfullname idlist_opt select upsert], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Input '$' with pending reduce 321
parser: Reduce 321 [ecmd ::= cmdx SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 317 [input ::= cmdlist], go to state 0.
parser: ... then shift 'input', pending reduce -2
parser: Accept!
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
parser: [[[SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE name='t1_content' AND type='index' ORDER BY rowid]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'FROM' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'STRING' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'STRING', pending reduce 332
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix STRING]
parser: Input 'DOT' with pending reduce 332
parser: Reduce 332 [nm ::= STRING], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Shift 'DOT', go to state 245
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID' in state 245
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 245.
parser: ... then shift 'nm', pending reduce 109
parser: Reduce 109 [dbnm ::= DOT nm], go to state 349.
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[SELECT distinct selcollist from WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND' in state 537
parser: Reduce 168 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'AND', go to state 120
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID' in state 120
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr EQ]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr EQ STRING]
parser: Input 'ORDER' in state 537
parser: Reduce 168 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Reduce 179 [expr ::= expr AND expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[CREATE INDEX t1_content ON t1(x ASC,  x DESC) ]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'INDEX' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 221 [uniqueflag ::=].
parser: ... then shift 'uniqueflag', go to state 453
parser: Shift 'INDEX', go to state 315
parser: Return. Stack=[createkw uniqueflag INDEX]
parser: Input 'ID' in state 315
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 225
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists ID]
parser: Input 'ON' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 225.
parser: ... then shift 'nm', go to state 314
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 452
parser: Shift 'ON', go to state 224
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON]
parser: Input 'ID' in state 224
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON ID]
parser: Input 'LP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 224.
parser: ... then shift 'nm', go to state 451
parser: Shift 'LP', go to state 18
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP]
parser: Input 'ID' in state 18
parser: Shift 'ID', go to state 416
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP ID]
parser: Input 'ASC' in state 416
parser: FALLBACK ASC => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 18.
parser: ... then shift 'expr', go to state 13
parser: Shift 'ASC', pending reduce 131
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP expr ASC]
parser: Input 'COMMA' with pending reduce 131
parser: Reduce 131 [sortorder ::= ASC], go to state 13.
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 18.
parser: ... then shift 'sortlist', go to state 400
parser: Shift 'COMMA', go to state 95
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist COMMA]
parser: Input 'ID' in state 95
parser: Shift 'ID', go to state 416
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist COMMA ID]
parser: Input 'DESC' in state 416
parser: FALLBACK DESC => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 95.
parser: ... then shift 'expr', go to state 14
parser: Shift 'DESC', pending reduce 132
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist COMMA expr DESC]
parser: Input 'RP' with pending reduce 132
parser: Reduce 132 [sortorder ::= DESC], go to state 14.
parser: ... then shift 'sortorder', pending reduce 129
parser: Reduce 129 [sortlist ::= sortlist COMMA expr sortorder], go to state 18.
parser: ... then shift 'sortlist', go to state 400
parser: Shift 'RP', go to state 313
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP]
parser: Input 'SEMI' in state 313
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', pending reduce 219
parser: Reduce 219 [cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
CREATE INDEX docid ON t1(x DESC, x ASC) ;;
UPDATE t1 SET x=1;COMMIT;SELECT x, x FROM t1 WHERE x = 1 AND x IN (2, 4, 5) ORDER BY x ASC, x ASC;;
UPDATE t1 SET x=1, x=63;SELECT * FROM t1 INNER JOIN t1 AS x;;
CREATE INDEX c0content ON t1(x ASC,  x ASC) ;;
UPDATE t1 SET x=1, x=64;;
CREATE INDEX t1_segments ON t1(x ASC,  x DESC) ;;
SELECT x, x FROM t1 WHERE x = 3 AND x IN (2, 4, 5) ORDER BY x DESC, x ASC;SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE name='docid' AND type='index' ORDER BY rowid;;
UPDATE t1 SET x=32, x=3;;
UPDATE t1 SET x=25, x=11;;
SELECT coalesce(not x,99) FROM t1;;
SELECT coalesce(x IS NULL AND x=5,99) FROM t1;;
SELECT 5 not between x and x FROM t1;SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE name='docid' AND type='index' ORDER BY rowid;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
UPDATE t1 SET x=NULL, x=3;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1_content' AND type!='trigger' ORDER BY rowid;;
CREATE UNIQUE INDEX blockid ON t1(x ASC);;
SELECT coalesce(x&x,99) FROM t1;;
SELECT 1%0 FROM t1;;
SELECT coalesce(x>>x,99) FROM t1;CREATE TABLE block(t1_segdir);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;
SELECT
    SrcWord, t1.x
    FROM 
      (SELECT 'FACTORING' AS SrcWord UNION SELECT 'SWIMMING' AS SrcWord )
    LEFT JOIN 
      t1
    WHERE t1.x= (
      SELECT BeginningId FROM (
        SELECT SrcWord, B.x as BeginningId, B.x || E.x As Connected
        FROM t1 B LEFT JOIN t1 E ON B.x=E.x
        WHERE Connected=SrcWord LIMIT 1
      )
    )
;;
INSERT INTO t1(x) VALUES(10);;
SELECT * FROM block;;
SELECT x IS x FROM t1;;
SELECT x+x FROM t1;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;
SELECT ( 
      SELECT x FROM (
        SELECT * FROM t1 WHERE x=out.x ORDER BY x LIMIT 10 OFFSET 1
      ) WHERE x=out.x
    ) FROM t1 AS out;;
SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;;
UPDATE t1 SET x=-9223372036854775807, x=-2;;
UPDATE t1 SET x=-9223372036854775808, x=0;;
UPDATE t1 SET x=9223372036854775807, x=0;;
UPDATE t1 SET x=9223372036854775807, x=-1;;
CREATE INDEX level ON t1(x ASC,  x ASC) ;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
UPDATE t1 SET x=-3037000500, x=-3037000500;PRAGMA journal_mode = DELETE;;
SELECT x NOT LIKE x FROM t1;;
SELECT x-x FROM t1;;
VACUUM;;
UPDATE t1 SET x=1e300, x=1e300;;
SELECT x notnull FROM t1;;
UPDATE t1 SET x='0.0', x='abc';;
UPDATE t1 SET x='abxyzzycy', x='A%CX';;
UPDATE t1 SET x='abc', x='aáˆ´_c';;
UPDATE t1 SET x='abcdefg', x='a*[^def]g';;
UPDATE t1 SET x='ABC', x='A[^A-D]C';;
UPDATE t1 SET x='ABC', x='A[^]B]C';;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;SELECT x FROM t1 WHERE x<10 AND x>8 ORDER BY x;SELECT typeof(00000009223372036854775807);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;PRAGMA max_page_count = 100;VACUUM ;SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'SELECT' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[ecmd SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[ecmd SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt ID]
parser: Input 'FROM' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[ecmd SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'INTEGER' in state 117
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ INTEGER]
parser: Input 'AND' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'AND', go to state 120
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID' in state 120
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'IN' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Shift 'IN', pending reduce 200
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr AND expr IN]
parser: Input 'LP' with pending reduce 200
parser: Reduce 200 [in_op ::= IN], go to state 76.
parser: ... then shift 'in_op', go to state 209
parser: Shift 'LP', go to state 3
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr AND expr in_op LP]
parser: Input 'INTEGER' in state 3
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr AND expr in_op LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 3.
parser: ... then shift 'term', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 3.
parser: ... then shift 'nexprlist', go to state 517
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr AND expr in_op LP nexprlist COMMA]
parser: Input 'INTEGER' in state 107
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr AND expr in_op LP nexprlist COMMA INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 3.
parser: ... then shift 'nexprlist', go to state 517
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr AND expr in_op LP nexprlist COMMA]
parser: Input 'INTEGER' in state 107
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr AND expr in_op LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 3.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 3.
parser: ... then shift 'exprlist', go to state 519
parser: Shift 'RP', pending reduce 202
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr AND expr in_op LP exprlist RP]
parser: Input 'ORDER' with pending reduce 202
parser: Reduce 202 [expr ::= expr in_op LP exprlist RP], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Reduce 179 [expr ::= expr AND expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[ecmd SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[ecmd SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'DESC' in state 416
parser: FALLBACK DESC => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Shift 'DESC', pending reduce 132
parser: Return. Stack=[ecmd SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY expr DESC]
parser: Input 'COMMA' with pending reduce 132
parser: Reduce 132 [sortorder ::= DESC], go to state 13.
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Shift 'COMMA', go to state 95
parser: Return. Stack=[ecmd SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY sortlist COMMA]
parser: Input 'ID' in state 95
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY sortlist COMMA ID]
parser: Input 'DESC' in state 416
parser: FALLBACK DESC => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 95.
parser: ... then shift 'expr', go to state 14
parser: Shift 'DESC', pending reduce 132
parser: Return. Stack=[ecmd SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY sortlist COMMA expr DESC]
parser: Input 'SEMI' with pending reduce 132
parser: Reduce 132 [sortorder ::= DESC], go to state 14.
parser: ... then shift 'sortorder', pending reduce 129
parser: Reduce 129 [sortlist ::= sortlist COMMA expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 1.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 1.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
parser: [[[;
CREATE INDEX docid ON t1(x DESC, x ASC) ;;
UPDATE t1 SET x=1;COMMIT;SELECT x, x FROM t1 WHERE x = 1 AND x IN (2, 4, 5) ORDER BY x ASC, x ASC;;
UPDATE t1 SET x=1, x=63;SELECT * FROM t1 INNER JOIN t1 AS x;;
CREATE INDEX c0content ON t1(x ASC,  x ASC) ;;
UPDATE t1 SET x=1, x=64;;
CREATE INDEX t1_segments ON t1(x ASC,  x DESC) ;;
SELECT x, x FROM t1 WHERE x = 3 AND x IN (2, 4, 5) ORDER BY x DESC, x ASC;SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE name='docid' AND type='index' ORDER BY rowid;;
UPDATE t1 SET x=32, x=3;;
UPDATE t1 SET x=25, x=11;;
SELECT coalesce(not x,99) FROM t1;;
SELECT coalesce(x IS NULL AND x=5,99) FROM t1;;
SELECT 5 not between x and x FROM t1;SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE name='docid' AND type='index' ORDER BY rowid;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
UPDATE t1 SET x=NULL, x=3;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1_content' AND type!='trigger' ORDER BY rowid;;
CREATE UNIQUE INDEX blockid ON t1(x ASC);;
SELECT coalesce(x&x,99) FROM t1;;
SELECT 1%0 FROM t1;;
SELECT coalesce(x>>x,99) FROM t1;CREATE TABLE block(t1_segdir);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;
SELECT
    SrcWord, t1.x
    FROM 
      (SELECT 'FACTORING' AS SrcWord UNION SELECT 'SWIMMING' AS SrcWord )
    LEFT JOIN 
      t1
    WHERE t1.x= (
      SELECT BeginningId FROM (
        SELECT SrcWord, B.x as BeginningId, B.x || E.x As Connected
        FROM t1 B LEFT JOIN t1 E ON B.x=E.x
        WHERE Connected=SrcWord LIMIT 1
      )
    )
;;
INSERT INTO t1(x) VALUES(10);;
SELECT * FROM block;;
SELECT x IS x FROM t1;;
SELECT x+x FROM t1;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;
SELECT ( 
      SELECT x FROM (
        SELECT * FROM t1 WHERE x=out.x ORDER BY x LIMIT 10 OFFSET 1
      ) WHERE x=out.x
    ) FROM t1 AS out;;
SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;;
UPDATE t1 SET x=-9223372036854775807, x=-2;;
UPDATE t1 SET x=-9223372036854775808, x=0;;
UPDATE t1 SET x=9223372036854775807, x=0;;
UPDATE t1 SET x=9223372036854775807, x=-1;;
CREATE INDEX level ON t1(x ASC,  x ASC) ;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
UPDATE t1 SET x=-3037000500, x=-3037000500;PRAGMA journal_mode = DELETE;;
SELECT x NOT LIKE x FROM t1;;
SELECT x-x FROM t1;;
VACUUM;;
UPDATE t1 SET x=1e300, x=1e300;;
SELECT x notnull FROM t1;;
UPDATE t1 SET x='0.0', x='abc';;
UPDATE t1 SET x='abxyzzycy', x='A%CX';;
UPDATE t1 SET x='abc', x='aáˆ´_c';;
UPDATE t1 SET x='abcdefg', x='a*[^def]g';;
UPDATE t1 SET x='ABC', x='A[^A-D]C';;
UPDATE t1 SET x='ABC', x='A[^]B]C';;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;SELECT x FROM t1 WHERE x<10 AND x>8 ORDER BY x;SELECT typeof(00000009223372036854775807);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;PRAGMA max_page_count = 100;VACUUM ;SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'CREATE' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[ecmd CREATE]
parser: Input 'INDEX' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 1.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 221 [uniqueflag ::=].
parser: ... then shift 'uniqueflag', go to state 453
parser: Shift 'INDEX', go to state 315
parser: Return. Stack=[ecmd createkw uniqueflag INDEX]
parser: Input 'ID' in state 315
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 225
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd createkw uniqueflag INDEX ifnotexists ID]
parser: Input 'ON' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 225.
parser: ... then shift 'nm', go to state 314
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 452
parser: Shift 'ON', go to state 224
parser: Return. Stack=[ecmd createkw uniqueflag INDEX ifnotexists nm dbnm ON]
parser: Input 'ID' in state 224
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd createkw uniqueflag INDEX ifnotexists nm dbnm ON ID]
parser: Input 'LP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 224.
parser: ... then shift 'nm', go to state 451
parser: Shift 'LP', go to state 18
parser: Return. Stack=[ecmd createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP]
parser: Input 'ID' in state 18
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP ID]
parser: Input 'DESC' in state 416
parser: FALLBACK DESC => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 18.
parser: ... then shift 'expr', go to state 13
parser: Shift 'DESC', pending reduce 132
parser: Return. Stack=[ecmd createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP expr DESC]
parser: Input 'COMMA' with pending reduce 132
parser: Reduce 132 [sortorder ::= DESC], go to state 13.
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 18.
parser: ... then shift 'sortlist', go to state 400
parser: Shift 'COMMA', go to state 95
parser: Return. Stack=[ecmd createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist COMMA]
parser: Input 'ID' in state 95
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist COMMA ID]
parser: Input 'ASC' in state 416
parser: FALLBACK ASC => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 95.
parser: ... then shift 'expr', go to state 14
parser: Shift 'ASC', pending reduce 131
parser: Return. Stack=[ecmd createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist COMMA expr ASC]
parser: Input 'RP' with pending reduce 131
parser: Reduce 131 [sortorder ::= ASC], go to state 14.
parser: ... then shift 'sortorder', pending reduce 129
parser: Reduce 129 [sortlist ::= sortlist COMMA expr sortorder], go to state 18.
parser: ... then shift 'sortlist', go to state 400
parser: Shift 'RP', go to state 313
parser: Return. Stack=[ecmd createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP]
parser: Input 'SEMI' in state 313
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', pending reduce 219
parser: Reduce 219 [cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt], go to state 1.
parser: [[[INSERT INTO 'main'.sqlite_master VALUES('index','docid','t1',#1,'CREATE INDEX docid ON t1(x DESC, x ASC) ');]]]
parser: Input 'INSERT' in state 0
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'INSERT', go to state 311
parser: Return. Stack=[with INSERT]
parser: Input 'INTO' in state 311
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', pending reduce 156
parser: Reduce 156 [insert_cmd ::= INSERT orconf], go to state 219.
parser: ... then shift 'insert_cmd', go to state 427
parser: Shift 'INTO', go to state 164
parser: Return. Stack=[with insert_cmd INTO]
parser: Input 'STRING' in state 164
parser: Shift 'STRING', pending reduce 332
parser: Return. Stack=[with insert_cmd INTO STRING]
parser: Input 'DOT' with pending reduce 332
parser: Reduce 332 [nm ::= STRING], go to state 164.
parser: ... then shift 'nm', go to state 393
parser: Shift 'DOT', go to state 218
parser: Return. Stack=[with insert_cmd INTO nm DOT]
parser: Input 'ID' in state 218
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with insert_cmd INTO nm DOT ID]
parser: Input 'VALUES' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 218.
parser: ... then shift 'nm', go to state 429
parser: Reduce 113 [xfullname ::= nm DOT nm], go to state 164.
parser: ... then shift 'xfullname', go to state 298
parser: Reduce 158 [idlist_opt ::=].
parser: ... then shift 'idlist_opt', go to state 35
parser: Shift 'VALUES', go to state 526
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES]
parser: Input 'LP' in state 526
parser: Shift 'LP', go to state 28
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP]
parser: Input 'STRING' in state 28
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 28.
parser: ... then shift 'term', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'STRING' in state 107
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'STRING' in state 107
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'VARIABLE' in state 107
parser: Shift 'VARIABLE', pending reduce 170
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA VARIABLE]
parser: Input 'COMMA' with pending reduce 170
parser: Reduce 170 [expr ::= VARIABLE], go to state 107.
parser: ... then shift 'expr', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'STRING' in state 107
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA STRING]
parser: Input 'RP' in state 537
parser: Reduce 168 [term ::= STRING], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'RP', pending reduce 89
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist RP]
parser: Input 'SEMI' with pending reduce 89
parser: Reduce 89 [values ::= VALUES LP nexprlist RP], go to state 35.
parser: ... then shift 'values', go to state 532
parser: Reduce 348 [oneselect ::= values], go to state 35.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 35.
parser: ... then shift 'select', go to state 297
parser: Reduce 152 [upsert ::=].
parser: ... then shift 'upsert', pending reduce 150
parser: Reduce 150 [cmd ::= with insert_cmd INTO xfullname idlist_opt select upsert], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Input '$' with pending reduce 321
parser: Reduce 321 [ecmd ::= cmdx SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 317 [input ::= cmdlist], go to state 0.
parser: ... then shift 'input', pending reduce -2
parser: Accept!
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
parser: [[[SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE name='docid' AND type='index' ORDER BY rowid]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'FROM' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'STRING' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'STRING', pending reduce 332
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix STRING]
parser: Input 'DOT' with pending reduce 332
parser: Reduce 332 [nm ::= STRING], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Shift 'DOT', go to state 245
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID' in state 245
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 245.
parser: ... then shift 'nm', pending reduce 109
parser: Reduce 109 [dbnm ::= DOT nm], go to state 349.
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[SELECT distinct selcollist from WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND' in state 537
parser: Reduce 168 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'AND', go to state 120
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID' in state 120
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr EQ]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr EQ STRING]
parser: Input 'ORDER' in state 537
parser: Reduce 168 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Reduce 179 [expr ::= expr AND expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[CREATE INDEX docid ON t1(x DESC, x ASC) ]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'INDEX' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 221 [uniqueflag ::=].
parser: ... then shift 'uniqueflag', go to state 453
parser: Shift 'INDEX', go to state 315
parser: Return. Stack=[createkw uniqueflag INDEX]
parser: Input 'ID' in state 315
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 225
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists ID]
parser: Input 'ON' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 225.
parser: ... then shift 'nm', go to state 314
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 452
parser: Shift 'ON', go to state 224
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON]
parser: Input 'ID' in state 224
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON ID]
parser: Input 'LP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 224.
parser: ... then shift 'nm', go to state 451
parser: Shift 'LP', go to state 18
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP]
parser: Input 'ID' in state 18
parser: Shift 'ID', go to state 416
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP ID]
parser: Input 'DESC' in state 416
parser: FALLBACK DESC => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 18.
parser: ... then shift 'expr', go to state 13
parser: Shift 'DESC', pending reduce 132
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP expr DESC]
parser: Input 'COMMA' with pending reduce 132
parser: Reduce 132 [sortorder ::= DESC], go to state 13.
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 18.
parser: ... then shift 'sortlist', go to state 400
parser: Shift 'COMMA', go to state 95
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist COMMA]
parser: Input 'ID' in state 95
parser: Shift 'ID', go to state 416
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist COMMA ID]
parser: Input 'ASC' in state 416
parser: FALLBACK ASC => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 95.
parser: ... then shift 'expr', go to state 14
parser: Shift 'ASC', pending reduce 131
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist COMMA expr ASC]
parser: Input 'RP' with pending reduce 131
parser: Reduce 131 [sortorder ::= ASC], go to state 14.
parser: ... then shift 'sortorder', pending reduce 129
parser: Reduce 129 [sortlist ::= sortlist COMMA expr sortorder], go to state 18.
parser: ... then shift 'sortlist', go to state 400
parser: Shift 'RP', go to state 313
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP]
parser: Input 'SEMI' in state 313
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', pending reduce 219
parser: Reduce 219 [cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[;
UPDATE t1 SET x=1;COMMIT;SELECT x, x FROM t1 WHERE x = 1 AND x IN (2, 4, 5) ORDER BY x ASC, x ASC;;
UPDATE t1 SET x=1, x=63;SELECT * FROM t1 INNER JOIN t1 AS x;;
CREATE INDEX c0content ON t1(x ASC,  x ASC) ;;
UPDATE t1 SET x=1, x=64;;
CREATE INDEX t1_segments ON t1(x ASC,  x DESC) ;;
SELECT x, x FROM t1 WHERE x = 3 AND x IN (2, 4, 5) ORDER BY x DESC, x ASC;SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE name='docid' AND type='index' ORDER BY rowid;;
UPDATE t1 SET x=32, x=3;;
UPDATE t1 SET x=25, x=11;;
SELECT coalesce(not x,99) FROM t1;;
SELECT coalesce(x IS NULL AND x=5,99) FROM t1;;
SELECT 5 not between x and x FROM t1;SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE name='docid' AND type='index' ORDER BY rowid;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
UPDATE t1 SET x=NULL, x=3;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1_content' AND type!='trigger' ORDER BY rowid;;
CREATE UNIQUE INDEX blockid ON t1(x ASC);;
SELECT coalesce(x&x,99) FROM t1;;
SELECT 1%0 FROM t1;;
SELECT coalesce(x>>x,99) FROM t1;CREATE TABLE block(t1_segdir);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;
SELECT
    SrcWord, t1.x
    FROM 
      (SELECT 'FACTORING' AS SrcWord UNION SELECT 'SWIMMING' AS SrcWord )
    LEFT JOIN 
      t1
    WHERE t1.x= (
      SELECT BeginningId FROM (
        SELECT SrcWord, B.x as BeginningId, B.x || E.x As Connected
        FROM t1 B LEFT JOIN t1 E ON B.x=E.x
        WHERE Connected=SrcWord LIMIT 1
      )
    )
;;
INSERT INTO t1(x) VALUES(10);;
SELECT * FROM block;;
SELECT x IS x FROM t1;;
SELECT x+x FROM t1;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;
SELECT ( 
      SELECT x FROM (
        SELECT * FROM t1 WHERE x=out.x ORDER BY x LIMIT 10 OFFSET 1
      ) WHERE x=out.x
    ) FROM t1 AS out;;
SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;;
UPDATE t1 SET x=-9223372036854775807, x=-2;;
UPDATE t1 SET x=-9223372036854775808, x=0;;
UPDATE t1 SET x=9223372036854775807, x=0;;
UPDATE t1 SET x=9223372036854775807, x=-1;;
CREATE INDEX level ON t1(x ASC,  x ASC) ;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
UPDATE t1 SET x=-3037000500, x=-3037000500;PRAGMA journal_mode = DELETE;;
SELECT x NOT LIKE x FROM t1;;
SELECT x-x FROM t1;;
VACUUM;;
UPDATE t1 SET x=1e300, x=1e300;;
SELECT x notnull FROM t1;;
UPDATE t1 SET x='0.0', x='abc';;
UPDATE t1 SET x='abxyzzycy', x='A%CX';;
UPDATE t1 SET x='abc', x='aáˆ´_c';;
UPDATE t1 SET x='abcdefg', x='a*[^def]g';;
UPDATE t1 SET x='ABC', x='A[^A-D]C';;
UPDATE t1 SET x='ABC', x='A[^]B]C';;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;SELECT x FROM t1 WHERE x<10 AND x>8 ORDER BY x;SELECT typeof(00000009223372036854775807);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;PRAGMA max_page_count = 100;VACUUM ;SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'UPDATE' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'UPDATE', go to state 299
parser: Return. Stack=[ecmd with UPDATE]
parser: Input 'ID' in state 299
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', go to state 165
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd with UPDATE orconf ID]
parser: Input 'SET' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 165.
parser: ... then shift 'nm', go to state 393
parser: Reduce 112 [xfullname ::= nm], go to state 165.
parser: ... then shift 'xfullname', go to state 271
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 428
parser: Shift 'SET', go to state 153
parser: Return. Stack=[ecmd with UPDATE orconf xfullname indexed_opt SET]
parser: Input 'ID' in state 153
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd with UPDATE orconf xfullname indexed_opt SET ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 153.
parser: ... then shift 'nm', go to state 442
parser: Shift 'EQ', go to state 84
parser: Return. Stack=[ecmd with UPDATE orconf xfullname indexed_opt SET nm EQ]
parser: Input 'INTEGER' in state 84
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with UPDATE orconf xfullname indexed_opt SET nm EQ INTEGER]
parser: Input 'SEMI' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 84.
parser: ... then shift 'term', go to state 58
parser: Reduce 148 [setlist ::= nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', pending reduce 145
parser: Reduce 145 [cmd ::= with UPDATE orconf xfullname indexed_opt SET setlist where_opt], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
parser: [[[COMMIT;SELECT x, x FROM t1 WHERE x = 1 AND x IN (2, 4, 5) ORDER BY x ASC, x ASC;;
UPDATE t1 SET x=1, x=63;SELECT * FROM t1 INNER JOIN t1 AS x;;
CREATE INDEX c0content ON t1(x ASC,  x ASC) ;;
UPDATE t1 SET x=1, x=64;;
CREATE INDEX t1_segments ON t1(x ASC,  x DESC) ;;
SELECT x, x FROM t1 WHERE x = 3 AND x IN (2, 4, 5) ORDER BY x DESC, x ASC;SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE name='docid' AND type='index' ORDER BY rowid;;
UPDATE t1 SET x=32, x=3;;
UPDATE t1 SET x=25, x=11;;
SELECT coalesce(not x,99) FROM t1;;
SELECT coalesce(x IS NULL AND x=5,99) FROM t1;;
SELECT 5 not between x and x FROM t1;SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE name='docid' AND type='index' ORDER BY rowid;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
UPDATE t1 SET x=NULL, x=3;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1_content' AND type!='trigger' ORDER BY rowid;;
CREATE UNIQUE INDEX blockid ON t1(x ASC);;
SELECT coalesce(x&x,99) FROM t1;;
SELECT 1%0 FROM t1;;
SELECT coalesce(x>>x,99) FROM t1;CREATE TABLE block(t1_segdir);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;
SELECT
    SrcWord, t1.x
    FROM 
      (SELECT 'FACTORING' AS SrcWord UNION SELECT 'SWIMMING' AS SrcWord )
    LEFT JOIN 
      t1
    WHERE t1.x= (
      SELECT BeginningId FROM (
        SELECT SrcWord, B.x as BeginningId, B.x || E.x As Connected
        FROM t1 B LEFT JOIN t1 E ON B.x=E.x
        WHERE Connected=SrcWord LIMIT 1
      )
    )
;;
INSERT INTO t1(x) VALUES(10);;
SELECT * FROM block;;
SELECT x IS x FROM t1;;
SELECT x+x FROM t1;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;
SELECT ( 
      SELECT x FROM (
        SELECT * FROM t1 WHERE x=out.x ORDER BY x LIMIT 10 OFFSET 1
      ) WHERE x=out.x
    ) FROM t1 AS out;;
SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;;
UPDATE t1 SET x=-9223372036854775807, x=-2;;
UPDATE t1 SET x=-9223372036854775808, x=0;;
UPDATE t1 SET x=9223372036854775807, x=0;;
UPDATE t1 SET x=9223372036854775807, x=-1;;
CREATE INDEX level ON t1(x ASC,  x ASC) ;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
UPDATE t1 SET x=-3037000500, x=-3037000500;PRAGMA journal_mode = DELETE;;
SELECT x NOT LIKE x FROM t1;;
SELECT x-x FROM t1;;
VACUUM;;
UPDATE t1 SET x=1e300, x=1e300;;
SELECT x notnull FROM t1;;
UPDATE t1 SET x='0.0', x='abc';;
UPDATE t1 SET x='abxyzzycy', x='A%CX';;
UPDATE t1 SET x='abc', x='aáˆ´_c';;
UPDATE t1 SET x='abcdefg', x='a*[^def]g';;
UPDATE t1 SET x='ABC', x='A[^A-D]C';;
UPDATE t1 SET x='ABC', x='A[^]B]C';;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;SELECT x FROM t1 WHERE x<10 AND x>8 ORDER BY x;SELECT typeof(00000009223372036854775807);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;PRAGMA max_page_count = 100;VACUUM ;SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;]]]
parser: Input 'COMMIT' in state 0
parser: Shift 'COMMIT', go to state 366
parser: Return. Stack=[COMMIT]
parser: Input 'SEMI' in state 366
parser: Reduce 323 [trans_opt ::=].
parser: ... then shift 'trans_opt', pending reduce 8
parser: Reduce 8 [cmd ::= COMMIT|END trans_opt], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT x, x FROM t1 WHERE x = 1 AND x IN (2, 4, 5) ORDER BY x ASC, x ASC;;
UPDATE t1 SET x=1, x=63;SELECT * FROM t1 INNER JOIN t1 AS x;;
CREATE INDEX c0content ON t1(x ASC,  x ASC) ;;
UPDATE t1 SET x=1, x=64;;
CREATE INDEX t1_segments ON t1(x ASC,  x DESC) ;;
SELECT x, x FROM t1 WHERE x = 3 AND x IN (2, 4, 5) ORDER BY x DESC, x ASC;SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE name='docid' AND type='index' ORDER BY rowid;;
UPDATE t1 SET x=32, x=3;;
UPDATE t1 SET x=25, x=11;;
SELECT coalesce(not x,99) FROM t1;;
SELECT coalesce(x IS NULL AND x=5,99) FROM t1;;
SELECT 5 not between x and x FROM t1;SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE name='docid' AND type='index' ORDER BY rowid;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
UPDATE t1 SET x=NULL, x=3;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1_content' AND type!='trigger' ORDER BY rowid;;
CREATE UNIQUE INDEX blockid ON t1(x ASC);;
SELECT coalesce(x&x,99) FROM t1;;
SELECT 1%0 FROM t1;;
SELECT coalesce(x>>x,99) FROM t1;CREATE TABLE block(t1_segdir);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;
SELECT
    SrcWord, t1.x
    FROM 
      (SELECT 'FACTORING' AS SrcWord UNION SELECT 'SWIMMING' AS SrcWord )
    LEFT JOIN 
      t1
    WHERE t1.x= (
      SELECT BeginningId FROM (
        SELECT SrcWord, B.x as BeginningId, B.x || E.x As Connected
        FROM t1 B LEFT JOIN t1 E ON B.x=E.x
        WHERE Connected=SrcWord LIMIT 1
      )
    )
;;
INSERT INTO t1(x) VALUES(10);;
SELECT * FROM block;;
SELECT x IS x FROM t1;;
SELECT x+x FROM t1;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;
SELECT ( 
      SELECT x FROM (
        SELECT * FROM t1 WHERE x=out.x ORDER BY x LIMIT 10 OFFSET 1
      ) WHERE x=out.x
    ) FROM t1 AS out;;
SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;;
UPDATE t1 SET x=-9223372036854775807, x=-2;;
UPDATE t1 SET x=-9223372036854775808, x=0;;
UPDATE t1 SET x=9223372036854775807, x=0;;
UPDATE t1 SET x=9223372036854775807, x=-1;;
CREATE INDEX level ON t1(x ASC,  x ASC) ;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
UPDATE t1 SET x=-3037000500, x=-3037000500;PRAGMA journal_mode = DELETE;;
SELECT x NOT LIKE x FROM t1;;
SELECT x-x FROM t1;;
VACUUM;;
UPDATE t1 SET x=1e300, x=1e300;;
SELECT x notnull FROM t1;;
UPDATE t1 SET x='0.0', x='abc';;
UPDATE t1 SET x='abxyzzycy', x='A%CX';;
UPDATE t1 SET x='abc', x='aáˆ´_c';;
UPDATE t1 SET x='abcdefg', x='a*[^def]g';;
UPDATE t1 SET x='ABC', x='A[^A-D]C';;
UPDATE t1 SET x='ABC', x='A[^]B]C';;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;SELECT x FROM t1 WHERE x<10 AND x>8 ORDER BY x;SELECT typeof(00000009223372036854775807);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;PRAGMA max_page_count = 100;VACUUM ;SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'FROM' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[SELECT distinct selcollist from WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'INTEGER' in state 117
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ INTEGER]
parser: Input 'AND' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'AND', go to state 120
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID' in state 120
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'IN' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Shift 'IN', pending reduce 200
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr IN]
parser: Input 'LP' with pending reduce 200
parser: Reduce 200 [in_op ::= IN], go to state 76.
parser: ... then shift 'in_op', go to state 209
parser: Shift 'LP', go to state 3
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr in_op LP]
parser: Input 'INTEGER' in state 3
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr in_op LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 3.
parser: ... then shift 'term', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 3.
parser: ... then shift 'nexprlist', go to state 517
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr in_op LP nexprlist COMMA]
parser: Input 'INTEGER' in state 107
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr in_op LP nexprlist COMMA INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 3.
parser: ... then shift 'nexprlist', go to state 517
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr in_op LP nexprlist COMMA]
parser: Input 'INTEGER' in state 107
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr in_op LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 3.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 3.
parser: ... then shift 'exprlist', go to state 519
parser: Shift 'RP', pending reduce 202
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr in_op LP exprlist RP]
parser: Input 'ORDER' with pending reduce 202
parser: Reduce 202 [expr ::= expr in_op LP exprlist RP], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Reduce 179 [expr ::= expr AND expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'ASC' in state 416
parser: FALLBACK ASC => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Shift 'ASC', pending reduce 131
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY expr ASC]
parser: Input 'COMMA' with pending reduce 131
parser: Reduce 131 [sortorder ::= ASC], go to state 13.
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Shift 'COMMA', go to state 95
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY sortlist COMMA]
parser: Input 'ID' in state 95
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY sortlist COMMA ID]
parser: Input 'ASC' in state 416
parser: FALLBACK ASC => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 95.
parser: ... then shift 'expr', go to state 14
parser: Shift 'ASC', pending reduce 131
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY sortlist COMMA expr ASC]
parser: Input 'SEMI' with pending reduce 131
parser: Reduce 131 [sortorder ::= ASC], go to state 14.
parser: ... then shift 'sortorder', pending reduce 129
parser: Reduce 129 [sortlist ::= sortlist COMMA expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[;
UPDATE t1 SET x=1, x=63;SELECT * FROM t1 INNER JOIN t1 AS x;;
CREATE INDEX c0content ON t1(x ASC,  x ASC) ;;
UPDATE t1 SET x=1, x=64;;
CREATE INDEX t1_segments ON t1(x ASC,  x DESC) ;;
SELECT x, x FROM t1 WHERE x = 3 AND x IN (2, 4, 5) ORDER BY x DESC, x ASC;SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE name='docid' AND type='index' ORDER BY rowid;;
UPDATE t1 SET x=32, x=3;;
UPDATE t1 SET x=25, x=11;;
SELECT coalesce(not x,99) FROM t1;;
SELECT coalesce(x IS NULL AND x=5,99) FROM t1;;
SELECT 5 not between x and x FROM t1;SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE name='docid' AND type='index' ORDER BY rowid;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
UPDATE t1 SET x=NULL, x=3;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1_content' AND type!='trigger' ORDER BY rowid;;
CREATE UNIQUE INDEX blockid ON t1(x ASC);;
SELECT coalesce(x&x,99) FROM t1;;
SELECT 1%0 FROM t1;;
SELECT coalesce(x>>x,99) FROM t1;CREATE TABLE block(t1_segdir);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;
SELECT
    SrcWord, t1.x
    FROM 
      (SELECT 'FACTORING' AS SrcWord UNION SELECT 'SWIMMING' AS SrcWord )
    LEFT JOIN 
      t1
    WHERE t1.x= (
      SELECT BeginningId FROM (
        SELECT SrcWord, B.x as BeginningId, B.x || E.x As Connected
        FROM t1 B LEFT JOIN t1 E ON B.x=E.x
        WHERE Connected=SrcWord LIMIT 1
      )
    )
;;
INSERT INTO t1(x) VALUES(10);;
SELECT * FROM block;;
SELECT x IS x FROM t1;;
SELECT x+x FROM t1;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;
SELECT ( 
      SELECT x FROM (
        SELECT * FROM t1 WHERE x=out.x ORDER BY x LIMIT 10 OFFSET 1
      ) WHERE x=out.x
    ) FROM t1 AS out;;
SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;;
UPDATE t1 SET x=-9223372036854775807, x=-2;;
UPDATE t1 SET x=-9223372036854775808, x=0;;
UPDATE t1 SET x=9223372036854775807, x=0;;
UPDATE t1 SET x=9223372036854775807, x=-1;;
CREATE INDEX level ON t1(x ASC,  x ASC) ;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
UPDATE t1 SET x=-3037000500, x=-3037000500;PRAGMA journal_mode = DELETE;;
SELECT x NOT LIKE x FROM t1;;
SELECT x-x FROM t1;;
VACUUM;;
UPDATE t1 SET x=1e300, x=1e300;;
SELECT x notnull FROM t1;;
UPDATE t1 SET x='0.0', x='abc';;
UPDATE t1 SET x='abxyzzycy', x='A%CX';;
UPDATE t1 SET x='abc', x='aáˆ´_c';;
UPDATE t1 SET x='abcdefg', x='a*[^def]g';;
UPDATE t1 SET x='ABC', x='A[^A-D]C';;
UPDATE t1 SET x='ABC', x='A[^]B]C';;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;SELECT x FROM t1 WHERE x<10 AND x>8 ORDER BY x;SELECT typeof(00000009223372036854775807);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;PRAGMA max_page_count = 100;VACUUM ;SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'UPDATE' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'UPDATE', go to state 299
parser: Return. Stack=[ecmd with UPDATE]
parser: Input 'ID' in state 299
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', go to state 165
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd with UPDATE orconf ID]
parser: Input 'SET' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 165.
parser: ... then shift 'nm', go to state 393
parser: Reduce 112 [xfullname ::= nm], go to state 165.
parser: ... then shift 'xfullname', go to state 271
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 428
parser: Shift 'SET', go to state 153
parser: Return. Stack=[ecmd with UPDATE orconf xfullname indexed_opt SET]
parser: Input 'ID' in state 153
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd with UPDATE orconf xfullname indexed_opt SET ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 153.
parser: ... then shift 'nm', go to state 442
parser: Shift 'EQ', go to state 84
parser: Return. Stack=[ecmd with UPDATE orconf xfullname indexed_opt SET nm EQ]
parser: Input 'INTEGER' in state 84
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with UPDATE orconf xfullname indexed_opt SET nm EQ INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 84.
parser: ... then shift 'term', go to state 58
parser: Reduce 148 [setlist ::= nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[ecmd with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[ecmd with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'INTEGER' in state 86
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ INTEGER]
parser: Input 'SEMI' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', pending reduce 145
parser: Reduce 145 [cmd ::= with UPDATE orconf xfullname indexed_opt SET setlist where_opt], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
parser: [[[SELECT * FROM t1 INNER JOIN t1 AS x;;
CREATE INDEX c0content ON t1(x ASC,  x ASC) ;;
UPDATE t1 SET x=1, x=64;;
CREATE INDEX t1_segments ON t1(x ASC,  x DESC) ;;
SELECT x, x FROM t1 WHERE x = 3 AND x IN (2, 4, 5) ORDER BY x DESC, x ASC;SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE name='docid' AND type='index' ORDER BY rowid;;
UPDATE t1 SET x=32, x=3;;
UPDATE t1 SET x=25, x=11;;
SELECT coalesce(not x,99) FROM t1;;
SELECT coalesce(x IS NULL AND x=5,99) FROM t1;;
SELECT 5 not between x and x FROM t1;SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE name='docid' AND type='index' ORDER BY rowid;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
UPDATE t1 SET x=NULL, x=3;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1_content' AND type!='trigger' ORDER BY rowid;;
CREATE UNIQUE INDEX blockid ON t1(x ASC);;
SELECT coalesce(x&x,99) FROM t1;;
SELECT 1%0 FROM t1;;
SELECT coalesce(x>>x,99) FROM t1;CREATE TABLE block(t1_segdir);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;
SELECT
    SrcWord, t1.x
    FROM 
      (SELECT 'FACTORING' AS SrcWord UNION SELECT 'SWIMMING' AS SrcWord )
    LEFT JOIN 
      t1
    WHERE t1.x= (
      SELECT BeginningId FROM (
        SELECT SrcWord, B.x as BeginningId, B.x || E.x As Connected
        FROM t1 B LEFT JOIN t1 E ON B.x=E.x
        WHERE Connected=SrcWord LIMIT 1
      )
    )
;;
INSERT INTO t1(x) VALUES(10);;
SELECT * FROM block;;
SELECT x IS x FROM t1;;
SELECT x+x FROM t1;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;
SELECT ( 
      SELECT x FROM (
        SELECT * FROM t1 WHERE x=out.x ORDER BY x LIMIT 10 OFFSET 1
      ) WHERE x=out.x
    ) FROM t1 AS out;;
SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;;
UPDATE t1 SET x=-9223372036854775807, x=-2;;
UPDATE t1 SET x=-9223372036854775808, x=0;;
UPDATE t1 SET x=9223372036854775807, x=0;;
UPDATE t1 SET x=9223372036854775807, x=-1;;
CREATE INDEX level ON t1(x ASC,  x ASC) ;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
UPDATE t1 SET x=-3037000500, x=-3037000500;PRAGMA journal_mode = DELETE;;
SELECT x NOT LIKE x FROM t1;;
SELECT x-x FROM t1;;
VACUUM;;
UPDATE t1 SET x=1e300, x=1e300;;
SELECT x notnull FROM t1;;
UPDATE t1 SET x='0.0', x='abc';;
UPDATE t1 SET x='abxyzzycy', x='A%CX';;
UPDATE t1 SET x='abc', x='aáˆ´_c';;
UPDATE t1 SET x='abcdefg', x='a*[^def]g';;
UPDATE t1 SET x='ABC', x='A[^A-D]C';;
UPDATE t1 SET x='ABC', x='A[^]B]C';;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;SELECT x FROM t1 WHERE x<10 AND x>8 ORDER BY x;SELECT typeof(00000009223372036854775807);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;PRAGMA max_page_count = 100;VACUUM ;SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 96
parser: Return. Stack=[SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'JOIN_KW' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Shift 'JOIN_KW', go to state 208
parser: Return. Stack=[SELECT distinct selcollist FROM seltablist JOIN_KW]
parser: Input 'JOIN' in state 208
parser: Shift 'JOIN', pending reduce 117
parser: Return. Stack=[SELECT distinct selcollist FROM seltablist JOIN_KW JOIN]
parser: Input 'ID' with pending reduce 117
parser: Reduce 117 [joinop ::= JOIN_KW JOIN], go to state 263.
parser: ... then shift 'joinop', pending reduce 102
parser: Reduce 102 [stl_prefix ::= seltablist joinop], go to state 197.
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'AS' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Shift 'AS', go to state 242
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm dbnm AS]
parser: Input 'ID' in state 242
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm dbnm AS ID]
parser: Input 'SEMI' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 242.
parser: ... then shift 'nm', pending reduce 98
parser: Reduce 98 [as ::= AS nm], go to state 243.
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[;
CREATE INDEX c0content ON t1(x ASC,  x ASC) ;;
UPDATE t1 SET x=1, x=64;;
CREATE INDEX t1_segments ON t1(x ASC,  x DESC) ;;
SELECT x, x FROM t1 WHERE x = 3 AND x IN (2, 4, 5) ORDER BY x DESC, x ASC;SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE name='docid' AND type='index' ORDER BY rowid;;
UPDATE t1 SET x=32, x=3;;
UPDATE t1 SET x=25, x=11;;
SELECT coalesce(not x,99) FROM t1;;
SELECT coalesce(x IS NULL AND x=5,99) FROM t1;;
SELECT 5 not between x and x FROM t1;SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE name='docid' AND type='index' ORDER BY rowid;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
UPDATE t1 SET x=NULL, x=3;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1_content' AND type!='trigger' ORDER BY rowid;;
CREATE UNIQUE INDEX blockid ON t1(x ASC);;
SELECT coalesce(x&x,99) FROM t1;;
SELECT 1%0 FROM t1;;
SELECT coalesce(x>>x,99) FROM t1;CREATE TABLE block(t1_segdir);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;
SELECT
    SrcWord, t1.x
    FROM 
      (SELECT 'FACTORING' AS SrcWord UNION SELECT 'SWIMMING' AS SrcWord )
    LEFT JOIN 
      t1
    WHERE t1.x= (
      SELECT BeginningId FROM (
        SELECT SrcWord, B.x as BeginningId, B.x || E.x As Connected
        FROM t1 B LEFT JOIN t1 E ON B.x=E.x
        WHERE Connected=SrcWord LIMIT 1
      )
    )
;;
INSERT INTO t1(x) VALUES(10);;
SELECT * FROM block;;
SELECT x IS x FROM t1;;
SELECT x+x FROM t1;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;
SELECT ( 
      SELECT x FROM (
        SELECT * FROM t1 WHERE x=out.x ORDER BY x LIMIT 10 OFFSET 1
      ) WHERE x=out.x
    ) FROM t1 AS out;;
SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;;
UPDATE t1 SET x=-9223372036854775807, x=-2;;
UPDATE t1 SET x=-9223372036854775808, x=0;;
UPDATE t1 SET x=9223372036854775807, x=0;;
UPDATE t1 SET x=9223372036854775807, x=-1;;
CREATE INDEX level ON t1(x ASC,  x ASC) ;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
UPDATE t1 SET x=-3037000500, x=-3037000500;PRAGMA journal_mode = DELETE;;
SELECT x NOT LIKE x FROM t1;;
SELECT x-x FROM t1;;
VACUUM;;
UPDATE t1 SET x=1e300, x=1e300;;
SELECT x notnull FROM t1;;
UPDATE t1 SET x='0.0', x='abc';;
UPDATE t1 SET x='abxyzzycy', x='A%CX';;
UPDATE t1 SET x='abc', x='aáˆ´_c';;
UPDATE t1 SET x='abcdefg', x='a*[^def]g';;
UPDATE t1 SET x='ABC', x='A[^A-D]C';;
UPDATE t1 SET x='ABC', x='A[^]B]C';;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;SELECT x FROM t1 WHERE x<10 AND x>8 ORDER BY x;SELECT typeof(00000009223372036854775807);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;PRAGMA max_page_count = 100;VACUUM ;SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'CREATE' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[ecmd CREATE]
parser: Input 'INDEX' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 1.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 221 [uniqueflag ::=].
parser: ... then shift 'uniqueflag', go to state 453
parser: Shift 'INDEX', go to state 315
parser: Return. Stack=[ecmd createkw uniqueflag INDEX]
parser: Input 'ID' in state 315
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 225
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd createkw uniqueflag INDEX ifnotexists ID]
parser: Input 'ON' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 225.
parser: ... then shift 'nm', go to state 314
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 452
parser: Shift 'ON', go to state 224
parser: Return. Stack=[ecmd createkw uniqueflag INDEX ifnotexists nm dbnm ON]
parser: Input 'ID' in state 224
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd createkw uniqueflag INDEX ifnotexists nm dbnm ON ID]
parser: Input 'LP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 224.
parser: ... then shift 'nm', go to state 451
parser: Shift 'LP', go to state 18
parser: Return. Stack=[ecmd createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP]
parser: Input 'ID' in state 18
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP ID]
parser: Input 'ASC' in state 416
parser: FALLBACK ASC => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 18.
parser: ... then shift 'expr', go to state 13
parser: Shift 'ASC', pending reduce 131
parser: Return. Stack=[ecmd createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP expr ASC]
parser: Input 'COMMA' with pending reduce 131
parser: Reduce 131 [sortorder ::= ASC], go to state 13.
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 18.
parser: ... then shift 'sortlist', go to state 400
parser: Shift 'COMMA', go to state 95
parser: Return. Stack=[ecmd createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist COMMA]
parser: Input 'ID' in state 95
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist COMMA ID]
parser: Input 'ASC' in state 416
parser: FALLBACK ASC => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 95.
parser: ... then shift 'expr', go to state 14
parser: Shift 'ASC', pending reduce 131
parser: Return. Stack=[ecmd createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist COMMA expr ASC]
parser: Input 'RP' with pending reduce 131
parser: Reduce 131 [sortorder ::= ASC], go to state 14.
parser: ... then shift 'sortorder', pending reduce 129
parser: Reduce 129 [sortlist ::= sortlist COMMA expr sortorder], go to state 18.
parser: ... then shift 'sortlist', go to state 400
parser: Shift 'RP', go to state 313
parser: Return. Stack=[ecmd createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP]
parser: Input 'SEMI' in state 313
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', pending reduce 219
parser: Reduce 219 [cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt], go to state 1.
parser: [[[INSERT INTO 'main'.sqlite_master VALUES('index','c0content','t1',#1,'CREATE INDEX c0content ON t1(x ASC,  x ASC) ');]]]
parser: Input 'INSERT' in state 0
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'INSERT', go to state 311
parser: Return. Stack=[with INSERT]
parser: Input 'INTO' in state 311
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', pending reduce 156
parser: Reduce 156 [insert_cmd ::= INSERT orconf], go to state 219.
parser: ... then shift 'insert_cmd', go to state 427
parser: Shift 'INTO', go to state 164
parser: Return. Stack=[with insert_cmd INTO]
parser: Input 'STRING' in state 164
parser: Shift 'STRING', pending reduce 332
parser: Return. Stack=[with insert_cmd INTO STRING]
parser: Input 'DOT' with pending reduce 332
parser: Reduce 332 [nm ::= STRING], go to state 164.
parser: ... then shift 'nm', go to state 393
parser: Shift 'DOT', go to state 218
parser: Return. Stack=[with insert_cmd INTO nm DOT]
parser: Input 'ID' in state 218
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with insert_cmd INTO nm DOT ID]
parser: Input 'VALUES' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 218.
parser: ... then shift 'nm', go to state 429
parser: Reduce 113 [xfullname ::= nm DOT nm], go to state 164.
parser: ... then shift 'xfullname', go to state 298
parser: Reduce 158 [idlist_opt ::=].
parser: ... then shift 'idlist_opt', go to state 35
parser: Shift 'VALUES', go to state 526
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES]
parser: Input 'LP' in state 526
parser: Shift 'LP', go to state 28
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP]
parser: Input 'STRING' in state 28
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 28.
parser: ... then shift 'term', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'STRING' in state 107
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'STRING' in state 107
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'VARIABLE' in state 107
parser: Shift 'VARIABLE', pending reduce 170
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA VARIABLE]
parser: Input 'COMMA' with pending reduce 170
parser: Reduce 170 [expr ::= VARIABLE], go to state 107.
parser: ... then shift 'expr', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'STRING' in state 107
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA STRING]
parser: Input 'RP' in state 537
parser: Reduce 168 [term ::= STRING], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'RP', pending reduce 89
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist RP]
parser: Input 'SEMI' with pending reduce 89
parser: Reduce 89 [values ::= VALUES LP nexprlist RP], go to state 35.
parser: ... then shift 'values', go to state 532
parser: Reduce 348 [oneselect ::= values], go to state 35.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 35.
parser: ... then shift 'select', go to state 297
parser: Reduce 152 [upsert ::=].
parser: ... then shift 'upsert', pending reduce 150
parser: Reduce 150 [cmd ::= with insert_cmd INTO xfullname idlist_opt select upsert], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Input '$' with pending reduce 321
parser: Reduce 321 [ecmd ::= cmdx SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 317 [input ::= cmdlist], go to state 0.
parser: ... then shift 'input', pending reduce -2
parser: Accept!
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
parser: [[[SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE name='c0content' AND type='index' ORDER BY rowid]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'FROM' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'STRING' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'STRING', pending reduce 332
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix STRING]
parser: Input 'DOT' with pending reduce 332
parser: Reduce 332 [nm ::= STRING], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Shift 'DOT', go to state 245
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID' in state 245
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 245.
parser: ... then shift 'nm', pending reduce 109
parser: Reduce 109 [dbnm ::= DOT nm], go to state 349.
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[SELECT distinct selcollist from WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND' in state 537
parser: Reduce 168 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'AND', go to state 120
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID' in state 120
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr EQ]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr EQ STRING]
parser: Input 'ORDER' in state 537
parser: Reduce 168 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Reduce 179 [expr ::= expr AND expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[CREATE INDEX c0content ON t1(x ASC,  x ASC) ]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'INDEX' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 221 [uniqueflag ::=].
parser: ... then shift 'uniqueflag', go to state 453
parser: Shift 'INDEX', go to state 315
parser: Return. Stack=[createkw uniqueflag INDEX]
parser: Input 'ID' in state 315
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 225
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists ID]
parser: Input 'ON' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 225.
parser: ... then shift 'nm', go to state 314
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 452
parser: Shift 'ON', go to state 224
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON]
parser: Input 'ID' in state 224
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON ID]
parser: Input 'LP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 224.
parser: ... then shift 'nm', go to state 451
parser: Shift 'LP', go to state 18
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP]
parser: Input 'ID' in state 18
parser: Shift 'ID', go to state 416
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP ID]
parser: Input 'ASC' in state 416
parser: FALLBACK ASC => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 18.
parser: ... then shift 'expr', go to state 13
parser: Shift 'ASC', pending reduce 131
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP expr ASC]
parser: Input 'COMMA' with pending reduce 131
parser: Reduce 131 [sortorder ::= ASC], go to state 13.
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 18.
parser: ... then shift 'sortlist', go to state 400
parser: Shift 'COMMA', go to state 95
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist COMMA]
parser: Input 'ID' in state 95
parser: Shift 'ID', go to state 416
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist COMMA ID]
parser: Input 'ASC' in state 416
parser: FALLBACK ASC => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 95.
parser: ... then shift 'expr', go to state 14
parser: Shift 'ASC', pending reduce 131
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist COMMA expr ASC]
parser: Input 'RP' with pending reduce 131
parser: Reduce 131 [sortorder ::= ASC], go to state 14.
parser: ... then shift 'sortorder', pending reduce 129
parser: Reduce 129 [sortlist ::= sortlist COMMA expr sortorder], go to state 18.
parser: ... then shift 'sortlist', go to state 400
parser: Shift 'RP', go to state 313
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP]
parser: Input 'SEMI' in state 313
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', pending reduce 219
parser: Reduce 219 [cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[;
UPDATE t1 SET x=1, x=64;;
CREATE INDEX t1_segments ON t1(x ASC,  x DESC) ;;
SELECT x, x FROM t1 WHERE x = 3 AND x IN (2, 4, 5) ORDER BY x DESC, x ASC;SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE name='docid' AND type='index' ORDER BY rowid;;
UPDATE t1 SET x=32, x=3;;
UPDATE t1 SET x=25, x=11;;
SELECT coalesce(not x,99) FROM t1;;
SELECT coalesce(x IS NULL AND x=5,99) FROM t1;;
SELECT 5 not between x and x FROM t1;SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE name='docid' AND type='index' ORDER BY rowid;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
UPDATE t1 SET x=NULL, x=3;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1_content' AND type!='trigger' ORDER BY rowid;;
CREATE UNIQUE INDEX blockid ON t1(x ASC);;
SELECT coalesce(x&x,99) FROM t1;;
SELECT 1%0 FROM t1;;
SELECT coalesce(x>>x,99) FROM t1;CREATE TABLE block(t1_segdir);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;
SELECT
    SrcWord, t1.x
    FROM 
      (SELECT 'FACTORING' AS SrcWord UNION SELECT 'SWIMMING' AS SrcWord )
    LEFT JOIN 
      t1
    WHERE t1.x= (
      SELECT BeginningId FROM (
        SELECT SrcWord, B.x as BeginningId, B.x || E.x As Connected
        FROM t1 B LEFT JOIN t1 E ON B.x=E.x
        WHERE Connected=SrcWord LIMIT 1
      )
    )
;;
INSERT INTO t1(x) VALUES(10);;
SELECT * FROM block;;
SELECT x IS x FROM t1;;
SELECT x+x FROM t1;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;
SELECT ( 
      SELECT x FROM (
        SELECT * FROM t1 WHERE x=out.x ORDER BY x LIMIT 10 OFFSET 1
      ) WHERE x=out.x
    ) FROM t1 AS out;;
SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;;
UPDATE t1 SET x=-9223372036854775807, x=-2;;
UPDATE t1 SET x=-9223372036854775808, x=0;;
UPDATE t1 SET x=9223372036854775807, x=0;;
UPDATE t1 SET x=9223372036854775807, x=-1;;
CREATE INDEX level ON t1(x ASC,  x ASC) ;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
UPDATE t1 SET x=-3037000500, x=-3037000500;PRAGMA journal_mode = DELETE;;
SELECT x NOT LIKE x FROM t1;;
SELECT x-x FROM t1;;
VACUUM;;
UPDATE t1 SET x=1e300, x=1e300;;
SELECT x notnull FROM t1;;
UPDATE t1 SET x='0.0', x='abc';;
UPDATE t1 SET x='abxyzzycy', x='A%CX';;
UPDATE t1 SET x='abc', x='aáˆ´_c';;
UPDATE t1 SET x='abcdefg', x='a*[^def]g';;
UPDATE t1 SET x='ABC', x='A[^A-D]C';;
UPDATE t1 SET x='ABC', x='A[^]B]C';;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;SELECT x FROM t1 WHERE x<10 AND x>8 ORDER BY x;SELECT typeof(00000009223372036854775807);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;PRAGMA max_page_count = 100;VACUUM ;SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'UPDATE' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'UPDATE', go to state 299
parser: Return. Stack=[ecmd with UPDATE]
parser: Input 'ID' in state 299
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', go to state 165
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd with UPDATE orconf ID]
parser: Input 'SET' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 165.
parser: ... then shift 'nm', go to state 393
parser: Reduce 112 [xfullname ::= nm], go to state 165.
parser: ... then shift 'xfullname', go to state 271
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 428
parser: Shift 'SET', go to state 153
parser: Return. Stack=[ecmd with UPDATE orconf xfullname indexed_opt SET]
parser: Input 'ID' in state 153
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd with UPDATE orconf xfullname indexed_opt SET ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 153.
parser: ... then shift 'nm', go to state 442
parser: Shift 'EQ', go to state 84
parser: Return. Stack=[ecmd with UPDATE orconf xfullname indexed_opt SET nm EQ]
parser: Input 'INTEGER' in state 84
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with UPDATE orconf xfullname indexed_opt SET nm EQ INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 84.
parser: ... then shift 'term', go to state 58
parser: Reduce 148 [setlist ::= nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[ecmd with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[ecmd with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'INTEGER' in state 86
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ INTEGER]
parser: Input 'SEMI' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', pending reduce 145
parser: Reduce 145 [cmd ::= with UPDATE orconf xfullname indexed_opt SET setlist where_opt], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
parser: [[[;
CREATE INDEX t1_segments ON t1(x ASC,  x DESC) ;;
SELECT x, x FROM t1 WHERE x = 3 AND x IN (2, 4, 5) ORDER BY x DESC, x ASC;SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE name='docid' AND type='index' ORDER BY rowid;;
UPDATE t1 SET x=32, x=3;;
UPDATE t1 SET x=25, x=11;;
SELECT coalesce(not x,99) FROM t1;;
SELECT coalesce(x IS NULL AND x=5,99) FROM t1;;
SELECT 5 not between x and x FROM t1;SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE name='docid' AND type='index' ORDER BY rowid;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
UPDATE t1 SET x=NULL, x=3;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1_content' AND type!='trigger' ORDER BY rowid;;
CREATE UNIQUE INDEX blockid ON t1(x ASC);;
SELECT coalesce(x&x,99) FROM t1;;
SELECT 1%0 FROM t1;;
SELECT coalesce(x>>x,99) FROM t1;CREATE TABLE block(t1_segdir);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;
SELECT
    SrcWord, t1.x
    FROM 
      (SELECT 'FACTORING' AS SrcWord UNION SELECT 'SWIMMING' AS SrcWord )
    LEFT JOIN 
      t1
    WHERE t1.x= (
      SELECT BeginningId FROM (
        SELECT SrcWord, B.x as BeginningId, B.x || E.x As Connected
        FROM t1 B LEFT JOIN t1 E ON B.x=E.x
        WHERE Connected=SrcWord LIMIT 1
      )
    )
;;
INSERT INTO t1(x) VALUES(10);;
SELECT * FROM block;;
SELECT x IS x FROM t1;;
SELECT x+x FROM t1;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;
SELECT ( 
      SELECT x FROM (
        SELECT * FROM t1 WHERE x=out.x ORDER BY x LIMIT 10 OFFSET 1
      ) WHERE x=out.x
    ) FROM t1 AS out;;
SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;;
UPDATE t1 SET x=-9223372036854775807, x=-2;;
UPDATE t1 SET x=-9223372036854775808, x=0;;
UPDATE t1 SET x=9223372036854775807, x=0;;
UPDATE t1 SET x=9223372036854775807, x=-1;;
CREATE INDEX level ON t1(x ASC,  x ASC) ;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
UPDATE t1 SET x=-3037000500, x=-3037000500;PRAGMA journal_mode = DELETE;;
SELECT x NOT LIKE x FROM t1;;
SELECT x-x FROM t1;;
VACUUM;;
UPDATE t1 SET x=1e300, x=1e300;;
SELECT x notnull FROM t1;;
UPDATE t1 SET x='0.0', x='abc';;
UPDATE t1 SET x='abxyzzycy', x='A%CX';;
UPDATE t1 SET x='abc', x='aáˆ´_c';;
UPDATE t1 SET x='abcdefg', x='a*[^def]g';;
UPDATE t1 SET x='ABC', x='A[^A-D]C';;
UPDATE t1 SET x='ABC', x='A[^]B]C';;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;SELECT x FROM t1 WHERE x<10 AND x>8 ORDER BY x;SELECT typeof(00000009223372036854775807);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;PRAGMA max_page_count = 100;VACUUM ;SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'CREATE' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[ecmd CREATE]
parser: Input 'INDEX' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 1.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 221 [uniqueflag ::=].
parser: ... then shift 'uniqueflag', go to state 453
parser: Shift 'INDEX', go to state 315
parser: Return. Stack=[ecmd createkw uniqueflag INDEX]
parser: Input 'ID' in state 315
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 225
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd createkw uniqueflag INDEX ifnotexists ID]
parser: Input 'ON' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 225.
parser: ... then shift 'nm', go to state 314
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 452
parser: Shift 'ON', go to state 224
parser: Return. Stack=[ecmd createkw uniqueflag INDEX ifnotexists nm dbnm ON]
parser: Input 'ID' in state 224
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd createkw uniqueflag INDEX ifnotexists nm dbnm ON ID]
parser: Input 'LP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 224.
parser: ... then shift 'nm', go to state 451
parser: Shift 'LP', go to state 18
parser: Return. Stack=[ecmd createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP]
parser: Input 'ID' in state 18
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP ID]
parser: Input 'ASC' in state 416
parser: FALLBACK ASC => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 18.
parser: ... then shift 'expr', go to state 13
parser: Shift 'ASC', pending reduce 131
parser: Return. Stack=[ecmd createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP expr ASC]
parser: Input 'COMMA' with pending reduce 131
parser: Reduce 131 [sortorder ::= ASC], go to state 13.
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 18.
parser: ... then shift 'sortlist', go to state 400
parser: Shift 'COMMA', go to state 95
parser: Return. Stack=[ecmd createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist COMMA]
parser: Input 'ID' in state 95
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist COMMA ID]
parser: Input 'DESC' in state 416
parser: FALLBACK DESC => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 95.
parser: ... then shift 'expr', go to state 14
parser: Shift 'DESC', pending reduce 132
parser: Return. Stack=[ecmd createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist COMMA expr DESC]
parser: Input 'RP' with pending reduce 132
parser: Reduce 132 [sortorder ::= DESC], go to state 14.
parser: ... then shift 'sortorder', pending reduce 129
parser: Reduce 129 [sortlist ::= sortlist COMMA expr sortorder], go to state 18.
parser: ... then shift 'sortlist', go to state 400
parser: Shift 'RP', go to state 313
parser: Return. Stack=[ecmd createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP]
parser: Input 'SEMI' in state 313
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', pending reduce 219
parser: Reduce 219 [cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt], go to state 1.
parser: [[[INSERT INTO 'main'.sqlite_master VALUES('index','t1_segments','t1',#1,'CREATE INDEX t1_segments ON t1(x ASC,  x DESC) ');]]]
parser: Input 'INSERT' in state 0
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'INSERT', go to state 311
parser: Return. Stack=[with INSERT]
parser: Input 'INTO' in state 311
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', pending reduce 156
parser: Reduce 156 [insert_cmd ::= INSERT orconf], go to state 219.
parser: ... then shift 'insert_cmd', go to state 427
parser: Shift 'INTO', go to state 164
parser: Return. Stack=[with insert_cmd INTO]
parser: Input 'STRING' in state 164
parser: Shift 'STRING', pending reduce 332
parser: Return. Stack=[with insert_cmd INTO STRING]
parser: Input 'DOT' with pending reduce 332
parser: Reduce 332 [nm ::= STRING], go to state 164.
parser: ... then shift 'nm', go to state 393
parser: Shift 'DOT', go to state 218
parser: Return. Stack=[with insert_cmd INTO nm DOT]
parser: Input 'ID' in state 218
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with insert_cmd INTO nm DOT ID]
parser: Input 'VALUES' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 218.
parser: ... then shift 'nm', go to state 429
parser: Reduce 113 [xfullname ::= nm DOT nm], go to state 164.
parser: ... then shift 'xfullname', go to state 298
parser: Reduce 158 [idlist_opt ::=].
parser: ... then shift 'idlist_opt', go to state 35
parser: Shift 'VALUES', go to state 526
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES]
parser: Input 'LP' in state 526
parser: Shift 'LP', go to state 28
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP]
parser: Input 'STRING' in state 28
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 28.
parser: ... then shift 'term', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'STRING' in state 107
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'STRING' in state 107
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'VARIABLE' in state 107
parser: Shift 'VARIABLE', pending reduce 170
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA VARIABLE]
parser: Input 'COMMA' with pending reduce 170
parser: Reduce 170 [expr ::= VARIABLE], go to state 107.
parser: ... then shift 'expr', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'STRING' in state 107
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA STRING]
parser: Input 'RP' in state 537
parser: Reduce 168 [term ::= STRING], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'RP', pending reduce 89
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist RP]
parser: Input 'SEMI' with pending reduce 89
parser: Reduce 89 [values ::= VALUES LP nexprlist RP], go to state 35.
parser: ... then shift 'values', go to state 532
parser: Reduce 348 [oneselect ::= values], go to state 35.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 35.
parser: ... then shift 'select', go to state 297
parser: Reduce 152 [upsert ::=].
parser: ... then shift 'upsert', pending reduce 150
parser: Reduce 150 [cmd ::= with insert_cmd INTO xfullname idlist_opt select upsert], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Input '$' with pending reduce 321
parser: Reduce 321 [ecmd ::= cmdx SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 317 [input ::= cmdlist], go to state 0.
parser: ... then shift 'input', pending reduce -2
parser: Accept!
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
parser: [[[SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE name='t1_segments' AND type='index' ORDER BY rowid]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'FROM' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'STRING' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'STRING', pending reduce 332
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix STRING]
parser: Input 'DOT' with pending reduce 332
parser: Reduce 332 [nm ::= STRING], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Shift 'DOT', go to state 245
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID' in state 245
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 245.
parser: ... then shift 'nm', pending reduce 109
parser: Reduce 109 [dbnm ::= DOT nm], go to state 349.
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[SELECT distinct selcollist from WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND' in state 537
parser: Reduce 168 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'AND', go to state 120
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID' in state 120
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr EQ]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr EQ STRING]
parser: Input 'ORDER' in state 537
parser: Reduce 168 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Reduce 179 [expr ::= expr AND expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[CREATE INDEX t1_segments ON t1(x ASC,  x DESC) ]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'INDEX' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 221 [uniqueflag ::=].
parser: ... then shift 'uniqueflag', go to state 453
parser: Shift 'INDEX', go to state 315
parser: Return. Stack=[createkw uniqueflag INDEX]
parser: Input 'ID' in state 315
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 225
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists ID]
parser: Input 'ON' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 225.
parser: ... then shift 'nm', go to state 314
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 452
parser: Shift 'ON', go to state 224
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON]
parser: Input 'ID' in state 224
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON ID]
parser: Input 'LP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 224.
parser: ... then shift 'nm', go to state 451
parser: Shift 'LP', go to state 18
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP]
parser: Input 'ID' in state 18
parser: Shift 'ID', go to state 416
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP ID]
parser: Input 'ASC' in state 416
parser: FALLBACK ASC => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 18.
parser: ... then shift 'expr', go to state 13
parser: Shift 'ASC', pending reduce 131
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP expr ASC]
parser: Input 'COMMA' with pending reduce 131
parser: Reduce 131 [sortorder ::= ASC], go to state 13.
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 18.
parser: ... then shift 'sortlist', go to state 400
parser: Shift 'COMMA', go to state 95
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist COMMA]
parser: Input 'ID' in state 95
parser: Shift 'ID', go to state 416
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist COMMA ID]
parser: Input 'DESC' in state 416
parser: FALLBACK DESC => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 95.
parser: ... then shift 'expr', go to state 14
parser: Shift 'DESC', pending reduce 132
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist COMMA expr DESC]
parser: Input 'RP' with pending reduce 132
parser: Reduce 132 [sortorder ::= DESC], go to state 14.
parser: ... then shift 'sortorder', pending reduce 129
parser: Reduce 129 [sortlist ::= sortlist COMMA expr sortorder], go to state 18.
parser: ... then shift 'sortlist', go to state 400
parser: Shift 'RP', go to state 313
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP]
parser: Input 'SEMI' in state 313
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', pending reduce 219
parser: Reduce 219 [cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[;
SELECT x, x FROM t1 WHERE x = 3 AND x IN (2, 4, 5) ORDER BY x DESC, x ASC;SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE name='docid' AND type='index' ORDER BY rowid;;
UPDATE t1 SET x=32, x=3;;
UPDATE t1 SET x=25, x=11;;
SELECT coalesce(not x,99) FROM t1;;
SELECT coalesce(x IS NULL AND x=5,99) FROM t1;;
SELECT 5 not between x and x FROM t1;SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE name='docid' AND type='index' ORDER BY rowid;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
UPDATE t1 SET x=NULL, x=3;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1_content' AND type!='trigger' ORDER BY rowid;;
CREATE UNIQUE INDEX blockid ON t1(x ASC);;
SELECT coalesce(x&x,99) FROM t1;;
SELECT 1%0 FROM t1;;
SELECT coalesce(x>>x,99) FROM t1;CREATE TABLE block(t1_segdir);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;
SELECT
    SrcWord, t1.x
    FROM 
      (SELECT 'FACTORING' AS SrcWord UNION SELECT 'SWIMMING' AS SrcWord )
    LEFT JOIN 
      t1
    WHERE t1.x= (
      SELECT BeginningId FROM (
        SELECT SrcWord, B.x as BeginningId, B.x || E.x As Connected
        FROM t1 B LEFT JOIN t1 E ON B.x=E.x
        WHERE Connected=SrcWord LIMIT 1
      )
    )
;;
INSERT INTO t1(x) VALUES(10);;
SELECT * FROM block;;
SELECT x IS x FROM t1;;
SELECT x+x FROM t1;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;
SELECT ( 
      SELECT x FROM (
        SELECT * FROM t1 WHERE x=out.x ORDER BY x LIMIT 10 OFFSET 1
      ) WHERE x=out.x
    ) FROM t1 AS out;;
SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;;
UPDATE t1 SET x=-9223372036854775807, x=-2;;
UPDATE t1 SET x=-9223372036854775808, x=0;;
UPDATE t1 SET x=9223372036854775807, x=0;;
UPDATE t1 SET x=9223372036854775807, x=-1;;
CREATE INDEX level ON t1(x ASC,  x ASC) ;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
UPDATE t1 SET x=-3037000500, x=-3037000500;PRAGMA journal_mode = DELETE;;
SELECT x NOT LIKE x FROM t1;;
SELECT x-x FROM t1;;
VACUUM;;
UPDATE t1 SET x=1e300, x=1e300;;
SELECT x notnull FROM t1;;
UPDATE t1 SET x='0.0', x='abc';;
UPDATE t1 SET x='abxyzzycy', x='A%CX';;
UPDATE t1 SET x='abc', x='aáˆ´_c';;
UPDATE t1 SET x='abcdefg', x='a*[^def]g';;
UPDATE t1 SET x='ABC', x='A[^A-D]C';;
UPDATE t1 SET x='ABC', x='A[^]B]C';;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;SELECT x FROM t1 WHERE x<10 AND x>8 ORDER BY x;SELECT typeof(00000009223372036854775807);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;PRAGMA max_page_count = 100;VACUUM ;SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'SELECT' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[ecmd SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[ecmd SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt ID]
parser: Input 'FROM' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[ecmd SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'INTEGER' in state 117
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ INTEGER]
parser: Input 'AND' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'AND', go to state 120
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID' in state 120
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'IN' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Shift 'IN', pending reduce 200
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr AND expr IN]
parser: Input 'LP' with pending reduce 200
parser: Reduce 200 [in_op ::= IN], go to state 76.
parser: ... then shift 'in_op', go to state 209
parser: Shift 'LP', go to state 3
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr AND expr in_op LP]
parser: Input 'INTEGER' in state 3
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr AND expr in_op LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 3.
parser: ... then shift 'term', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 3.
parser: ... then shift 'nexprlist', go to state 517
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr AND expr in_op LP nexprlist COMMA]
parser: Input 'INTEGER' in state 107
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr AND expr in_op LP nexprlist COMMA INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 3.
parser: ... then shift 'nexprlist', go to state 517
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr AND expr in_op LP nexprlist COMMA]
parser: Input 'INTEGER' in state 107
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr AND expr in_op LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 3.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 3.
parser: ... then shift 'exprlist', go to state 519
parser: Shift 'RP', pending reduce 202
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr AND expr in_op LP exprlist RP]
parser: Input 'ORDER' with pending reduce 202
parser: Reduce 202 [expr ::= expr in_op LP exprlist RP], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Reduce 179 [expr ::= expr AND expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[ecmd SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[ecmd SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'DESC' in state 416
parser: FALLBACK DESC => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Shift 'DESC', pending reduce 132
parser: Return. Stack=[ecmd SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY expr DESC]
parser: Input 'COMMA' with pending reduce 132
parser: Reduce 132 [sortorder ::= DESC], go to state 13.
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Shift 'COMMA', go to state 95
parser: Return. Stack=[ecmd SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY sortlist COMMA]
parser: Input 'ID' in state 95
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY sortlist COMMA ID]
parser: Input 'ASC' in state 416
parser: FALLBACK ASC => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 95.
parser: ... then shift 'expr', go to state 14
parser: Shift 'ASC', pending reduce 131
parser: Return. Stack=[ecmd SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY sortlist COMMA expr ASC]
parser: Input 'SEMI' with pending reduce 131
parser: Reduce 131 [sortorder ::= ASC], go to state 14.
parser: ... then shift 'sortorder', pending reduce 129
parser: Reduce 129 [sortlist ::= sortlist COMMA expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 1.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 1.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
parser: [[[SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE name='docid' AND type='index' ORDER BY rowid;;
UPDATE t1 SET x=32, x=3;;
UPDATE t1 SET x=25, x=11;;
SELECT coalesce(not x,99) FROM t1;;
SELECT coalesce(x IS NULL AND x=5,99) FROM t1;;
SELECT 5 not between x and x FROM t1;SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE name='docid' AND type='index' ORDER BY rowid;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
UPDATE t1 SET x=NULL, x=3;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1_content' AND type!='trigger' ORDER BY rowid;;
CREATE UNIQUE INDEX blockid ON t1(x ASC);;
SELECT coalesce(x&x,99) FROM t1;;
SELECT 1%0 FROM t1;;
SELECT coalesce(x>>x,99) FROM t1;CREATE TABLE block(t1_segdir);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;
SELECT
    SrcWord, t1.x
    FROM 
      (SELECT 'FACTORING' AS SrcWord UNION SELECT 'SWIMMING' AS SrcWord )
    LEFT JOIN 
      t1
    WHERE t1.x= (
      SELECT BeginningId FROM (
        SELECT SrcWord, B.x as BeginningId, B.x || E.x As Connected
        FROM t1 B LEFT JOIN t1 E ON B.x=E.x
        WHERE Connected=SrcWord LIMIT 1
      )
    )
;;
INSERT INTO t1(x) VALUES(10);;
SELECT * FROM block;;
SELECT x IS x FROM t1;;
SELECT x+x FROM t1;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;
SELECT ( 
      SELECT x FROM (
        SELECT * FROM t1 WHERE x=out.x ORDER BY x LIMIT 10 OFFSET 1
      ) WHERE x=out.x
    ) FROM t1 AS out;;
SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;;
UPDATE t1 SET x=-9223372036854775807, x=-2;;
UPDATE t1 SET x=-9223372036854775808, x=0;;
UPDATE t1 SET x=9223372036854775807, x=0;;
UPDATE t1 SET x=9223372036854775807, x=-1;;
CREATE INDEX level ON t1(x ASC,  x ASC) ;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
UPDATE t1 SET x=-3037000500, x=-3037000500;PRAGMA journal_mode = DELETE;;
SELECT x NOT LIKE x FROM t1;;
SELECT x-x FROM t1;;
VACUUM;;
UPDATE t1 SET x=1e300, x=1e300;;
SELECT x notnull FROM t1;;
UPDATE t1 SET x='0.0', x='abc';;
UPDATE t1 SET x='abxyzzycy', x='A%CX';;
UPDATE t1 SET x='abc', x='aáˆ´_c';;
UPDATE t1 SET x='abcdefg', x='a*[^def]g';;
UPDATE t1 SET x='ABC', x='A[^A-D]C';;
UPDATE t1 SET x='ABC', x='A[^]B]C';;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;SELECT x FROM t1 WHERE x<10 AND x>8 ORDER BY x;SELECT typeof(00000009223372036854775807);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;PRAGMA max_page_count = 100;VACUUM ;SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'FROM' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'STRING' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'STRING', pending reduce 332
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix STRING]
parser: Input 'DOT' with pending reduce 332
parser: Reduce 332 [nm ::= STRING], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Shift 'DOT', go to state 245
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID' in state 245
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 245.
parser: ... then shift 'nm', pending reduce 109
parser: Reduce 109 [dbnm ::= DOT nm], go to state 349.
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[SELECT distinct selcollist from WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND' in state 537
parser: Reduce 168 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'AND', go to state 120
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID' in state 120
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr EQ]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr EQ STRING]
parser: Input 'ORDER' in state 537
parser: Reduce 168 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Reduce 179 [expr ::= expr AND expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[;
UPDATE t1 SET x=32, x=3;;
UPDATE t1 SET x=25, x=11;;
SELECT coalesce(not x,99) FROM t1;;
SELECT coalesce(x IS NULL AND x=5,99) FROM t1;;
SELECT 5 not between x and x FROM t1;SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE name='docid' AND type='index' ORDER BY rowid;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
UPDATE t1 SET x=NULL, x=3;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1_content' AND type!='trigger' ORDER BY rowid;;
CREATE UNIQUE INDEX blockid ON t1(x ASC);;
SELECT coalesce(x&x,99) FROM t1;;
SELECT 1%0 FROM t1;;
SELECT coalesce(x>>x,99) FROM t1;CREATE TABLE block(t1_segdir);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;
SELECT
    SrcWord, t1.x
    FROM 
      (SELECT 'FACTORING' AS SrcWord UNION SELECT 'SWIMMING' AS SrcWord )
    LEFT JOIN 
      t1
    WHERE t1.x= (
      SELECT BeginningId FROM (
        SELECT SrcWord, B.x as BeginningId, B.x || E.x As Connected
        FROM t1 B LEFT JOIN t1 E ON B.x=E.x
        WHERE Connected=SrcWord LIMIT 1
      )
    )
;;
INSERT INTO t1(x) VALUES(10);;
SELECT * FROM block;;
SELECT x IS x FROM t1;;
SELECT x+x FROM t1;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;
SELECT ( 
      SELECT x FROM (
        SELECT * FROM t1 WHERE x=out.x ORDER BY x LIMIT 10 OFFSET 1
      ) WHERE x=out.x
    ) FROM t1 AS out;;
SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;;
UPDATE t1 SET x=-9223372036854775807, x=-2;;
UPDATE t1 SET x=-9223372036854775808, x=0;;
UPDATE t1 SET x=9223372036854775807, x=0;;
UPDATE t1 SET x=9223372036854775807, x=-1;;
CREATE INDEX level ON t1(x ASC,  x ASC) ;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
UPDATE t1 SET x=-3037000500, x=-3037000500;PRAGMA journal_mode = DELETE;;
SELECT x NOT LIKE x FROM t1;;
SELECT x-x FROM t1;;
VACUUM;;
UPDATE t1 SET x=1e300, x=1e300;;
SELECT x notnull FROM t1;;
UPDATE t1 SET x='0.0', x='abc';;
UPDATE t1 SET x='abxyzzycy', x='A%CX';;
UPDATE t1 SET x='abc', x='aáˆ´_c';;
UPDATE t1 SET x='abcdefg', x='a*[^def]g';;
UPDATE t1 SET x='ABC', x='A[^A-D]C';;
UPDATE t1 SET x='ABC', x='A[^]B]C';;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;SELECT x FROM t1 WHERE x<10 AND x>8 ORDER BY x;SELECT typeof(00000009223372036854775807);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;PRAGMA max_page_count = 100;VACUUM ;SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'UPDATE' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'UPDATE', go to state 299
parser: Return. Stack=[ecmd with UPDATE]
parser: Input 'ID' in state 299
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', go to state 165
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd with UPDATE orconf ID]
parser: Input 'SET' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 165.
parser: ... then shift 'nm', go to state 393
parser: Reduce 112 [xfullname ::= nm], go to state 165.
parser: ... then shift 'xfullname', go to state 271
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 428
parser: Shift 'SET', go to state 153
parser: Return. Stack=[ecmd with UPDATE orconf xfullname indexed_opt SET]
parser: Input 'ID' in state 153
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd with UPDATE orconf xfullname indexed_opt SET ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 153.
parser: ... then shift 'nm', go to state 442
parser: Shift 'EQ', go to state 84
parser: Return. Stack=[ecmd with UPDATE orconf xfullname indexed_opt SET nm EQ]
parser: Input 'INTEGER' in state 84
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with UPDATE orconf xfullname indexed_opt SET nm EQ INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 84.
parser: ... then shift 'term', go to state 58
parser: Reduce 148 [setlist ::= nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[ecmd with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[ecmd with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'INTEGER' in state 86
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ INTEGER]
parser: Input 'SEMI' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', pending reduce 145
parser: Reduce 145 [cmd ::= with UPDATE orconf xfullname indexed_opt SET setlist where_opt], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
parser: [[[;
UPDATE t1 SET x=25, x=11;;
SELECT coalesce(not x,99) FROM t1;;
SELECT coalesce(x IS NULL AND x=5,99) FROM t1;;
SELECT 5 not between x and x FROM t1;SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE name='docid' AND type='index' ORDER BY rowid;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
UPDATE t1 SET x=NULL, x=3;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1_content' AND type!='trigger' ORDER BY rowid;;
CREATE UNIQUE INDEX blockid ON t1(x ASC);;
SELECT coalesce(x&x,99) FROM t1;;
SELECT 1%0 FROM t1;;
SELECT coalesce(x>>x,99) FROM t1;CREATE TABLE block(t1_segdir);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;
SELECT
    SrcWord, t1.x
    FROM 
      (SELECT 'FACTORING' AS SrcWord UNION SELECT 'SWIMMING' AS SrcWord )
    LEFT JOIN 
      t1
    WHERE t1.x= (
      SELECT BeginningId FROM (
        SELECT SrcWord, B.x as BeginningId, B.x || E.x As Connected
        FROM t1 B LEFT JOIN t1 E ON B.x=E.x
        WHERE Connected=SrcWord LIMIT 1
      )
    )
;;
INSERT INTO t1(x) VALUES(10);;
SELECT * FROM block;;
SELECT x IS x FROM t1;;
SELECT x+x FROM t1;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;
SELECT ( 
      SELECT x FROM (
        SELECT * FROM t1 WHERE x=out.x ORDER BY x LIMIT 10 OFFSET 1
      ) WHERE x=out.x
    ) FROM t1 AS out;;
SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;;
UPDATE t1 SET x=-9223372036854775807, x=-2;;
UPDATE t1 SET x=-9223372036854775808, x=0;;
UPDATE t1 SET x=9223372036854775807, x=0;;
UPDATE t1 SET x=9223372036854775807, x=-1;;
CREATE INDEX level ON t1(x ASC,  x ASC) ;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
UPDATE t1 SET x=-3037000500, x=-3037000500;PRAGMA journal_mode = DELETE;;
SELECT x NOT LIKE x FROM t1;;
SELECT x-x FROM t1;;
VACUUM;;
UPDATE t1 SET x=1e300, x=1e300;;
SELECT x notnull FROM t1;;
UPDATE t1 SET x='0.0', x='abc';;
UPDATE t1 SET x='abxyzzycy', x='A%CX';;
UPDATE t1 SET x='abc', x='aáˆ´_c';;
UPDATE t1 SET x='abcdefg', x='a*[^def]g';;
UPDATE t1 SET x='ABC', x='A[^A-D]C';;
UPDATE t1 SET x='ABC', x='A[^]B]C';;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;SELECT x FROM t1 WHERE x<10 AND x>8 ORDER BY x;SELECT typeof(00000009223372036854775807);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;PRAGMA max_page_count = 100;VACUUM ;SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'UPDATE' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'UPDATE', go to state 299
parser: Return. Stack=[ecmd with UPDATE]
parser: Input 'ID' in state 299
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', go to state 165
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd with UPDATE orconf ID]
parser: Input 'SET' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 165.
parser: ... then shift 'nm', go to state 393
parser: Reduce 112 [xfullname ::= nm], go to state 165.
parser: ... then shift 'xfullname', go to state 271
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 428
parser: Shift 'SET', go to state 153
parser: Return. Stack=[ecmd with UPDATE orconf xfullname indexed_opt SET]
parser: Input 'ID' in state 153
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd with UPDATE orconf xfullname indexed_opt SET ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 153.
parser: ... then shift 'nm', go to state 442
parser: Shift 'EQ', go to state 84
parser: Return. Stack=[ecmd with UPDATE orconf xfullname indexed_opt SET nm EQ]
parser: Input 'INTEGER' in state 84
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with UPDATE orconf xfullname indexed_opt SET nm EQ INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 84.
parser: ... then shift 'term', go to state 58
parser: Reduce 148 [setlist ::= nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[ecmd with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[ecmd with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'INTEGER' in state 86
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ INTEGER]
parser: Input 'SEMI' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', pending reduce 145
parser: Reduce 145 [cmd ::= with UPDATE orconf xfullname indexed_opt SET setlist where_opt], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
parser: [[[;
SELECT coalesce(not x,99) FROM t1;;
SELECT coalesce(x IS NULL AND x=5,99) FROM t1;;
SELECT 5 not between x and x FROM t1;SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE name='docid' AND type='index' ORDER BY rowid;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
UPDATE t1 SET x=NULL, x=3;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1_content' AND type!='trigger' ORDER BY rowid;;
CREATE UNIQUE INDEX blockid ON t1(x ASC);;
SELECT coalesce(x&x,99) FROM t1;;
SELECT 1%0 FROM t1;;
SELECT coalesce(x>>x,99) FROM t1;CREATE TABLE block(t1_segdir);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;
SELECT
    SrcWord, t1.x
    FROM 
      (SELECT 'FACTORING' AS SrcWord UNION SELECT 'SWIMMING' AS SrcWord )
    LEFT JOIN 
      t1
    WHERE t1.x= (
      SELECT BeginningId FROM (
        SELECT SrcWord, B.x as BeginningId, B.x || E.x As Connected
        FROM t1 B LEFT JOIN t1 E ON B.x=E.x
        WHERE Connected=SrcWord LIMIT 1
      )
    )
;;
INSERT INTO t1(x) VALUES(10);;
SELECT * FROM block;;
SELECT x IS x FROM t1;;
SELECT x+x FROM t1;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;
SELECT ( 
      SELECT x FROM (
        SELECT * FROM t1 WHERE x=out.x ORDER BY x LIMIT 10 OFFSET 1
      ) WHERE x=out.x
    ) FROM t1 AS out;;
SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;;
UPDATE t1 SET x=-9223372036854775807, x=-2;;
UPDATE t1 SET x=-9223372036854775808, x=0;;
UPDATE t1 SET x=9223372036854775807, x=0;;
UPDATE t1 SET x=9223372036854775807, x=-1;;
CREATE INDEX level ON t1(x ASC,  x ASC) ;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
UPDATE t1 SET x=-3037000500, x=-3037000500;PRAGMA journal_mode = DELETE;;
SELECT x NOT LIKE x FROM t1;;
SELECT x-x FROM t1;;
VACUUM;;
UPDATE t1 SET x=1e300, x=1e300;;
SELECT x notnull FROM t1;;
UPDATE t1 SET x='0.0', x='abc';;
UPDATE t1 SET x='abxyzzycy', x='A%CX';;
UPDATE t1 SET x='abc', x='aáˆ´_c';;
UPDATE t1 SET x='abcdefg', x='a*[^def]g';;
UPDATE t1 SET x='ABC', x='A[^A-D]C';;
UPDATE t1 SET x='ABC', x='A[^]B]C';;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;SELECT x FROM t1 WHERE x<10 AND x>8 ORDER BY x;SELECT typeof(00000009223372036854775807);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;PRAGMA max_page_count = 100;VACUUM ;SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'SELECT' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[ecmd SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt ID LP]
parser: Input 'NOT' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'NOT', go to state 105
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt ID LP distinct NOT]
parser: Input 'ID' in state 105
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt ID LP distinct NOT ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 105.
parser: ... then shift 'expr', go to state 75
parser: Reduce 194 [expr ::= NOT expr], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt ID LP distinct nexprlist COMMA]
parser: Input 'INTEGER' in state 107
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt ID LP distinct nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'FROM' in state 192
parser: Reduce 173 [expr ::= ID|INDEXED LP distinct exprlist RP], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[ecmd SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'SEMI' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 1.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 1.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
parser: [[[;
SELECT coalesce(x IS NULL AND x=5,99) FROM t1;;
SELECT 5 not between x and x FROM t1;SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE name='docid' AND type='index' ORDER BY rowid;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
UPDATE t1 SET x=NULL, x=3;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1_content' AND type!='trigger' ORDER BY rowid;;
CREATE UNIQUE INDEX blockid ON t1(x ASC);;
SELECT coalesce(x&x,99) FROM t1;;
SELECT 1%0 FROM t1;;
SELECT coalesce(x>>x,99) FROM t1;CREATE TABLE block(t1_segdir);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;
SELECT
    SrcWord, t1.x
    FROM 
      (SELECT 'FACTORING' AS SrcWord UNION SELECT 'SWIMMING' AS SrcWord )
    LEFT JOIN 
      t1
    WHERE t1.x= (
      SELECT BeginningId FROM (
        SELECT SrcWord, B.x as BeginningId, B.x || E.x As Connected
        FROM t1 B LEFT JOIN t1 E ON B.x=E.x
        WHERE Connected=SrcWord LIMIT 1
      )
    )
;;
INSERT INTO t1(x) VALUES(10);;
SELECT * FROM block;;
SELECT x IS x FROM t1;;
SELECT x+x FROM t1;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;
SELECT ( 
      SELECT x FROM (
        SELECT * FROM t1 WHERE x=out.x ORDER BY x LIMIT 10 OFFSET 1
      ) WHERE x=out.x
    ) FROM t1 AS out;;
SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;;
UPDATE t1 SET x=-9223372036854775807, x=-2;;
UPDATE t1 SET x=-9223372036854775808, x=0;;
UPDATE t1 SET x=9223372036854775807, x=0;;
UPDATE t1 SET x=9223372036854775807, x=-1;;
CREATE INDEX level ON t1(x ASC,  x ASC) ;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
UPDATE t1 SET x=-3037000500, x=-3037000500;PRAGMA journal_mode = DELETE;;
SELECT x NOT LIKE x FROM t1;;
SELECT x-x FROM t1;;
VACUUM;;
UPDATE t1 SET x=1e300, x=1e300;;
SELECT x notnull FROM t1;;
UPDATE t1 SET x='0.0', x='abc';;
UPDATE t1 SET x='abxyzzycy', x='A%CX';;
UPDATE t1 SET x='abc', x='aáˆ´_c';;
UPDATE t1 SET x='abcdefg', x='a*[^def]g';;
UPDATE t1 SET x='ABC', x='A[^A-D]C';;
UPDATE t1 SET x='ABC', x='A[^]B]C';;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;SELECT x FROM t1 WHERE x<10 AND x>8 ORDER BY x;SELECT typeof(00000009223372036854775807);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;PRAGMA max_page_count = 100;VACUUM ;SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'SELECT' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[ecmd SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'IS' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Shift 'IS', go to state 110
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt ID LP distinct expr IS]
parser: Input 'NULL' in state 110
parser: Shift 'NULL', pending reduce 167
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt ID LP distinct expr IS NULL]
parser: Input 'AND' with pending reduce 167
parser: Reduce 167 [term ::= NULL|FLOAT|BLOB], go to state 110.
parser: ... then shift 'term', go to state 127
parser: Reduce 192 [expr ::= expr IS expr], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Shift 'AND', go to state 120
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt ID LP distinct expr AND]
parser: Input 'ID' in state 120
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt ID LP distinct expr AND ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt ID LP distinct expr AND expr EQ]
parser: Input 'INTEGER' in state 117
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt ID LP distinct expr AND expr EQ INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Reduce 179 [expr ::= expr AND expr], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt ID LP distinct nexprlist COMMA]
parser: Input 'INTEGER' in state 107
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt ID LP distinct nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'FROM' in state 192
parser: Reduce 173 [expr ::= ID|INDEXED LP distinct exprlist RP], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[ecmd SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'SEMI' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 1.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 1.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
parser: [[[;
SELECT 5 not between x and x FROM t1;SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE name='docid' AND type='index' ORDER BY rowid;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
UPDATE t1 SET x=NULL, x=3;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1_content' AND type!='trigger' ORDER BY rowid;;
CREATE UNIQUE INDEX blockid ON t1(x ASC);;
SELECT coalesce(x&x,99) FROM t1;;
SELECT 1%0 FROM t1;;
SELECT coalesce(x>>x,99) FROM t1;CREATE TABLE block(t1_segdir);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;
SELECT
    SrcWord, t1.x
    FROM 
      (SELECT 'FACTORING' AS SrcWord UNION SELECT 'SWIMMING' AS SrcWord )
    LEFT JOIN 
      t1
    WHERE t1.x= (
      SELECT BeginningId FROM (
        SELECT SrcWord, B.x as BeginningId, B.x || E.x As Connected
        FROM t1 B LEFT JOIN t1 E ON B.x=E.x
        WHERE Connected=SrcWord LIMIT 1
      )
    )
;;
INSERT INTO t1(x) VALUES(10);;
SELECT * FROM block;;
SELECT x IS x FROM t1;;
SELECT x+x FROM t1;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;
SELECT ( 
      SELECT x FROM (
        SELECT * FROM t1 WHERE x=out.x ORDER BY x LIMIT 10 OFFSET 1
      ) WHERE x=out.x
    ) FROM t1 AS out;;
SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;;
UPDATE t1 SET x=-9223372036854775807, x=-2;;
UPDATE t1 SET x=-9223372036854775808, x=0;;
UPDATE t1 SET x=9223372036854775807, x=0;;
UPDATE t1 SET x=9223372036854775807, x=-1;;
CREATE INDEX level ON t1(x ASC,  x ASC) ;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
UPDATE t1 SET x=-3037000500, x=-3037000500;PRAGMA journal_mode = DELETE;;
SELECT x NOT LIKE x FROM t1;;
SELECT x-x FROM t1;;
VACUUM;;
UPDATE t1 SET x=1e300, x=1e300;;
SELECT x notnull FROM t1;;
UPDATE t1 SET x='0.0', x='abc';;
UPDATE t1 SET x='abxyzzycy', x='A%CX';;
UPDATE t1 SET x='abc', x='aáˆ´_c';;
UPDATE t1 SET x='abcdefg', x='a*[^def]g';;
UPDATE t1 SET x='ABC', x='A[^A-D]C';;
UPDATE t1 SET x='ABC', x='A[^]B]C';;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;SELECT x FROM t1 WHERE x<10 AND x>8 ORDER BY x;SELECT typeof(00000009223372036854775807);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;PRAGMA max_page_count = 100;VACUUM ;SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'SELECT' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[ecmd SELECT]
parser: Input 'INTEGER' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt INTEGER]
parser: Input 'NOT' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 77.
parser: ... then shift 'term', go to state 16
parser: Shift 'NOT', go to state 384
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt term NOT]
parser: Input 'BETWEEN' in state 384
parser: Shift 'BETWEEN', pending reduce 198
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt term NOT BETWEEN]
parser: Input 'ID' with pending reduce 198
parser: Reduce 198 [between_op ::= NOT BETWEEN], go to state 16.
parser: ... then shift 'between_op', go to state 109
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt term between_op ID]
parser: Input 'AND' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 109.
parser: ... then shift 'expr', go to state 72
parser: Shift 'AND', go to state 108
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt term between_op expr AND]
parser: Input 'ID' in state 108
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt term between_op expr AND ID]
parser: Input 'FROM' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 108.
parser: ... then shift 'expr', go to state 126
parser: Reduce 199 [expr ::= expr between_op expr AND expr], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[ecmd SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'SEMI' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 1.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 1.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
parser: [[[SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE name='docid' AND type='index' ORDER BY rowid;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
UPDATE t1 SET x=NULL, x=3;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1_content' AND type!='trigger' ORDER BY rowid;;
CREATE UNIQUE INDEX blockid ON t1(x ASC);;
SELECT coalesce(x&x,99) FROM t1;;
SELECT 1%0 FROM t1;;
SELECT coalesce(x>>x,99) FROM t1;CREATE TABLE block(t1_segdir);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;
SELECT
    SrcWord, t1.x
    FROM 
      (SELECT 'FACTORING' AS SrcWord UNION SELECT 'SWIMMING' AS SrcWord )
    LEFT JOIN 
      t1
    WHERE t1.x= (
      SELECT BeginningId FROM (
        SELECT SrcWord, B.x as BeginningId, B.x || E.x As Connected
        FROM t1 B LEFT JOIN t1 E ON B.x=E.x
        WHERE Connected=SrcWord LIMIT 1
      )
    )
;;
INSERT INTO t1(x) VALUES(10);;
SELECT * FROM block;;
SELECT x IS x FROM t1;;
SELECT x+x FROM t1;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;
SELECT ( 
      SELECT x FROM (
        SELECT * FROM t1 WHERE x=out.x ORDER BY x LIMIT 10 OFFSET 1
      ) WHERE x=out.x
    ) FROM t1 AS out;;
SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;;
UPDATE t1 SET x=-9223372036854775807, x=-2;;
UPDATE t1 SET x=-9223372036854775808, x=0;;
UPDATE t1 SET x=9223372036854775807, x=0;;
UPDATE t1 SET x=9223372036854775807, x=-1;;
CREATE INDEX level ON t1(x ASC,  x ASC) ;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
UPDATE t1 SET x=-3037000500, x=-3037000500;PRAGMA journal_mode = DELETE;;
SELECT x NOT LIKE x FROM t1;;
SELECT x-x FROM t1;;
VACUUM;;
UPDATE t1 SET x=1e300, x=1e300;;
SELECT x notnull FROM t1;;
UPDATE t1 SET x='0.0', x='abc';;
UPDATE t1 SET x='abxyzzycy', x='A%CX';;
UPDATE t1 SET x='abc', x='aáˆ´_c';;
UPDATE t1 SET x='abcdefg', x='a*[^def]g';;
UPDATE t1 SET x='ABC', x='A[^A-D]C';;
UPDATE t1 SET x='ABC', x='A[^]B]C';;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;SELECT x FROM t1 WHERE x<10 AND x>8 ORDER BY x;SELECT typeof(00000009223372036854775807);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;PRAGMA max_page_count = 100;VACUUM ;SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'FROM' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'STRING' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'STRING', pending reduce 332
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix STRING]
parser: Input 'DOT' with pending reduce 332
parser: Reduce 332 [nm ::= STRING], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Shift 'DOT', go to state 245
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID' in state 245
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 245.
parser: ... then shift 'nm', pending reduce 109
parser: Reduce 109 [dbnm ::= DOT nm], go to state 349.
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[SELECT distinct selcollist from WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND' in state 537
parser: Reduce 168 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'AND', go to state 120
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID' in state 120
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr EQ]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr EQ STRING]
parser: Input 'ORDER' in state 537
parser: Reduce 168 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Reduce 179 [expr ::= expr AND expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
UPDATE t1 SET x=NULL, x=3;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1_content' AND type!='trigger' ORDER BY rowid;;
CREATE UNIQUE INDEX blockid ON t1(x ASC);;
SELECT coalesce(x&x,99) FROM t1;;
SELECT 1%0 FROM t1;;
SELECT coalesce(x>>x,99) FROM t1;CREATE TABLE block(t1_segdir);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;
SELECT
    SrcWord, t1.x
    FROM 
      (SELECT 'FACTORING' AS SrcWord UNION SELECT 'SWIMMING' AS SrcWord )
    LEFT JOIN 
      t1
    WHERE t1.x= (
      SELECT BeginningId FROM (
        SELECT SrcWord, B.x as BeginningId, B.x || E.x As Connected
        FROM t1 B LEFT JOIN t1 E ON B.x=E.x
        WHERE Connected=SrcWord LIMIT 1
      )
    )
;;
INSERT INTO t1(x) VALUES(10);;
SELECT * FROM block;;
SELECT x IS x FROM t1;;
SELECT x+x FROM t1;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;
SELECT ( 
      SELECT x FROM (
        SELECT * FROM t1 WHERE x=out.x ORDER BY x LIMIT 10 OFFSET 1
      ) WHERE x=out.x
    ) FROM t1 AS out;;
SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;;
UPDATE t1 SET x=-9223372036854775807, x=-2;;
UPDATE t1 SET x=-9223372036854775808, x=0;;
UPDATE t1 SET x=9223372036854775807, x=0;;
UPDATE t1 SET x=9223372036854775807, x=-1;;
CREATE INDEX level ON t1(x ASC,  x ASC) ;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
UPDATE t1 SET x=-3037000500, x=-3037000500;PRAGMA journal_mode = DELETE;;
SELECT x NOT LIKE x FROM t1;;
SELECT x-x FROM t1;;
VACUUM;;
UPDATE t1 SET x=1e300, x=1e300;;
SELECT x notnull FROM t1;;
UPDATE t1 SET x='0.0', x='abc';;
UPDATE t1 SET x='abxyzzycy', x='A%CX';;
UPDATE t1 SET x='abc', x='aáˆ´_c';;
UPDATE t1 SET x='abcdefg', x='a*[^def]g';;
UPDATE t1 SET x='ABC', x='A[^A-D]C';;
UPDATE t1 SET x='ABC', x='A[^]B]C';;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;SELECT x FROM t1 WHERE x<10 AND x>8 ORDER BY x;SELECT typeof(00000009223372036854775807);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;PRAGMA max_page_count = 100;VACUUM ;SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'SELECT' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[ecmd SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[ecmd SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt ID]
parser: Input 'FROM' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[ecmd SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'INTEGER' in state 117
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ INTEGER]
parser: Input 'AND' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'AND', go to state 120
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID' in state 120
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'IN' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Shift 'IN', pending reduce 200
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr AND expr IN]
parser: Input 'LP' with pending reduce 200
parser: Reduce 200 [in_op ::= IN], go to state 76.
parser: ... then shift 'in_op', go to state 209
parser: Shift 'LP', go to state 3
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr AND expr in_op LP]
parser: Input 'INTEGER' in state 3
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr AND expr in_op LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 3.
parser: ... then shift 'term', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 3.
parser: ... then shift 'nexprlist', go to state 517
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr AND expr in_op LP nexprlist COMMA]
parser: Input 'INTEGER' in state 107
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr AND expr in_op LP nexprlist COMMA INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 3.
parser: ... then shift 'nexprlist', go to state 517
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr AND expr in_op LP nexprlist COMMA]
parser: Input 'INTEGER' in state 107
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr AND expr in_op LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 3.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 3.
parser: ... then shift 'exprlist', go to state 519
parser: Shift 'RP', pending reduce 202
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr AND expr in_op LP exprlist RP]
parser: Input 'ORDER' with pending reduce 202
parser: Reduce 202 [expr ::= expr in_op LP exprlist RP], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Reduce 179 [expr ::= expr AND expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[ecmd SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[ecmd SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'DESC' in state 416
parser: FALLBACK DESC => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Shift 'DESC', pending reduce 132
parser: Return. Stack=[ecmd SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY expr DESC]
parser: Input 'COMMA' with pending reduce 132
parser: Reduce 132 [sortorder ::= DESC], go to state 13.
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Shift 'COMMA', go to state 95
parser: Return. Stack=[ecmd SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY sortlist COMMA]
parser: Input 'ID' in state 95
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY sortlist COMMA ID]
parser: Input 'DESC' in state 416
parser: FALLBACK DESC => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 95.
parser: ... then shift 'expr', go to state 14
parser: Shift 'DESC', pending reduce 132
parser: Return. Stack=[ecmd SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY sortlist COMMA expr DESC]
parser: Input 'SEMI' with pending reduce 132
parser: Reduce 132 [sortorder ::= DESC], go to state 14.
parser: ... then shift 'sortorder', pending reduce 129
parser: Reduce 129 [sortlist ::= sortlist COMMA expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 1.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 1.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
parser: [[[;
UPDATE t1 SET x=NULL, x=3;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1_content' AND type!='trigger' ORDER BY rowid;;
CREATE UNIQUE INDEX blockid ON t1(x ASC);;
SELECT coalesce(x&x,99) FROM t1;;
SELECT 1%0 FROM t1;;
SELECT coalesce(x>>x,99) FROM t1;CREATE TABLE block(t1_segdir);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;
SELECT
    SrcWord, t1.x
    FROM 
      (SELECT 'FACTORING' AS SrcWord UNION SELECT 'SWIMMING' AS SrcWord )
    LEFT JOIN 
      t1
    WHERE t1.x= (
      SELECT BeginningId FROM (
        SELECT SrcWord, B.x as BeginningId, B.x || E.x As Connected
        FROM t1 B LEFT JOIN t1 E ON B.x=E.x
        WHERE Connected=SrcWord LIMIT 1
      )
    )
;;
INSERT INTO t1(x) VALUES(10);;
SELECT * FROM block;;
SELECT x IS x FROM t1;;
SELECT x+x FROM t1;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;
SELECT ( 
      SELECT x FROM (
        SELECT * FROM t1 WHERE x=out.x ORDER BY x LIMIT 10 OFFSET 1
      ) WHERE x=out.x
    ) FROM t1 AS out;;
SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;;
UPDATE t1 SET x=-9223372036854775807, x=-2;;
UPDATE t1 SET x=-9223372036854775808, x=0;;
UPDATE t1 SET x=9223372036854775807, x=0;;
UPDATE t1 SET x=9223372036854775807, x=-1;;
CREATE INDEX level ON t1(x ASC,  x ASC) ;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
UPDATE t1 SET x=-3037000500, x=-3037000500;PRAGMA journal_mode = DELETE;;
SELECT x NOT LIKE x FROM t1;;
SELECT x-x FROM t1;;
VACUUM;;
UPDATE t1 SET x=1e300, x=1e300;;
SELECT x notnull FROM t1;;
UPDATE t1 SET x='0.0', x='abc';;
UPDATE t1 SET x='abxyzzycy', x='A%CX';;
UPDATE t1 SET x='abc', x='aáˆ´_c';;
UPDATE t1 SET x='abcdefg', x='a*[^def]g';;
UPDATE t1 SET x='ABC', x='A[^A-D]C';;
UPDATE t1 SET x='ABC', x='A[^]B]C';;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;SELECT x FROM t1 WHERE x<10 AND x>8 ORDER BY x;SELECT typeof(00000009223372036854775807);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;PRAGMA max_page_count = 100;VACUUM ;SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'UPDATE' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'UPDATE', go to state 299
parser: Return. Stack=[ecmd with UPDATE]
parser: Input 'ID' in state 299
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', go to state 165
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd with UPDATE orconf ID]
parser: Input 'SET' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 165.
parser: ... then shift 'nm', go to state 393
parser: Reduce 112 [xfullname ::= nm], go to state 165.
parser: ... then shift 'xfullname', go to state 271
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 428
parser: Shift 'SET', go to state 153
parser: Return. Stack=[ecmd with UPDATE orconf xfullname indexed_opt SET]
parser: Input 'ID' in state 153
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd with UPDATE orconf xfullname indexed_opt SET ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 153.
parser: ... then shift 'nm', go to state 442
parser: Shift 'EQ', go to state 84
parser: Return. Stack=[ecmd with UPDATE orconf xfullname indexed_opt SET nm EQ]
parser: Input 'NULL' in state 84
parser: Shift 'NULL', pending reduce 167
parser: Return. Stack=[ecmd with UPDATE orconf xfullname indexed_opt SET nm EQ NULL]
parser: Input 'COMMA' with pending reduce 167
parser: Reduce 167 [term ::= NULL|FLOAT|BLOB], go to state 84.
parser: ... then shift 'term', go to state 58
parser: Reduce 148 [setlist ::= nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[ecmd with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[ecmd with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'INTEGER' in state 86
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ INTEGER]
parser: Input 'SEMI' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', pending reduce 145
parser: Reduce 145 [cmd ::= with UPDATE orconf xfullname indexed_opt SET setlist where_opt], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
parser: [[[;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1_content' AND type!='trigger' ORDER BY rowid;;
CREATE UNIQUE INDEX blockid ON t1(x ASC);;
SELECT coalesce(x&x,99) FROM t1;;
SELECT 1%0 FROM t1;;
SELECT coalesce(x>>x,99) FROM t1;CREATE TABLE block(t1_segdir);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;
SELECT
    SrcWord, t1.x
    FROM 
      (SELECT 'FACTORING' AS SrcWord UNION SELECT 'SWIMMING' AS SrcWord )
    LEFT JOIN 
      t1
    WHERE t1.x= (
      SELECT BeginningId FROM (
        SELECT SrcWord, B.x as BeginningId, B.x || E.x As Connected
        FROM t1 B LEFT JOIN t1 E ON B.x=E.x
        WHERE Connected=SrcWord LIMIT 1
      )
    )
;;
INSERT INTO t1(x) VALUES(10);;
SELECT * FROM block;;
SELECT x IS x FROM t1;;
SELECT x+x FROM t1;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;
SELECT ( 
      SELECT x FROM (
        SELECT * FROM t1 WHERE x=out.x ORDER BY x LIMIT 10 OFFSET 1
      ) WHERE x=out.x
    ) FROM t1 AS out;;
SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;;
UPDATE t1 SET x=-9223372036854775807, x=-2;;
UPDATE t1 SET x=-9223372036854775808, x=0;;
UPDATE t1 SET x=9223372036854775807, x=0;;
UPDATE t1 SET x=9223372036854775807, x=-1;;
CREATE INDEX level ON t1(x ASC,  x ASC) ;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
UPDATE t1 SET x=-3037000500, x=-3037000500;PRAGMA journal_mode = DELETE;;
SELECT x NOT LIKE x FROM t1;;
SELECT x-x FROM t1;;
VACUUM;;
UPDATE t1 SET x=1e300, x=1e300;;
SELECT x notnull FROM t1;;
UPDATE t1 SET x='0.0', x='abc';;
UPDATE t1 SET x='abxyzzycy', x='A%CX';;
UPDATE t1 SET x='abc', x='aáˆ´_c';;
UPDATE t1 SET x='abcdefg', x='a*[^def]g';;
UPDATE t1 SET x='ABC', x='A[^A-D]C';;
UPDATE t1 SET x='ABC', x='A[^]B]C';;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;SELECT x FROM t1 WHERE x<10 AND x>8 ORDER BY x;SELECT typeof(00000009223372036854775807);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;PRAGMA max_page_count = 100;VACUUM ;SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'SELECT' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[ecmd SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[ecmd SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[ecmd SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt ID]
parser: Input 'FROM' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[ecmd SELECT distinct selcollist FROM]
parser: Input 'STRING' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'STRING', pending reduce 332
parser: Return. Stack=[ecmd SELECT distinct selcollist FROM stl_prefix STRING]
parser: Input 'DOT' with pending reduce 332
parser: Reduce 332 [nm ::= STRING], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Shift 'DOT', go to state 245
parser: Return. Stack=[ecmd SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID' in state 245
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 245.
parser: ... then shift 'nm', pending reduce 109
parser: Reduce 109 [dbnm ::= DOT nm], go to state 349.
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND' in state 537
parser: Reduce 168 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'AND', go to state 120
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID' in state 120
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'NE' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Shift 'NE', go to state 117
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr AND expr NE]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr AND expr NE STRING]
parser: Input 'ORDER' in state 537
parser: Reduce 168 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Reduce 179 [expr ::= expr AND expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[ecmd SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[ecmd SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 1.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 1.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
parser: [[[;
CREATE UNIQUE INDEX blockid ON t1(x ASC);;
SELECT coalesce(x&x,99) FROM t1;;
SELECT 1%0 FROM t1;;
SELECT coalesce(x>>x,99) FROM t1;CREATE TABLE block(t1_segdir);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;
SELECT
    SrcWord, t1.x
    FROM 
      (SELECT 'FACTORING' AS SrcWord UNION SELECT 'SWIMMING' AS SrcWord )
    LEFT JOIN 
      t1
    WHERE t1.x= (
      SELECT BeginningId FROM (
        SELECT SrcWord, B.x as BeginningId, B.x || E.x As Connected
        FROM t1 B LEFT JOIN t1 E ON B.x=E.x
        WHERE Connected=SrcWord LIMIT 1
      )
    )
;;
INSERT INTO t1(x) VALUES(10);;
SELECT * FROM block;;
SELECT x IS x FROM t1;;
SELECT x+x FROM t1;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;
SELECT ( 
      SELECT x FROM (
        SELECT * FROM t1 WHERE x=out.x ORDER BY x LIMIT 10 OFFSET 1
      ) WHERE x=out.x
    ) FROM t1 AS out;;
SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;;
UPDATE t1 SET x=-9223372036854775807, x=-2;;
UPDATE t1 SET x=-9223372036854775808, x=0;;
UPDATE t1 SET x=9223372036854775807, x=0;;
UPDATE t1 SET x=9223372036854775807, x=-1;;
CREATE INDEX level ON t1(x ASC,  x ASC) ;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
UPDATE t1 SET x=-3037000500, x=-3037000500;PRAGMA journal_mode = DELETE;;
SELECT x NOT LIKE x FROM t1;;
SELECT x-x FROM t1;;
VACUUM;;
UPDATE t1 SET x=1e300, x=1e300;;
SELECT x notnull FROM t1;;
UPDATE t1 SET x='0.0', x='abc';;
UPDATE t1 SET x='abxyzzycy', x='A%CX';;
UPDATE t1 SET x='abc', x='aáˆ´_c';;
UPDATE t1 SET x='abcdefg', x='a*[^def]g';;
UPDATE t1 SET x='ABC', x='A[^A-D]C';;
UPDATE t1 SET x='ABC', x='A[^]B]C';;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;SELECT x FROM t1 WHERE x<10 AND x>8 ORDER BY x;SELECT typeof(00000009223372036854775807);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;PRAGMA max_page_count = 100;VACUUM ;SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'CREATE' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[ecmd CREATE]
parser: Input 'UNIQUE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 1.
parser: ... then shift 'createkw', go to state 134
parser: Shift 'UNIQUE', pending reduce 220
parser: Return. Stack=[ecmd createkw UNIQUE]
parser: Input 'INDEX' with pending reduce 220
parser: Reduce 220 [uniqueflag ::= UNIQUE], go to state 134.
parser: ... then shift 'uniqueflag', go to state 453
parser: Shift 'INDEX', go to state 315
parser: Return. Stack=[ecmd createkw uniqueflag INDEX]
parser: Input 'ID' in state 315
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 225
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd createkw uniqueflag INDEX ifnotexists ID]
parser: Input 'ON' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 225.
parser: ... then shift 'nm', go to state 314
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 452
parser: Shift 'ON', go to state 224
parser: Return. Stack=[ecmd createkw uniqueflag INDEX ifnotexists nm dbnm ON]
parser: Input 'ID' in state 224
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd createkw uniqueflag INDEX ifnotexists nm dbnm ON ID]
parser: Input 'LP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 224.
parser: ... then shift 'nm', go to state 451
parser: Shift 'LP', go to state 18
parser: Return. Stack=[ecmd createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP]
parser: Input 'ID' in state 18
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP ID]
parser: Input 'ASC' in state 416
parser: FALLBACK ASC => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 18.
parser: ... then shift 'expr', go to state 13
parser: Shift 'ASC', pending reduce 131
parser: Return. Stack=[ecmd createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP expr ASC]
parser: Input 'RP' with pending reduce 131
parser: Reduce 131 [sortorder ::= ASC], go to state 13.
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 18.
parser: ... then shift 'sortlist', go to state 400
parser: Shift 'RP', go to state 313
parser: Return. Stack=[ecmd createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP]
parser: Input 'SEMI' in state 313
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', pending reduce 219
parser: Reduce 219 [cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt], go to state 1.
parser: [[[INSERT INTO 'main'.sqlite_master VALUES('index','blockid','t1',#1,'CREATE UNIQUE INDEX blockid ON t1(x ASC)');]]]
parser: Input 'INSERT' in state 0
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'INSERT', go to state 311
parser: Return. Stack=[with INSERT]
parser: Input 'INTO' in state 311
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', pending reduce 156
parser: Reduce 156 [insert_cmd ::= INSERT orconf], go to state 219.
parser: ... then shift 'insert_cmd', go to state 427
parser: Shift 'INTO', go to state 164
parser: Return. Stack=[with insert_cmd INTO]
parser: Input 'STRING' in state 164
parser: Shift 'STRING', pending reduce 332
parser: Return. Stack=[with insert_cmd INTO STRING]
parser: Input 'DOT' with pending reduce 332
parser: Reduce 332 [nm ::= STRING], go to state 164.
parser: ... then shift 'nm', go to state 393
parser: Shift 'DOT', go to state 218
parser: Return. Stack=[with insert_cmd INTO nm DOT]
parser: Input 'ID' in state 218
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with insert_cmd INTO nm DOT ID]
parser: Input 'VALUES' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 218.
parser: ... then shift 'nm', go to state 429
parser: Reduce 113 [xfullname ::= nm DOT nm], go to state 164.
parser: ... then shift 'xfullname', go to state 298
parser: Reduce 158 [idlist_opt ::=].
parser: ... then shift 'idlist_opt', go to state 35
parser: Shift 'VALUES', go to state 526
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES]
parser: Input 'LP' in state 526
parser: Shift 'LP', go to state 28
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP]
parser: Input 'STRING' in state 28
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 28.
parser: ... then shift 'term', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'STRING' in state 107
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'STRING' in state 107
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'VARIABLE' in state 107
parser: Shift 'VARIABLE', pending reduce 170
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA VARIABLE]
parser: Input 'COMMA' with pending reduce 170
parser: Reduce 170 [expr ::= VARIABLE], go to state 107.
parser: ... then shift 'expr', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'STRING' in state 107
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA STRING]
parser: Input 'RP' in state 537
parser: Reduce 168 [term ::= STRING], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'RP', pending reduce 89
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist RP]
parser: Input 'SEMI' with pending reduce 89
parser: Reduce 89 [values ::= VALUES LP nexprlist RP], go to state 35.
parser: ... then shift 'values', go to state 532
parser: Reduce 348 [oneselect ::= values], go to state 35.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 35.
parser: ... then shift 'select', go to state 297
parser: Reduce 152 [upsert ::=].
parser: ... then shift 'upsert', pending reduce 150
parser: Reduce 150 [cmd ::= with insert_cmd INTO xfullname idlist_opt select upsert], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Input '$' with pending reduce 321
parser: Reduce 321 [ecmd ::= cmdx SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 317 [input ::= cmdlist], go to state 0.
parser: ... then shift 'input', pending reduce -2
parser: Accept!
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
parser: [[[SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE name='blockid' AND type='index' ORDER BY rowid]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'FROM' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'STRING' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'STRING', pending reduce 332
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix STRING]
parser: Input 'DOT' with pending reduce 332
parser: Reduce 332 [nm ::= STRING], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Shift 'DOT', go to state 245
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID' in state 245
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 245.
parser: ... then shift 'nm', pending reduce 109
parser: Reduce 109 [dbnm ::= DOT nm], go to state 349.
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[SELECT distinct selcollist from WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND' in state 537
parser: Reduce 168 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'AND', go to state 120
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID' in state 120
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr EQ]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr EQ STRING]
parser: Input 'ORDER' in state 537
parser: Reduce 168 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Reduce 179 [expr ::= expr AND expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[CREATE UNIQUE INDEX blockid ON t1(x ASC)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'UNIQUE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Shift 'UNIQUE', pending reduce 220
parser: Return. Stack=[createkw UNIQUE]
parser: Input 'INDEX' with pending reduce 220
parser: Reduce 220 [uniqueflag ::= UNIQUE], go to state 134.
parser: ... then shift 'uniqueflag', go to state 453
parser: Shift 'INDEX', go to state 315
parser: Return. Stack=[createkw uniqueflag INDEX]
parser: Input 'ID' in state 315
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 225
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists ID]
parser: Input 'ON' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 225.
parser: ... then shift 'nm', go to state 314
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 452
parser: Shift 'ON', go to state 224
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON]
parser: Input 'ID' in state 224
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON ID]
parser: Input 'LP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 224.
parser: ... then shift 'nm', go to state 451
parser: Shift 'LP', go to state 18
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP]
parser: Input 'ID' in state 18
parser: Shift 'ID', go to state 416
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP ID]
parser: Input 'ASC' in state 416
parser: FALLBACK ASC => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 18.
parser: ... then shift 'expr', go to state 13
parser: Shift 'ASC', pending reduce 131
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP expr ASC]
parser: Input 'RP' with pending reduce 131
parser: Reduce 131 [sortorder ::= ASC], go to state 13.
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 18.
parser: ... then shift 'sortlist', go to state 400
parser: Shift 'RP', go to state 313
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP]
parser: Input 'SEMI' in state 313
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', pending reduce 219
parser: Reduce 219 [cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[;
SELECT coalesce(x&x,99) FROM t1;;
SELECT 1%0 FROM t1;;
SELECT coalesce(x>>x,99) FROM t1;CREATE TABLE block(t1_segdir);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;
SELECT
    SrcWord, t1.x
    FROM 
      (SELECT 'FACTORING' AS SrcWord UNION SELECT 'SWIMMING' AS SrcWord )
    LEFT JOIN 
      t1
    WHERE t1.x= (
      SELECT BeginningId FROM (
        SELECT SrcWord, B.x as BeginningId, B.x || E.x As Connected
        FROM t1 B LEFT JOIN t1 E ON B.x=E.x
        WHERE Connected=SrcWord LIMIT 1
      )
    )
;;
INSERT INTO t1(x) VALUES(10);;
SELECT * FROM block;;
SELECT x IS x FROM t1;;
SELECT x+x FROM t1;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;
SELECT ( 
      SELECT x FROM (
        SELECT * FROM t1 WHERE x=out.x ORDER BY x LIMIT 10 OFFSET 1
      ) WHERE x=out.x
    ) FROM t1 AS out;;
SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;;
UPDATE t1 SET x=-9223372036854775807, x=-2;;
UPDATE t1 SET x=-9223372036854775808, x=0;;
UPDATE t1 SET x=9223372036854775807, x=0;;
UPDATE t1 SET x=9223372036854775807, x=-1;;
CREATE INDEX level ON t1(x ASC,  x ASC) ;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
UPDATE t1 SET x=-3037000500, x=-3037000500;PRAGMA journal_mode = DELETE;;
SELECT x NOT LIKE x FROM t1;;
SELECT x-x FROM t1;;
VACUUM;;
UPDATE t1 SET x=1e300, x=1e300;;
SELECT x notnull FROM t1;;
UPDATE t1 SET x='0.0', x='abc';;
UPDATE t1 SET x='abxyzzycy', x='A%CX';;
UPDATE t1 SET x='abc', x='aáˆ´_c';;
UPDATE t1 SET x='abcdefg', x='a*[^def]g';;
UPDATE t1 SET x='ABC', x='A[^A-D]C';;
UPDATE t1 SET x='ABC', x='A[^]B]C';;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;SELECT x FROM t1 WHERE x<10 AND x>8 ORDER BY x;SELECT typeof(00000009223372036854775807);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;PRAGMA max_page_count = 100;VACUUM ;SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'SELECT' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[ecmd SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'BITAND' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Shift 'BITAND', go to state 116
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt ID LP distinct expr BITAND]
parser: Input 'ID' in state 116
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt ID LP distinct expr BITAND ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 116.
parser: ... then shift 'expr', go to state 131
parser: Reduce 183 [expr ::= expr BITAND|BITOR|LSHIFT|RSHIFT expr], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt ID LP distinct nexprlist COMMA]
parser: Input 'INTEGER' in state 107
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt ID LP distinct nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'FROM' in state 192
parser: Reduce 173 [expr ::= ID|INDEXED LP distinct exprlist RP], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[ecmd SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'SEMI' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 1.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 1.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
parser: [[[;
SELECT 1%0 FROM t1;;
SELECT coalesce(x>>x,99) FROM t1;CREATE TABLE block(t1_segdir);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;
SELECT
    SrcWord, t1.x
    FROM 
      (SELECT 'FACTORING' AS SrcWord UNION SELECT 'SWIMMING' AS SrcWord )
    LEFT JOIN 
      t1
    WHERE t1.x= (
      SELECT BeginningId FROM (
        SELECT SrcWord, B.x as BeginningId, B.x || E.x As Connected
        FROM t1 B LEFT JOIN t1 E ON B.x=E.x
        WHERE Connected=SrcWord LIMIT 1
      )
    )
;;
INSERT INTO t1(x) VALUES(10);;
SELECT * FROM block;;
SELECT x IS x FROM t1;;
SELECT x+x FROM t1;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;
SELECT ( 
      SELECT x FROM (
        SELECT * FROM t1 WHERE x=out.x ORDER BY x LIMIT 10 OFFSET 1
      ) WHERE x=out.x
    ) FROM t1 AS out;;
SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;;
UPDATE t1 SET x=-9223372036854775807, x=-2;;
UPDATE t1 SET x=-9223372036854775808, x=0;;
UPDATE t1 SET x=9223372036854775807, x=0;;
UPDATE t1 SET x=9223372036854775807, x=-1;;
CREATE INDEX level ON t1(x ASC,  x ASC) ;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
UPDATE t1 SET x=-3037000500, x=-3037000500;PRAGMA journal_mode = DELETE;;
SELECT x NOT LIKE x FROM t1;;
SELECT x-x FROM t1;;
VACUUM;;
UPDATE t1 SET x=1e300, x=1e300;;
SELECT x notnull FROM t1;;
UPDATE t1 SET x='0.0', x='abc';;
UPDATE t1 SET x='abxyzzycy', x='A%CX';;
UPDATE t1 SET x='abc', x='aáˆ´_c';;
UPDATE t1 SET x='abcdefg', x='a*[^def]g';;
UPDATE t1 SET x='ABC', x='A[^A-D]C';;
UPDATE t1 SET x='ABC', x='A[^]B]C';;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;SELECT x FROM t1 WHERE x<10 AND x>8 ORDER BY x;SELECT typeof(00000009223372036854775807);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;PRAGMA max_page_count = 100;VACUUM ;SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'SELECT' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[ecmd SELECT]
parser: Input 'INTEGER' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt INTEGER]
parser: Input 'REM' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 77.
parser: ... then shift 'term', go to state 16
parser: Shift 'REM', go to state 114
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt term REM]
parser: Input 'INTEGER' in state 114
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt term REM INTEGER]
parser: Input 'FROM' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 114.
parser: ... then shift 'term', go to state 145
parser: Reduce 185 [expr ::= expr STAR|SLASH|REM expr], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[ecmd SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'SEMI' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 1.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 1.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
parser: [[[;
SELECT coalesce(x>>x,99) FROM t1;CREATE TABLE block(t1_segdir);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;
SELECT
    SrcWord, t1.x
    FROM 
      (SELECT 'FACTORING' AS SrcWord UNION SELECT 'SWIMMING' AS SrcWord )
    LEFT JOIN 
      t1
    WHERE t1.x= (
      SELECT BeginningId FROM (
        SELECT SrcWord, B.x as BeginningId, B.x || E.x As Connected
        FROM t1 B LEFT JOIN t1 E ON B.x=E.x
        WHERE Connected=SrcWord LIMIT 1
      )
    )
;;
INSERT INTO t1(x) VALUES(10);;
SELECT * FROM block;;
SELECT x IS x FROM t1;;
SELECT x+x FROM t1;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;
SELECT ( 
      SELECT x FROM (
        SELECT * FROM t1 WHERE x=out.x ORDER BY x LIMIT 10 OFFSET 1
      ) WHERE x=out.x
    ) FROM t1 AS out;;
SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;;
UPDATE t1 SET x=-9223372036854775807, x=-2;;
UPDATE t1 SET x=-9223372036854775808, x=0;;
UPDATE t1 SET x=9223372036854775807, x=0;;
UPDATE t1 SET x=9223372036854775807, x=-1;;
CREATE INDEX level ON t1(x ASC,  x ASC) ;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
UPDATE t1 SET x=-3037000500, x=-3037000500;PRAGMA journal_mode = DELETE;;
SELECT x NOT LIKE x FROM t1;;
SELECT x-x FROM t1;;
VACUUM;;
UPDATE t1 SET x=1e300, x=1e300;;
SELECT x notnull FROM t1;;
UPDATE t1 SET x='0.0', x='abc';;
UPDATE t1 SET x='abxyzzycy', x='A%CX';;
UPDATE t1 SET x='abc', x='aáˆ´_c';;
UPDATE t1 SET x='abcdefg', x='a*[^def]g';;
UPDATE t1 SET x='ABC', x='A[^A-D]C';;
UPDATE t1 SET x='ABC', x='A[^]B]C';;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;SELECT x FROM t1 WHERE x<10 AND x>8 ORDER BY x;SELECT typeof(00000009223372036854775807);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;PRAGMA max_page_count = 100;VACUUM ;SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'SELECT' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[ecmd SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RSHIFT' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Shift 'RSHIFT', go to state 116
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt ID LP distinct expr RSHIFT]
parser: Input 'ID' in state 116
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt ID LP distinct expr RSHIFT ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 116.
parser: ... then shift 'expr', go to state 131
parser: Reduce 183 [expr ::= expr BITAND|BITOR|LSHIFT|RSHIFT expr], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt ID LP distinct nexprlist COMMA]
parser: Input 'INTEGER' in state 107
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt ID LP distinct nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'FROM' in state 192
parser: Reduce 173 [expr ::= ID|INDEXED LP distinct exprlist RP], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[ecmd SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'SEMI' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 1.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 1.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
parser: [[[CREATE TABLE block(t1_segdir);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;
SELECT
    SrcWord, t1.x
    FROM 
      (SELECT 'FACTORING' AS SrcWord UNION SELECT 'SWIMMING' AS SrcWord )
    LEFT JOIN 
      t1
    WHERE t1.x= (
      SELECT BeginningId FROM (
        SELECT SrcWord, B.x as BeginningId, B.x || E.x As Connected
        FROM t1 B LEFT JOIN t1 E ON B.x=E.x
        WHERE Connected=SrcWord LIMIT 1
      )
    )
;;
INSERT INTO t1(x) VALUES(10);;
SELECT * FROM block;;
SELECT x IS x FROM t1;;
SELECT x+x FROM t1;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;
SELECT ( 
      SELECT x FROM (
        SELECT * FROM t1 WHERE x=out.x ORDER BY x LIMIT 10 OFFSET 1
      ) WHERE x=out.x
    ) FROM t1 AS out;;
SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;;
UPDATE t1 SET x=-9223372036854775807, x=-2;;
UPDATE t1 SET x=-9223372036854775808, x=0;;
UPDATE t1 SET x=9223372036854775807, x=0;;
UPDATE t1 SET x=9223372036854775807, x=-1;;
CREATE INDEX level ON t1(x ASC,  x ASC) ;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
UPDATE t1 SET x=-3037000500, x=-3037000500;PRAGMA journal_mode = DELETE;;
SELECT x NOT LIKE x FROM t1;;
SELECT x-x FROM t1;;
VACUUM;;
UPDATE t1 SET x=1e300, x=1e300;;
SELECT x notnull FROM t1;;
UPDATE t1 SET x='0.0', x='abc';;
UPDATE t1 SET x='abxyzzycy', x='A%CX';;
UPDATE t1 SET x='abc', x='aáˆ´_c';;
UPDATE t1 SET x='abcdefg', x='a*[^def]g';;
UPDATE t1 SET x='ABC', x='A[^A-D]C';;
UPDATE t1 SET x='ABC', x='A[^]B]C';;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;SELECT x FROM t1 WHERE x<10 AND x>8 ORDER BY x;SELECT typeof(00000009223372036854775807);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;PRAGMA max_page_count = 100;VACUUM ;SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 388
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP ID]
parser: Input 'RP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 190
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 376
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 150
parser: Reduce 330 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Reduce 60 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 538
parser: Shift 'RP', go to state 361
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 361
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: [[[UPDATE 'main'.sqlite_master SET type='table', name='block', tbl_name='block', rootpage=#2, sql='CREATE TABLE block(t1_segdir)' WHERE rowid=#1]]]
parser: Input 'UPDATE' in state 0
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'UPDATE', go to state 299
parser: Return. Stack=[with UPDATE]
parser: Input 'STRING' in state 299
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', go to state 165
parser: Shift 'STRING', pending reduce 332
parser: Return. Stack=[with UPDATE orconf STRING]
parser: Input 'DOT' with pending reduce 332
parser: Reduce 332 [nm ::= STRING], go to state 165.
parser: ... then shift 'nm', go to state 393
parser: Shift 'DOT', go to state 218
parser: Return. Stack=[with UPDATE orconf nm DOT]
parser: Input 'ID' in state 218
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf nm DOT ID]
parser: Input 'SET' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 218.
parser: ... then shift 'nm', go to state 429
parser: Reduce 113 [xfullname ::= nm DOT nm], go to state 165.
parser: ... then shift 'xfullname', go to state 271
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 428
parser: Shift 'SET', go to state 153
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET]
parser: Input 'ID' in state 153
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 153.
parser: ... then shift 'nm', go to state 442
parser: Shift 'EQ', go to state 84
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ]
parser: Input 'STRING' in state 84
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 84.
parser: ... then shift 'term', go to state 58
parser: Reduce 148 [setlist ::= nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'VARIABLE' in state 86
parser: Shift 'VARIABLE', pending reduce 170
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ VARIABLE]
parser: Input 'COMMA' with pending reduce 170
parser: Reduce 170 [expr ::= VARIABLE], go to state 86.
parser: ... then shift 'expr', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'WHERE' in state 537
parser: Reduce 168 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 416
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr EQ]
parser: Input 'VARIABLE' in state 117
parser: Shift 'VARIABLE', pending reduce 170
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr EQ VARIABLE]
parser: Input 'SEMI' with pending reduce 170
parser: Reduce 170 [expr ::= VARIABLE], go to state 117.
parser: ... then shift 'expr', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 270.
parser: ... then shift 'where_opt', pending reduce 145
parser: Reduce 145 [cmd ::= with UPDATE orconf xfullname indexed_opt SET setlist where_opt], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Input '$' with pending reduce 321
parser: Reduce 321 [ecmd ::= cmdx SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 317 [input ::= cmdlist], go to state 0.
parser: ... then shift 'input', pending reduce -2
parser: Accept!
parser: ... then shift 'create_table_args', pending reduce 328
parser: Reduce 328 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'FROM' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'STRING' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'STRING', pending reduce 332
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix STRING]
parser: Input 'DOT' with pending reduce 332
parser: Reduce 332 [nm ::= STRING], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Shift 'DOT', go to state 245
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID' in state 245
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 245.
parser: ... then shift 'nm', pending reduce 109
parser: Reduce 109 [dbnm ::= DOT nm], go to state 349.
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[SELECT distinct selcollist from WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND' in state 537
parser: Reduce 168 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'AND', go to state 120
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID' in state 120
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'NE' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Shift 'NE', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr NE]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr NE STRING]
parser: Input 'ORDER' in state 537
parser: Reduce 168 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Reduce 179 [expr ::= expr AND expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[CREATE TABLE block(t1_segdir)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 388
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP ID]
parser: Input 'RP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 190
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 376
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 150
parser: Reduce 330 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Reduce 60 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 538
parser: Shift 'RP', go to state 361
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 361
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 328
parser: Reduce 328 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;
SELECT
    SrcWord, t1.x
    FROM 
      (SELECT 'FACTORING' AS SrcWord UNION SELECT 'SWIMMING' AS SrcWord )
    LEFT JOIN 
      t1
    WHERE t1.x= (
      SELECT BeginningId FROM (
        SELECT SrcWord, B.x as BeginningId, B.x || E.x As Connected
        FROM t1 B LEFT JOIN t1 E ON B.x=E.x
        WHERE Connected=SrcWord LIMIT 1
      )
    )
;;
INSERT INTO t1(x) VALUES(10);;
SELECT * FROM block;;
SELECT x IS x FROM t1;;
SELECT x+x FROM t1;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;
SELECT ( 
      SELECT x FROM (
        SELECT * FROM t1 WHERE x=out.x ORDER BY x LIMIT 10 OFFSET 1
      ) WHERE x=out.x
    ) FROM t1 AS out;;
SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;;
UPDATE t1 SET x=-9223372036854775807, x=-2;;
UPDATE t1 SET x=-9223372036854775808, x=0;;
UPDATE t1 SET x=9223372036854775807, x=0;;
UPDATE t1 SET x=9223372036854775807, x=-1;;
CREATE INDEX level ON t1(x ASC,  x ASC) ;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
UPDATE t1 SET x=-3037000500, x=-3037000500;PRAGMA journal_mode = DELETE;;
SELECT x NOT LIKE x FROM t1;;
SELECT x-x FROM t1;;
VACUUM;;
UPDATE t1 SET x=1e300, x=1e300;;
SELECT x notnull FROM t1;;
UPDATE t1 SET x='0.0', x='abc';;
UPDATE t1 SET x='abxyzzycy', x='A%CX';;
UPDATE t1 SET x='abc', x='aáˆ´_c';;
UPDATE t1 SET x='abcdefg', x='a*[^def]g';;
UPDATE t1 SET x='ABC', x='A[^A-D]C';;
UPDATE t1 SET x='ABC', x='A[^]B]C';;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;SELECT x FROM t1 WHERE x<10 AND x>8 ORDER BY x;SELECT typeof(00000009223372036854775807);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;PRAGMA max_page_count = 100;VACUUM ;SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'SELECT' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[ecmd SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[ecmd SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[ecmd SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt ID]
parser: Input 'FROM' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[ecmd SELECT distinct selcollist FROM]
parser: Input 'STRING' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'STRING', pending reduce 332
parser: Return. Stack=[ecmd SELECT distinct selcollist FROM stl_prefix STRING]
parser: Input 'DOT' with pending reduce 332
parser: Reduce 332 [nm ::= STRING], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Shift 'DOT', go to state 245
parser: Return. Stack=[ecmd SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID' in state 245
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 245.
parser: ... then shift 'nm', pending reduce 109
parser: Reduce 109 [dbnm ::= DOT nm], go to state 349.
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND' in state 537
parser: Reduce 168 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'AND', go to state 120
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID' in state 120
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'NE' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Shift 'NE', go to state 117
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr AND expr NE]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr AND expr NE STRING]
parser: Input 'ORDER' in state 537
parser: Reduce 168 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Reduce 179 [expr ::= expr AND expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[ecmd SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[ecmd SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 1.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 1.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
parser: [[[;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;
SELECT
    SrcWord, t1.x
    FROM 
      (SELECT 'FACTORING' AS SrcWord UNION SELECT 'SWIMMING' AS SrcWord )
    LEFT JOIN 
      t1
    WHERE t1.x= (
      SELECT BeginningId FROM (
        SELECT SrcWord, B.x as BeginningId, B.x || E.x As Connected
        FROM t1 B LEFT JOIN t1 E ON B.x=E.x
        WHERE Connected=SrcWord LIMIT 1
      )
    )
;;
INSERT INTO t1(x) VALUES(10);;
SELECT * FROM block;;
SELECT x IS x FROM t1;;
SELECT x+x FROM t1;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;
SELECT ( 
      SELECT x FROM (
        SELECT * FROM t1 WHERE x=out.x ORDER BY x LIMIT 10 OFFSET 1
      ) WHERE x=out.x
    ) FROM t1 AS out;;
SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;;
UPDATE t1 SET x=-9223372036854775807, x=-2;;
UPDATE t1 SET x=-9223372036854775808, x=0;;
UPDATE t1 SET x=9223372036854775807, x=0;;
UPDATE t1 SET x=9223372036854775807, x=-1;;
CREATE INDEX level ON t1(x ASC,  x ASC) ;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
UPDATE t1 SET x=-3037000500, x=-3037000500;PRAGMA journal_mode = DELETE;;
SELECT x NOT LIKE x FROM t1;;
SELECT x-x FROM t1;;
VACUUM;;
UPDATE t1 SET x=1e300, x=1e300;;
SELECT x notnull FROM t1;;
UPDATE t1 SET x='0.0', x='abc';;
UPDATE t1 SET x='abxyzzycy', x='A%CX';;
UPDATE t1 SET x='abc', x='aáˆ´_c';;
UPDATE t1 SET x='abcdefg', x='a*[^def]g';;
UPDATE t1 SET x='ABC', x='A[^A-D]C';;
UPDATE t1 SET x='ABC', x='A[^]B]C';;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;SELECT x FROM t1 WHERE x<10 AND x>8 ORDER BY x;SELECT typeof(00000009223372036854775807);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;PRAGMA max_page_count = 100;VACUUM ;SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'SEMI' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[ecmd SEMI]
parser: Input 'SELECT' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 1.
parser: ... then shift 'ecmd', pending reduce 318
parser: Reduce 318 [cmdlist ::= cmdlist ecmd], go to state 0.
parser: ... then shift 'cmdlist', go to state 1
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[cmdlist SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[cmdlist SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[cmdlist SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID]
parser: Input 'FROM' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[cmdlist SELECT distinct selcollist FROM]
parser: Input 'STRING' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'STRING', pending reduce 332
parser: Return. Stack=[cmdlist SELECT distinct selcollist FROM stl_prefix STRING]
parser: Input 'DOT' with pending reduce 332
parser: Reduce 332 [nm ::= STRING], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Shift 'DOT', go to state 245
parser: Return. Stack=[cmdlist SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID' in state 245
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[cmdlist SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 245.
parser: ... then shift 'nm', pending reduce 109
parser: Reduce 109 [dbnm ::= DOT nm], go to state 349.
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 416
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND' in state 537
parser: Reduce 168 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'AND', go to state 120
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID' in state 120
parser: Shift 'ID', go to state 416
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'NE' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Shift 'NE', go to state 117
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr AND expr NE]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr AND expr NE STRING]
parser: Input 'ORDER' in state 537
parser: Reduce 168 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Reduce 179 [expr ::= expr AND expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[cmdlist SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[cmdlist SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[cmdlist SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 1.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 1.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdlist cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping cmdlist
parser: [[[;
SELECT
    SrcWord, t1.x
    FROM 
      (SELECT 'FACTORING' AS SrcWord UNION SELECT 'SWIMMING' AS SrcWord )
    LEFT JOIN 
      t1
    WHERE t1.x= (
      SELECT BeginningId FROM (
        SELECT SrcWord, B.x as BeginningId, B.x || E.x As Connected
        FROM t1 B LEFT JOIN t1 E ON B.x=E.x
        WHERE Connected=SrcWord LIMIT 1
      )
    )
;;
INSERT INTO t1(x) VALUES(10);;
SELECT * FROM block;;
SELECT x IS x FROM t1;;
SELECT x+x FROM t1;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;;
SELECT ( 
      SELECT x FROM (
        SELECT * FROM t1 WHERE x=out.x ORDER BY x LIMIT 10 OFFSET 1
      ) WHERE x=out.x
    ) FROM t1 AS out;;
SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;;
UPDATE t1 SET x=-9223372036854775807, x=-2;;
UPDATE t1 SET x=-9223372036854775808, x=0;;
UPDATE t1 SET x=9223372036854775807, x=0;;
UPDATE t1 SET x=9223372036854775807, x=-1;;
CREATE INDEX level ON t1(x ASC,  x ASC) ;;
SELECT x, x FROM t1 WHERE x = 4 AND x IN (2, 4, 5) ORDER BY x DESC, x DESC;;
UPDATE t1 SET x=-3037000500, x=-3037000500;PRAGMA journal_mode = DELETE;;
SELECT x NOT LIKE x FROM t1;;
SELECT x-x FROM t1;;
VACUUM;;
UPDATE t1 SET x=1e300, x=1e300;;
SELECT x notnull FROM t1;;
UPDATE t1 SET x='0.0', x='abc';;
UPDATE t1 SET x='abxyzzycy', x='A%CX';;
UPDATE t1 SET x='abc', x='aáˆ´_c';;
UPDATE t1 SET x='abcdefg', x='a*[^def]g';;
UPDATE t1 SET x='ABC', x='A[^A-D]C';;
UPDATE t1 SET x='ABC', x='A[^]B]C';;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;SELECT x FROM t1 WHERE x<10 AND x>8 ORDER BY x;SELECT typeof(00000009223372036854775807);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORDER BY rowid;PRAGMA max_page_count = 100;VACUUM ;SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'SELECT' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[ecmd SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[ecmd SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt ID]
parser: Input 'DOT' in state 416
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 77.
parser: ... then shift 'nm', go to state 491
parser: Shift 'DOT', go to state 205
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt nm DOT]
parser: Input 'ID' in state 205
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt nm DOT ID]
parser: Input 'FROM' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 205.
parser: ... then shift 'nm', go to state 534
parser: Reduce 165 [expr ::= nm DOT nm], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[ecmd SELECT distinct selcollist FROM]
parser: Input 'LP' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'LP', go to state 5
parser: Return. Stack=[ecmd SELECT distinct selcollist FROM stl_prefix LP]
parser: Input 'SELECT' in state 5
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[ecmd SELECT distinct selcollist FROM stl_prefix LP SELECT]
parser: Input 'STRING' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[ecmd SELECT distinct selcollist FROM stl_prefix LP SELECT distinct sclp scanpt STRING]
parser: Input 'AS' in state 537
parser: Reduce 168 [term ::= STRING], go to state 77.
parser: ... then shift 'term', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Shift 'AS', go to state 242
parser: Return. Stack=[ecmd SELECT distinct selcollist FROM stl_prefix LP SELECT distinct sclp scanpt term scanpt AS]
parser: Input 'ID' in state 242
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd SELECT distinct selcollist FROM stl_prefix LP SELECT distinct sclp scanpt term scanpt AS ID]
parser: Input 'UNION' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 242.
parser: ... then shift 'nm', pending reduce 98
parser: Reduce 98 [as ::= AS nm], go to state 259.
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Reduce 100 [from ::=].
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 5.
parser: ... then shift 'oneselect', go to state 264
parser: Shift 'UNION', go to state 533
parser: Return. Stack=[ecmd SELECT distinct selcollist FROM stl_prefix LP oneselect UNION]
parser: Input 'SELECT' in state 533
parser: Reduce 84 [multiselect_op ::= UNION], go to state 264.
parser: ... then shift 'multiselect_op', go to state 195
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[ecmd SELECT distinct selcollist FROM stl_prefix LP oneselect multiselect_op SELECT]
parser: Input 'STRING' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[ecmd SELECT distinct selcollist FROM stl_prefix LP oneselect multiselect_op SELECT distinct sclp scanpt STRING]
parser: Input 'AS' in state 537
parser: Reduce 168 [term ::= STRING], go to state 77.
parser: ... then shift 'term', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Shift 'AS', go to state 242
parser: Return. Stack=[ecmd SELECT distinct selcollist FROM stl_prefix LP oneselect multiselect_op SELECT distinct sclp scanpt term scanpt AS]
parser: Input 'ID' in state 242
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd SELECT distinct selcollist FROM stl_prefix LP oneselect multiselect_op SELECT distinct sclp scanpt term scanpt AS ID]
parser: Input 'RP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 242.
parser: ... then shift 'nm', pending reduce 98
parser: Reduce 98 [as ::= AS nm], go to state 259.
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Reduce 100 [from ::=].
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 195.
parser: ... then shift 'oneselect', pending reduce 83
parser: Reduce 83 [selectnowith ::= selectnowith multiselect_op oneselect], go to state 5.
parser: ... then shift 'selectnowith', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 5.
parser: ... then shift 'select', go to state 492
parser: Shift 'RP', go to state 260
parser: Return. Stack=[ecmd SELECT distinct selcollist FROM stl_prefix LP select RP]
parser: Input 'JOIN_KW' in state 260
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 342
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 341
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 106
parser: Reduce 106 [seltablist ::= stl_prefix LP select RP as on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Shift 'JOIN_KW', go to state 208
parser: Return. Stack=[ecmd SELECT distinct selcollist FROM seltablist JOIN_KW]
parser: Input 'JOIN' in state 208
parser: Shift 'JOIN', pending reduce 117
parser: Return. Stack=[ecmd SELECT distinct selcollist FROM seltablist JOIN_KW JOIN]
parser: Input 'ID' with pending reduce 117
parser: Reduce 117 [joinop ::= JOIN_KW JOIN], go to state 263.
parser: ... then shift 'joinop', pending reduce 102
parser: Reduce 102 [stl_prefix ::= seltablist joinop], go to state 197.
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE ID]
parser: Input 'DOT' in state 416
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 93.
parser: ... then shift 'nm', go to state 535
parser: Shift 'DOT', go to state 249
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE nm DOT]
parser: Input 'ID' in state 249
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE nm DOT ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 249.
parser: ... then shift 'nm', go to state 534
parser: Reduce 165 [expr ::= nm DOT nm], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'LP' in state 117
parser: Shift 'LP', go to state 4
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ LP]
parser: Input 'SELECT' in state 4
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ LP SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ LP SELECT distinct sclp scanpt ID]
parser: Input 'FROM' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ LP SELECT distinct selcollist FROM]
parser: Input 'LP' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'LP', go to state 5
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ LP SELECT distinct selcollist FROM stl_prefix LP]
parser: Input 'SELECT' in state 5
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ LP SELECT distinct selcollist FROM stl_prefix LP SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ LP SELECT distinct selcollist FROM stl_prefix LP SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ LP SELECT distinct selcollist FROM stl_prefix LP SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ LP SELECT distinct selcollist FROM stl_prefix LP SELECT distinct sclp scanpt ID]
parser: Input 'DOT' in state 416
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 77.
parser: ... then shift 'nm', go to state 491
parser: Shift 'DOT', go to state 205
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ LP SELECT distinct selcollist FROM stl_prefix LP SELECT distinct sclp scanpt nm DOT]
parser: Input 'ID' in state 205
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ LP SELECT distinct selcollist FROM stl_prefix LP SELECT distinct sclp scanpt nm DOT ID]
parser: Input 'AS' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 205.
parser: ... then shift 'nm', go to state 534
parser: Reduce 165 [expr ::= nm DOT nm], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Shift 'AS', go to state 242
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ LP SELECT distinct selcollist FROM stl_prefix LP SELECT distinct sclp scanpt expr scanpt AS]
parser: Input 'ID' in state 242
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ LP SELECT distinct selcollist FROM stl_prefix LP SELECT distinct sclp scanpt expr scanpt AS ID]
parser: Input 'COMMA' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 242.
parser: ... then shift 'nm', pending reduce 98
parser: Reduce 98 [as ::= AS nm], go to state 259.
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ LP SELECT distinct selcollist FROM stl_prefix LP SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ LP SELECT distinct selcollist FROM stl_prefix LP SELECT distinct sclp scanpt ID]
parser: Input 'DOT' in state 416
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 77.
parser: ... then shift 'nm', go to state 491
parser: Shift 'DOT', go to state 205
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ LP SELECT distinct selcollist FROM stl_prefix LP SELECT distinct sclp scanpt nm DOT]
parser: Input 'ID' in state 205
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ LP SELECT distinct selcollist FROM stl_prefix LP SELECT distinct sclp scanpt nm DOT ID]
parser: Input 'CONCAT' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 205.
parser: ... then shift 'nm', go to state 534
parser: Reduce 165 [expr ::= nm DOT nm], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Shift 'CONCAT', go to state 113
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ LP SELECT distinct selcollist FROM stl_prefix LP SELECT distinct sclp scanpt expr CONCAT]
parser: Input 'ID' in state 113
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ LP SELECT distinct selcollist FROM stl_prefix LP SELECT distinct sclp scanpt expr CONCAT ID]
parser: Input 'DOT' in state 416
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 113.
parser: ... then shift 'nm', go to state 535
parser: Shift 'DOT', go to state 249
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ LP SELECT distinct selcollist FROM stl_prefix LP SELECT distinct sclp scanpt expr CONCAT nm DOT]
parser: Input 'ID' in state 249
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ LP SELECT distinct selcollist FROM stl_prefix LP SELECT distinct sclp scanpt expr CONCAT nm DOT ID]
parser: Input 'AS' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 249.
parser: ... then shift 'nm', go to state 534
parser: Reduce 165 [expr ::= nm DOT nm], go to state 113.
parser: ... then shift 'expr', go to state 146
parser: Reduce 186 [expr ::= expr CONCAT expr], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Shift 'AS', go to state 242
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ LP SELECT distinct selcollist FROM stl_prefix LP SELECT distinct sclp scanpt expr scanpt AS]
parser: Input 'ID' in state 242
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ LP SELECT distinct selcollist FROM stl_prefix LP SELECT distinct sclp scanpt expr scanpt AS ID]
parser: Input 'FROM' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 242.
parser: ... then shift 'nm', pending reduce 98
parser: Reduce 98 [as ::= AS nm], go to state 259.
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ LP SELECT distinct selcollist FROM stl_prefix LP SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ LP SELECT distinct selcollist FROM stl_prefix LP SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ID' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Shift 'ID', pending reduce 350
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ LP SELECT distinct selcollist FROM stl_prefix LP SELECT distinct selcollist FROM stl_prefix nm dbnm ID]
parser: Input 'JOIN_KW' with pending reduce 350
parser: Reduce 350 [as ::= ID|STRING], go to state 243.
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Shift 'JOIN_KW', go to state 208
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ LP SELECT distinct selcollist FROM stl_prefix LP SELECT distinct selcollist FROM seltablist JOIN_KW]
parser: Input 'JOIN' in state 208
parser: Shift 'JOIN', pending reduce 117
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ LP SELECT distinct selcollist FROM stl_prefix LP SELECT distinct selcollist FROM seltablist JOIN_KW JOIN]
parser: Input 'ID' with pending reduce 117
parser: Reduce 117 [joinop ::= JOIN_KW JOIN], go to state 263.
parser: ... then shift 'joinop', pending reduce 102
parser: Reduce 102 [stl_prefix ::= seltablist joinop], go to state 197.
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ LP SELECT distinct selcollist FROM stl_prefix LP SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ID' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Shift 'ID', pending reduce 350
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ LP SELECT distinct selcollist FROM stl_prefix LP SELECT distinct selcollist FROM stl_prefix nm dbnm ID]
parser: Input 'ON' with pending reduce 350
parser: Reduce 350 [as ::= ID|STRING], go to state 243.
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Shift 'ON', go to state 92
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ LP SELECT distinct selcollist FROM stl_prefix LP SELECT distinct selcollist FROM stl_prefix nm dbnm as indexed_opt ON]
parser: Input 'ID' in state 92
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ LP SELECT distinct selcollist FROM stl_prefix LP SELECT distinct selcollist FROM stl_prefix nm dbnm as indexed_opt ON ID]
parser: Input 'DOT' in state 416
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 92.
parser: ... then shift 'nm', go to state 535
parser: Shift 'DOT', go to state 249
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ LP SELECT distinct selcollist FROM stl_prefix LP SELECT distinct selcollist FROM stl_prefix nm dbnm as indexed_opt ON nm DOT]
parser: Input 'ID' in state 249
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ LP SELECT distinct selcollist FROM stl_prefix LP SELECT distinct selcollist FROM stl_prefix nm dbnm as indexed_opt ON nm DOT ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 249.
parser: ... then shift 'nm', go to state 534
parser: Reduce 165 [expr ::= nm DOT nm], go to state 92.
parser: ... then shift 'expr', go to state 62
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ LP SELECT distinct selcollist FROM stl_prefix LP SELECT distinct selcollist FROM stl_prefix nm dbnm as indexed_opt ON expr EQ]
parser: Input 'ID' in state 117
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ LP SELECT distinct selcollist FROM stl_prefix LP SELECT distinct selcollist FROM stl_prefix nm dbnm as indexed_opt ON expr EQ ID]
parser: Input 'DOT' in state 416
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 117.
parser: ... then shift 'nm', go to state 535
parser: Shift 'DOT', go to state 249
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ LP SELECT distinct selcollist FROM stl_prefix LP SELECT distinct selcollist FROM stl_prefix nm dbnm as indexed_opt ON expr EQ nm DOT]
parser: Input 'ID' in state 249
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ LP SELECT distinct selcollist FROM stl_prefix LP SELECT distinct selcollist FROM stl_prefix nm dbnm as indexed_opt ON expr EQ nm DOT ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 249.
parser: ... then shift 'nm', go to state 534
parser: Reduce 165 [expr ::= nm DOT nm], go to state 117.
parser: ... then shift 'expr', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 92.
parser: ... then shift 'expr', go to state 62
parser: Reduce 120 [on_opt ::= ON expr], go to state 348.
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ LP SELECT distinct selcollist FROM stl_prefix LP SELECT distinct selcollist from WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ LP SELECT distinct selcollist FROM stl_prefix LP SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ LP SELECT distinct selcollist FROM stl_prefix LP SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'ID' in state 117
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ LP SELECT distinct selcollist FROM stl_prefix LP SELECT distinct selcollist from WHERE expr EQ ID]
parser: Input 'LIMIT' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 117.
parser: ... then shift 'expr', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Shift 'LIMIT', go to state 122
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ LP SELECT distinct selcollist FROM stl_prefix LP SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt LIMIT]
parser: Input 'INTEGER' in state 122
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ LP SELECT distinct selcollist FROM stl_prefix LP SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt LIMIT INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 122.
parser: ... then shift 'term', go to state 43
parser: Reduce 139 [limit_opt ::= LIMIT expr], go to state 357.
parser: ... then shift 'limit_opt', pending reduce 87
parser: Red
Program received signal SIGABRT, Aborted.
__GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:50
(gdb) #0  __GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:50
#1  0x00007f63e1c71859 in __GI_abort () at abort.c:79
#2  0x00007f63e1c71729 in __assert_fail_base (fmt=0x7f63e1e07588 "%s%s%s:%u: %s%sAssertion `%s' failed.\n%n", assertion=0x21b92e "pItem->addrFillSub==0", file=0x22873d "sqlite3.c", line=130468, function=<optimized out>)
    at assert.c:92
#3  0x00007f63e1c82fd6 in __GI___assert_fail (assertion=0x21b92e "pItem->addrFillSub==0", file=0x22873d "sqlite3.c", line=130468, function=0x223e82 "int sqlite3Select(Parse *, Select *, SelectDest *)") at assert.c:101
#4  0x00000000002fcfa0 in sqlite3Select (pParse=0x7ffd384dfd10, p=0x1c4ffb0, pDest=0x7ffd384de5a8) at sqlite3.c:130468
#5  0x000000000034f659 in sqlite3CodeSubselect (pParse=0x7ffd384dfd10, pExpr=0x1c4fb00) at sqlite3.c:99820
#6  0x000000000034bbfd in sqlite3ExprCodeTarget (pParse=0x7ffd384dfd10, pExpr=0x1c4fb00, target=7) at sqlite3.c:100770
#7  0x00000000003790ab in codeEqualityTerm (pParse=0x7ffd384dfd10, pTerm=0x1c49470, pLevel=0x1c497d0, iEq=1, bRev=0, iTarget=7) at sqlite3.c:136648
#8  0x000000000037a706 in codeAllEqualityTerms (pParse=0x7ffd384dfd10, pLevel=0x1c497d0, bRev=0, nExtraReg=0, pzAff=0x7ffd384deb28) at sqlite3.c:136869
#9  0x0000000000375cb8 in sqlite3WhereCodeOneLoopStart (pParse=0x7ffd384dfd10, v=0x1c4ecf0, pWInfo=0x1c493e0, iLevel=1, pLevel=0x1c497d0, notReady=18446744073709551614) at sqlite3.c:137776
#10 0x000000000036c3cc in sqlite3WhereBegin (pParse=0x7ffd384dfd10, pTabList=0x1c57e40, pWhere=0x1c4f650, pOrderBy=0x0, pResultSet=0x1c54150, wctrlFlags=0, iAuxArg=320) at sqlite3.c:145128
#11 0x00000000002fdcea in sqlite3Select (pParse=0x7ffd384dfd10, p=0x1c4f1a0, pDest=0x7ffd384df100) at sqlite3.c:130695
#12 0x00000000002ecaa8 in yy_reduce (yypParser=0x7ffd384df330, yyruleno=79, yyLookahead=1, yyLookaheadToken=..., pParse=0x7ffd384dfd10) at sqlite3.c:151581
#13 0x00000000002e92f8 in sqlite3Parser (yyp=0x7ffd384df330, yymajor=1, yyminor=...) at sqlite3.c:152877
#14 0x00000000002a68b3 in sqlite3RunParser (pParse=0x7ffd384dfd10, 
    zSql=0x1c8461f ";;\nINSERT INTO t1(x) VALUES(10);;\nSELECT * FROM block;;\nSELECT x IS x FROM t1;;\nSELECT x+x FROM t1;;\nSELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='block' AND type!='trigger' ORD"..., pzErrMsg=0x7ffd384dfef0) at sqlite3.c:154013
#15 0x00000000002a1683 in sqlite3Prepare (db=0x1c412b0, 
    zSql=0x1c44bab ";\nSELECT\n    SrcWord, t1.x\n    FROM \n      (SELECT 'FACTORING' AS SrcWord UNION SELECT 'SWIMMING' AS SrcWord )\n    LEFT JOIN \n      t1\n    WHERE t1.x= (\n      SELECT BeginningId FROM (\n        SELECT "..., nBytes=1911, prepFlags=128, pReprepare=0x0, ppStmt=0x7ffd384e0028, pzTail=0x7ffd384e0010) at sqlite3.c:124303
#16 0x00000000002a0d4e in sqlite3LockAndPrepare (db=0x1c412b0, 
    zSql=0x1c44bab ";\nSELECT\n    SrcWord, t1.x\n    FROM \n      (SELECT 'FACTORING' AS SrcWord UNION SELECT 'SWIMMING' AS SrcWord )\n    LEFT JOIN \n      t1\n    WHERE t1.x= (\n      SELECT BeginningId FROM (\n        SELECT "..., nBytes=1911, prepFlags=128, pOld=0x0, ppStmt=0x7ffd384e0028, pzTail=0x7ffd384e0010) at sqlite3.c:124403
#17 0x000000000029247f in sqlite3_prepare_v2 (db=0x1c412b0, 
    zSql=0x1c44bab ";\nSELECT\n    SrcWord, t1.x\n    FROM \n      (SELECT 'FACTORING' AS SrcWord UNION SELECT 'SWIMMING' AS SrcWord )\n    LEFT JOIN \n      t1\n    WHERE t1.x= (\n      SELECT BeginningId FROM (\n        SELECT "..., nBytes=1911, ppStmt=0x7ffd384e0028, pzTail=0x7ffd384e0010) at sqlite3.c:124487
#18 0x0000000000256bd0 in main (argc=1, argv=0x7ffd384e01d8) at target.cc:106
(gdb) quit
A debugging session is active.

	Inferior 1 [process 4862] will be killed.

Quit anyway? (y or n) [answered Y; input not from terminal]
