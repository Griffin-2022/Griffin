GNU gdb (Ubuntu 9.2-0ubuntu1~20.04.1) 9.2
Copyright (C) 2020 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type "show copying" and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
    <http://www.gnu.org/software/gdb/documentation/>.

For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from /root/sqlite_driver_fast...
(gdb) Starting program: /root/sqlite_driver_fast < "/root/out/default/crashes/id:000124,sig:06,src:020521+019314,time:39829374,execs:8928091,op:merge.so,pos:0"
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
parser: [[[;
INSERT INTO t1 VALUES(4, '123.e+2');SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='tbl1' AND type!='trigger' ORDER BY rowid;;
INSERT INTO t1 VALUES(16, '  123e4');;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;;
SELECT
    SrcWord, t1.c0content
    FROM 
      (SELECT 'FACTORING' AS SrcWord UNION SELECT 'SWIMMING' AS SrcWord )
    LEFT JOIN 
      t1
    WHERE t1.x= (
      SELECT BeginningId FROM (
        SELECT SrcWord, B.x as BeginningId, B.c0content || E.c0content As Connected
        FROM t1 B LEFT JOIN t1 E ON B.x=E.x
        WHERE Connected=SrcWord LIMIT 1
      )
    )
;;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE name='t1' AND type='table' ORDER BY rowid;;
SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;;
 ;
PRAGMA temp_store_directory='';;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;;
SELECT docid, docid FROM t1 WHERE docid = 4 AND docid IN (2, 4, 5) ORDER BY docid DESC, docid DESC;;

INSERT INTO sqlite_stat1
vALUES('t1','t4all','600000 16000M 40000 10000 200 600 1P0 40 10');;

CREATE VIRTUAL TABLE blockid USING fts4(tokenize=unicode61 "separators=aB");;

CREATE VIRTUAL TABLE c0a USING fts4(tokenize=unicode61 "separators=aB");;
SELECT docid, docid FROM t1 WHERE docid = 4 AND docid IN (2, 4, 5) ORDER BY docid DESC, docid DESC;;
CREATE INDEX t0o ON t1(c0content ASC,  c0content ASC) ;;
SELECT a, a FROM blockid WHERE a = 4 AND a IN (2, 4, 5) ORDER BY a DESC, a DESC;;
CREATE TABLE c0o00(c1t0o);;
;
;
PRAGMA temp_store_directory='';SELECT t0 FROM blockid WHERE t0 IN (SELECT a FROM blockid) ORDER BY t0 ASC;SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;SELECT x FROM t1 WHERE x IN (SELECT leaves_end_block FROM block) ORDER BY x DESC;SELECT * FROM c0o00 WHMRE;CREATE TRIGGER t2 AFTER INSERT ON blockid BEGIN
    SELECT * FROM blockid WHERE abc.idx = 1;
  END;;
 ;
PRAGMA temp_store_directory='';CREATE TABLE t3(t4);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='c0o00' AND type!='trigger' ORDER BY rowid;END;;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='blockid' AND type!='trigger' ORDER BY rowid;CREATE TABLE 'main'.'t5'(t6 INTEGER PRIMARY KEY, 't7');;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='blockid' AND type!='trigger' ORDER BY rowid;;
SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='c0o00' AND type!='trigger' ORDER BY rowid;;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE name='t3' AND type='table' ORDER BY rowid;;
PRAGMA temp_store_directory='';]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'INSERT' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'INSERT', go to state 311
parser: Return. Stack=[ecmd with INSERT]
parser: Input 'INTO' in state 311
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', pending reduce 156
parser: Reduce 156 [insert_cmd ::= INSERT orconf], go to state 219.
parser: ... then shift 'insert_cmd', go to state 427
parser: Shift 'INTO', go to state 164
parser: Return. Stack=[ecmd with insert_cmd INTO]
parser: Input 'ID' in state 164
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd with insert_cmd INTO ID]
parser: Input 'VALUES' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 164.
parser: ... then shift 'nm', go to state 393
parser: Reduce 112 [xfullname ::= nm], go to state 164.
parser: ... then shift 'xfullname', go to state 298
parser: Reduce 158 [idlist_opt ::=].
parser: ... then shift 'idlist_opt', go to state 35
parser: Shift 'VALUES', go to state 526
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES]
parser: Input 'LP' in state 526
parser: Shift 'LP', go to state 28
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP]
parser: Input 'INTEGER' in state 28
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 28.
parser: ... then shift 'term', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'STRING' in state 107
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA STRING]
parser: Input 'RP' in state 537
parser: Reduce 168 [term ::= STRING], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'RP', pending reduce 89
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist RP]
parser: Input 'SEMI' with pending reduce 89
parser: Reduce 89 [values ::= VALUES LP nexprlist RP], go to state 35.
parser: ... then shift 'values', go to state 532
parser: Reduce 348 [oneselect ::= values], go to state 35.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 35.
parser: ... then shift 'select', go to state 297
parser: Reduce 152 [upsert ::=].
parser: ... then shift 'upsert', pending reduce 150
parser: Reduce 150 [cmd ::= with insert_cmd INTO xfullname idlist_opt select upsert], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
parser: [[[SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='tbl1' AND type!='trigger' ORDER BY rowid;;
INSERT INTO t1 VALUES(16, '  123e4');;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;;
SELECT
    SrcWord, t1.c0content
    FROM 
      (SELECT 'FACTORING' AS SrcWord UNION SELECT 'SWIMMING' AS SrcWord )
    LEFT JOIN 
      t1
    WHERE t1.x= (
      SELECT BeginningId FROM (
        SELECT SrcWord, B.x as BeginningId, B.c0content || E.c0content As Connected
        FROM t1 B LEFT JOIN t1 E ON B.x=E.x
        WHERE Connected=SrcWord LIMIT 1
      )
    )
;;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE name='t1' AND type='table' ORDER BY rowid;;
SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;;
 ;
PRAGMA temp_store_directory='';;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;;
SELECT docid, docid FROM t1 WHERE docid = 4 AND docid IN (2, 4, 5) ORDER BY docid DESC, docid DESC;;

INSERT INTO sqlite_stat1
vALUES('t1','t4all','600000 16000M 40000 10000 200 600 1P0 40 10');;

CREATE VIRTUAL TABLE blockid USING fts4(tokenize=unicode61 "separators=aB");;

CREATE VIRTUAL TABLE c0a USING fts4(tokenize=unicode61 "separators=aB");;
SELECT docid, docid FROM t1 WHERE docid = 4 AND docid IN (2, 4, 5) ORDER BY docid DESC, docid DESC;;
CREATE INDEX t0o ON t1(c0content ASC,  c0content ASC) ;;
SELECT a, a FROM blockid WHERE a = 4 AND a IN (2, 4, 5) ORDER BY a DESC, a DESC;;
CREATE TABLE c0o00(c1t0o);;
;
;
PRAGMA temp_store_directory='';SELECT t0 FROM blockid WHERE t0 IN (SELECT a FROM blockid) ORDER BY t0 ASC;SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;SELECT x FROM t1 WHERE x IN (SELECT leaves_end_block FROM block) ORDER BY x DESC;SELECT * FROM c0o00 WHMRE;CREATE TRIGGER t2 AFTER INSERT ON blockid BEGIN
    SELECT * FROM blockid WHERE abc.idx = 1;
  END;;
 ;
PRAGMA temp_store_directory='';CREATE TABLE t3(t4);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='c0o00' AND type!='trigger' ORDER BY rowid;END;;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='blockid' AND type!='trigger' ORDER BY rowid;CREATE TABLE 'main'.'t5'(t6 INTEGER PRIMARY KEY, 't7');;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='blockid' AND type!='trigger' ORDER BY rowid;;
SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='c0o00' AND type!='trigger' ORDER BY rowid;;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE name='t3' AND type='table' ORDER BY rowid;;
PRAGMA temp_store_directory='';]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'FROM' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'STRING' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'STRING', pending reduce 332
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix STRING]
parser: Input 'DOT' with pending reduce 332
parser: Reduce 332 [nm ::= STRING], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Shift 'DOT', go to state 245
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID' in state 245
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 245.
parser: ... then shift 'nm', pending reduce 109
parser: Reduce 109 [dbnm ::= DOT nm], go to state 349.
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[SELECT distinct selcollist from WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND' in state 537
parser: Reduce 168 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'AND', go to state 120
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID' in state 120
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'NE' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Shift 'NE', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr NE]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr NE STRING]
parser: Input 'ORDER' in state 537
parser: Reduce 168 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Reduce 179 [expr ::= expr AND expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[;
INSERT INTO t1 VALUES(16, '  123e4');;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;;
SELECT
    SrcWord, t1.c0content
    FROM 
      (SELECT 'FACTORING' AS SrcWord UNION SELECT 'SWIMMING' AS SrcWord )
    LEFT JOIN 
      t1
    WHERE t1.x= (
      SELECT BeginningId FROM (
        SELECT SrcWord, B.x as BeginningId, B.c0content || E.c0content As Connected
        FROM t1 B LEFT JOIN t1 E ON B.x=E.x
        WHERE Connected=SrcWord LIMIT 1
      )
    )
;;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE name='t1' AND type='table' ORDER BY rowid;;
SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;;
 ;
PRAGMA temp_store_directory='';;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;;
SELECT docid, docid FROM t1 WHERE docid = 4 AND docid IN (2, 4, 5) ORDER BY docid DESC, docid DESC;;

INSERT INTO sqlite_stat1
vALUES('t1','t4all','600000 16000M 40000 10000 200 600 1P0 40 10');;

CREATE VIRTUAL TABLE blockid USING fts4(tokenize=unicode61 "separators=aB");;

CREATE VIRTUAL TABLE c0a USING fts4(tokenize=unicode61 "separators=aB");;
SELECT docid, docid FROM t1 WHERE docid = 4 AND docid IN (2, 4, 5) ORDER BY docid DESC, docid DESC;;
CREATE INDEX t0o ON t1(c0content ASC,  c0content ASC) ;;
SELECT a, a FROM blockid WHERE a = 4 AND a IN (2, 4, 5) ORDER BY a DESC, a DESC;;
CREATE TABLE c0o00(c1t0o);;
;
;
PRAGMA temp_store_directory='';SELECT t0 FROM blockid WHERE t0 IN (SELECT a FROM blockid) ORDER BY t0 ASC;SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;SELECT x FROM t1 WHERE x IN (SELECT leaves_end_block FROM block) ORDER BY x DESC;SELECT * FROM c0o00 WHMRE;CREATE TRIGGER t2 AFTER INSERT ON blockid BEGIN
    SELECT * FROM blockid WHERE abc.idx = 1;
  END;;
 ;
PRAGMA temp_store_directory='';CREATE TABLE t3(t4);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='c0o00' AND type!='trigger' ORDER BY rowid;END;;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='blockid' AND type!='trigger' ORDER BY rowid;CREATE TABLE 'main'.'t5'(t6 INTEGER PRIMARY KEY, 't7');;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='blockid' AND type!='trigger' ORDER BY rowid;;
SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='c0o00' AND type!='trigger' ORDER BY rowid;;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE name='t3' AND type='table' ORDER BY rowid;;
PRAGMA temp_store_directory='';]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'INSERT' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'INSERT', go to state 311
parser: Return. Stack=[ecmd with INSERT]
parser: Input 'INTO' in state 311
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', pending reduce 156
parser: Reduce 156 [insert_cmd ::= INSERT orconf], go to state 219.
parser: ... then shift 'insert_cmd', go to state 427
parser: Shift 'INTO', go to state 164
parser: Return. Stack=[ecmd with insert_cmd INTO]
parser: Input 'ID' in state 164
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd with insert_cmd INTO ID]
parser: Input 'VALUES' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 164.
parser: ... then shift 'nm', go to state 393
parser: Reduce 112 [xfullname ::= nm], go to state 164.
parser: ... then shift 'xfullname', go to state 298
parser: Reduce 158 [idlist_opt ::=].
parser: ... then shift 'idlist_opt', go to state 35
parser: Shift 'VALUES', go to state 526
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES]
parser: Input 'LP' in state 526
parser: Shift 'LP', go to state 28
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP]
parser: Input 'INTEGER' in state 28
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 28.
parser: ... then shift 'term', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'STRING' in state 107
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA STRING]
parser: Input 'RP' in state 537
parser: Reduce 168 [term ::= STRING], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'RP', pending reduce 89
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist RP]
parser: Input 'SEMI' with pending reduce 89
parser: Reduce 89 [values ::= VALUES LP nexprlist RP], go to state 35.
parser: ... then shift 'values', go to state 532
parser: Reduce 348 [oneselect ::= values], go to state 35.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 35.
parser: ... then shift 'select', go to state 297
parser: Reduce 152 [upsert ::=].
parser: ... then shift 'upsert', pending reduce 150
parser: Reduce 150 [cmd ::= with insert_cmd INTO xfullname idlist_opt select upsert], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
parser: [[[;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;;
SELECT
    SrcWord, t1.c0content
    FROM 
      (SELECT 'FACTORING' AS SrcWord UNION SELECT 'SWIMMING' AS SrcWord )
    LEFT JOIN 
      t1
    WHERE t1.x= (
      SELECT BeginningId FROM (
        SELECT SrcWord, B.x as BeginningId, B.c0content || E.c0content As Connected
        FROM t1 B LEFT JOIN t1 E ON B.x=E.x
        WHERE Connected=SrcWord LIMIT 1
      )
    )
;;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE name='t1' AND type='table' ORDER BY rowid;;
SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;;
 ;
PRAGMA temp_store_directory='';;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;;
SELECT docid, docid FROM t1 WHERE docid = 4 AND docid IN (2, 4, 5) ORDER BY docid DESC, docid DESC;;

INSERT INTO sqlite_stat1
vALUES('t1','t4all','600000 16000M 40000 10000 200 600 1P0 40 10');;

CREATE VIRTUAL TABLE blockid USING fts4(tokenize=unicode61 "separators=aB");;

CREATE VIRTUAL TABLE c0a USING fts4(tokenize=unicode61 "separators=aB");;
SELECT docid, docid FROM t1 WHERE docid = 4 AND docid IN (2, 4, 5) ORDER BY docid DESC, docid DESC;;
CREATE INDEX t0o ON t1(c0content ASC,  c0content ASC) ;;
SELECT a, a FROM blockid WHERE a = 4 AND a IN (2, 4, 5) ORDER BY a DESC, a DESC;;
CREATE TABLE c0o00(c1t0o);;
;
;
PRAGMA temp_store_directory='';SELECT t0 FROM blockid WHERE t0 IN (SELECT a FROM blockid) ORDER BY t0 ASC;SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;SELECT x FROM t1 WHERE x IN (SELECT leaves_end_block FROM block) ORDER BY x DESC;SELECT * FROM c0o00 WHMRE;CREATE TRIGGER t2 AFTER INSERT ON blockid BEGIN
    SELECT * FROM blockid WHERE abc.idx = 1;
  END;;
 ;
PRAGMA temp_store_directory='';CREATE TABLE t3(t4);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='c0o00' AND type!='trigger' ORDER BY rowid;END;;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='blockid' AND type!='trigger' ORDER BY rowid;CREATE TABLE 'main'.'t5'(t6 INTEGER PRIMARY KEY, 't7');;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='blockid' AND type!='trigger' ORDER BY rowid;;
SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='c0o00' AND type!='trigger' ORDER BY rowid;;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE name='t3' AND type='table' ORDER BY rowid;;
PRAGMA temp_store_directory='';]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'SELECT' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[ecmd SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[ecmd SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[ecmd SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt ID]
parser: Input 'FROM' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[ecmd SELECT distinct selcollist FROM]
parser: Input 'STRING' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'STRING', pending reduce 332
parser: Return. Stack=[ecmd SELECT distinct selcollist FROM stl_prefix STRING]
parser: Input 'DOT' with pending reduce 332
parser: Reduce 332 [nm ::= STRING], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Shift 'DOT', go to state 245
parser: Return. Stack=[ecmd SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID' in state 245
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 245.
parser: ... then shift 'nm', pending reduce 109
parser: Reduce 109 [dbnm ::= DOT nm], go to state 349.
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND' in state 537
parser: Reduce 168 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'AND', go to state 120
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID' in state 120
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'NE' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Shift 'NE', go to state 117
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr AND expr NE]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr AND expr NE STRING]
parser: Input 'ORDER' in state 537
parser: Reduce 168 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Reduce 179 [expr ::= expr AND expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[ecmd SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[ecmd SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 1.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 1.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
parser: [[[SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;;
SELECT
    SrcWord, t1.c0content
    FROM 
      (SELECT 'FACTORING' AS SrcWord UNION SELECT 'SWIMMING' AS SrcWord )
    LEFT JOIN 
      t1
    WHERE t1.x= (
      SELECT BeginningId FROM (
        SELECT SrcWord, B.x as BeginningId, B.c0content || E.c0content As Connected
        FROM t1 B LEFT JOIN t1 E ON B.x=E.x
        WHERE Connected=SrcWord LIMIT 1
      )
    )
;;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE name='t1' AND type='table' ORDER BY rowid;;
SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;;
 ;
PRAGMA temp_store_directory='';;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;;
SELECT docid, docid FROM t1 WHERE docid = 4 AND docid IN (2, 4, 5) ORDER BY docid DESC, docid DESC;;

INSERT INTO sqlite_stat1
vALUES('t1','t4all','600000 16000M 40000 10000 200 600 1P0 40 10');;

CREATE VIRTUAL TABLE blockid USING fts4(tokenize=unicode61 "separators=aB");;

CREATE VIRTUAL TABLE c0a USING fts4(tokenize=unicode61 "separators=aB");;
SELECT docid, docid FROM t1 WHERE docid = 4 AND docid IN (2, 4, 5) ORDER BY docid DESC, docid DESC;;
CREATE INDEX t0o ON t1(c0content ASC,  c0content ASC) ;;
SELECT a, a FROM blockid WHERE a = 4 AND a IN (2, 4, 5) ORDER BY a DESC, a DESC;;
CREATE TABLE c0o00(c1t0o);;
;
;
PRAGMA temp_store_directory='';SELECT t0 FROM blockid WHERE t0 IN (SELECT a FROM blockid) ORDER BY t0 ASC;SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;SELECT x FROM t1 WHERE x IN (SELECT leaves_end_block FROM block) ORDER BY x DESC;SELECT * FROM c0o00 WHMRE;CREATE TRIGGER t2 AFTER INSERT ON blockid BEGIN
    SELECT * FROM blockid WHERE abc.idx = 1;
  END;;
 ;
PRAGMA temp_store_directory='';CREATE TABLE t3(t4);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='c0o00' AND type!='trigger' ORDER BY rowid;END;;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='blockid' AND type!='trigger' ORDER BY rowid;CREATE TABLE 'main'.'t5'(t6 INTEGER PRIMARY KEY, 't7');;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='blockid' AND type!='trigger' ORDER BY rowid;;
SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='c0o00' AND type!='trigger' ORDER BY rowid;;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE name='t3' AND type='table' ORDER BY rowid;;
PRAGMA temp_store_directory='';]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'FROM' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'STRING' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'STRING', pending reduce 332
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix STRING]
parser: Input 'DOT' with pending reduce 332
parser: Reduce 332 [nm ::= STRING], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Shift 'DOT', go to state 245
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID' in state 245
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 245.
parser: ... then shift 'nm', pending reduce 109
parser: Reduce 109 [dbnm ::= DOT nm], go to state 349.
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[SELECT distinct selcollist from WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND' in state 537
parser: Reduce 168 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'AND', go to state 120
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID' in state 120
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'NE' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Shift 'NE', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr NE]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr NE STRING]
parser: Input 'ORDER' in state 537
parser: Reduce 168 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Reduce 179 [expr ::= expr AND expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[;
SELECT
    SrcWord, t1.c0content
    FROM 
      (SELECT 'FACTORING' AS SrcWord UNION SELECT 'SWIMMING' AS SrcWord )
    LEFT JOIN 
      t1
    WHERE t1.x= (
      SELECT BeginningId FROM (
        SELECT SrcWord, B.x as BeginningId, B.c0content || E.c0content As Connected
        FROM t1 B LEFT JOIN t1 E ON B.x=E.x
        WHERE Connected=SrcWord LIMIT 1
      )
    )
;;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE name='t1' AND type='table' ORDER BY rowid;;
SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;;
 ;
PRAGMA temp_store_directory='';;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;;
SELECT docid, docid FROM t1 WHERE docid = 4 AND docid IN (2, 4, 5) ORDER BY docid DESC, docid DESC;;

INSERT INTO sqlite_stat1
vALUES('t1','t4all','600000 16000M 40000 10000 200 600 1P0 40 10');;

CREATE VIRTUAL TABLE blockid USING fts4(tokenize=unicode61 "separators=aB");;

CREATE VIRTUAL TABLE c0a USING fts4(tokenize=unicode61 "separators=aB");;
SELECT docid, docid FROM t1 WHERE docid = 4 AND docid IN (2, 4, 5) ORDER BY docid DESC, docid DESC;;
CREATE INDEX t0o ON t1(c0content ASC,  c0content ASC) ;;
SELECT a, a FROM blockid WHERE a = 4 AND a IN (2, 4, 5) ORDER BY a DESC, a DESC;;
CREATE TABLE c0o00(c1t0o);;
;
;
PRAGMA temp_store_directory='';SELECT t0 FROM blockid WHERE t0 IN (SELECT a FROM blockid) ORDER BY t0 ASC;SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;SELECT x FROM t1 WHERE x IN (SELECT leaves_end_block FROM block) ORDER BY x DESC;SELECT * FROM c0o00 WHMRE;CREATE TRIGGER t2 AFTER INSERT ON blockid BEGIN
    SELECT * FROM blockid WHERE abc.idx = 1;
  END;;
 ;
PRAGMA temp_store_directory='';CREATE TABLE t3(t4);;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='c0o00' AND type!='trigger' ORDER BY rowid;END;;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='blockid' AND type!='trigger' ORDER BY rowid;CREATE TABLE 'main'.'t5'(t6 INTEGER PRIMARY KEY, 't7');;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='blockid' AND type!='trigger' ORDER BY rowid;;
SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='c0o00' AND type!='trigger' ORDER BY rowid;;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE name='t3' AND type='table' ORDER BY rowid;;
PRAGMA temp_store_directory='';]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'SELECT' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[ecmd SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[ecmd SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt ID]
parser: Input 'DOT' in state 416
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 77.
parser: ... then shift 'nm', go to state 491
parser: Shift 'DOT', go to state 205
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt nm DOT]
parser: Input 'ID' in state 205
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt nm DOT ID]
parser: Input 'FROM' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 205.
parser: ... then shift 'nm', go to state 534
parser: Reduce 165 [expr ::= nm DOT nm], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[ecmd SELECT distinct selcollist FROM]
parser: Input 'LP' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'LP', go to state 5
parser: Return. Stack=[ecmd SELECT distinct selcollist FROM stl_prefix LP]
parser: Input 'SELECT' in state 5
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[ecmd SELECT distinct selcollist FROM stl_prefix LP SELECT]
parser: Input 'STRING' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[ecmd SELECT distinct selcollist FROM stl_prefix LP SELECT distinct sclp scanpt STRING]
parser: Input 'AS' in state 537
parser: Reduce 168 [term ::= STRING], go to state 77.
parser: ... then shift 'term', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Shift 'AS', go to state 242
parser: Return. Stack=[ecmd SELECT distinct selcollist FROM stl_prefix LP SELECT distinct sclp scanpt term scanpt AS]
parser: Input 'ID' in state 242
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd SELECT distinct selcollist FROM stl_prefix LP SELECT distinct sclp scanpt term scanpt AS ID]
parser: Input 'UNION' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 242.
parser: ... then shift 'nm', pending reduce 98
parser: Reduce 98 [as ::= AS nm], go to state 259.
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Reduce 100 [from ::=].
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 5.
parser: ... then shift 'oneselect', go to state 264
parser: Shift 'UNION', go to state 533
parser: Return. Stack=[ecmd SELECT distinct selcollist FROM stl_prefix LP oneselect UNION]
parser: Input 'SELECT' in state 533
parser: Reduce 84 [multiselect_op ::= UNION], go to state 264.
parser: ... then shift 'multiselect_op', go to state 195
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[ecmd SELECT distinct selcollist FROM stl_prefix LP oneselect multiselect_op SELECT]
parser: Input 'STRING' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[ecmd SELECT distinct selcollist FROM stl_prefix LP oneselect multiselect_op SELECT distinct sclp scanpt STRING]
parser: Input 'AS' in state 537
parser: Reduce 168 [term ::= STRING], go to state 77.
parser: ... then shift 'term', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Shift 'AS', go to state 242
parser: Return. Stack=[ecmd SELECT distinct selcollist FROM stl_prefix LP oneselect multiselect_op SELECT distinct sclp scanpt term scanpt AS]
parser: Input 'ID' in state 242
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd SELECT distinct selcollist FROM stl_prefix LP oneselect multiselect_op SELECT distinct sclp scanpt term scanpt AS ID]
parser: Input 'RP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 242.
parser: ... then shift 'nm', pending reduce 98
parser: Reduce 98 [as ::= AS nm], go to state 259.
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Reduce 100 [from ::=].
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 195.
parser: ... then shift 'oneselect', pending reduce 83
parser: Reduce 83 [selectnowith ::= selectnowith multiselect_op oneselect], go to state 5.
parser: ... then shift 'selectnowith', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 5.
parser: ... then shift 'select', go to state 492
parser: Shift 'RP', go to state 260
parser: Return. Stack=[ecmd SELECT distinct selcollist FROM stl_prefix LP select RP]
parser: Input 'JOIN_KW' in state 260
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 342
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 341
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 106
parser: Reduce 106 [seltablist ::= stl_prefix LP select RP as on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Shift 'JOIN_KW', go to state 208
parser: Return. Stack=[ecmd SELECT distinct selcollist FROM seltablist JOIN_KW]
parser: Input 'JOIN' in state 208
parser: Shift 'JOIN', pending reduce 117
parser: Return. Stack=[ecmd SELECT distinct selcollist FROM seltablist JOIN_KW JOIN]
parser: Input 'ID' with pending reduce 117
parser: Reduce 117 [joinop ::= JOIN_KW JOIN], go to state 263.
parser: ... then shift 'joinop', pending reduce 102
parser: Reduce 102 [stl_prefix ::= seltablist joinop], go to state 197.
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE ID]
parser: Input 'DOT' in state 416
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 93.
parser: ... then shift 'nm', go to state 535
parser: Shift 'DOT', go to state 249
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE nm DOT]
parser: Input 'ID' in state 249
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE nm DOT ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 249.
parser: ... then shift 'nm', go to state 534
parser: Reduce 165 [expr ::= nm DOT nm], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'LP' in state 117
parser: Shift 'LP', go to state 4
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ LP]
parser: Input 'SELECT' in state 4
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ LP SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ LP SELECT distinct sclp scanpt ID]
parser: Input 'FROM' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ LP SELECT distinct selcollist FROM]
parser: Input 'LP' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'LP', go to state 5
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ LP SELECT distinct selcollist FROM stl_prefix LP]
parser: Input 'SELECT' in state 5
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ LP SELECT distinct selcollist FROM stl_prefix LP SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ LP SELECT distinct selcollist FROM stl_prefix LP SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ LP SELECT distinct selcollist FROM stl_prefix LP SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ LP SELECT distinct selcollist FROM stl_prefix LP SELECT distinct sclp scanpt ID]
parser: Input 'DOT' in state 416
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 77.
parser: ... then shift 'nm', go to state 491
parser: Shift 'DOT', go to state 205
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ LP SELECT distinct selcollist FROM stl_prefix LP SELECT distinct sclp scanpt nm DOT]
parser: Input 'ID' in state 205
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ LP SELECT distinct selcollist FROM stl_prefix LP SELECT distinct sclp scanpt nm DOT ID]
parser: Input 'AS' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 205.
parser: ... then shift 'nm', go to state 534
parser: Reduce 165 [expr ::= nm DOT nm], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Shift 'AS', go to state 242
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ LP SELECT distinct selcollist FROM stl_prefix LP SELECT distinct sclp scanpt expr scanpt AS]
parser: Input 'ID' in state 242
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ LP SELECT distinct selcollist FROM stl_prefix LP SELECT distinct sclp scanpt expr scanpt AS ID]
parser: Input 'COMMA' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 242.
parser: ... then shift 'nm', pending reduce 98
parser: Reduce 98 [as ::= AS nm], go to state 259.
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ LP SELECT distinct selcollist FROM stl_prefix LP SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ LP SELECT distinct selcollist FROM stl_prefix LP SELECT distinct sclp scanpt ID]
parser: Input 'DOT' in state 416
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 77.
parser: ... then shift 'nm', go to state 491
parser: Shift 'DOT', go to state 205
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ LP SELECT distinct selcollist FROM stl_prefix LP SELECT distinct sclp scanpt nm DOT]
parser: Input 'ID' in state 205
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ LP SELECT distinct selcollist FROM stl_prefix LP SELECT distinct sclp scanpt nm DOT ID]
parser: Input 'CONCAT' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 205.
parser: ... then shift 'nm', go to state 534
parser: Reduce 165 [expr ::= nm DOT nm], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Shift 'CONCAT', go to state 113
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ LP SELECT distinct selcollist FROM stl_prefix LP SELECT distinct sclp scanpt expr CONCAT]
parser: Input 'ID' in state 113
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ LP SELECT distinct selcollist FROM stl_prefix LP SELECT distinct sclp scanpt expr CONCAT ID]
parser: Input 'DOT' in state 416
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 113.
parser: ... then shift 'nm', go to state 535
parser: Shift 'DOT', go to state 249
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ LP SELECT distinct selcollist FROM stl_prefix LP SELECT distinct sclp scanpt expr CONCAT nm DOT]
parser: Input 'ID' in state 249
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ LP SELECT distinct selcollist FROM stl_prefix LP SELECT distinct sclp scanpt expr CONCAT nm DOT ID]
parser: Input 'AS' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 249.
parser: ... then shift 'nm', go to state 534
parser: Reduce 165 [expr ::= nm DOT nm], go to state 113.
parser: ... then shift 'expr', go to state 146
parser: Reduce 186 [expr ::= expr CONCAT expr], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Shift 'AS', go to state 242
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ LP SELECT distinct selcollist FROM stl_prefix LP SELECT distinct sclp scanpt expr scanpt AS]
parser: Input 'ID' in state 242
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ LP SELECT distinct selcollist FROM stl_prefix LP SELECT distinct sclp scanpt expr scanpt AS ID]
parser: Input 'FROM' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 242.
parser: ... then shift 'nm', pending reduce 98
parser: Reduce 98 [as ::= AS nm], go to state 259.
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ LP SELECT distinct selcollist FROM stl_prefix LP SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ LP SELECT distinct selcollist FROM stl_prefix LP SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ID' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Shift 'ID', pending reduce 350
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ LP SELECT distinct selcollist FROM stl_prefix LP SELECT distinct selcollist FROM stl_prefix nm dbnm ID]
parser: Input 'JOIN_KW' with pending reduce 350
parser: Reduce 350 [as ::= ID|STRING], go to state 243.
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Shift 'JOIN_KW', go to state 208
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ LP SELECT distinct selcollist FROM stl_prefix LP SELECT distinct selcollist FROM seltablist JOIN_KW]
parser: Input 'JOIN' in state 208
parser: Shift 'JOIN', pending reduce 117
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ LP SELECT distinct selcollist FROM stl_prefix LP SELECT distinct selcollist FROM seltablist JOIN_KW JOIN]
parser: Input 'ID' with pending reduce 117
parser: Reduce 117 [joinop ::= JOIN_KW JOIN], go to state 263.
parser: ... then shift 'joinop', pending reduce 102
parser: Reduce 102 [stl_prefix ::= seltablist joinop], go to state 197.
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ LP SELECT distinct selcollist FROM stl_prefix LP SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ID' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Shift 'ID', pending reduce 350
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ LP SELECT distinct selcollist FROM stl_prefix LP SELECT distinct selcollist FROM stl_prefix nm dbnm ID]
parser: Input 'ON' with pending reduce 350
parser: Reduce 350 [as ::= ID|STRING], go to state 243.
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Shift 'ON', go to state 92
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ LP SELECT distinct selcollist FROM stl_prefix LP SELECT distinct selcollist FROM stl_prefix nm dbnm as indexed_opt ON]
parser: Input 'ID' in state 92
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ LP SELECT distinct selcollist FROM stl_prefix LP SELECT distinct selcollist FROM stl_prefix nm dbnm as indexed_opt ON ID]
parser: Input 'DOT' in state 416
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 92.
parser: ... then shift 'nm', go to state 535
parser: Shift 'DOT', go to state 249
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ LP SELECT distinct selcollist FROM stl_prefix LP SELECT distinct selcollist FROM stl_prefix nm dbnm as indexed_opt ON nm DOT]
parser: Input 'ID' in state 249
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ LP SELECT distinct selcollist FROM stl_prefix LP SELECT distinct selcollist FROM stl_prefix nm dbnm as indexed_opt ON nm DOT ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 249.
parser: ... then shift 'nm', go to state 534
parser: Reduce 165 [expr ::= nm DOT nm], go to state 92.
parser: ... then shift 'expr', go to state 62
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ LP SELECT distinct selcollist FROM stl_prefix LP SELECT distinct selcollist FROM stl_prefix nm dbnm as indexed_opt ON expr EQ]
parser: Input 'ID' in state 117
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ LP SELECT distinct selcollist FROM stl_prefix LP SELECT distinct selcollist FROM stl_prefix nm dbnm as indexed_opt ON expr EQ ID]
parser: Input 'DOT' in state 416
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 117.
parser: ... then shift 'nm', go to state 535
parser: Shift 'DOT', go to state 249
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ LP SELECT distinct selcollist FROM stl_prefix LP SELECT distinct selcollist FROM stl_prefix nm dbnm as indexed_opt ON expr EQ nm DOT]
parser: Input 'ID' in state 249
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ LP SELECT distinct selcollist FROM stl_prefix LP SELECT distinct selcollist FROM stl_prefix nm dbnm as indexed_opt ON expr EQ nm DOT ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 249.
parser: ... then shift 'nm', go to state 534
parser: Reduce 165 [expr ::= nm DOT nm], go to state 117.
parser: ... then shift 'expr', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 92.
parser: ... then shift 'expr', go to state 62
parser: Reduce 120 [on_opt ::= ON expr], go to state 348.
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ LP SELECT distinct selcollist FROM stl_prefix LP SELECT distinct selcollist from WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ LP SELECT distinct selcollist FROM stl_prefix LP SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ LP SELECT distinct selcollist FROM stl_prefix LP SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'ID' in state 117
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ LP SELECT distinct selcollist FROM stl_prefix LP SELECT distinct selcollist from WHERE expr EQ ID]
parser: Input 'LIMIT' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 117.
parser: ... then shift 'expr', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Shift 'LIMIT', go to state 122
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ LP SELECT distinct selcollist FROM stl_prefix LP SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt LIMIT]
parser: Input 'INTEGER' in state 122
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ LP SELECT distinct selcollist FROM stl_prefix LP SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt LIMIT INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 122.
parser: ... then shift 'term', go to state 43
parser: Reduce 139 [limit_opt ::= LIMIT expr], go to state 357.
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 5.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 5.
parser: ... then shift 'select', go to state 492
parser: Shift 'RP', go to state 260
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ LP SELECT distinct selcollist FROM stl_prefix LP select RP]
parser: Input 'RP' in state 260
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 342
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 341
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 106
parser: Reduce 1
Program received signal SIGABRT, Aborted.
__GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:50
(gdb) #0  __GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:50
#1  0x00007f9dee60c859 in __GI_abort () at abort.c:79
#2  0x00007f9dee60c729 in __assert_fail_base (fmt=0x7f9dee7a2588 "%s%s%s:%u: %s%sAssertion `%s' failed.\n%n", assertion=0x21b92e "pItem->addrFillSub==0", file=0x22873d "sqlite3.c", line=130468, function=<optimized out>)
    at assert.c:92
#3  0x00007f9dee61dfd6 in __GI___assert_fail (assertion=0x21b92e "pItem->addrFillSub==0", file=0x22873d "sqlite3.c", line=130468, function=0x223e82 "int sqlite3Select(Parse *, Select *, SelectDest *)") at assert.c:101
#4  0x00000000002fcfa0 in sqlite3Select (pParse=0x7fff371a19b0, p=0xeef290, pDest=0x7fff371a0248) at sqlite3.c:130468
#5  0x000000000034f659 in sqlite3CodeSubselect (pParse=0x7fff371a19b0, pExpr=0xeeede0) at sqlite3.c:99820
#6  0x000000000034bbfd in sqlite3ExprCodeTarget (pParse=0x7fff371a19b0, pExpr=0xeeede0, target=7) at sqlite3.c:100770
#7  0x00000000003790ab in codeEqualityTerm (pParse=0x7fff371a19b0, pTerm=0xee8750, pLevel=0xee8ab0, iEq=1, bRev=0, iTarget=7) at sqlite3.c:136648
#8  0x000000000037a706 in codeAllEqualityTerms (pParse=0x7fff371a19b0, pLevel=0xee8ab0, bRev=0, nExtraReg=0, pzAff=0x7fff371a07c8) at sqlite3.c:136869
#9  0x0000000000375cb8 in sqlite3WhereCodeOneLoopStart (pParse=0x7fff371a19b0, v=0xeedfd0, pWInfo=0xee86c0, iLevel=1, pLevel=0xee8ab0, notReady=18446744073709551614) at sqlite3.c:137776
#10 0x000000000036c3cc in sqlite3WhereBegin (pParse=0x7fff371a19b0, pTabList=0xeffdc0, pWhere=0xeee930, pOrderBy=0x0, pResultSet=0xefb2c0, wctrlFlags=0, iAuxArg=320) at sqlite3.c:145128
#11 0x00000000002fdcea in sqlite3Select (pParse=0x7fff371a19b0, p=0xeee480, pDest=0x7fff371a0da0) at sqlite3.c:130695
#12 0x00000000002ecaa8 in yy_reduce (yypParser=0x7fff371a0fd0, yyruleno=79, yyLookahead=1, yyLookaheadToken=..., pParse=0x7fff371a19b0) at sqlite3.c:151581
#13 0x00000000002e92f8 in sqlite3Parser (yyp=0x7fff371a0fd0, yymajor=1, yyminor=...) at sqlite3.c:152877
#14 0x00000000002a68b3 in sqlite3RunParser (pParse=0x7fff371a19b0, 
    zSql=0xf089a7 ";;;\nSELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE name='t1' AND type='table' ORDER BY rowid;;\nSELECT name, rootpage, sql FROM \"main\".sqlite_master ORDER BY rowid;;;\nSELECT name, rootpage,"..., pzErrMsg=0x7fff371a1b90) at sqlite3.c:154013
#15 0x00000000002a1683 in sqlite3Prepare (db=0xee48c0, 
    zSql=0xee5410 ";\nSELECT\n    SrcWord, t1.c0content\n    FROM \n      (SELECT 'FACTORING' AS SrcWord UNION SELECT 'SWIMMING' AS SrcWord )\n    LEFT JOIN \n      t1\n    WHERE t1.x= (\n      SELECT BeginningId FROM (\n       "..., nBytes=2594, prepFlags=128, pReprepare=0x0, ppStmt=0x7fff371a1cc8, pzTail=0x7fff371a1cb0) at sqlite3.c:124303
#16 0x00000000002a0d4e in sqlite3LockAndPrepare (db=0xee48c0, 
    zSql=0xee5410 ";\nSELECT\n    SrcWord, t1.c0content\n    FROM \n      (SELECT 'FACTORING' AS SrcWord UNION SELECT 'SWIMMING' AS SrcWord )\n    LEFT JOIN \n      t1\n    WHERE t1.x= (\n      SELECT BeginningId FROM (\n       "..., nBytes=2594, prepFlags=128, pOld=0x0, ppStmt=0x7fff371a1cc8, pzTail=0x7fff371a1cb0) at sqlite3.c:124403
#17 0x000000000029247f in sqlite3_prepare_v2 (db=0xee48c0, 
    zSql=0xee5410 ";\nSELECT\n    SrcWord, t1.c0content\n    FROM \n      (SELECT 'FACTORING' AS SrcWord UNION SELECT 'SWIMMING' AS SrcWord )\n    LEFT JOIN \n      t1\n    WHERE t1.x= (\n      SELECT BeginningId FROM (\n       "..., nBytes=2594, ppStmt=0x7fff371a1cc8, pzTail=0x7fff371a1cb0) at sqlite3.c:124487
#18 0x0000000000256bd0 in main (argc=1, argv=0x7fff371a1e78) at target.cc:106
(gdb) quit
A debugging session is active.

	Inferior 1 [process 5314] will be killed.

Quit anyway? (y or n) [answered Y; input not from terminal]
