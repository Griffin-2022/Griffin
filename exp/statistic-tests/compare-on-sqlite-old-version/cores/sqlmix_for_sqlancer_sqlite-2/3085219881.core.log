GNU gdb (Ubuntu 9.2-0ubuntu1~20.04.1) 9.2
Copyright (C) 2020 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type "show copying" and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
    <http://www.gnu.org/software/gdb/documentation/>.

For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from /root/sqlite_driver_fast...
(gdb) Starting program: /root/sqlite_driver_fast < "/root/out/default/crashes/id:000482,sig:11,src:019926+018419,time:16089132,execs:3118353,op:merge.so,pos:0"
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
SQL: [;PRAGMA vdbe_trace=on;]
VDBE Trace:
   0 Init             0    1    0               00 Start at 1
   1 Expire           0    0    0               00 
   2 Halt             0    0    0               00 
SQL: [;insert into following (preceding, preceding, preceding)
    values (2, 4312, 2);]
VDBE Trace:
   0 Init             0    7    0               00 Start at 7
   7 Transaction      0    1    3 0             01 usesStmtJournal=0
   8 Goto             0    1    0               00 
   1 OpenWrite        0    3    0 1             00 root=3 iDb=0; following
   2 NewRowid         0    1    0               00 r[1]=rowid
REG[1] =  i:1
   3 Integer          2    2    0               00 r[2]=2
REG[2] =  i:2
   4 MakeRecord       2    1    3               00 r[3]=mkrec(r[2])
REG[3] =  s3[020102...]
   5 Insert           0    3    1 following     39 intkey=r[1] data=r[3]
REG[3] =  s3[020102...]
REG[1] =  i:1
   6 Halt             0    0    0               00 
SQL: [;PRAGMA vdbe_listing=on;]
VDBE Program Listing:
   0 Init             0    1    0               00 Start at 1
   1 Expire           0    0    0               00 
   2 Halt             0    0    0               00 
VDBE Trace:
   0 Init             0    1    0               00 Start at 1
   1 Expire           0    0    0               00 
   2 Halt             0    0    0               00 
SQL: [;
;SELECT preceding FROM following WHERE preceding LIKE 'ab' ORDER BY 1;]
VDBE Program Listing:
   0 Init             0   20    0               00 Start at 20
   1 SorterOpen       1    3    0 k(1,B)        00 
   2 OpenRead         0    3    0 1             00 root=3 iDb=0; following
   3 Explain          3    0    0 SCAN TABLE following 00 
   4 Rewind           0   12    0               00 
   5 Column           0    0    3               00 r[3]=following.preceding
   6 Function0        1    2    1 like(2)       02 r[1]=func(r[2..3])
   7 IfNot            1   11    1               00 
   8 Column           0    0    4               00 r[4]=following.preceding
   9 MakeRecord       4    1    6               00 r[6]=mkrec(r[4])
  10 SorterInsert     1    6    4 1             00 key=r[6]
  11 Next             0    5    0               01 
  12 Explain         12    0    0 USE TEMP B-TREE FOR ORDER BY 00 
  13 OpenPseudo       2    7    3               00 3 columns in r[7]
  14 SorterSort       1   19    0               00 
  15 SorterData       1    7    2               00 r[7]=data
  16 Column           2    0    5               00 r[5]=preceding
  17 ResultRow        5    1    0               00 output=r[5]
  18 SorterNext       1   15    0               00 
  19 Halt             0    0    0               00 
  20 Transaction      0    0    3 0             01 usesStmtJournal=0
  21 String8          0    2    0 ab            00 r[2]='ab'
  22 Goto             0    1    0               00 
VDBE Trace:
   0 Init             0   20    0               00 Start at 20
  20 Transaction      0    0    3 0             01 usesStmtJournal=0
  21 String8          0    2    0 ab            00 r[2]='ab'
REG[2] =   t2[ab](8)
  22 Goto             0    1    0               00 
   1 SorterOpen       1    3    0 k(1,B)        00 
   2 OpenRead         0    3    0 1             00 root=3 iDb=0; following
   3 Explain          3    0    0 SCAN TABLE following 00 
   4 Rewind           0   12    0               00 
   5 Column           0    0    3               00 r[3]=following.preceding
REG[3] =  i:2
   6 Function0        1    2    1 like(2)       02 r[1]=func(r[2..3])
REG[2] =   t2[ab](8)
REG[3] =  i:2
REG[1] =  i:0
   7 IfNot            1   11    1               00 
REG[1] =  i:0
  11 Next             0    5    0               01 
  12 Explain         12    0    0 USE TEMP B-TREE FOR ORDER BY 00 
  13 OpenPseudo       2    7    3               00 3 columns in r[7]
  14 SorterSort       1   19    0               00 
  19 Halt             0    0    0               00 
SQL: [;SELECT i.c0,
      (SELECT sum(CASE WHEN (t.preceding == i.c0) THEN 1 ELSE 0 END)
         FROM following t
      ) AS segfault
    FROM
     (SELECT curr.preceding as c0
        FROM following curr
          -- you also can comment out the next line
          -- it causes segfault to happen after one row is outputted
          INNER JOIN t0 a ON (curr.preceding = c0)
          LEFT JOIN following r ON (r.preceding <> 0 AND r.preceding < curr.preceding)
       GROUP BY curr.preceding
      HAVING r.preceding IS NULL
    ) i;]
VDBE Program Listing:
   0 Init             0  102    0               00 Start at 102
   1 InitCoroutine    1   76    2               00 i
   2 Explain          2    0    0 CO-ROUTINE 2  00 
   3 SorterOpen       5    2    0 k(1,B)        00 
   4 Integer          0    5    0               00 r[5]=0; clear abort flag
   5 Null             0    8    8               00 r[8..8]=NULL
   6 Gosub            7   72    0               00 
   7 OpenRead         1    3    0 1             00 root=3 iDb=0; following
   8 OpenRead         2    2    0 1             00 root=2 iDb=0; t0
   9 OpenRead         3    3    0 1             00 root=3 iDb=0; following
  10 Explain         10    2    0 SCAN TABLE following AS curr 00 
  11 Rewind           1   47    0               00 
  12 Once             0   20    0               00 
  13 OpenAutoindex    6    2    0 k(2,B,)       00 nColumn=2; for t0
  14 Rewind           2   20    0               00 
  15 Column           2    0   11               00 r[11]=t0.c0
  16 Rowid            2   12    0               00 r[12]=rowid
  17 MakeRecord      11    2   10               00 r[10]=mkrec(r[11..12])
  18 IdxInsert        6   10    0               10 key=r[10]
  19 Next             2   15    0               03 
  20 Explain         20    2    0 SEARCH TABLE t0 AS a USING AUTOMATIC COVERING INDEX (c0=?) 00 
  21 Column           1    0   13               00 r[13]=following.preceding
  22 IsNull          13   46    0               00 if r[13]==NULL goto 46
  23 Affinity        13    1    0 D             00 affinity(r[13])
  24 SeekGE           6   46   13 1             00 key=r[13]
  25 IdxGT            6   46   13 1             00 key=r[13]
  26 Explain         26    2    0 SCAN TABLE following AS r 00 
  27 Integer          0   14    0               00 r[14]=0; init LEFT JOIN no-match flag
  28 Rewind           3   42    0               00 
  29 Column           3    0   10               00 r[10]=following.preceding
  30 Integer          0   15    0               00 r[15]=0
  31 Eq              15   41   10 (BINARY)      51 if r[10]==r[15] goto 41
  32 Column           3    0   15               00 r[15]=following.preceding
  33 Column           1    0   10               00 r[10]=following.preceding
  34 Ge              10   41   15 (BINARY)      51 if r[15]>=r[10] goto 41
  35 Integer          1   14    0               00 r[14]=1; record LEFT JOIN hit
  36 Explain         36    2    0 USE TEMP B-TREE FOR GROUP BY 00 
  37 Column           1    0   11               00 r[11]=following.preceding
  38 Column           3    0   12               00 r[12]=following.preceding
  39 MakeRecord      11    2   10               00 r[10]=mkrec(r[11..12])
  40 SorterInsert     5   10    0               00 key=r[10]
  41 Next             3   29    0               01 
  42 IfPos           14   45    0               00 if r[14]>0 then r[14]-=0, goto 45
  43 NullRow          3    0    0               00 
  44 Goto             0   35    0               00 
  45 Next             6   25    0               00 
  46 Next             1   12    0               01 
  47 OpenPseudo       7   10    2               00 2 columns in r[10]
  48 SorterSort       5   75    0               00 GROUP BY sort
  49 SorterData       5   10    7               00 r[10]=data
  50 Column           7    0    9               00 r[9]=
  51 Compare          8    9    1 k(1,B)        00 r[8] <-> r[9]
  52 Jump            53   57   53               00 
  53 Move             9    8    1               00 r[8]=r[9]
  54 Gosub            6   66    0               00 output one row
  55 IfPos            5   75    0               00 if r[5]>0 then r[5]-=0, goto 75; check abort flag
  56 Gosub            7   72    0               00 reset accumulator
  57 If               4   60    0               00 
  58 Column           7    0    2               00 r[2]=
  59 Column           7    1    3               00 r[3]=
  60 Integer          1    4    0               00 r[4]=1; indicate data in accumulator
  61 SorterNext       5   49    0               00 
  62 Gosub            6   66    0               00 output final row
  63 Goto             0   75    0               00 
  64 Integer          1    5    0               00 r[5]=1; set abort flag
  65 Return           6    0    0               00 
  66 IfPos            4   68    0               00 if r[4]>0 then r[4]-=0, goto 68; Groupby result generator entry point
  67 Return           6    0    0               00 
  68 NotNull          3   67    0               00 if r[3]!=NULL goto 67
  69 Copy             2   16    0               00 r[16]=r[2]
  70 Yield            1    0    0               00 
  71 Return           6    0    0               00 end groupby result generator
  72 Null             0    2    3               00 r[2..3]=NULL
  73 Integer          0    4    0               00 r[4]=0; indicate accumulator empty
  74 Return           7    0    0               00 
  75 EndCoroutine     1    0    0               00 
  76 Explain         76    0    0 SCAN SUBQUERY 2 AS i 00 
  77 InitCoroutine    1    0    2               00 
  78 Yield            1  101    0               00 next row of i
  79 Copy            16   17    0               00 r[17]=r[16]; i.c0
  80 Explain         80    0    0 CORRELATED SCALAR SUBQUERY 1 00 
  81 Null             0   19   19               00 r[19..19]=NULL; Init subquery result
  82 Integer          1   20    0               00 r[20]=1; LIMIT counter
  83 Null             0   21   22               00 r[21..22]=NULL
  84 OpenRead         4    3    0 1             00 root=3 iDb=0; following
  85 Explain         85   80    0 SCAN TABLE following AS t 00 
  86 Rewind           4   95    0               00 
  87 Column           4    0   24               00 r[24]=following.preceding
  88 Copy            16   25    0               00 r[25]=r[16]; i.c0
  89 Ne              25   92   24 (BINARY)      51 if r[24]!=r[25] goto 92
  90 Integer          1   23    0               00 r[23]=1
  91 Goto             0   93    0               00 
  92 Integer          0   23    0               00 r[23]=0
  93 AggStep          0   23   21 sum(1)        01 accum=r[21] step(r[23])
  94 Next             4   87    0               01 
  95 AggFinal        21    1    0 sum(1)        00 accum=r[21] N=1
  96 Copy            21   19    0               00 r[19]=r[21]
  97 DecrJumpZero    20   98    0               00 if (--r[20])==0 goto 98
  98 Copy            19   18    0               00 r[18]=r[19]
  99 ResultRow       17    2    0               00 output=r[17..18]
 100 Goto             0   78    0               00 
 101 Halt             0    0    0               00 
 102 Transaction      0    0    3 0             01 usesStmtJournal=0
 103 Goto             0    1    0               00 
VDBE Trace:
   0 Init             0  102    0               00 Start at 102
 102 Transaction      0    0    3 0             01 usesStmtJournal=0
 103 Goto             0    1    0               00 
   1 InitCoroutine    1   76    2               00 i
  76 Explain         76    0    0 SCAN SUBQUERY 2 AS i 00 
  77 InitCoroutine    1    0    2               00 
  78 Yield            1  101    0               00 next row of i
REG[1] =  i:1
REG[1] =  i:78
   2 Explain          2    0    0 CO-ROUTINE 2  00 
   3 SorterOpen       5    2    0 k(1,B)        00 
   4 Integer          0    5    0               00 r[5]=0; clear abort flag
REG[5] =  i:0
   5 Null             0    8    8               00 r[8..8]=NULL
REG[8] =  NULL
   6 Gosub            7   72    0               00 
REG[7] =  i:6
  72 Null             0    2    3               00 r[2..3]=NULL
REG[2] =  NULL
  73 Integer          0    4    0               00 r[4]=0; indicate accumulator empty
REG[4] =  i:0
  74 Return           7    0    0               00 
REG[7] =  i:6
   7 OpenRead         1    3    0 1             00 root=3 iDb=0; following
   8 OpenRead         2    2    0 1             00 root=2 iDb=0; t0
   9 OpenRead         3    3    0 1             00 root=3 iDb=0; following
  10 Explain         10    2    0 SCAN TABLE following AS curr 00 
  11 Rewind           1   47    0               00 
  12 Once             0   20    0               00 
  13 OpenAutoindex    6    2    0 k(2,B,)       00 nColumn=2; for t0
  14 Rewind           2   20    0               00 
  15 Column           2    0   11               00 r[11]=t0.c0
REG[11] =  i:1
  16 Rowid            2   12    0               00 r[12]=rowid
REG[12] =  i:1
  17 MakeRecord      11    2   10               00 r[10]=mkrec(r[11..12])
REG[10] =  s3[030909...]
  18 IdxInsert        6   10    0               10 key=r[10]
REG[10] =  s3[030909...]
  19 Next             2   15    0               03 
  15 Column           2    0   11               00 r[11]=t0.c0
REG[11] =  i:2
  16 Rowid            2   12    0               00 r[12]=rowid
REG[12] =  i:2
  17 MakeRecord      11    2   10               00 r[10]=mkrec(r[11..12])
REG[10] =  s5[0301010202.....]
  18 IdxInsert        6   10    0               10 key=r[10]
REG[10] =  s5[0301010202.....]
  19 Next             2   15    0               03 
  15 Column           2    0   11               00 r[11]=t0.c0
REG[11] =  i:3
  16 Rowid            2   12    0               00 r[12]=rowid
REG[12] =  i:3
  17 MakeRecord      11    2   10               00 r[10]=mkrec(r[11..12])
REG[10] =  s5[0301010303.....]
  18 IdxInsert        6   10    0               10 key=r[10]
REG[10] =  s5[0301010303.....]
  19 Next             2   15    0               03 
  20 Explain         20    2    0 SEARCH TABLE t0 AS a USING AUTOMATIC COVERING INDEX (c0=?) 00 
  21 Column           1    0   13               00 r[13]=following.preceding
REG[13] =  i:2
  22 IsNull          13   46    0               00 if r[13]==NULL goto 46
REG[13] =  i:2
  23 Affinity        13    1    0 D             00 affinity(r[13])
  24 SeekGE           6   46   13 1             00 key=r[13]
REG[13] =  i:2
  25 IdxGT            6   46   13 1             00 key=r[13]
REG[13] =  i:2
  26 Explain         26    2    0 SCAN TABLE following AS r 00 
  27 Integer          0   14    0               00 r[14]=0; init LEFT JOIN no-match flag
REG[14] =  i:0
  28 Rewind           3   42    0               00 
  29 Column           3    0   10               00 r[10]=following.preceding
REG[10] =  i:2
  30 Integer          0   15    0               00 r[15]=0
REG[15] =  i:0
  31 Eq              15   41   10 (BINARY)      51 if r[10]==r[15] goto 41
REG[15] =  i:0
REG[10] =  i:2
  32 Column           3    0   15               00 r[15]=following.preceding
REG[15] =  i:2
  33 Column           1    0   10               00 r[10]=following.preceding
REG[10] =  i:2
  34 Ge              10   41   15 (BINARY)      51 if r[15]>=r[10] goto 41
REG[10] =  i:2
REG[15] =  i:2
  41 Next             3   29    0               01 
  42 IfPos           14   45    0               00 if r[14]>0 then r[14]-=0, goto 45
REG[14] =  i:0
  43 NullRow          3    0    0               00 
  44 Goto             0   35    0               00 
  35 Integer          1   14    0               00 r[14]=1; record LEFT JOIN hit
REG[14] =  i:1
  36 Explain         36    2    0 USE TEMP B-TREE FOR GROUP BY 00 
  37 Column           1    0   11               00 r[11]=following.preceding
REG[11] =  i:2
  38 Column           3    0   12               00 r[12]=following.preceding
REG[12] =  NULL
  39 MakeRecord      11    2   10               00 r[10]=mkrec(r[11..12])
REG[10] =  s4[03010002....]
  40 SorterInsert     5   10    0               00 key=r[10]
REG[10] =  s4[03010002....]
  41 Next             3   29    0               01 
  42 IfPos           14   45    0               00 if r[14]>0 then r[14]-=0, goto 45
REG[14] =  i:1
  45 Next             6   25    0               00 
  25 IdxGT            6   46   13 1             00 key=r[13]
REG[13] =  i:2
  46 Next             1   12    0               01 
  47 OpenPseudo       7   10    2               00 2 columns in r[10]
  48 SorterSort       5   75    0               00 GROUP BY sort
  49 SorterData       5   10    7               00 r[10]=data
  50 Column           7    0    9               00 r[9]=
REG[9] =  i:2
  51 Compare          8    9    1 k(1,B)        00 r[8] <-> r[9]
REG[8] =  NULL
REG[9] =  i:2
  52 Jump            53   57   53               00 
  53 Move             9    8    1               00 r[8]=r[9]
REG[8] =  i:2
  54 Gosub            6   66    0               00 output one row
REG[6] =  i:54
  66 IfPos            4   68    0               00 if r[4]>0 then r[4]-=0, goto 68; Groupby result generator entry point
REG[4] =  i:0
  67 Return           6    0    0               00 
REG[6] =  i:54
  55 IfPos            5   75    0               00 if r[5]>0 then r[5]-=0, goto 75; check abort flag
REG[5] =  i:0
  56 Gosub            7   72    0               00 reset accumulator
REG[7] =  i:56
  72 Null             0    2    3               00 r[2..3]=NULL
REG[2] =  NULL
  73 Integer          0    4    0               00 r[4]=0; indicate accumulator empty
REG[4] =  i:0
  74 Return           7    0    0               00 
REG[7] =  i:56
  57 If               4   60    0               00 
REG[4] =  i:0
  58 Column           7    0    2               00 r[2]=
REG[2] =  i:2
  59 Column           7    1    3               00 r[3]=
REG[3] =  NULL
  60 Integer          1    4    0               00 r[4]=1; indicate data in accumulator
REG[4] =  i:1
  61 SorterNext       5   49    0               00 
  62 Gosub            6   66    0               00 output final row
REG[6] =  i:62
  66 IfPos            4   68    0               00 if r[4]>0 then r[4]-=0, goto 68; Groupby result generator entry point
REG[4] =  i:1
  68 NotNull          3   67    0               00 if r[3]!=NULL goto 67
REG[3] =  NULL
  69 Copy             2   16    0               00 r[16]=r[2]
REG[16] =  i:2
  70 Yield            1    0    0               00 
REG[1] =  i:78
REG[1] =  i:70
  79 Copy            16   17    0               00 r[17]=r[16]; i.c0
REG[17] =  i:2
  80 Explain         80    0    0 CORRELATED SCALAR SUBQUERY 1 00 
  81 Null             0   19   19               00 r[19..19]=NULL; Init subquery result
REG[19] =  NULL
  82 Integer          1   20    0               00 r[20]=1; LIMIT counter
REG[20] =  i:1
  83 Null             0   21   22               00 r[21..22]=NULL
REG[21] =  NULL
  84 OpenRead         4    3    0 1             00 root=3 iDb=0; following
  85 Explain         85   80    0 SCAN TABLE following AS t 00 
  86 Rewind           4   95    0               00 
  87 Column           4    0   24               00 r[24]=following.preceding
REG[24] =  i:2
  88 Copy            16   25    0               00 r[25]=r[16]; i.c0
REG[25] =  i:2
  89 Ne              25   92   24 (BINARY)      51 if r[24]!=r[25] goto 92
REG[25] =  i:2
REG[24] =  i:2
  90 Integer          1   23    0               00 r[23]=1
REG[23] =  i:1
  91 Goto             0   93    0               00 
  93 AggStep          0   23   21 sum(1)        01 accum=r[21] step(r[23])
REG[23] =  i:1
  94 Next             4   87    0               01 
  95 AggFinal        21    1    0 sum(1)        00 accum=r[21] N=1
  96 Copy            21   19    0               00 r[19]=r[21]
REG[19] =  i:1
  97 DecrJumpZero    20   98    0               00 if (--r[20])==0 goto 98
REG[20] =  i:1
  98 Copy            19   18    0               00 r[18]=r[19]
REG[18] =  i:1
  99 ResultRow       17    2    0               00 output=r[17..18]
REG[17] =  i:2
REG[18] =  i:1
 100 Goto             0   78    0               00 
  78 Yield            1  101    0               00 next row of i
REG[1] =  i:70
REG[1] =  i:78
  71 Return           6    0    0               00 end groupby result generator
REG[6] =  i:62
  63 Goto             0   75    0               00 
  75 EndCoroutine     1    0    0               00 
REG[1] =  i:78
 101 Halt             0    0    0               00 
SQL: [;DROP TABLE IF EXISTS v0;]
VDBE Program Listing:
   0 Init             0   38    0               00 Start at 38
   1 Null             0    1    0               00 r[1]=NULL
   2 OpenWrite        0    1    1 5             00 root=1 iDb=1; sqlite_temp_master
   3 Explain          3    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   13    0               00 
   5 Column           0    2    2               00 r[2]=sqlite_temp_master.tbl_name
   6 Ne               3   12    2 (BINARY)      52 if r[2]!=r[3] goto 12
   7 Column           0    0    2               00 r[2]=sqlite_temp_master.type
   8 Eq               4   12    2 (BINARY)      52 if r[2]==r[4] goto 12
   9 Rowid            0    5    0               00 r[5]=rowid
  10 Once             0   11    0               00 
  11 Delete           0    0    0               02 
  12 Next             0    5    0               01 
  13 Destroy          2    2    1               00 
  14 Null             0    6    7               00 r[6..7]=NULL
  15 IfNot            2   24    1               00 
  16 OpenRead         1    1    1 4             00 root=1 iDb=1; sqlite_temp_master
  17 Explain         17    0    0 SCAN TABLE sqlite_master 00 
  18 Rewind           1   24    0               00 
  19 Column           1    3   13               00 r[13]=sqlite_temp_master.rootpage
  20 Ne               2   23   13 (BINARY)      54 if r[13]!=r[2] goto 23
  21 Rowid            1    7    0               00 r[7]=rowid
  22 RowSetAdd        6    7    0               00 rowset(6)=r[7]
  23 Next             1   19    0               01 
  24 OpenWrite        1    1    1 5             00 root=1 iDb=1; sqlite_temp_master
  25 RowSetRead       6   35    7               00 r[7]=rowset(6)
  26 NotExists        1   25    7               00 intkey=r[7]
  27 Column           1    0    8               00 r[8]=sqlite_temp_master.type
  28 Column           1    1    9               00 r[9]=sqlite_temp_master.name
  29 Column           1    2   10               00 r[10]=sqlite_temp_master.tbl_name
  30 Integer          2   11    0               00 r[11]=2
  31 Column           1    4   12               00 r[12]=sqlite_temp_master.sql
  32 MakeRecord       8    5   13 BBBDB         00 r[13]=mkrec(r[8..12])
  33 Insert           1   13    7               00 intkey=r[7] data=r[13]
  34 Goto             0   25    0               00 
  35 DropTable        1    0    0 v0            00 
  36 SetCookie        1    1    2               00 
  37 Halt             0    0    0               00 
  38 Transaction      1    1    1 0             01 usesStmtJournal=1
  39 String8          0    3    0 v0            00 r[3]='v0'
  40 String8          0    4    0 trigger       00 r[4]='trigger'
  41 Goto             0    1    0               00 
VDBE Trace:
   0 Init             0   38    0               00 Start at 38
  38 Transaction      1    1    1 0             01 usesStmtJournal=1
  39 String8          0    3    0 v0            00 r[3]='v0'
REG[3] =   t2[v0](8)
  40 String8          0    4    0 trigger       00 r[4]='trigger'
REG[4] =   t7[trigger](8)
  41 Goto             0    1    0               00 
   1 Null             0    1    0               00 r[1]=NULL
REG[1] =  NULL
   2 OpenWrite        0    1    1 5             00 root=1 iDb=1; sqlite_temp_master
   3 Explain          3    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   13    0               00 
   5 Column           0    2    2               00 r[2]=sqlite_temp_master.tbl_name
REG[2] =   s2[v0](8)
   6 Ne               3   12    2 (BINARY)      52 if r[2]!=r[3] goto 12
REG[3] =   t2[v0](8)
REG[2] =   s2[v0](8)
   7 Column           0    0    2               00 r[2]=sqlite_temp_master.type
REG[2] =   s5[table](8)
   8 Eq               4   12    2 (BINARY)      52 if r[2]==r[4] goto 12
REG[4] =   t7[trigger](8)
REG[2] =   s5[table](8)
   9 Rowid            0    5    0               00 r[5]=rowid
REG[5] =  i:1
  10 Once             0   11    0               00 
  11 Delete           0    0    0               02 
  12 Next             0    5    0               01 
  13 Destroy          2    2    1               00 
REG[2] =  i:0
  14 Null             0    6    7               00 r[6..7]=NULL
REG[6] =  NULL
  15 IfNot            2   24    1               00 
REG[2] =  i:0
  24 OpenWrite        1    1    1 5             00 root=1 iDb=1; sqlite_temp_master
  25 RowSetRead       6   35    7               00 r[7]=rowset(6)
REG[6] =  NULL
REG[7] =  NULL
  35 DropTable        1    0    0 v0            00 
  36 SetCookie        1    1    2               00 
  37 Halt             0    0    0               00 
SQL: [;CREATE TABLE test002 (
      test003 INTEGER PRIMARY KEY AUTOINCREMENT,
      field1 INTEGER
    );]
VDBE Program Listing:
   0 Init             0   28    0               00 Start at 28
   1 ReadCookie       0    3    2               00 
   2 If               3    5    0               00 
   3 SetCookie        0    2    4               00 
   4 SetCookie        0    5    1               00 
   5 CreateBtree      0    2    1               00 r[2]=root iDb=0 flags=1
   6 OpenWrite        0    1    0 5             00 root=1 iDb=0
   7 NewRowid         0    1    0               00 r[1]=rowid
   8 Blob             6    3    0              00 r[3]= (len=6)
   9 Insert           0    3    1               08 intkey=r[1] data=r[3]
  10 Close            0    0    0               00 
  11 Close            0    0    0               00 
  12 Null             0    4    5               00 r[4..5]=NULL
  13 OpenWrite        1    1    0 5             00 root=1 iDb=0; sqlite_master
  14 Explain         14    0    0 SEARCH TABLE sqlite_master USING INTEGER PRIMARY KEY (rowid=?) 00 
  15 SeekRowid        1   17    1               00 intkey=r[1]
  16 Rowid            1    5    0               00 r[5]=rowid
  17 IsNull           5   25    0               00 if r[5]==NULL goto 25
  18 String8          0    6    0 table         00 r[6]='table'
  19 String8          0    7    0 test002       00 r[7]='test002'
  20 String8          0    8    0 test002       00 r[8]='test002'
  21 Copy             2    9    0               00 r[9]=r[2]
  22 String8          0   10    0 CREATE TABLE test002 (
      test003 INTEGER PRIMARY KEY AUTOINCREMENT,
      field1 INTEGER
    ) 00 r[10]='CREATE TABLE test002 (
      test003 INTEGER PRIMARY KEY AUTOINCREMENT,
      field1 INTEGER
  23 MakeRecord       6    5   11 BBBDB         00 r[11]=mkrec(r[6..10])
  24 Insert           1   11    5               00 intkey=r[5] data=r[11]
  25 SetCookie        0    1    4               00 
  26 ParseSchema      0    0    0 tbl_name='test002' AND type!='trigger' 00 
  27 Halt             0    0    0               00 
  28 Transaction      0    1    3 0             01 usesStmtJournal=0
  29 Goto             0    1    0               00 
VDBE Trace:
   0 Init             0   28    0               00 Start at 28
  28 Transaction      0    1    3 0             01 usesStmtJournal=0
  29 Goto             0    1    0               00 
   1 ReadCookie       0    3    2               00 
REG[3] =  i:4
   2 If               3    5    0               00 
REG[3] =  i:4
   5 CreateBtree      0    2    1               00 r[2]=root iDb=0 flags=1
REG[2] =  i:6
   6 OpenWrite        0    1    0 5             00 root=1 iDb=0
   7 NewRowid         0    1    0               00 r[1]=rowid
REG[1] =  i:5
   8 Blob             6    3    0              00 r[3]= (len=6)
REG[3] =  t6[060000000000......]
   9 Insert           0    3    1               08 intkey=r[1] data=r[3]
REG[3] =  t6[060000000000......]
REG[1] =  i:5
  10 Close            0    0    0               00 
  11 Close            0    0    0               00 
  12 Null             0    4    5               00 r[4..5]=NULL
REG[4] =  NULL
  13 OpenWrite        1    1    0 5             00 root=1 iDb=0; sqlite_master
  14 Explain         14    0    0 SEARCH TABLE sqlite_master USING INTEGER PRIMARY KEY (rowid=?) 00 
  15 SeekRowid        1   17    1               00 intkey=r[1]
REG[1] =  i:5
  16 Rowid            1    5    0               00 r[5]=rowid
REG[5] =  i:5
  17 IsNull           5   25    0               00 if r[5]==NULL goto 25
REG[5] =  i:5
  18 String8          0    6    0 table         00 r[6]='table'
REG[6] =   t5[table](8)
  19 String8          0    7    0 test002       00 r[7]='test002'
REG[7] =   t7[test002](8)
  20 String8          0    8    0 test002       00 r[8]='test002'
REG[8] =   t7[test002](8)
  21 Copy             2    9    0               00 r[9]=r[2]
REG[9] =  i:6
  22 String8          0   10    0 CREATE TABLE test002 (
      test003 INTEGER PRIMARY KEY AUTOINCREMENT,
      field1 INTEGER
    ) 00 r[10]='CREATE TABLE test002 (
      test003 INTEGER PRIMARY KEY AUTOINCREMENT,
      field1 INTEGER
REG[10] =   t98[CREATE TABLE te](8)
  23 MakeRecord       6    5   11 BBBDB         00 r[11]=mkrec(r[6..10])
REG[11] =  s125[07171B1B0181517461626C6574657374......Qtabletest]
  24 Insert           1   11    5               00 intkey=r[5] data=r[11]
REG[11] =  s125[07171B1B0181517461626C6574657374......Qtabletest]
REG[5] =  i:5
  25 SetCookie        0    1    4               00 
  26 ParseSchema      0    0    0 tbl_name='test002' AND type!='trigger' 00 
VDBE Program Listing:
   0 Init             0   15    0               00 Start at 15
   1 Noop             1    5    0               00 
   2 OpenRead         0    1    0 5             00 root=1 iDb=0; sqlite_master
   3 Explain          3    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   14    0               00 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
   6 Ne               2   13    1 (BINARY)      52 if r[1]!=r[2] goto 13
   7 Column           0    0    1               00 r[1]=sqlite_master.type
   8 Eq               3   13    1 (BINARY)      52 if r[1]==r[3] goto 13
   9 Column           0    1    4               00 r[4]=sqlite_master.name
  10 Column           0    3    5               00 r[5]=sqlite_master.rootpage
  11 Column           0    4    6               00 r[6]=sqlite_master.sql
  12 ResultRow        4    3    0               00 output=r[4..6]
  13 Next             0    5    0               01 
  14 Halt             0    0    0               00 
  15 Transaction      0    0    4 0             00 usesStmtJournal=0
  16 String8          0    2    0 test002       00 r[2]='test002'
  17 String8          0    3    0 trigger       00 r[3]='trigger'
  18 Goto             0    1    0               00 
VDBE Trace:
   0 Init             0   15    0               00 Start at 15
  15 Transaction      0    0    4 0             00 usesStmtJournal=0
  16 String8          0    2    0 test002       00 r[2]='test002'
REG[2] =   t7[test002](8)
  17 String8          0    3    0 trigger       00 r[3]='trigger'
REG[3] =   t7[trigger](8)
  18 Goto             0    1    0               00 
   1 Noop             1    5    0               00 
   2 OpenRead         0    1    0 5             00 root=1 iDb=0; sqlite_master
   3 Explain          3    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   14    0               00 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[t0](8)
   6 Ne               2   13    1 (BINARY)      52 if r[1]!=r[2] goto 13
REG[2] =   t7[test002](8)
REG[1] =   s2[t0](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s9[following](8)
   6 Ne               2   13    1 (BINARY)      52 if r[1]!=r[2] goto 13
REG[2] =   t7[test002](8)
REG[1] =   s9[following](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[t1](8)
   6 Ne               2   13    1 (BINARY)      52 if r[1]!=r[2] goto 13
REG[2] =   t7[test002](8)
REG[1] =   s2[t1](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s15[sqlite_sequence](8)
   6 Ne               2   13    1 (BINARY)      52 if r[1]!=r[2] goto 13
REG[2] =   t7[test002](8)
REG[1] =   s15[sqlite_sequence](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s7[test002](8)
   6 Ne               2   13    1 (BINARY)      52 if r[1]!=r[2] goto 13
REG[2] =   t7[test002](8)
REG[1] =   s7[test002](8)
   7 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[table](8)
   8 Eq               3   13    1 (BINARY)      52 if r[1]==r[3] goto 13
REG[3] =   t7[trigger](8)
REG[1] =   s5[table](8)
   9 Column           0    1    4               00 r[4]=sqlite_master.name
REG[4] =   s7[test002](8)
  10 Column           0    3    5               00 r[5]=sqlite_master.rootpage
REG[5] =  i:6
  11 Column           0    4    6               00 r[6]=sqlite_master.sql
REG[6] =   s98[CREATE TABLE te](8)
  12 ResultRow        4    3    0               00 output=r[4..6]
REG[4] =   s7[test002](8)
REG[5] =  i:6
REG[6] =   s98[CREATE TABLE te](8)
  13 Next             0    5    0               01 
  14 Halt             0    0    0               00 
  27 Halt             0    0    0               00 
SQL: [;SELECT
     (SELECT sum(c0==xyz) FROM t0)
    FROM
     (SELECT curr.c0 as xyz
        FROM t0 AS curr LEFT JOIN t0 AS other
       GROUP BY curr.c0);]
VDBE Program Listing:
   0 Init             0   73    0               00 Start at 73
   1 InitCoroutine    1   51    2               00 subquery_2
   2 Explain          2    0    0 CO-ROUTINE 2  00 
   3 SorterOpen       4    1    0 k(1,B)        00 
   4 Integer          0    4    0               00 r[4]=0; clear abort flag
   5 Null             0    7    7               00 r[7..7]=NULL
   6 Gosub            6   47    0               00 
   7 OpenRead         1    2    0 1             00 root=2 iDb=0; t0
   8 OpenRead         2    2    0 0             00 root=2 iDb=0; t0
   9 Explain          9    2    0 SCAN TABLE t0 AS curr 00 
  10 Rewind           1   24    0               00 
  11 Explain         11    2    0 SCAN TABLE t0 AS other 00 
  12 Integer          0    9    0               00 r[9]=0; init LEFT JOIN no-match flag
  13 Rewind           2   20    0               00 
  14 Integer          1    9    0               00 r[9]=1; record LEFT JOIN hit
  15 Explain         15    2    0 USE TEMP B-TREE FOR GROUP BY 00 
  16 Column           1    0   10               00 r[10]=t0.c0
  17 MakeRecord      10    1   11               00 r[11]=mkrec(r[10])
  18 SorterInsert     4   11    0               00 key=r[11]
  19 Next             2   14    0               01 
  20 IfPos            9   23    0               00 if r[9]>0 then r[9]-=0, goto 23
  21 NullRow          2    0    0               00 
  22 Goto             0   14    0               00 
  23 Next             1   11    0               01 
  24 OpenPseudo       5   10    1               00 1 columns in r[10]
  25 SorterSort       4   50    0               00 GROUP BY sort
  26 SorterData       4   10    5               00 r[10]=data
  27 Column           5    0    8               00 r[8]=
  28 Compare          7    8    1 k(1,B)        00 r[7] <-> r[8]
  29 Jump            30   34   30               00 
  30 Move             8    7    1               00 r[7]=r[8]
  31 Gosub            5   42    0               00 output one row
  32 IfPos            4   50    0               00 if r[4]>0 then r[4]-=0, goto 50; check abort flag
  33 Gosub            6   47    0               00 reset accumulator
  34 If               3   36    0               00 
  35 Column           5    0    2               00 r[2]=
  36 Integer          1    3    0               00 r[3]=1; indicate data in accumulator
  37 SorterNext       4   26    0               00 
  38 Gosub            5   42    0               00 output final row
  39 Goto             0   50    0               00 
  40 Integer          1    4    0               00 r[4]=1; set abort flag
  41 Return           5    0    0               00 
  42 IfPos            3   44    0               00 if r[3]>0 then r[3]-=0, goto 44; Groupby result generator entry point
  43 Return           5    0    0               00 
  44 Copy             2   12    0               00 r[12]=r[2]
  45 Yield            1    0    0               00 
  46 Return           5    0    0               00 end groupby result generator
  47 Null             0    2    2               00 r[2..2]=NULL
  48 Integer          0    3    0               00 r[3]=0; indicate accumulator empty
  49 Return           6    0    0               00 
  50 EndCoroutine     1    0    0               00 
  51 Explain         51    0    0 SCAN SUBQUERY 2 00 
  52 InitCoroutine    1    0    2               00 
  53 Yield            1   72    0               00 next row of subquery_2
  54 Explain         54    0    0 CORRELATED SCALAR SUBQUERY 1 00 
  55 Null             0   14   14               00 r[14..14]=NULL; Init subquery result
  56 Integer          1   15    0               00 r[15]=1; LIMIT counter
  57 Null             0   16   17               00 r[16..17]=NULL
  58 OpenRead         3    2    0 1             00 root=2 iDb=0; t0
  59 Explain         59   54    0 SCAN TABLE t0 00 
  60 Rewind           3   66    0               00 
  61 Column           3    0   19               00 r[19]=t0.c0
  62 Copy            12   20    0               00 r[20]=r[12]; subquery_2.xyz
  63 Eq              20   18   19 (BINARY)      63 r[18] = (r[19]==r[20])
  64 AggStep          0   18   16 sum(1)        01 accum=r[16] step(r[18])
  65 Next             3   61    0               01 
  66 AggFinal        16    1    0 sum(1)        00 accum=r[16] N=1
  67 Copy            16   14    0               00 r[14]=r[16]
  68 DecrJumpZero    15   69    0               00 if (--r[15])==0 goto 69
  69 Copy            14   13    0               00 r[13]=r[14]
  70 ResultRow       13    1    0               00 output=r[13]
  71 Goto             0   53    0               00 
  72 Halt             0    0    0               00 
  73 Transaction      0    0    4 0             01 usesStmtJournal=0
  74 Goto             0    1    0               00 
VDBE Trace:
   0 Init             0   73    0               00 Start at 73
  73 Transaction      0    0    4 0             01 usesStmtJournal=0
  74 Goto             0    1    0               00 
   1 InitCoroutine    1   51    2               00 subquery_2
  51 Explain         51    0    0 SCAN SUBQUERY 2 00 
  52 InitCoroutine    1    0    2               00 
  53 Yield            1   72    0               00 next row of subquery_2
REG[1] =  i:1
REG[1] =  i:53
   2 Explain          2    0    0 CO-ROUTINE 2  00 
   3 SorterOpen       4    1    0 k(1,B)        00 
   4 Integer          0    4    0               00 r[4]=0; clear abort flag
REG[4] =  i:0
   5 Null             0    7    7               00 r[7..7]=NULL
REG[7] =  NULL
   6 Gosub            6   47    0               00 
REG[6] =  i:6
  47 Null             0    2    2               00 r[2..2]=NULL
REG[2] =  NULL
  48 Integer          0    3    0               00 r[3]=0; indicate accumulator empty
REG[3] =  i:0
  49 Return           6    0    0               00 
REG[6] =  i:6
   7 OpenRead         1    2    0 1             00 root=2 iDb=0; t0
   8 OpenRead         2    2    0 0             00 root=2 iDb=0; t0
   9 Explain          9    2    0 SCAN TABLE t0 AS curr 00 
  10 Rewind           1   24    0               00 
  11 Explain         11    2    0 SCAN TABLE t0 AS other 00 
  12 Integer          0    9    0               00 r[9]=0; init LEFT JOIN no-match flag
REG[9] =  i:0
  13 Rewind           2   20    0               00 
  14 Integer          1    9    0               00 r[9]=1; record LEFT JOIN hit
REG[9] =  i:1
  15 Explain         15    2    0 USE TEMP B-TREE FOR GROUP BY 00 
  16 Column           1    0   10               00 r[10]=t0.c0
REG[10] =  i:1
  17 MakeRecord      10    1   11               00 r[11]=mkrec(r[10])
REG[11] =  s2[0209..]
  18 SorterInsert     4   11    0               00 key=r[11]
REG[11] =  s2[0209..]
  19 Next             2   14    0               01 
  14 Integer          1    9    0               00 r[9]=1; record LEFT JOIN hit
REG[9] =  i:1
  15 Explain         15    2    0 USE TEMP B-TREE FOR GROUP BY 00 
  16 Column           1    0   10               00 r[10]=t0.c0
REG[10] =  i:1
  17 MakeRecord      10    1   11               00 r[11]=mkrec(r[10])
REG[11] =  s2[0209..]
  18 SorterInsert     4   11    0               00 key=r[11]
REG[11] =  s2[0209..]
  19 Next             2   14    0               01 
  14 Integer          1    9    0               00 r[9]=1; record LEFT JOIN hit
REG[9] =  i:1
  15 Explain         15    2    0 USE TEMP B-TREE FOR GROUP BY 00 
  16 Column           1    0   10               00 r[10]=t0.c0
REG[10] =  i:1
  17 MakeRecord      10    1   11               00 r[11]=mkrec(r[10])
REG[11] =  s2[0209..]
  18 SorterInsert     4   11    0               00 key=r[11]
REG[11] =  s2[0209..]
  19 Next             2   14    0               01 
  20 IfPos            9   23    0               00 if r[9]>0 then r[9]-=0, goto 23
REG[9] =  i:1
  23 Next             1   11    0               01 
  11 Explain         11    2    0 SCAN TABLE t0 AS other 00 
  12 Integer          0    9    0               00 r[9]=0; init LEFT JOIN no-match flag
REG[9] =  i:0
  13 Rewind           2   20    0               00 
  14 Integer          1    9    0               00 r[9]=1; record LEFT JOIN hit
REG[9] =  i:1
  15 Explain         15    2    0 USE TEMP B-TREE FOR GROUP BY 00 
  16 Column           1    0   10               00 r[10]=t0.c0
REG[10] =  i:2
  17 MakeRecord      10    1   11               00 r[11]=mkrec(r[10])
REG[11] =  s3[020102...]
  18 SorterInsert     4   11    0               00 key=r[11]
REG[11] =  s3[020102...]
  19 Next             2   14    0               01 
  14 Integer          1    9    0               00 r[9]=1; record LEFT JOIN hit
REG[9] =  i:1
  15 Explain         15    2    0 USE TEMP B-TREE FOR GROUP BY 00 
  16 Column           1    0   10               00 r[10]=t0.c0
REG[10] =  i:2
  17 MakeRecord      10    1   11               00 r[11]=mkrec(r[10])
REG[11] =  s3[020102...]
  18 SorterInsert     4   11    0               00 key=r[11]
REG[11] =  s3[020102...]
  19 Next             2   14    0               01 
  14 Integer          1    9    0               00 r[9]=1; record LEFT JOIN hit
REG[9] =  i:1
  15 Explain         15    2    0 USE TEMP B-TREE FOR GROUP BY 00 
  16 Column           1    0   10               00 r[10]=t0.c0
REG[10] =  i:2
  17 MakeRecord      10    1   11               00 r[11]=mkrec(r[10])
REG[11] =  s3[020102...]
  18 SorterInsert     4   11    0               00 key=r[11]
REG[11] =  s3[020102...]
  19 Next             2   14    0               01 
  20 IfPos            9   23    0               00 if r[9]>0 then r[9]-=0, goto 23
REG[9] =  i:1
  23 Next             1   11    0               01 
  11 Explain         11    2    0 SCAN TABLE t0 AS other 00 
  12 Integer          0    9    0               00 r[9]=0; init LEFT JOIN no-match flag
REG[9] =  i:0
  13 Rewind           2   20    0               00 
  14 Integer          1    9    0               00 r[9]=1; record LEFT JOIN hit
REG[9] =  i:1
  15 Explain         15    2    0 USE TEMP B-TREE FOR GROUP BY 00 
  16 Column           1    0   10               00 r[10]=t0.c0
REG[10] =  i:3
  17 MakeRecord      10    1   11               00 r[11]=mkrec(r[10])
REG[11] =  s3[020103...]
  18 SorterInsert     4   11    0               00 key=r[11]
REG[11] =  s3[020103...]
  19 Next             2   14    0               01 
  14 Integer          1    9    0               00 r[9]=1; record LEFT JOIN hit
REG[9] =  i:1
  15 Explain         15    2    0 USE TEMP B-TREE FOR GROUP BY 00 
  16 Column           1    0   10               00 r[10]=t0.c0
REG[10] =  i:3
  17 MakeRecord      10    1   11               00 r[11]=mkrec(r[10])
REG[11] =  s3[020103...]
  18 SorterInsert     4   11    0               00 key=r[11]
REG[11] =  s3[020103...]
  19 Next             2   14    0               01 
  14 Integer          1    9    0               00 r[9]=1; record LEFT JOIN hit
REG[9] =  i:1
  15 Explain         15    2    0 USE TEMP B-TREE FOR GROUP BY 00 
  16 Column           1    0   10               00 r[10]=t0.c0
REG[10] =  i:3
  17 MakeRecord      10    1   11               00 r[11]=mkrec(r[10])
REG[11] =  s3[020103...]
  18 SorterInsert     4   11    0               00 key=r[11]
REG[11] =  s3[020103...]
  19 Next             2   14    0               01 
  20 IfPos            9   23    0               00 if r[9]>0 then r[9]-=0, goto 23
REG[9] =  i:1
  23 Next             1   11    0               01 
  24 OpenPseudo       5   10    1               00 1 columns in r[10]
  25 SorterSort       4   50    0               00 GROUP BY sort
  26 SorterData       4   10    5               00 r[10]=data
  27 Column           5    0    8               00 r[8]=
REG[8] =  i:1
  28 Compare          7    8    1 k(1,B)        00 r[7] <-> r[8]
REG[7] =  NULL
REG[8] =  i:1
  29 Jump            30   34   30               00 
  30 Move             8    7    1               00 r[7]=r[8]
REG[7] =  i:1
  31 Gosub            5   42    0               00 output one row
REG[5] =  i:31
  42 IfPos            3   44    0               00 if r[3]>0 then r[3]-=0, goto 44; Groupby result generator entry point
REG[3] =  i:0
  43 Return           5    0    0               00 
REG[5] =  i:31
  32 IfPos            4   50    0               00 if r[4]>0 then r[4]-=0, goto 50; check abort flag
REG[4] =  i:0
  33 Gosub            6   47    0               00 reset accumulator
REG[6] =  i:33
  47 Null             0    2    2               00 r[2..2]=NULL
REG[2] =  NULL
  48 Integer          0    3    0               00 r[3]=0; indicate accumulator empty
REG[3] =  i:0
  49 Return           6    0    0               00 
REG[6] =  i:33
  34 If               3   36    0               00 
REG[3] =  i:0
  35 Column           5    0    2               00 r[2]=
REG[2] =  i:1
  36 Integer          1    3    0               00 r[3]=1; indicate data in accumulator
REG[3] =  i:1
  37 SorterNext       4   26    0               00 
  26 SorterData       4   10    5               00 r[10]=data
  27 Column           5    0    8               00 r[8]=
REG[8] =  i:1
  28 Compare          7    8    1 k(1,B)        00 r[7] <-> r[8]
REG[7] =  i:1
REG[8] =  i:1
  29 Jump            30   34   30               00 
  34 If               3   36    0               00 
REG[3] =  i:1
  36 Integer          1    3    0               00 r[3]=1; indicate data in accumulator
REG[3] =  i:1
  37 SorterNext       4   26    0               00 
  26 SorterData       4   10    5               00 r[10]=data
  27 Column           5    0    8               00 r[8]=
REG[8] =  i:1
  28 Compare          7    8    1 k(1,B)        00 r[7] <-> r[8]
REG[7] =  i:1
REG[8] =  i:1
  29 Jump            30   34   30               00 
  34 If               3   36    0               00 
REG[3] =  i:1
  36 Integer          1    3    0               00 r[3]=1; indicate data in accumulator
REG[3] =  i:1
  37 SorterNext       4   26    0               00 
  26 SorterData       4   10    5               00 r[10]=data
  27 Column           5    0    8               00 r[8]=
REG[8] =  i:2
  28 Compare          7    8    1 k(1,B)        00 r[7] <-> r[8]
REG[7] =  i:1
REG[8] =  i:2
  29 Jump            30   34   30               00 
  30 Move             8    7    1               00 r[7]=r[8]
REG[7] =  i:2
  31 Gosub            5   42    0               00 output one row
REG[5] =  i:31
  42 IfPos            3   44    0               00 if r[3]>0 then r[3]-=0, goto 44; Groupby result generator entry point
REG[3] =  i:1
  44 Copy             2   12    0               00 r[12]=r[2]
REG[12] =  i:1
  45 Yield            1    0    0               00 
REG[1] =  i:53
REG[1] =  i:45
  54 Explain         54    0    0 CORRELATED SCALAR SUBQUERY 1 00 
  55 Null             0   14   14               00 r[14..14]=NULL; Init subquery result
REG[14] =  NULL
  56 Integer          1   15    0               00 r[15]=1; LIMIT counter
REG[15] =  i:1
  57 Null             0   16   17               00 r[16..17]=NULL
REG[16] =  NULL
  58 OpenRead         3    2    0 1             00 root=2 iDb=0; t0
  59 Explain         59   54    0 SCAN TABLE t0 00 
  60 Rewind           3   66    0               00 
  61 Column           3    0   19               00 r[19]=t0.c0
REG[19] =  i:1
  62 Copy            12   20    0               00 r[20]=r[12]; subquery_2.xyz
REG[20] =  i:1
  63 Eq              20   18   19 (BINARY)      63 r[18] = (r[19]==r[20])
REG[20] =  i:1
REG[19] =  i:1
REG[18] =  i:1
  64 AggStep          0   18   16 sum(1)        01 accum=r[16] step(r[18])
REG[18] =  i:1
  65 Next             3   61    0               01 
  61 Column           3    0   19               00 r[19]=t0.c0
REG[19] =  i:2
  62 Copy            12   20    0               00 r[20]=r[12]; subquery_2.xyz
REG[20] =  i:1
  63 Eq              20   18   19 (BINARY)      63 r[18] = (r[19]==r[20])
REG[20] =  i:1
REG[19] =  i:2
REG[18] =  i:0
  64 AggStep1         0   18   16 sum(1)        01 accum=r[16] step(r[18])
REG[18] =  i:0
  65 Next             3   61    0               01 
  61 Column           3    0   19               00 r[19]=t0.c0
REG[19] =  i:3
  62 Copy            12   20    0               00 r[20]=r[12]; subquery_2.xyz
REG[20] =  i:1
  63 Eq              20   18   19 (BINARY)      63 r[18] = (r[19]==r[20])
REG[20] =  i:1
REG[19] =  i:3
REG[18] =  i:0
  64 AggStep1         0   18   16 sum(1)        01 accum=r[16] step(r[18])
REG[18] =  i:0
  65 Next             3   61    0               01 
  66 AggFinal        16    1    0 sum(1)        00 accum=r[16] N=1
  67 Copy            16   14    0               00 r[14]=r[16]
REG[14] =  i:1
  68 DecrJumpZero    15   69    0               00 if (--r[15])==0 goto 69
REG[15] =  i:1
  69 Copy            14   13    0               00 r[13]=r[14]
REG[13] =  i:1
  70 ResultRow       13    1    0               00 output=r[13]
REG[13] =  i:1
  71 Goto             0   53    0               00 
  53 Yield            1   72    0               00 next row of subquery_2
REG[1] =  i:45
REG[1] =  i:53
  46 Return           5    0    0               00 end groupby result generator
REG[5] =  i:31
  32 IfPos            4   50    0               00 if r[4]>0 then r[4]-=0, goto 50; check abort flag
REG[4] =  i:0
  33 Gosub            6   47    0               00 reset accumulator
REG[6] =  i:33
  47 Null             0    2    2               00 r[2..2]=NULL
REG[2] =  NULL
  48 Integer          0    3    0               00 r[3]=0; indicate accumulator empty
REG[3] =  i:0
  49 Return           6    0    0               00 
REG[6] =  i:33
  34 If               3   36    0               00 
REG[3] =  i:0
  35 Column           5    0    2               00 r[2]=
REG[2] =  i:2
  36 Integer          1    3    0               00 r[3]=1; indicate data in accumulator
REG[3] =  i:1
  37 SorterNext       4   26    0               00 
  26 SorterData       4   10    5               00 r[10]=data
  27 Column           5    0    8               00 r[8]=
REG[8] =  i:2
  28 Compare          7    8    1 k(1,B)        00 r[7] <-> r[8]
REG[7] =  i:2
REG[8] =  i:2
  29 Jump            30   34   30               00 
  34 If               3   36    0               00 
REG[3] =  i:1
  36 Integer          1    3    0               00 r[3]=1; indicate data in accumulator
REG[3] =  i:1
  37 SorterNext       4   26    0               00 
  26 SorterData       4   10    5               00 r[10]=data
  27 Column           5    0    8               00 r[8]=
REG[8] =  i:2
  28 Compare          7    8    1 k(1,B)        00 r[7] <-> r[8]
REG[7] =  i:2
REG[8] =  i:2
  29 Jump            30   34   30               00 
  34 If               3   36    0               00 
REG[3] =  i:1
  36 Integer          1    3    0               00 r[3]=1; indicate data in accumulator
REG[3] =  i:1
  37 SorterNext       4   26    0               00 
  26 SorterData       4   10    5               00 r[10]=data
  27 Column           5    0    8               00 r[8]=
REG[8] =  i:3
  28 Compare          7    8    1 k(1,B)        00 r[7] <-> r[8]
REG[7] =  i:2
REG[8] =  i:3
  29 Jump            30   34   30               00 
  30 Move             8    7    1               00 r[7]=r[8]
REG[7] =  i:3
  31 Gosub            5   42    0               00 output one row
REG[5] =  i:31
  42 IfPos            3   44    0               00 if r[3]>0 then r[3]-=0, goto 44; Groupby result generator entry point
REG[3] =  i:1
  44 Copy             2   12    0               00 r[12]=r[2]
REG[12] =  i:2
  45 Yield            1    0    0               00 
REG[1] =  i:53
REG[1] =  i:45
  54 Explain         54    0    0 CORRELATED SCALAR SUBQUERY 1 00 
  55 Null             0   14   14               00 r[14..14]=NULL; Init subquery result
REG[14] =  NULL
  56 Integer          1   15    0               00 r[15]=1; LIMIT counter
REG[15] =  i:1
  57 Null             0   16   17               00 r[16..17]=NULL
REG[16] =  NULL
  58 OpenRead         3    2    0 1             00 root=2 iDb=0; t0
  59 Explain         59   54    0 SCAN TABLE t0 00 
  60 Rewind           3   66    0               00 
  61 Column           3    0   19               00 r[19]=t0.c0
REG[19] =  i:1
  62 Copy            12   20    0               00 r[20]=r[12]; subquery_2.xyz
REG[20] =  i:2
  63 Eq              20   18   19 (BINARY)      63 r[18] = (r[19]==r[20])
REG[20] =  i:2
REG[19] =  i:1
REG[18] =  i:0
  64 AggStep1         0   18   16 sum(1)        01 accum=r[16] step(r[18])
REG[18] =  i:0
  65 Next             3   61    0               01 
  61 Column           3    0   19               00 r[19]=t0.c0
REG[19] =  i:2
  62 Copy            12   20    0               00 r[20]=r[12]; subquery_2.xyz
REG[20] =  i:2
  63 Eq              20   18   19 (BINARY)      63 r[18] = (r[19]==r[20])
REG[20] =  i:2
REG[19] =  i:2
REG[18] =  i:1
  64 AggStep1         0   18   16 sum(1)        01 accum=r[16] step(r[18])
REG[18] =  i:1
  65 Next             3   61    0               01 
  61 Column           3    0   19               00 r[19]=t0.c0
REG[19] =  i:3
  62 Copy            12   20    0               00 r[20]=r[12]; subquery_2.xyz
REG[20] =  i:2
  63 Eq              20   18   19 (BINARY)      63 r[18] = (r[19]==r[20])
REG[20] =  i:2
REG[19] =  i:3
REG[18] =  i:0
  64 AggStep1         0   18   16 sum(1)        01 accum=r[16] step(r[18])
REG[18] =  i:0
  65 Next             3   61    0               01 
  66 AggFinal        16    1    0 sum(1)        00 accum=r[16] N=1
  67 Copy            16   14    0               00 r[14]=r[16]
REG[14] =  i:1
  68 DecrJumpZero    15   69    0               00 if (--r[15])==0 goto 69
REG[15] =  i:1
  69 Copy            14   13    0               00 r[13]=r[14]
REG[13] =  i:1
  70 ResultRow       13    1    0               00 output=r[13]
REG[13] =  i:1
  71 Goto             0   53    0               00 
  53 Yield            1   72    0               00 next row of subquery_2
REG[1] =  i:45
REG[1] =  i:53
  46 Return           5    0    0               00 end groupby result generator
REG[5] =  i:31
  32 IfPos            4   50    0               00 if r[4]>0 then r[4]-=0, goto 50; check abort flag
REG[4] =  i:0
  33 Gosub            6   47    0               00 reset accumulator
REG[6] =  i:33
  47 Null             0    2    2               00 r[2..2]=NULL
REG[2] =  NULL
  48 Integer          0    3    0               00 r[3]=0; indicate accumulator empty
REG[3] =  i:0
  49 Return           6    0    0               00 
REG[6] =  i:33
  34 If               3   36    0               00 
REG[3] =  i:0
  35 Column           5    0    2               00 r[2]=
REG[2] =  i:3
  36 Integer          1    3    0               00 r[3]=1; indicate data in accumulator
REG[3] =  i:1
  37 SorterNext       4   26    0               00 
  26 SorterData       4   10    5               00 r[10]=data
  27 Column           5    0    8               00 r[8]=
REG[8] =  i:3
  28 Compare          7    8    1 k(1,B)        00 r[7] <-> r[8]
REG[7] =  i:3
REG[8] =  i:3
  29 Jump            30   34   30               00 
  34 If               3   36    0               00 
REG[3] =  i:1
  36 Integer          1    3    0               00 r[3]=1; indicate data in accumulator
REG[3] =  i:1
  37 SorterNext       4   26    0               00 
  26 SorterData       4   10    5               00 r[10]=data
  27 Column           5    0    8               00 r[8]=
REG[8] =  i:3
  28 Compare          7    8    1 k(1,B)        00 r[7] <-> r[8]
REG[7] =  i:3
REG[8] =  i:3
  29 Jump            30   34   30               00 
  34 If               3   36    0               00 
REG[3] =  i:1
  36 Integer          1    3    0               00 r[3]=1; indicate data in accumulator
REG[3] =  i:1
  37 SorterNext       4   26    0               00 
  38 Gosub            5   42    0               00 output final row
REG[5] =  i:38
  42 IfPos            3   44    0               00 if r[3]>0 then r[3]-=0, goto 44; Groupby result generator entry point
REG[3] =  i:1
  44 Copy             2   12    0               00 r[12]=r[2]
REG[12] =  i:3
  45 Yield            1    0    0               00 
REG[1] =  i:53
REG[1] =  i:45
  54 Explain         54    0    0 CORRELATED SCALAR SUBQUERY 1 00 
  55 Null             0   14   14               00 r[14..14]=NULL; Init subquery result
REG[14] =  NULL
  56 Integer          1   15    0               00 r[15]=1; LIMIT counter
REG[15] =  i:1
  57 Null             0   16   17               00 r[16..17]=NULL
REG[16] =  NULL
  58 OpenRead         3    2    0 1             00 root=2 iDb=0; t0
  59 Explain         59   54    0 SCAN TABLE t0 00 
  60 Rewind           3   66    0               00 
  61 Column           3    0   19               00 r[19]=t0.c0
REG[19] =  i:1
  62 Copy            12   20    0               00 r[20]=r[12]; subquery_2.xyz
REG[20] =  i:3
  63 Eq              20   18   19 (BINARY)      63 r[18] = (r[19]==r[20])
REG[20] =  i:3
REG[19] =  i:1
REG[18] =  i:0
  64 AggStep1         0   18   16 sum(1)        01 accum=r[16] step(r[18])
REG[18] =  i:0
  65 Next             3   61    0               01 
  61 Column           3    0   19               00 r[19]=t0.c0
REG[19] =  i:2
  62 Copy            12   20    0               00 r[20]=r[12]; subquery_2.xyz
REG[20] =  i:3
  63 Eq              20   18   19 (BINARY)      63 r[18] = (r[19]==r[20])
REG[20] =  i:3
REG[19] =  i:2
REG[18] =  i:0
  64 AggStep1         0   18   16 sum(1)        01 accum=r[16] step(r[18])
REG[18] =  i:0
  65 Next             3   61    0               01 
  61 Column           3    0   19               00 r[19]=t0.c0
REG[19] =  i:3
  62 Copy            12   20    0               00 r[20]=r[12]; subquery_2.xyz
REG[20] =  i:3
  63 Eq              20   18   19 (BINARY)      63 r[18] = (r[19]==r[20])
REG[20] =  i:3
REG[19] =  i:3
REG[18] =  i:1
  64 AggStep1         0   18   16 sum(1)        01 accum=r[16] step(r[18])
REG[18] =  i:1
  65 Next             3   61    0               01 
  66 AggFinal        16    1    0 sum(1)        00 accum=r[16] N=1
  67 Copy            16   14    0               00 r[14]=r[16]
REG[14] =  i:1
  68 DecrJumpZero    15   69    0               00 if (--r[15])==0 goto 69
REG[15] =  i:1
  69 Copy            14   13    0               00 r[13]=r[14]
REG[13] =  i:1
  70 ResultRow       13    1    0               00 output=r[13]
REG[13] =  i:1
  71 Goto             0   53    0               00 
  53 Yield            1   72    0               00 next row of subquery_2
REG[1] =  i:45
REG[1] =  i:53
  46 Return           5    0    0               00 end groupby result generator
REG[5] =  i:38
  39 Goto             0   50    0               00 
  50 EndCoroutine     1    0    0               00 
REG[1] =  i:53
  72 Halt             0    0    0               00 
SQL: [;
;DROP TABLE IF EXISTS following;]
VDBE Program Listing:
   0 Init             0   38    0               00 Start at 38
   1 Null             0    1    0               00 r[1]=NULL
   2 OpenWrite        0    1    0 5             00 root=1 iDb=0; sqlite_master
   3 Explain          3    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   13    0               00 
   5 Column           0    2    2               00 r[2]=sqlite_master.tbl_name
   6 Ne               3   12    2 (BINARY)      52 if r[2]!=r[3] goto 12
   7 Column           0    0    2               00 r[2]=sqlite_master.type
   8 Eq               4   12    2 (BINARY)      52 if r[2]==r[4] goto 12
   9 Rowid            0    5    0               00 r[5]=rowid
  10 Once             0   11    0               00 
  11 Delete           0    0    0               02 
  12 Next             0    5    0               01 
  13 Destroy          3    2    0               00 
  14 Null             0    6    7               00 r[6..7]=NULL
  15 IfNot            2   24    1               00 
  16 OpenRead         1    1    0 4             00 root=1 iDb=0; sqlite_master
  17 Explain         17    0    0 SCAN TABLE sqlite_master 00 
  18 Rewind           1   24    0               00 
  19 Column           1    3   13               00 r[13]=sqlite_master.rootpage
  20 Ne               2   23   13 (BINARY)      54 if r[13]!=r[2] goto 23
  21 Rowid            1    7    0               00 r[7]=rowid
  22 RowSetAdd        6    7    0               00 rowset(6)=r[7]
  23 Next             1   19    0               01 
  24 OpenWrite        1    1    0 5             00 root=1 iDb=0; sqlite_master
  25 RowSetRead       6   35    7               00 r[7]=rowset(6)
  26 NotExists        1   25    7               00 intkey=r[7]
  27 Column           1    0    8               00 r[8]=sqlite_master.type
  28 Column           1    1    9               00 r[9]=sqlite_master.name
  29 Column           1    2   10               00 r[10]=sqlite_master.tbl_name
  30 Integer          3   11    0               00 r[11]=3
  31 Column           1    4   12               00 r[12]=sqlite_master.sql
  32 MakeRecord       8    5   13 BBBDB         00 r[13]=mkrec(r[8..12])
  33 Insert           1   13    7               00 intkey=r[7] data=r[13]
  34 Goto             0   25    0               00 
  35 DropTable        0    0    0 following     00 
  36 SetCookie        0    1    5               00 
  37 Halt             0    0    0               00 
  38 Transaction      0    1    4 0             01 usesStmtJournal=1
  39 String8          0    3    0 following     00 r[3]='following'
  40 String8          0    4    0 trigger       00 r[4]='trigger'
  41 Goto             0    1    0               00 
VDBE Trace:
   0 Init             0   38    0               00 Start at 38
  38 Transaction      0    1    4 0             01 usesStmtJournal=1
  39 String8          0    3    0 following     00 r[3]='following'
REG[3] =   t9[following](8)
  40 String8          0    4    0 trigger       00 r[4]='trigger'
REG[4] =   t7[trigger](8)
  41 Goto             0    1    0               00 
   1 Null             0    1    0               00 r[1]=NULL
REG[1] =  NULL
   2 OpenWrite        0    1    0 5             00 root=1 iDb=0; sqlite_master
   3 Explain          3    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   13    0               00 
   5 Column           0    2    2               00 r[2]=sqlite_master.tbl_name
REG[2] =   s2[t0](8)
   6 Ne               3   12    2 (BINARY)      52 if r[2]!=r[3] goto 12
REG[3] =   t9[following](8)
REG[2] =   s2[t0](8)
  12 Next             0    5    0               01 
   5 Column           0    2    2               00 r[2]=sqlite_master.tbl_name
REG[2] =   s9[following](8)
   6 Ne               3   12    2 (BINARY)      52 if r[2]!=r[3] goto 12
REG[3] =   t9[following](8)
REG[2] =   s9[following](8)
   7 Column           0    0    2               00 r[2]=sqlite_master.type
REG[2] =   s5[table](8)
   8 Eq               4   12    2 (BINARY)      52 if r[2]==r[4] goto 12
REG[4] =   t7[trigger](8)
REG[2] =   s5[table](8)
   9 Rowid            0    5    0               00 r[5]=rowid
REG[5] =  i:2
  10 Once             0   11    0               00 
  11 Delete           0    0    0               02 
  12 Next             0    5    0               01 
   5 Column           0    2    2               00 r[2]=sqlite_master.tbl_name
REG[2] =   s2[t1](8)
   6 Ne               3   12    2 (BINARY)      52 if r[2]!=r[3] goto 12
REG[3] =   t9[following](8)
REG[2] =   s2[t1](8)
  12 Next             0    5    0               01 
   5 Column           0    2    2               00 r[2]=sqlite_master.tbl_name
REG[2] =   s15[sqlite_sequence](8)
   6 Ne               3   12    2 (BINARY)      52 if r[2]!=r[3] goto 12
REG[3] =   t9[following](8)
REG[2] =   s15[sqlite_sequence](8)
  12 Next             0    5    0               01 
   5 Column           0    2    2               00 r[2]=sqlite_master.tbl_name
REG[2] =   s7[test002](8)
   6 Ne               3   12    2 (BINARY)      52 if r[2]!=r[3] goto 12
REG[3] =   t9[following](8)
REG[2] =   s7[test002](8)
  12 Next             0    5    0               01 
  13 Destroy          3    2    0               00 
REG[2] =  i:0
  14 Null             0    6    7               00 r[6..7]=NULL
REG[6] =  NULL
  15 IfNot            2   24    1               00 
REG[2] =  i:0
  24 OpenWrite        1    1    0 5             00 root=1 iDb=0; sqlite_master
  25 RowSetRead       6   35    7               00 r[7]=rowset(6)
REG[6] =  NULL
REG[7] =  NULL
  35 DropTable        0    0    0 following     00 
  36 SetCookie        0    1    5               00 
  37 Halt             0    0    0               00 
SQL: [;
;SELECT c0 FROM t0 WHERE c0 LIKE 'ab%d' ORDER BY 1;]
VDBE Program Listing:
   0 Init             0   20    0               00 Start at 20
   1 SorterOpen       1    3    0 k(1,B)        00 
   2 OpenRead         0    2    0 1             00 root=2 iDb=0; t0
   3 Explain          3    0    0 SCAN TABLE t0 00 
   4 Rewind           0   12    0               00 
   5 Column           0    0    3               00 r[3]=t0.c0
   6 Function0        1    2    1 like(2)       02 r[1]=func(r[2..3])
   7 IfNot            1   11    1               00 
   8 Column           0    0    4               00 r[4]=t0.c0
   9 MakeRecord       4    1    6               00 r[6]=mkrec(r[4])
  10 SorterInsert     1    6    4 1             00 key=r[6]
  11 Next             0    5    0               01 
  12 Explain         12    0    0 USE TEMP B-TREE FOR ORDER BY 00 
  13 OpenPseudo       2    7    3               00 3 columns in r[7]
  14 SorterSort       1   19    0               00 
  15 SorterData       1    7    2               00 r[7]=data
  16 Column           2    0    5               00 r[5]=c0
  17 ResultRow        5    1    0               00 output=r[5]
  18 SorterNext       1   15    0               00 
  19 Halt             0    0    0               00 
  20 Transaction      0    0    5 0             01 usesStmtJournal=0
  21 String8          0    2    0 ab%d          00 r[2]='ab%d'
  22 Goto             0    1    0               00 
VDBE Trace:
   0 Init             0   20    0               00 Start at 20
  20 Transaction      0    0    5 0             01 usesStmtJournal=0
  21 String8          0    2    0 ab%d          00 r[2]='ab%d'
REG[2] =   t4[ab%d](8)
  22 Goto             0    1    0               00 
   1 SorterOpen       1    3    0 k(1,B)        00 
   2 OpenRead         0    2    0 1             00 root=2 iDb=0; t0
   3 Explain          3    0    0 SCAN TABLE t0 00 
   4 Rewind           0   12    0               00 
   5 Column           0    0    3               00 r[3]=t0.c0
REG[3] =  i:1
   6 Function0        1    2    1 like(2)       02 r[1]=func(r[2..3])
REG[2] =   t4[ab%d](8)
REG[3] =  i:1
REG[1] =  i:0
   7 IfNot            1   11    1               00 
REG[1] =  i:0
  11 Next             0    5    0               01 
   5 Column           0    0    3               00 r[3]=t0.c0
REG[3] =  i:2
   6 Function         1    2    1 like(2)       02 r[1]=func(r[2..3])
REG[2] =   t4[ab%d](8)
REG[3] =  i:2
REG[1] =  i:0
   7 IfNot            1   11    1               00 
REG[1] =  i:0
  11 Next             0    5    0               01 
   5 Column           0    0    3               00 r[3]=t0.c0
REG[3] =  i:3
   6 Function         1    2    1 like(2)       02 r[1]=func(r[2..3])
REG[2] =   t4[ab%d](8)
REG[3] =  i:3
REG[1] =  i:0
   7 IfNot            1   11    1               00 
REG[1] =  i:0
  11 Next             0    5    0               01 
  12 Explain         12    0    0 USE TEMP B-TREE FOR ORDER BY 00 
  13 OpenPseudo       2    7    3               00 3 columns in r[7]
  14 SorterSort       1   19    0               00 
  19 Halt             0    0    0               00 
SQL: [;DROP TABLE IF EXISTS t1;]
VDBE Program Listing:
   0 Init             0   48    0               00 Start at 48
   1 Null             0    1    0               00 r[1]=NULL
   2 OpenWrite        0    5    0 2             00 root=5 iDb=0; sqlite_sequence
   3 Explain          3    0    0 SCAN TABLE sqlite_sequence 00 
   4 Rewind           0   11    0               00 
   5 Column           0    0    2               00 r[2]=sqlite_sequence.name
   6 Ne               3   10    2 (BINARY)      51 if r[2]!=r[3] goto 10
   7 Rowid            0    4    0               00 r[4]=rowid
   8 Once             0    9    0               00 
   9 Delete           0    0    0               02 
  10 Next             0    5    0               01 
  11 Null             0    5    0               00 r[5]=NULL
  12 OpenWrite        1    1    0 5             00 root=1 iDb=0; sqlite_master
  13 Explain         13    0    0 SCAN TABLE sqlite_master 00 
  14 Rewind           1   23    0               00 
  15 Column           1    2    2               00 r[2]=sqlite_master.tbl_name
  16 Ne               3   22    2 (BINARY)      52 if r[2]!=r[3] goto 22
  17 Column           1    0    2               00 r[2]=sqlite_master.type
  18 Eq               6   22    2 (BINARY)      52 if r[2]==r[6] goto 22
  19 Rowid            1    7    0               00 r[7]=rowid
  20 Once             0   21    0               00 
  21 Delete           1    0    0               02 
  22 Next             1   15    0               01 
  23 Destroy          4    2    0               00 
  24 Null             0    8    9               00 r[8..9]=NULL
  25 IfNot            2   34    1               00 
  26 OpenRead         2    1    0 4             00 root=1 iDb=0; sqlite_master
  27 Explain         27    0    0 SCAN TABLE sqlite_master 00 
  28 Rewind           2   34    0               00 
  29 Column           2    3   15               00 r[15]=sqlite_master.rootpage
  30 Ne               2   33   15 (BINARY)      54 if r[15]!=r[2] goto 33
  31 Rowid            2    9    0               00 r[9]=rowid
  32 RowSetAdd        8    9    0               00 rowset(8)=r[9]
  33 Next             2   29    0               01 
  34 OpenWrite        2    1    0 5             00 root=1 iDb=0; sqlite_master
  35 RowSetRead       8   45    9               00 r[9]=rowset(8)
  36 NotExists        2   35    9               00 intkey=r[9]
  37 Column           2    0   10               00 r[10]=sqlite_master.type
  38 Column           2    1   11               00 r[11]=sqlite_master.name
  39 Column           2    2   12               00 r[12]=sqlite_master.tbl_name
  40 Integer          4   13    0               00 r[13]=4
  41 Column           2    4   14               00 r[14]=sqlite_master.sql
  42 MakeRecord      10    5   15 BBBDB         00 r[15]=mkrec(r[10..14])
  43 Insert           2   15    9               00 intkey=r[9] data=r[15]
  44 Goto             0   35    0               00 
  45 DropTable        0    0    0 t1            00 
  46 SetCookie        0    1    6               00 
  47 Halt             0    0    0               00 
  48 Transaction      0    1    5 0             01 usesStmtJournal=1
  49 String8          0    3    0 t1            00 r[3]='t1'
  50 String8          0    6    0 trigger       00 r[6]='trigger'
  51 Goto             0    1    0               00 
VDBE Trace:
   0 Init             0   48    0               00 Start at 48
  48 Transaction      0    1    5 0             01 usesStmtJournal=1
  49 String8          0    3    0 t1            00 r[3]='t1'
REG[3] =   t2[t1](8)
  50 String8          0    6    0 trigger       00 r[6]='trigger'
REG[6] =   t7[trigger](8)
  51 Goto             0    1    0               00 
   1 Null             0    1    0               00 r[1]=NULL
REG[1] =  NULL
   2 OpenWrite        0    5    0 2             00 root=5 iDb=0; sqlite_sequence
   3 Explain          3    0    0 SCAN TABLE sqlite_sequence 00 
   4 Rewind           0   11    0               00 
  11 Null             0    5    0               00 r[5]=NULL
REG[5] =  NULL
  12 OpenWrite        1    1    0 5             00 root=1 iDb=0; sqlite_master
  13 Explain         13    0    0 SCAN TABLE sqlite_master 00 
  14 Rewind           1   23    0               00 
  15 Column           1    2    2               00 r[2]=sqlite_master.tbl_name
REG[2] =   s2[t0](8)
  16 Ne               3   22    2 (BINARY)      52 if r[2]!=r[3] goto 22
REG[3] =   t2[t1](8)
REG[2] =   s2[t0](8)
  22 Next             1   15    0               01 
  15 Column           1    2    2               00 r[2]=sqlite_master.tbl_name
REG[2] =   s2[t1](8)
  16 Ne               3   22    2 (BINARY)      52 if r[2]!=r[3] goto 22
REG[3] =   t2[t1](8)
REG[2] =   s2[t1](8)
  17 Column           1    0    2               00 r[2]=sqlite_master.type
REG[2] =   s5[table](8)
  18 Eq               6   22    2 (BINARY)      52 if r[2]==r[6] goto 22
REG[6] =   t7[trigger](8)
REG[2] =   s5[table](8)
  19 Rowid            1    7    0               00 r[7]=rowid
REG[7] =  i:3
  20 Once             0   21    0               00 
  21 Delete           1    0    0               02 
  22 Next             1   15    0               01 
  15 Column           1    2    2               00 r[2]=sqlite_master.tbl_name
REG[2] =   s15[sqlite_sequence](8)
  16 Ne               3   22    2 (BINARY)      52 if r[2]!=r[3] goto 22
REG[3] =   t2[t1](8)
REG[2] =   s15[sqlite_sequence](8)
  22 Next             1   15    0               01 
  15 Column           1    2    2               00 r[2]=sqlite_master.tbl_name
REG[2] =   s7[test002](8)
  16 Ne               3   22    2 (BINARY)      52 if r[2]!=r[3] goto 22
REG[3] =   t2[t1](8)
REG[2] =   s7[test002](8)
  22 Next             1   15    0               01 
  23 Destroy          4    2    0               00 
REG[2] =  i:0
  24 Null             0    8    9               00 r[8..9]=NULL
REG[8] =  NULL
  25 IfNot            2   34    1               00 
REG[2] =  i:0
  34 OpenWrite        2    1    0 5             00 root=1 iDb=0; sqlite_master
  35 RowSetRead       8   45    9               00 r[9]=rowset(8)
REG[8] =  NULL
REG[9] =  NULL
  45 DropTable        0    0    0 t1            00 
  46 SetCookie        0    1    6               00 
  47 Halt             0    0    0               00 
SQL: [;
;SELECT test003 FROM test002 WHERE test003 LIKE 'a_c%' ORDER BY 1;]
VDBE Program Listing:
   0 Init             0   15    0               00 Start at 15
   1 Noop             1    3    0               00 
   2 OpenRead         0    6    0 0             00 root=6 iDb=0; test002
   3 Explain          3    0    0 SEARCH TABLE test002 USING INTEGER PRIMARY KEY (rowid>? AND rowid<?) 00 
   4 SeekGE           0   14    1               00 key=r[1]; pk
   5 String8          0    2    0 b             00 r[2]='b'
   6 Rowid            0    3    0               00 r[3]=rowid
   7 Ge               2   14    3               53 if r[3]>=r[2] goto 14
   8 Rowid            0    6    0               00 r[6]=rowid
   9 Function0        1    5    4 like(2)       02 r[4]=func(r[5..6])
  10 IfNot            4   13    1               00 
  11 Rowid            0    7    0               00 r[7]=rowid
  12 ResultRow        7    1    0               00 output=r[7]
  13 Next             0    6    0               00 
  14 Halt             0    0    0               00 
  15 Transaction      0    0    6 0             01 usesStmtJournal=0
  16 String8          0    1    0 A             00 r[1]='A'
  17 String8          0    5    0 a_c%          00 r[5]='a_c%'
  18 Goto             0    1    0               00 
VDBE Trace:
   0 Init             0   15    0               00 Start at 15
  15 Transaction      0    0    6 0             01 usesStmtJournal=0
  16 String8          0    1    0 A             00 r[1]='A'
REG[1] =   t1[A](8)
  17 String8          0    5    0 a_c%          00 r[5]='a_c%'
REG[5] =   t4[a_c%](8)
  18 Goto             0    1    0               00 
   1 Noop             1    3    0               00 
   2 OpenRead         0    6    0 0             00 root=6 iDb=0; test002
   3 Explain          3    0    0 SEARCH TABLE test002 USING INTEGER PRIMARY KEY (rowid>? AND rowid<?) 00 
   4 SeekGE           0   14    1               00 key=r[1]; pk
REG[1] =   t1[A](8)
  14 Halt             0    0    0               00 
SQL: [;CREATE TABLE field2 (
      test004 INTEGER
    );]
VDBE Program Listing:
   0 Init             0   28    0               00 Start at 28
   1 ReadCookie       0    3    2               00 
   2 If               3    5    0               00 
   3 SetCookie        0    2    4               00 
   4 SetCookie        0    5    1               00 
   5 CreateBtree      0    2    1               00 r[2]=root iDb=0 flags=1
   6 OpenWrite        0    1    0 5             00 root=1 iDb=0
   7 NewRowid         0    1    0               00 r[1]=rowid
   8 Blob             6    3    0              00 r[3]= (len=6)
   9 Insert           0    3    1               08 intkey=r[1] data=r[3]
  10 Close            0    0    0               00 
  11 Close            0    0    0               00 
  12 Null             0    4    5               00 r[4..5]=NULL
  13 OpenWrite        1    1    0 5             00 root=1 iDb=0; sqlite_master
  14 Explain         14    0    0 SEARCH TABLE sqlite_master USING INTEGER PRIMARY KEY (rowid=?) 00 
  15 SeekRowid        1   17    1               00 intkey=r[1]
  16 Rowid            1    5    0               00 r[5]=rowid
  17 IsNull           5   25    0               00 if r[5]==NULL goto 25
  18 String8          0    6    0 table         00 r[6]='table'
  19 String8          0    7    0 field2        00 r[7]='field2'
  20 String8          0    8    0 field2        00 r[8]='field2'
  21 Copy             2    9    0               00 r[9]=r[2]
  22 String8          0   10    0 CREATE TABLE field2 (
      test004 INTEGER
    ) 00 r[10]='CREATE TABLE field2 (
      test004 INTEGER
    )'
  23 MakeRecord       6    5   11 BBBDB         00 r[11]=mkrec(r[6..10])
  24 Insert           1   11    5               00 intkey=r[5] data=r[11]
  25 SetCookie        0    1    7               00 
  26 ParseSchema      0    0    0 tbl_name='field2' AND type!='trigger' 00 
  27 Halt             0    0    0               00 
  28 Transaction      0    1    6 0             01 usesStmtJournal=0
  29 Goto             0    1    0               00 
VDBE Trace:
   0 Init             0   28    0               00 Start at 28
  28 Transaction      0    1    6 0             01 usesStmtJournal=0
  29 Goto             0    1    0               00 
   1 ReadCookie       0    3    2               00 
REG[3] =  i:4
   2 If               3    5    0               00 
REG[3] =  i:4
   5 CreateBtree      0    2    1               00 r[2]=root iDb=0 flags=1
REG[2] =  i:4
   6 OpenWrite        0    1    0 5             00 root=1 iDb=0
   7 NewRowid         0    1    0               00 r[1]=rowid
REG[1] =  i:6
   8 Blob             6    3    0              00 r[3]= (len=6)
REG[3] =  t6[060000000000......]
   9 Insert           0    3    1               08 intkey=r[1] data=r[3]
REG[3] =  t6[060000000000......]
REG[1] =  i:6
  10 Close            0    0    0               00 
  11 Close            0    0    0               00 
  12 Null             0    4    5               00 r[4..5]=NULL
REG[4] =  NULL
  13 OpenWrite        1    1    0 5             00 root=1 iDb=0; sqlite_master
  14 Explain         14    0    0 SEARCH TABLE sqlite_master USING INTEGER PRIMARY KEY (rowid=?) 00 
  15 SeekRowid        1   17    1               00 intkey=r[1]
REG[1] =  i:6
  16 Rowid            1    5    0               00 r[5]=rowid
REG[5] =  i:6
  17 IsNull           5   25    0               00 if r[5]==NULL goto 25
REG[5] =  i:6
  18 String8          0    6    0 table         00 r[6]='table'
REG[6] =   t5[table](8)
  19 String8          0    7    0 field2        00 r[7]='field2'
REG[7] =   t6[field2](8)
  20 String8          0    8    0 field2        00 r[8]='field2'
REG[8] =   t6[field2](8)
  21 Copy             2    9    0               00 r[9]=r[2]
REG[9] =  i:4
  22 String8          0   10    0 CREATE TABLE field2 (
      test004 INTEGER
    ) 00 r[10]='CREATE TABLE field2 (
      test004 INTEGER
    )'
REG[10] =   t49[CREATE TABLE fi](8)
  23 MakeRecord       6    5   11 BBBDB         00 r[11]=mkrec(r[6..10])
REG[11] =  s73[06171919016F7461626C656669656C64.....otablefield]
  24 Insert           1   11    5               00 intkey=r[5] data=r[11]
REG[11] =  s73[06171919016F7461626C656669656C64.....otablefield]
REG[5] =  i:6
  25 SetCookie        0    1    7               00 
  26 ParseSchema      0    0    0 tbl_name='field2' AND type!='trigger' 00 
VDBE Program Listing:
   0 Init             0   15    0               00 Start at 15
   1 Noop             1    5    0               00 
   2 OpenRead         0    1    0 5             00 root=1 iDb=0; sqlite_master
   3 Explain          3    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   14    0               00 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
   6 Ne               2   13    1 (BINARY)      52 if r[1]!=r[2] goto 13
   7 Column           0    0    1               00 r[1]=sqlite_master.type
   8 Eq               3   13    1 (BINARY)      52 if r[1]==r[3] goto 13
   9 Column           0    1    4               00 r[4]=sqlite_master.name
  10 Column           0    3    5               00 r[5]=sqlite_master.rootpage
  11 Column           0    4    6               00 r[6]=sqlite_master.sql
  12 ResultRow        4    3    0               00 output=r[4..6]
  13 Next             0    5    0               01 
  14 Halt             0    0    0               00 
  15 Transaction      0    0    7 0             00 usesStmtJournal=0
  16 String8          0    2    0 field2        00 r[2]='field2'
  17 String8          0    3    0 trigger       00 r[3]='trigger'
  18 Goto             0    1    0               00 
VDBE Trace:
   0 Init             0   15    0               00 Start at 15
  15 Transaction      0    0    7 0             00 usesStmtJournal=0
  16 String8          0    2    0 field2        00 r[2]='field2'
REG[2] =   t6[field2](8)
  17 String8          0    3    0 trigger       00 r[3]='trigger'
REG[3] =   t7[trigger](8)
  18 Goto             0    1    0               00 
   1 Noop             1    5    0               00 
   2 OpenRead         0    1    0 5             00 root=1 iDb=0; sqlite_master
   3 Explain          3    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   14    0               00 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[t0](8)
   6 Ne               2   13    1 (BINARY)      52 if r[1]!=r[2] goto 13
REG[2] =   t6[field2](8)
REG[1] =   s2[t0](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s15[sqlite_sequence](8)
   6 Ne               2   13    1 (BINARY)      52 if r[1]!=r[2] goto 13
REG[2] =   t6[field2](8)
REG[1] =   s15[sqlite_sequence](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s7[test002](8)
   6 Ne               2   13    1 (BINARY)      52 if r[1]!=r[2] goto 13
REG[2] =   t6[field2](8)
REG[1] =   s7[test002](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s6[field2](8)
   6 Ne               2   13    1 (BINARY)      52 if r[1]!=r[2] goto 13
REG[2] =   t6[field2](8)
REG[1] =   s6[field2](8)
   7 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[table](8)
   8 Eq               3   13    1 (BINARY)      52 if r[1]==r[3] goto 13
REG[3] =   t7[trigger](8)
REG[1] =   s5[table](8)
   9 Column           0    1    4               00 r[4]=sqlite_master.name
REG[4] =   s6[field2](8)
  10 Column           0    3    5               00 r[5]=sqlite_master.rootpage
REG[5] =  i:4
  11 Column           0    4    6               00 r[6]=sqlite_master.sql
REG[6] =   s49[CREATE TABLE fi](8)
  12 ResultRow        4    3    0               00 output=r[4..6]
REG[4] =   s6[field2](8)
REG[5] =  i:4
REG[6] =   s49[CREATE TABLE fi](8)
  13 Next             0    5    0               01 
  14 Halt             0    0    0               00 
  27 Halt             0    0    0               00 
SQL: [;
;SELECT test003 FROM test002 WHERE test003 LIKE '%bcd' ORDER BY 1;]
VDBE Program Listing:
   0 Init             0   12    0               00 Start at 12
   1 Noop             1    3    0               00 
   2 OpenRead         0    6    0 0             00 root=6 iDb=0; test002
   3 Explain          3    0    0 SCAN TABLE test002 00 
   4 Rewind           0   11    0               00 
   5 Rowid            0    3    0               00 r[3]=rowid
   6 Function0        1    2    1 like(2)       02 r[1]=func(r[2..3])
   7 IfNot            1   10    1               00 
   8 Rowid            0    4    0               00 r[4]=rowid
   9 ResultRow        4    1    0               00 output=r[4]
  10 Next             0    5    0               01 
  11 Halt             0    0    0               00 
  12 Transaction      0    0    7 0             01 usesStmtJournal=0
  13 String8          0    2    0 %bcd          00 r[2]='%bcd'
  14 Goto             0    1    0               00 
VDBE Trace:
   0 Init             0   12    0               00 Start at 12
  12 Transaction      0    0    7 0             01 usesStmtJournal=0
  13 String8          0    2    0 %bcd          00 r[2]='%bcd'
REG[2] =   t4[%bcd](8)
  14 Goto             0    1    0               00 
   1 Noop             1    3    0               00 
   2 OpenRead         0    6    0 0             00 root=6 iDb=0; test002
   3 Explain          3    0    0 SCAN TABLE test002 00 
   4 Rewind           0   11    0               00 
  11 Halt             0    0    0               00 
SQL: [;SELECT
     (SELECT sum(test003==xyz) FROM test002)
    FROM
     (SELECT c0 as xyz, max(c0) AS pqr
        FROM t0
       GROUP BY c0);]
VDBE Program Listing:
   0 Init             0   68    0               00 Start at 68
   1 InitCoroutine    1   46    2               00 subquery_2
   2 Explain          2    0    0 CO-ROUTINE 2  00 
   3 SorterOpen       3    1    0 k(1,B)        00 
   4 Integer          0    5    0               00 r[5]=0; clear abort flag
   5 Null             0    8    8               00 r[8..8]=NULL
   6 Gosub            7   42    0               00 
   7 OpenRead         1    2    0 1             00 root=2 iDb=0; t0
   8 Explain          8    2    0 SCAN TABLE t0 00 
   9 Rewind           1   15    0               00 
  10 Explain         10    2    0 USE TEMP B-TREE FOR GROUP BY 00 
  11 Column           1    0   10               00 r[10]=t0.c0
  12 MakeRecord      10    1   11               00 r[11]=mkrec(r[10])
  13 SorterInsert     3   11    0               00 key=r[11]
  14 Next             1   10    0               01 
  15 OpenPseudo       4   10    1               00 1 columns in r[10]
  16 SorterSort       3   45    0               00 GROUP BY sort
  17 SorterData       3   10    4               00 r[10]=data
  18 Column           4    0    9               00 r[9]=
  19 Compare          8    9    1 k(1,B)        00 r[8] <-> r[9]
  20 Jump            21   25   21               00 
  21 Move             9    8    1               00 r[8]=r[9]
  22 Gosub            6   36    0               00 output one row
  23 IfPos            5   45    0               00 if r[5]>0 then r[5]-=0, goto 45; check abort flag
  24 Gosub            7   42    0               00 reset accumulator
  25 Column           4    0   11               00 r[11]=
  26 CollSeq         12    0    0 (BINARY)      00 
  27 AggStep          0   11    3 max(1)        01 accum=r[3] step(r[11])
  28 If              12   30    0               00 
  29 Column           4    0    2               00 r[2]=
  30 Integer          1    4    0               00 r[4]=1; indicate data in accumulator
  31 SorterNext       3   17    0               00 
  32 Gosub            6   36    0               00 output final row
  33 Goto             0   45    0               00 
  34 Integer          1    5    0               00 r[5]=1; set abort flag
  35 Return           6    0    0               00 
  36 IfPos            4   38    0               00 if r[4]>0 then r[4]-=0, goto 38; Groupby result generator entry point
  37 Return           6    0    0               00 
  38 AggFinal         3    1    0 max(1)        00 accum=r[3] N=1
  39 Copy             2   13    1               00 r[13..14]=r[2..3]
  40 Yield            1    0    0               00 
  41 Return           6    0    0               00 end groupby result generator
  42 Null             0    2    3               00 r[2..3]=NULL
  43 Integer          0    4    0               00 r[4]=0; indicate accumulator empty
  44 Return           7    0    0               00 
  45 EndCoroutine     1    0    0               00 
  46 Explain         46    0    0 SCAN SUBQUERY 2 00 
  47 InitCoroutine    1    0    2               00 
  48 Yield            1   67    0               00 next row of subquery_2
  49 Explain         49    0    0 CORRELATED SCALAR SUBQUERY 1 00 
  50 Null             0   16   16               00 r[16..16]=NULL; Init subquery result
  51 Integer          1   17    0               00 r[17]=1; LIMIT counter
  52 Null             0   18   19               00 r[18..19]=NULL
  53 OpenRead         2    6    0 0             00 root=6 iDb=0; test002
  54 Explain         54   49    0 SCAN TABLE test002 00 
  55 Rewind           2   61    0               00 
  56 Rowid            2   21    0               00 r[21]=rowid
  57 Copy            13   22    0               00 r[22]=r[13]; subquery_2.xyz
  58 Eq              22   20   21 (BINARY)      63 r[20] = (r[21]==r[22])
  59 AggStep          0   20   18 sum(1)        01 accum=r[18] step(r[20])
  60 Next             2   56    0               01 
  61 AggFinal        18    1    0 sum(1)        00 accum=r[18] N=1
  62 Copy            18   16    0               00 r[16]=r[18]
  63 DecrJumpZero    17   64    0               00 if (--r[17])==0 goto 64
  64 Copy            16   15    0               00 r[15]=r[16]
  65 ResultRow       15    1    0               00 output=r[15]
  66 Goto             0   48    0               00 
  67 Halt             0    0    0               00 
  68 Transaction      0    0    7 0             01 usesStmtJournal=0
  69 Goto             0    1    0               00 
VDBE Trace:
   0 Init             0   68    0               00 Start at 68
  68 Transaction      0    0    7 0             01 usesStmtJournal=0
  69 Goto             0    1    0               00 
   1 InitCoroutine    1   46    2               00 subquery_2
  46 Explain         46    0    0 SCAN SUBQUERY 2 00 
  47 InitCoroutine    1    0    2               00 
  48 Yield            1   67    0               00 next row of subquery_2
REG[1] =  i:1
REG[1] =  i:48
   2 Explain          2    0    0 CO-ROUTINE 2  00 
   3 SorterOpen       3    1    0 k(1,B)        00 
   4 Integer          0    5    0               00 r[5]=0; clear abort flag
REG[5] =  i:0
   5 Null             0    8    8               00 r[8..8]=NULL
REG[8] =  NULL
   6 Gosub            7   42    0               00 
REG[7] =  i:6
  42 Null             0    2    3               00 r[2..3]=NULL
REG[2] =  NULL
  43 Integer          0    4    0               00 r[4]=0; indicate accumulator empty
REG[4] =  i:0
  44 Return           7    0    0               00 
REG[7] =  i:6
   7 OpenRead         1    2    0 1             00 root=2 iDb=0; t0
   8 Explain          8    2    0 SCAN TABLE t0 00 
   9 Rewind           1   15    0               00 
  10 Explain         10    2    0 USE TEMP B-TREE FOR GROUP BY 00 
  11 Column           1    0   10               00 r[10]=t0.c0
REG[10] =  i:1
  12 MakeRecord      10    1   11               00 r[11]=mkrec(r[10])
REG[11] =  s2[0209..]
  13 SorterInsert     3   11    0               00 key=r[11]
REG[11] =  s2[0209..]
  14 Next             1   10    0               01 
  10 Explain         10    2    0 USE TEMP B-TREE FOR GROUP BY 00 
  11 Column           1    0   10               00 r[10]=t0.c0
REG[10] =  i:2
  12 MakeRecord      10    1   11               00 r[11]=mkrec(r[10])
REG[11] =  s3[020102...]
  13 SorterInsert     3   11    0               00 key=r[11]
REG[11] =  s3[020102...]
  14 Next             1   10    0               01 
  10 Explain         10    2    0 USE TEMP B-TREE FOR GROUP BY 00 
  11 Column           1    0   10               00 r[10]=t0.c0
REG[10] =  i:3
  12 MakeRecord      10    1   11               00 r[11]=mkrec(r[10])
REG[11] =  s3[020103...]
  13 SorterInsert     3   11    0               00 key=r[11]
REG[11] =  s3[020103...]
  14 Next             1   10    0               01 
  15 OpenPseudo       4   10    1               00 1 columns in r[10]
  16 SorterSort       3   45    0               00 GROUP BY sort
  17 SorterData       3   10    4               00 r[10]=data
  18 Column           4    0    9               00 r[9]=
REG[9] =  i:1
  19 Compare          8    9    1 k(1,B)        00 r[8] <-> r[9]
REG[8] =  NULL
REG[9] =  i:1
  20 Jump            21   25   21               00 
  21 Move             9    8    1               00 r[8]=r[9]
REG[8] =  i:1
  22 Gosub            6   36    0               00 output one row
REG[6] =  i:22
  36 IfPos            4   38    0               00 if r[4]>0 then r[4]-=0, goto 38; Groupby result generator entry point
REG[4] =  i:0
  37 Return           6    0    0               00 
REG[6] =  i:22
  23 IfPos            5   45    0               00 if r[5]>0 then r[5]-=0, goto 45; check abort flag
REG[5] =  i:0
  24 Gosub            7   42    0               00 reset accumulator
REG[7] =  i:24
  42 Null             0    2    3               00 r[2..3]=NULL
REG[2] =  NULL
  43 Integer          0    4    0               00 r[4]=0; indicate accumulator empty
REG[4] =  i:0
  44 Return           7    0    0               00 
REG[7] =  i:24
  25 Column           4    0   11               00 r[11]=
REG[11] =  i:1
  26 CollSeq         12    0    0 (BINARY)      00 
  27 AggStep          0   11    3 max(1)        01 accum=r[3] step(r[11])
REG[11] =  i:1
  28 If              12   30    0               00 
REG[12] =  i:0
  29 Column           4    0    2               00 r[2]=
REG[2] =  i:1
  30 Integer          1    4    0               00 r[4]=1; indicate data in accumulator
REG[4] =  i:1
  31 SorterNext       3   17    0               00 
  17 SorterData       3   10    4               00 r[10]=data
  18 Column           4    0    9               00 r[9]=
REG[9] =  i:2
  19 Compare          8    9    1 k(1,B)        00 r[8] <-> r[9]
REG[8] =  i:1
REG[9] =  i:2
  20 Jump            21   25   21               00 
  21 Move             9    8    1               00 r[8]=r[9]
REG[8] =  i:2
  22 Gosub            6   36    0               00 output one row
REG[6] =  i:22
  36 IfPos            4   38    0               00 if r[4]>0 then r[4]-=0, goto 38; Groupby result generator entry point
REG[4] =  i:1
  38 AggFinal         3    1    0 max(1)        00 accum=r[3] N=1
  39 Copy             2   13    1               00 r[13..14]=r[2..3]
REG[13] =  i:1
REG[14] =  i:1
  40 Yield            1    0    0               00 
REG[1] =  i:48
REG[1] =  i:40
  49 Explain         49    0    0 CORRELATED SCALAR SUBQUERY 1 00 
  50 Null             0   16   16               00 r[16..16]=NULL; Init subquery result
REG[16] =  NULL
  51 Integer          1   17    0               00 r[17]=1; LIMIT counter
REG[17] =  i:1
  52 Null             0   18   19               00 r[18..19]=NULL
REG[18] =  NULL
  53 OpenRead         2    6    0 0             00 root=6 iDb=0; test002
  54 Explain         54   49    0 SCAN TABLE test002 00 
  55 Rewind           2   61    0               00 
  61 AggFinal        18    1    0 sum(1)        00 accum=r[18] N=1
  62 Copy            18   16    0               00 r[16]=r[18]
REG[16] =  NULL
  63 DecrJumpZero    17   64    0               00 if (--r[17])==0 goto 64
REG[17] =  i:1
  64 Copy            16   15    0               00 r[15]=r[16]
REG[15] =  NULL
  65 ResultRow       15    1    0               00 output=r[15]
REG[15] =  NULL
  66 Goto             0   48    0               00 
  48 Yield            1   67    0               00 next row of subquery_2
REG[1] =  i:40
REG[1] =  i:48
  41 Return           6    0    0               00 end groupby result generator
REG[6] =  i:22
  23 IfPos            5   45    0               00 if r[5]>0 then r[5]-=0, goto 45; check abort flag
REG[5] =  i:0
  24 Gosub            7   42    0               00 reset accumulator
REG[7] =  i:24
  42 Null             0    2    3               00 r[2..3]=NULL
REG[2] =  NULL
  43 Integer          0    4    0               00 r[4]=0; indicate accumulator empty
REG[4] =  i:0
  44 Return           7    0    0               00 
REG[7] =  i:24
  25 Column           4    0   11               00 r[11]=
REG[11] =  i:2
  26 CollSeq         12    0    0 (BINARY)      00 
  27 AggStep1         0   11    3 max(1)        01 accum=r[3] step(r[11])
REG[11] =  i:2
  28 If              12   30    0               00 
REG[12] =  i:0
  29 Column           4    0    2               00 r[2]=
REG[2] =  i:2
  30 Integer          1    4    0               00 r[4]=1; indicate data in accumulator
REG[4] =  i:1
  31 SorterNext       3   17    0               00 
  17 SorterData       3   10    4               00 r[10]=data
  18 Column           4    0    9               00 r[9]=
REG[9] =  i:3
  19 Compare          8    9    1 k(1,B)        00 r[8] <-> r[9]
REG[8] =  i:2
REG[9] =  i:3
  20 Jump            21   25   21               00 
  21 Move             9    8    1               00 r[8]=r[9]
REG[8] =  i:3
  22 Gosub            6   36    0               00 output one row
REG[6] =  i:22
  36 IfPos            4   38    0               00 if r[4]>0 then r[4]-=0, goto 38; Groupby result generator entry point
REG[4] =  i:1
  38 AggFinal         3    1    0 max(1)        00 accum=r[3] N=1
  39 Copy             2   13    1               00 r[13..14]=r[2..3]
REG[13] =  i:2
REG[14] =  i:2
  40 Yield            1    0    0               00 
REG[1] =  i:48
REG[1] =  i:40
  49 Explain         49    0    0 CORRELATED SCALAR SUBQUERY 1 00 
  50 Null             0   16   16               00 r[16..16]=NULL; Init subquery result
REG[16] =  NULL
  51 Integer          1   17    0               00 r[17]=1; LIMIT counter
REG[17] =  i:1
  52 Null             0   18   19               00 r[18..19]=NULL
REG[18] =  NULL
  53 OpenRead         2    6    0 0             00 root=6 iDb=0; test002
  54 Explain         54   49    0 SCAN TABLE test002 00 
  55 Rewind           2   61    0               00 
  61 AggFinal        18    1    0 sum(1)        00 accum=r[18] N=1
  62 Copy            18   16    0               00 r[16]=r[18]
REG[16] =  NULL
  63 DecrJumpZero    17   64    0               00 if (--r[17])==0 goto 64
REG[17] =  i:1
  64 Copy            16   15    0               00 r[15]=r[16]
REG[15] =  NULL
  65 ResultRow       15    1    0               00 output=r[15]
REG[15] =  NULL
  66 Goto             0   48    0               00 
  48 Yield            1   67    0               00 next row of subquery_2
REG[1] =  i:40
REG[1] =  i:48
  41 Return           6    0    0               00 end groupby result generator
REG[6] =  i:22
  23 IfPos            5   45    0               00 if r[5]>0 then r[5]-=0, goto 45; check abort flag
REG[5] =  i:0
  24 Gosub            7   42    0               00 reset accumulator
REG[7] =  i:24
  42 Null             0    2    3               00 r[2..3]=NULL
REG[2] =  NULL
  43 Integer          0    4    0               00 r[4]=0; indicate accumulator empty
REG[4] =  i:0
  44 Return           7    0    0               00 
REG[7] =  i:24
  25 Column           4    0   11               00 r[11]=
REG[11] =  i:3
  26 CollSeq         12    0    0 (BINARY)      00 
  27 AggStep1         0   11    3 max(1)        01 accum=r[3] step(r[11])
REG[11] =  i:3
  28 If              12   30    0               00 
REG[12] =  i:0
  29 Column           4    0    2               00 r[2]=
REG[2] =  i:3
  30 Integer          1    4    0               00 r[4]=1; indicate data in accumulator
REG[4] =  i:1
  31 SorterNext       3   17    0               00 
  32 Gosub            6   36    0               00 output final row
REG[6] =  i:32
  36 IfPos            4   38    0               00 if r[4]>0 then r[4]-=0, goto 38; Groupby result generator entry point
REG[4] =  i:1
  38 AggFinal         3    1    0 max(1)        00 accum=r[3] N=1
  39 Copy             2   13    1               00 r[13..14]=r[2..3]
REG[13] =  i:3
REG[14] =  i:3
  40 Yield            1    0    0               00 
REG[1] =  i:48
REG[1] =  i:40
  49 Explain         49    0    0 CORRELATED SCALAR SUBQUERY 1 00 
  50 Null             0   16   16               00 r[16..16]=NULL; Init subquery result
REG[16] =  NULL
  51 Integer          1   17    0               00 r[17]=1; LIMIT counter
REG[17] =  i:1
  52 Null             0   18   19               00 r[18..19]=NULL
REG[18] =  NULL
  53 OpenRead         2    6    0 0             00 root=6 iDb=0; test002
  54 Explain         54   49    0 SCAN TABLE test002 00 
  55 Rewind           2   61    0               00 
  61 AggFinal        18    1    0 sum(1)        00 accum=r[18] N=1
  62 Copy            18   16    0               00 r[16]=r[18]
REG[16] =  NULL
  63 DecrJumpZero    17   64    0               00 if (--r[17])==0 goto 64
REG[17] =  i:1
  64 Copy            16   15    0               00 r[15]=r[16]
REG[15] =  NULL
  65 ResultRow       15    1    0               00 output=r[15]
REG[15] =  NULL
  66 Goto             0   48    0               00 
  48 Yield            1   67    0               00 next row of subquery_2
REG[1] =  i:40
REG[1] =  i:48
  41 Return           6    0    0               00 end groupby result generator
REG[6] =  i:32
  33 Goto             0   45    0               00 
  45 EndCoroutine     1    0    0               00 
REG[1] =  i:48
  67 Halt             0    0    0               00 
SQL: [;
;SELECT field1 FROM test002 WHERE field1 GLOB 'abcde' ORDER BY 1;]
VDBE Program Listing:
   0 Init             0   20    0               00 Start at 20
   1 SorterOpen       1    3    0 k(1,B)        00 
   2 OpenRead         0    6    0 2             00 root=6 iDb=0; test002
   3 Explain          3    0    0 SCAN TABLE test002 00 
   4 Rewind           0   12    0               00 
   5 Column           0    1    3               00 r[3]=test002.field1
   6 Function0        1    2    1 glob(2)       02 r[1]=func(r[2..3])
   7 IfNot            1   11    1               00 
   8 Column           0    1    4               00 r[4]=test002.field1
   9 MakeRecord       4    1    6               00 r[6]=mkrec(r[4])
  10 SorterInsert     1    6    4 1             00 key=r[6]
  11 Next             0    5    0               01 
  12 Explain         12    0    0 USE TEMP B-TREE FOR ORDER BY 00 
  13 OpenPseudo       2    7    3               00 3 columns in r[7]
  14 SorterSort       1   19    0               00 
  15 SorterData       1    7    2               00 r[7]=data
  16 Column           2    0    5               00 r[5]=field1
  17 ResultRow        5    1    0               00 output=r[5]
  18 SorterNext       1   15    0               00 
  19 Halt             0    0    0               00 
  20 Transaction      0    0    7 0             01 usesStmtJournal=0
  21 String8          0    2    0 abcde         00 r[2]='abcde'
  22 Goto             0    1    0               00 
VDBE Trace:
   0 Init             0   20    0               00 Start at 20
  20 Transaction      0    0    7 0             01 usesStmtJournal=0
  21 String8          0    2    0 abcde         00 r[2]='abcde'
REG[2] =   t5[abcde](8)
  22 Goto             0    1    0               00 
   1 SorterOpen       1    3    0 k(1,B)        00 
   2 OpenRead         0    6    0 2             00 root=6 iDb=0; test002
   3 Explain          3    0    0 SCAN TABLE test002 00 
   4 Rewind           0   12    0               00 
  12 Explain         12    0    0 USE TEMP B-TREE FOR ORDER BY 00 
  13 OpenPseudo       2    7    3               00 3 columns in r[7]
  14 SorterSort       1   19    0               00 
  19 Halt             0    0    0               00 
SQL: [;
;PRAGMA case_sensitive_like=on
;]
VDBE Program Listing:
   0 Init             0    1    0               00 Start at 1
   1 Halt             0    0    0               00 
VDBE Trace:
   0 Init             0    1    0               00 Start at 1
   1 Halt             0    0    0               00 
SQL: [;
;DROP TABLE IF EXISTS field2;]
VDBE Program Listing:
   0 Init             0   38    0               00 Start at 38
   1 Null             0    1    0               00 r[1]=NULL
   2 OpenWrite        0    1    0 5             00 root=1 iDb=0; sqlite_master
   3 Explain          3    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   13    0               00 
   5 Column           0    2    2               00 r[2]=sqlite_master.tbl_name
   6 Ne               3   12    2 (BINARY)      52 if r[2]!=r[3] goto 12
   7 Column           0    0    2               00 r[2]=sqlite_master.type
   8 Eq               4   12    2 (BINARY)      52 if r[2]==r[4] goto 12
   9 Rowid            0    5    0               00 r[5]=rowid
  10 Once             0   11    0               00 
  11 Delete           0    0    0               02 
  12 Next             0    5    0               01 
  13 Destroy          4    2    0               00 
  14 Null             0    6    7               00 r[6..7]=NULL
  15 IfNot            2   24    1               00 
  16 OpenRead         1    1    0 4             00 root=1 iDb=0; sqlite_master
  17 Explain         17    0    0 SCAN TABLE sqlite_master 00 
  18 Rewind           1   24    0               00 
  19 Column           1    3   13               00 r[13]=sqlite_master.rootpage
  20 Ne               2   23   13 (BINARY)      54 if r[13]!=r[2] goto 23
  21 Rowid            1    7    0               00 r[7]=rowid
  22 RowSetAdd        6    7    0               00 rowset(6)=r[7]
  23 Next             1   19    0               01 
  24 OpenWrite        1    1    0 5             00 root=1 iDb=0; sqlite_master
  25 RowSetRead       6   35    7               00 r[7]=rowset(6)
  26 NotExists        1   25    7               00 intkey=r[7]
  27 Column           1    0    8               00 r[8]=sqlite_master.type
  28 Column           1    1    9               00 r[9]=sqlite_master.name
  29 Column           1    2   10               00 r[10]=sqlite_master.tbl_name
  30 Integer          4   11    0               00 r[11]=4
  31 Column           1    4   12               00 r[12]=sqlite_master.sql
  32 MakeRecord       8    5   13 BBBDB         00 r[13]=mkrec(r[8..12])
  33 Insert           1   13    7               00 intkey=r[7] data=r[13]
  34 Goto             0   25    0               00 
  35 DropTable        0    0    0 field2        00 
  36 SetCookie        0    1    8               00 
  37 Halt             0    0    0               00 
  38 Transaction      0    1    7 0             01 usesStmtJournal=1
  39 String8          0    3    0 field2        00 r[3]='field2'
  40 String8          0    4    0 trigger       00 r[4]='trigger'
  41 Goto             0    1    0               00 
VDBE Trace:
   0 Init             0   38    0               00 Start at 38
  38 Transaction      0    1    7 0             01 usesStmtJournal=1
  39 String8          0    3    0 field2        00 r[3]='field2'
REG[3] =   t6[field2](8)
  40 String8          0    4    0 trigger       00 r[4]='trigger'
REG[4] =   t7[trigger](8)
  41 Goto             0    1    0               00 
   1 Null             0    1    0               00 r[1]=NULL
REG[1] =  NULL
   2 OpenWrite        0    1    0 5             00 root=1 iDb=0; sqlite_master
   3 Explain          3    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   13    0               00 
   5 Column           0    2    2               00 r[2]=sqlite_master.tbl_name
REG[2] =   s2[t0](8)
   6 Ne               3   12    2 (BINARY)      52 if r[2]!=r[3] goto 12
REG[3] =   t6[field2](8)
REG[2] =   s2[t0](8)
  12 Next             0    5    0               01 
   5 Column           0    2    2               00 r[2]=sqlite_master.tbl_name
REG[2] =   s15[sqlite_sequence](8)
   6 Ne               3   12    2 (BINARY)      52 if r[2]!=r[3] goto 12
REG[3] =   t6[field2](8)
REG[2] =   s15[sqlite_sequence](8)
  12 Next             0    5    0               01 
   5 Column           0    2    2               00 r[2]=sqlite_master.tbl_name
REG[2] =   s7[test002](8)
   6 Ne               3   12    2 (BINARY)      52 if r[2]!=r[3] goto 12
REG[3] =   t6[field2](8)
REG[2] =   s7[test002](8)
  12 Next             0    5    0               01 
   5 Column           0    2    2               00 r[2]=sqlite_master.tbl_name
REG[2] =   s6[field2](8)
   6 Ne               3   12    2 (BINARY)      52 if r[2]!=r[3] goto 12
REG[3] =   t6[field2](8)
REG[2] =   s6[field2](8)
   7 Column           0    0    2               00 r[2]=sqlite_master.type
REG[2] =   s5[table](8)
   8 Eq               4   12    2 (BINARY)      52 if r[2]==r[4] goto 12
REG[4] =   t7[trigger](8)
REG[2] =   s5[table](8)
   9 Rowid            0    5    0               00 r[5]=rowid
REG[5] =  i:6
  10 Once             0   11    0               00 
  11 Delete           0    0    0               02 
  12 Next             0    5    0               01 
  13 Destroy          4    2    0               00 
REG[2] =  i:0
  14 Null             0    6    7               00 r[6..7]=NULL
REG[6] =  NULL
  15 IfNot            2   24    1               00 
REG[2] =  i:0
  24 OpenWrite        1    1    0 5             00 root=1 iDb=0; sqlite_master
  25 RowSetRead       6   35    7               00 r[7]=rowset(6)
REG[6] =  NULL
REG[7] =  NULL
  35 DropTable        0    0    0 field2        00 
  36 SetCookie        0    1    8               00 
  37 Halt             0    0    0               00 
SQL: [;DROP TABLE IF EXISTS test002;]
VDBE Program Listing:
   0 Init             0   48    0               00 Start at 48
   1 Null             0    1    0               00 r[1]=NULL
   2 OpenWrite        0    5    0 2             00 root=5 iDb=0; sqlite_sequence
   3 Explain          3    0    0 SCAN TABLE sqlite_sequence 00 
   4 Rewind           0   11    0               00 
   5 Column           0    0    2               00 r[2]=sqlite_sequence.name
   6 Ne               3   10    2 (BINARY)      51 if r[2]!=r[3] goto 10
   7 Rowid            0    4    0               00 r[4]=rowid
   8 Once             0    9    0               00 
   9 Delete           0    0    0               02 
  10 Next             0    5    0               01 
  11 Null             0    5    0               00 r[5]=NULL
  12 OpenWrite        1    1    0 5             00 root=1 iDb=0; sqlite_master
  13 Explain         13    0    0 SCAN TABLE sqlite_master 00 
  14 Rewind           1   23    0               00 
  15 Column           1    2    2               00 r[2]=sqlite_master.tbl_name
  16 Ne               3   22    2 (BINARY)      52 if r[2]!=r[3] goto 22
  17 Column           1    0    2               00 r[2]=sqlite_master.type
  18 Eq               6   22    2 (BINARY)      52 if r[2]==r[6] goto 22
  19 Rowid            1    7    0               00 r[7]=rowid
  20 Once             0   21    0               00 
  21 Delete           1    0    0               02 
  22 Next             1   15    0               01 
  23 Destroy          6    2    0               00 
  24 Null             0    8    9               00 r[8..9]=NULL
  25 IfNot            2   34    1               00 
  26 OpenRead         2    1    0 4             00 root=1 iDb=0; sqlite_master
  27 Explain         27    0    0 SCAN TABLE sqlite_master 00 
  28 Rewind           2   34    0               00 
  29 Column           2    3   15               00 r[15]=sqlite_master.rootpage
  30 Ne               2   33   15 (BINARY)      54 if r[15]!=r[2] goto 33
  31 Rowid            2    9    0               00 r[9]=rowid
  32 RowSetAdd        8    9    0               00 rowset(8)=r[9]
  33 Next             2   29    0               01 
  34 OpenWrite        2    1    0 5             00 root=1 iDb=0; sqlite_master
  35 RowSetRead       8   45    9               00 r[9]=rowset(8)
  36 NotExists        2   35    9               00 intkey=r[9]
  37 Column           2    0   10               00 r[10]=sqlite_master.type
  38 Column           2    1   11               00 r[11]=sqlite_master.name
  39 Column           2    2   12               00 r[12]=sqlite_master.tbl_name
  40 Integer          6   13    0               00 r[13]=6
  41 Column           2    4   14               00 r[14]=sqlite_master.sql
  42 MakeRecord      10    5   15 BBBDB         00 r[15]=mkrec(r[10..14])
  43 Insert           2   15    9               00 intkey=r[9] data=r[15]
  44 Goto             0   35    0               00 
  45 DropTable        0    0    0 test002       00 
  46 SetCookie        0    1    9               00 
  47 Halt             0    0    0               00 
  48 Transaction      0    1    8 0             01 usesStmtJournal=1
  49 String8          0    3    0 test002       00 r[3]='test002'
  50 String8          0    6    0 trigger       00 r[6]='trigger'
  51 Goto             0    1    0               00 
VDBE Trace:
   0 Init             0   48    0               00 Start at 48
  48 Transaction      0    1    8 0             01 usesStmtJournal=1
  49 String8          0    3    0 test002       00 r[3]='test002'
REG[3] =   t7[test002](8)
  50 String8          0    6    0 trigger       00 r[6]='trigger'
REG[6] =   t7[trigger](8)
  51 Goto             0    1    0               00 
   1 Null             0    1    0               00 r[1]=NULL
REG[1] =  NULL
   2 OpenWrite        0    5    0 2             00 root=5 iDb=0; sqlite_sequence
   3 Explain          3    0    0 SCAN TABLE sqlite_sequence 00 
   4 Rewind           0   11    0               00 
  11 Null             0    5    0               00 r[5]=NULL
REG[5] =  NULL
  12 OpenWrite        1    1    0 5             00 root=1 iDb=0; sqlite_master
  13 Explain         13    0    0 SCAN TABLE sqlite_master 00 
  14 Rewind           1   23    0               00 
  15 Column           1    2    2               00 r[2]=sqlite_master.tbl_name
REG[2] =   s2[t0](8)
  16 Ne               3   22    2 (BINARY)      52 if r[2]!=r[3] goto 22
REG[3] =   t7[test002](8)
REG[2] =   s2[t0](8)
  22 Next             1   15    0               01 
  15 Column           1    2    2               00 r[2]=sqlite_master.tbl_name
REG[2] =   s15[sqlite_sequence](8)
  16 Ne               3   22    2 (BINARY)      52 if r[2]!=r[3] goto 22
REG[3] =   t7[test002](8)
REG[2] =   s15[sqlite_sequence](8)
  22 Next             1   15    0               01 
  15 Column           1    2    2               00 r[2]=sqlite_master.tbl_name
REG[2] =   s7[test002](8)
  16 Ne               3   22    2 (BINARY)      52 if r[2]!=r[3] goto 22
REG[3] =   t7[test002](8)
REG[2] =   s7[test002](8)
  17 Column           1    0    2               00 r[2]=sqlite_master.type
REG[2] =   s5[table](8)
  18 Eq               6   22    2 (BINARY)      52 if r[2]==r[6] goto 22
REG[6] =   t7[trigger](8)
REG[2] =   s5[table](8)
  19 Rowid            1    7    0               00 r[7]=rowid
REG[7] =  i:5
  20 Once             0   21    0               00 
  21 Delete           1    0    0               02 
  22 Next             1   15    0               01 
  23 Destroy          6    2    0               00 
REG[2] =  i:0
  24 Null             0    8    9               00 r[8..9]=NULL
REG[8] =  NULL
  25 IfNot            2   34    1               00 
REG[2] =  i:0
  34 OpenWrite        2    1    0 5             00 root=1 iDb=0; sqlite_master
  35 RowSetRead       8   45    9               00 r[9]=rowset(8)
REG[8] =  NULL
REG[9] =  NULL
  45 DropTable        0    0    0 test002       00 
  46 SetCookie        0    1    9               00 
  47 Halt             0    0    0               00 
SQL: [;CREATE TABLE v0(following, over);]
VDBE Program Listing:
   0 Init             0   28    0               00 Start at 28
   1 ReadCookie       0    3    2               00 
   2 If               3    5    0               00 
   3 SetCookie        0    2    4               00 
   4 SetCookie        0    5    1               00 
   5 CreateBtree      0    2    1               00 r[2]=root iDb=0 flags=1
   6 OpenWrite        0    1    0 5             00 root=1 iDb=0
   7 NewRowid         0    1    0               00 r[1]=rowid
   8 Blob             6    3    0              00 r[3]= (len=6)
   9 Insert           0    3    1               08 intkey=r[1] data=r[3]
  10 Close            0    0    0               00 
  11 Close            0    0    0               00 
  12 Null             0    4    5               00 r[4..5]=NULL
  13 OpenWrite        1    1    0 5             00 root=1 iDb=0; sqlite_master
  14 Explain         14    0    0 SEARCH TABLE sqlite_master USING INTEGER PRIMARY KEY (rowid=?) 00 
  15 SeekRowid        1   17    1               00 intkey=r[1]
  16 Rowid            1    5    0               00 r[5]=rowid
  17 IsNull           5   25    0               00 if r[5]==NULL goto 25
  18 String8          0    6    0 table         00 r[6]='table'
  19 String8          0    7    0 v0            00 r[7]='v0'
  20 String8          0    8    0 v0            00 r[8]='v0'
  21 Copy             2    9    0               00 r[9]=r[2]
  22 String8          0   10    0 CREATE TABLE v0(following, over) 00 r[10]='CREATE TABLE v0(following, over)'
  23 MakeRecord       6    5   11 BBBDB         00 r[11]=mkrec(r[6..10])
  24 Insert           1   11    5               00 intkey=r[5] data=r[11]
  25 SetCookie        0    1   10               00 
  26 ParseSchema      0    0    0 tbl_name='v0' AND type!='trigger' 00 
  27 Halt             0    0    0               00 
  28 Transaction      0    1    9 0             01 usesStmtJournal=0
  29 Goto             0    1    0               00 
VDBE Trace:
   0 Init             0   28    0               00 Start at 28
  28 Transaction      0    1    9 0             01 usesStmtJournal=0
  29 Goto             0    1    0               00 
   1 ReadCookie       0    3    2               00 
REG[3] =  i:4
   2 If               3    5    0               00 
REG[3] =  i:4
   5 CreateBtree      0    2    1               00 r[2]=root iDb=0 flags=1
REG[2] =  i:4
   6 OpenWrite        0    1    0 5             00 root=1 iDb=0
   7 NewRowid         0    1    0               00 r[1]=rowid
REG[1] =  i:5
   8 Blob             6    3    0              00 r[3]= (len=6)
REG[3] =  t6[060000000000......]
   9 Insert           0    3    1               08 intkey=r[1] data=r[3]
REG[3] =  t6[060000000000......]
REG[1] =  i:5
  10 Close            0    0    0               00 
  11 Close            0    0    0               00 
  12 Null             0    4    5               00 r[4..5]=NULL
REG[4] =  NULL
  13 OpenWrite        1    1    0 5             00 root=1 iDb=0; sqlite_master
  14 Explain         14    0    0 SEARCH TABLE sqlite_master USING INTEGER PRIMARY KEY (rowid=?) 00 
  15 SeekRowid        1   17    1               00 intkey=r[1]
REG[1] =  i:5
  16 Rowid            1    5    0               00 r[5]=rowid
REG[5] =  i:5
  17 IsNull           5   25    0               00 if r[5]==NULL goto 25
REG[5] =  i:5
  18 String8          0    6    0 table         00 r[6]='table'
REG[6] =   t5[table](8)
  19 String8          0    7    0 v0            00 r[7]='v0'
REG[7] =   t2[v0](8)
  20 String8          0    8    0 v0            00 r[8]='v0'
REG[8] =   t2[v0](8)
  21 Copy             2    9    0               00 r[9]=r[2]
REG[9] =  i:4
  22 String8          0   10    0 CREATE TABLE v0(following, over) 00 r[10]='CREATE TABLE v0(following, over)'
REG[10] =   t32[CREATE TABLE v0](8)
  23 MakeRecord       6    5   11 BBBDB         00 r[11]=mkrec(r[6..10])
REG[11] =  s48[06171111014D7461626C657630763004.....Mtablev0v0.]
  24 Insert           1   11    5               00 intkey=r[5] data=r[11]
REG[11] =  s48[06171111014D7461626C657630763004.....Mtablev0v0.]
REG[5] =  i:5
  25 SetCookie        0    1   10               00 
  26 ParseSchema      0    0    0 tbl_name='v0' AND type!='trigger' 00 
VDBE Program Listing:
   0 Init             0   15    0               00 Start at 15
   1 Noop             1    5    0               00 
   2 OpenRead         0    1    0 5             00 root=1 iDb=0; sqlite_master
   3 Explain          3    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   14    0               00 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
   6 Ne               2   13    1 (BINARY)      52 if r[1]!=r[2] goto 13
   7 Column           0    0    1               00 r[1]=sqlite_master.type
   8 Eq               3   13    1 (BINARY)      52 if r[1]==r[3] goto 13
   9 Column           0    1    4               00 r[4]=sqlite_master.name
  10 Column           0    3    5               00 r[5]=sqlite_master.rootpage
  11 Column           0    4    6               00 r[6]=sqlite_master.sql
  12 ResultRow        4    3    0               00 output=r[4..6]
  13 Next             0    5    0               01 
  14 Halt             0    0    0               00 
  15 Transaction      0    0   10 0             00 usesStmtJournal=0
  16 String8          0    2    0 v0            00 r[2]='v0'
  17 String8          0    3    0 trigger       00 r[3]='trigger'
  18 Goto             0    1    0               00 
VDBE Trace:
   0 Init             0   15    0               00 Start at 15
  15 Transaction      0    0   10 0             00 usesStmtJournal=0
  16 String8          0    2    0 v0            00 r[2]='v0'
REG[2] =   t2[v0](8)
  17 String8          0    3    0 trigger       00 r[3]='trigger'
REG[3] =   t7[trigger](8)
  18 Goto             0    1    0               00 
   1 Noop             1    5    0               00 
   2 OpenRead         0    1    0 5             00 root=1 iDb=0; sqlite_master
   3 Explain          3    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   14    0               00 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[t0](8)
   6 Ne               2   13    1 (BINARY)      52 if r[1]!=r[2] goto 13
REG[2] =   t2[v0](8)
REG[1] =   s2[t0](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s15[sqlite_sequence](8)
   6 Ne               2   13    1 (BINARY)      52 if r[1]!=r[2] goto 13
REG[2] =   t2[v0](8)
REG[1] =   s15[sqlite_sequence](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[v0](8)
   6 Ne               2   13    1 (BINARY)      52 if r[1]!=r[2] goto 13
REG[2] =   t2[v0](8)
REG[1] =   s2[v0](8)
   7 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[table](8)
   8 Eq               3   13    1 (BINARY)      52 if r[1]==r[3] goto 13
REG[3] =   t7[trigger](8)
REG[1] =   s5[table](8)
   9 Column           0    1    4               00 r[4]=sqlite_master.name
REG[4] =   s2[v0](8)
  10 Column           0    3    5               00 r[5]=sqlite_master.rootpage
REG[5] =  i:4
  11 Column           0    4    6               00 r[6]=sqlite_master.sql
REG[6] =   s32[CREATE TABLE v0](8)
  12 ResultRow        4    3    0               00 output=r[4..6]
REG[4] =   s2[v0](8)
REG[5] =  i:4
REG[6] =   s32[CREATE TABLE v0](8)
  13 Next             0    5    0               01 
  14 Halt             0    0    0               00 
  27 Halt             0    0    0               00 
SQL: [;CREATE TABLE preceding (t1);]
VDBE Program Listing:
   0 Init             0   28    0               00 Start at 28
   1 ReadCookie       0    3    2               00 
   2 If               3    5    0               00 
   3 SetCookie        0    2    4               00 
   4 SetCookie        0    5    1               00 
   5 CreateBtree      0    2    1               00 r[2]=root iDb=0 flags=1
   6 OpenWrite        0    1    0 5             00 root=1 iDb=0
   7 NewRowid         0    1    0               00 r[1]=rowid
   8 Blob             6    3    0              00 r[3]= (len=6)
   9 Insert           0    3    1               08 intkey=r[1] data=r[3]
  10 Close            0    0    0               00 
  11 Close            0    0    0               00 
  12 Null             0    4    5               00 r[4..5]=NULL
  13 OpenWrite        1    1    0 5             00 root=1 iDb=0; sqlite_master
  14 Explain         14    0    0 SEARCH TABLE sqlite_master USING INTEGER PRIMARY KEY (rowid=?) 00 
  15 SeekRowid        1   17    1               00 intkey=r[1]
  16 Rowid            1    5    0               00 r[5]=rowid
  17 IsNull           5   25    0               00 if r[5]==NULL goto 25
  18 String8          0    6    0 table         00 r[6]='table'
  19 String8          0    7    0 preceding     00 r[7]='preceding'
  20 String8          0    8    0 preceding     00 r[8]='preceding'
  21 Copy             2    9    0               00 r[9]=r[2]
  22 String8          0   10    0 CREATE TABLE preceding (t1) 00 r[10]='CREATE TABLE preceding (t1)'
  23 MakeRecord       6    5   11 BBBDB         00 r[11]=mkrec(r[6..10])
  24 Insert           1   11    5               00 intkey=r[5] data=r[11]
  25 SetCookie        0    1   11               00 
  26 ParseSchema      0    0    0 tbl_name='preceding' AND type!='trigger' 00 
  27 Halt             0    0    0               00 
  28 Transaction      0    1   10 0             01 usesStmtJournal=0
  29 Goto             0    1    0               00 
VDBE Trace:
   0 Init             0   28    0               00 Start at 28
  28 Transaction      0    1   10 0             01 usesStmtJournal=0
  29 Goto             0    1    0               00 
   1 ReadCookie       0    3    2               00 
REG[3] =  i:4
   2 If               3    5    0               00 
REG[3] =  i:4
   5 CreateBtree      0    2    1               00 r[2]=root iDb=0 flags=1
REG[2] =  i:6
   6 OpenWrite        0    1    0 5             00 root=1 iDb=0
   7 NewRowid         0    1    0               00 r[1]=rowid
REG[1] =  i:6
   8 Blob             6    3    0              00 r[3]= (len=6)
REG[3] =  t6[060000000000......]
   9 Insert           0    3    1               08 intkey=r[1] data=r[3]
REG[3] =  t6[060000000000......]
REG[1] =  i:6
  10 Close            0    0    0               00 
  11 Close            0    0    0               00 
  12 Null             0    4    5               00 r[4..5]=NULL
REG[4] =  NULL
  13 OpenWrite        1    1    0 5             00 root=1 iDb=0; sqlite_master
  14 Explain         14    0    0 SEARCH TABLE sqlite_master USING INTEGER PRIMARY KEY (rowid=?) 00 
  15 SeekRowid        1   17    1               00 intkey=r[1]
REG[1] =  i:6
  16 Rowid            1    5    0               00 r[5]=rowid
REG[5] =  i:6
  17 IsNull           5   25    0               00 if r[5]==NULL goto 25
REG[5] =  i:6
  18 String8          0    6    0 table         00 r[6]='table'
REG[6] =   t5[table](8)
  19 String8          0    7    0 preceding     00 r[7]='preceding'
REG[7] =   t9[preceding](8)
  20 String8          0    8    0 preceding     00 r[8]='preceding'
REG[8] =   t9[preceding](8)
  21 Copy             2    9    0               00 r[9]=r[2]
REG[9] =  i:6
  22 String8          0   10    0 CREATE TABLE preceding (t1) 00 r[10]='CREATE TABLE preceding (t1)'
REG[10] =   t27[CREATE TABLE pr](8)
  23 MakeRecord       6    5   11 BBBDB         00 r[11]=mkrec(r[6..10])
REG[11] =  s57[06171F1F01437461626C657072656365.....Ctableprece]
  24 Insert           1   11    5               00 intkey=r[5] data=r[11]
REG[11] =  s57[06171F1F01437461626C657072656365.....Ctableprece]
REG[5] =  i:6
  25 SetCookie        0    1   11               00 
  26 ParseSchema      0    0    0 tbl_name='preceding' AND type!='trigger' 00 
VDBE Program Listing:
   0 Init             0   15    0               00 Start at 15
   1 Noop             1    5    0               00 
   2 OpenRead         0    1    0 5             00 root=1 iDb=0; sqlite_master
   3 Explain          3    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   14    0               00 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
   6 Ne               2   13    1 (BINARY)      52 if r[1]!=r[2] goto 13
   7 Column           0    0    1               00 r[1]=sqlite_master.type
   8 Eq               3   13    1 (BINARY)      52 if r[1]==r[3] goto 13
   9 Column           0    1    4               00 r[4]=sqlite_master.name
  10 Column           0    3    5               00 r[5]=sqlite_master.rootpage
  11 Column           0    4    6               00 r[6]=sqlite_master.sql
  12 ResultRow        4    3    0               00 output=r[4..6]
  13 Next             0    5    0               01 
  14 Halt             0    0    0               00 
  15 Transaction      0    0   11 0             00 usesStmtJournal=0
  16 String8          0    2    0 preceding     00 r[2]='preceding'
  17 String8          0    3    0 trigger       00 r[3]='trigger'
  18 Goto             0    1    0               00 
VDBE Trace:
   0 Init             0   15    0               00 Start at 15
  15 Transaction      0    0   11 0             00 usesStmtJournal=0
  16 String8          0    2    0 preceding     00 r[2]='preceding'
REG[2] =   t9[preceding](8)
  17 String8          0    3    0 trigger       00 r[3]='trigger'
REG[3] =   t7[trigger](8)
  18 Goto             0    1    0               00 
   1 Noop             1    5    0               00 
   2 OpenRead         0    1    0 5             00 root=1 iDb=0; sqlite_master
   3 Explain          3    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   14    0               00 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[t0](8)
   6 Ne               2   13    1 (BINARY)      52 if r[1]!=r[2] goto 13
REG[2] =   t9[preceding](8)
REG[1] =   s2[t0](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s15[sqlite_sequence](8)
   6 Ne               2   13    1 (BINARY)      52 if r[1]!=r[2] goto 13
REG[2] =   t9[preceding](8)
REG[1] =   s15[sqlite_sequence](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[v0](8)
   6 Ne               2   13    1 (BINARY)      52 if r[1]!=r[2] goto 13
REG[2] =   t9[preceding](8)
REG[1] =   s2[v0](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s9[preceding](8)
   6 Ne               2   13    1 (BINARY)      52 if r[1]!=r[2] goto 13
REG[2] =   t9[preceding](8)
REG[1] =   s9[preceding](8)
   7 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[table](8)
   8 Eq               3   13    1 (BINARY)      52 if r[1]==r[3] goto 13
REG[3] =   t7[trigger](8)
REG[1] =   s5[table](8)
   9 Column           0    1    4               00 r[4]=sqlite_master.name
REG[4] =   s9[preceding](8)
  10 Column           0    3    5               00 r[5]=sqlite_master.rootpage
REG[5] =  i:6
  11 Column           0    4    6               00 r[6]=sqlite_master.sql
REG[6] =   s27[CREATE TABLE pr](8)
  12 ResultRow        4    3    0               00 output=r[4..6]
REG[4] =   s9[preceding](8)
REG[5] =  i:6
REG[6] =   s27[CREATE TABLE pr](8)
  13 Next             0    5    0               01 
  14 Halt             0    0    0               00 
  27 Halt             0    0    0               00 
SQL: [SELECT t1 FROM preceding WHERE t1 LIKE 'abc%' ORDER BY 1
  
;]
VDBE Program Listing:
   0 Init             0   20    0               00 Start at 20
   1 SorterOpen       1    3    0 k(1,B)        00 
   2 OpenRead         0    6    0 1             00 root=6 iDb=0; preceding
   3 Explain          3    0    0 SCAN TABLE preceding 00 
   4 Rewind           0   12    0               00 
   5 Column           0    0    3               00 r[3]=preceding.t1
   6 Function0        1    2    1 like(2)       02 r[1]=func(r[2..3])
   7 IfNot            1   11    1               00 
   8 Column           0    0    4               00 r[4]=preceding.t1
   9 MakeRecord       4    1    6               00 r[6]=mkrec(r[4])
  10 SorterInsert     1    6    4 1             00 key=r[6]
  11 Next             0    5    0               01 
  12 Explain         12    0    0 USE TEMP B-TREE FOR ORDER BY 00 
  13 OpenPseudo       2    7    3               00 3 columns in r[7]
  14 SorterSort       1   19    0               00 
  15 SorterData       1    7    2               00 r[7]=data
  16 Column           2    0    5               00 r[5]=t1
  17 ResultRow        5    1    0               00 output=r[5]
  18 SorterNext       1   15    0               00 
  19 Halt             0    0    0               00 
  20 Transaction      0    0   11 0             01 usesStmtJournal=0
  21 String8          0    2    0 abc%          00 r[2]='abc%'
  22 Goto             0    1    0               00 
VDBE Trace:
   0 Init             0   20    0               00 Start at 20
  20 Transaction      0    0   11 0             01 usesStmtJournal=0
  21 String8          0    2    0 abc%          00 r[2]='abc%'
REG[2] =   t4[abc%](8)
  22 Goto             0    1    0               00 
   1 SorterOpen       1    3    0 k(1,B)        00 
   2 OpenRead         0    6    0 1             00 root=6 iDb=0; preceding
   3 Explain          3    0    0 SCAN TABLE preceding 00 
   4 Rewind           0   12    0               00 
  12 Explain         12    0    0 USE TEMP B-TREE FOR ORDER BY 00 
  13 OpenPseudo       2    7    3               00 3 columns in r[7]
  14 SorterSort       1   19    0               00 
  19 Halt             0    0    0               00 
SQL: [;SELECT (SELECT sum(t1=t1) FROM preceding), max(t1)
      FROM preceding
     GROUP BY t1;]
VDBE Program Listing:
   0 Init             0   61    0               00 Start at 61
   1 SorterOpen       2    1    0 k(1,B)        00 
   2 Integer          0    4    0               00 r[4]=0; clear abort flag
   3 Null             0    7    7               00 r[7..7]=NULL
   4 Gosub            6   57    0               00 
   5 OpenRead         0    6    0 1             00 root=6 iDb=0; preceding
   6 Explain          6    0    0 SCAN TABLE preceding 00 
   7 Rewind           0   13    0               00 
   8 Explain          8    0    0 USE TEMP B-TREE FOR GROUP BY 00 
   9 Column           0    0    9               00 r[9]=preceding.t1
  10 MakeRecord       9    1   10               00 r[10]=mkrec(r[9])
  11 SorterInsert     2   10    0               00 key=r[10]
  12 Next             0    8    0               01 
  13 OpenPseudo       3    9    1               00 1 columns in r[9]
  14 SorterSort       2   60    0               00 GROUP BY sort
  15 SorterData       2    9    3               00 r[9]=data
  16 Column           3    0    8               00 r[8]=
  17 Compare          7    8    1 k(1,B)        00 r[7] <-> r[8]
  18 Jump            19   23   19               00 
  19 Move             8    7    1               00 r[7]=r[8]
  20 Gosub            5   32    0               00 output one row
  21 IfPos            4   60    0               00 if r[4]>0 then r[4]-=0, goto 60; check abort flag
  22 Gosub            6   57    0               00 reset accumulator
  23 Column           3    0   10               00 r[10]=
  24 CollSeq          0    0    0 (BINARY)      00 
  25 AggStep          0   10    1 max(1)        01 accum=r[1] step(r[10])
  26 Integer          1    3    0               00 r[3]=1; indicate data in accumulator
  27 SorterNext       2   15    0               00 
  28 Gosub            5   32    0               00 output final row
  29 Goto             0   60    0               00 
  30 Integer          1    4    0               00 r[4]=1; set abort flag
  31 Return           5    0    0               00 
  32 IfPos            3   34    0               00 if r[3]>0 then r[3]-=0, goto 34; Groupby result generator entry point
  33 Return           5    0    0               00 
  34 AggFinal         1    1    0 max(1)        00 accum=r[1] N=1
  35 Integer         52   13    0               00 r[13]=52; return address
  36 Once             0   52    0               00 
  37 Explain         37    0    0 SCALAR SUBQUERY 1 00 
  38 Null             0   14   14               00 r[14..14]=NULL; Init subquery result
  39 Integer          1   15    0               00 r[15]=1; LIMIT counter
  40 Null             0   16   17               00 r[16..17]=NULL
  41 OpenRead         1    6    0 1             00 root=6 iDb=0; preceding
  42 Explain         42   37    0 SCAN TABLE preceding 00 
  43 Rewind           1   49    0               00 
  44 Column           1    0   18               00 r[18]=preceding.t1
  45 Column           1    0   19               00 r[19]=preceding.t1
  46 Eq              19   10   18 (BINARY)      61 r[10] = (r[18]==r[19])
  47 AggStep          0   10   16 sum(1)        01 accum=r[16] step(r[10])
  48 Next             1   44    0               01 
  49 AggFinal        16    1    0 sum(1)        00 accum=r[16] N=1
  50 Copy            16   14    0               00 r[14]=r[16]
  51 DecrJumpZero    15   52    0               00 if (--r[15])==0 goto 52
  52 Return          13    0    0               00 
  53 Copy            14   11    0               00 r[11]=r[14]
  54 Copy             1   12    0               00 r[12]=r[1]
  55 ResultRow       11    2    0               00 output=r[11..12]
  56 Return           5    0    0               00 end groupby result generator
  57 Null             0    1    2               00 r[1..2]=NULL
  58 Integer          0    3    0               00 r[3]=0; indicate accumulator empty
  59 Return           6    0    0               00 
  60 Halt             0    0    0               00 
  61 Transaction      0    0   11 0             01 usesStmtJournal=0
  62 Goto             0    1    0               00 
VDBE Trace:
   0 Init             0   61    0               00 Start at 61
  61 Transaction      0    0   11 0             01 usesStmtJournal=0
  62 Goto             0    1    0               00 
   1 SorterOpen       2    1    0 k(1,B)        00 
   2 Integer          0    4    0               00 r[4]=0; clear abort flag
REG[4] =  i:0
   3 Null             0    7    7               00 r[7..7]=NULL
REG[7] =  NULL
   4 Gosub            6   57    0               00 
REG[6] =  i:4
  57 Null             0    1    2               00 r[1..2]=NULL
REG[1] =  NULL
  58 Integer          0    3    0               00 r[3]=0; indicate accumulator empty
REG[3] =  i:0
  59 Return           6    0    0               00 
REG[6] =  i:4
   5 OpenRead         0    6    0 1             00 root=6 iDb=0; preceding
   6 Explain          6    0    0 SCAN TABLE preceding 00 
   7 Rewind           0   13    0               00 
  13 OpenPseudo       3    9    1               00 1 columns in r[9]
  14 SorterSort       2   60    0               00 GROUP BY sort
  60 Halt             0    0    0               00 
SQL: [;
;DROP TABLE IF EXISTS preceding;]
VDBE Program Listing:
   0 Init             0   38    0               00 Start at 38
   1 Null             0    1    0               00 r[1]=NULL
   2 OpenWrite        0    1    0 5             00 root=1 iDb=0; sqlite_master
   3 Explain          3    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   13    0               00 
   5 Column           0    2    2               00 r[2]=sqlite_master.tbl_name
   6 Ne               3   12    2 (BINARY)      52 if r[2]!=r[3] goto 12
   7 Column           0    0    2               00 r[2]=sqlite_master.type
   8 Eq               4   12    2 (BINARY)      52 if r[2]==r[4] goto 12
   9 Rowid            0    5    0               00 r[5]=rowid
  10 Once             0   11    0               00 
  11 Delete           0    0    0               02 
  12 Next             0    5    0               01 
  13 Destroy          6    2    0               00 
  14 Null             0    6    7               00 r[6..7]=NULL
  15 IfNot            2   24    1               00 
  16 OpenRead         1    1    0 4             00 root=1 iDb=0; sqlite_master
  17 Explain         17    0    0 SCAN TABLE sqlite_master 00 
  18 Rewind           1   24    0               00 
  19 Column           1    3   13               00 r[13]=sqlite_master.rootpage
  20 Ne               2   23   13 (BINARY)      54 if r[13]!=r[2] goto 23
  21 Rowid            1    7    0               00 r[7]=rowid
  22 RowSetAdd        6    7    0               00 rowset(6)=r[7]
  23 Next             1   19    0               01 
  24 OpenWrite        1    1    0 5             00 root=1 iDb=0; sqlite_master
  25 RowSetRead       6   35    7               00 r[7]=rowset(6)
  26 NotExists        1   25    7               00 intkey=r[7]
  27 Column           1    0    8               00 r[8]=sqlite_master.type
  28 Column           1    1    9               00 r[9]=sqlite_master.name
  29 Column           1    2   10               00 r[10]=sqlite_master.tbl_name
  30 Integer          6   11    0               00 r[11]=6
  31 Column           1    4   12               00 r[12]=sqlite_master.sql
  32 MakeRecord       8    5   13 BBBDB         00 r[13]=mkrec(r[8..12])
  33 Insert           1   13    7               00 intkey=r[7] data=r[13]
  34 Goto             0   25    0               00 
  35 DropTable        0    0    0 preceding     00 
  36 SetCookie        0    1   12               00 
  37 Halt             0    0    0               00 
  38 Transaction      0    1   11 0             01 usesStmtJournal=1
  39 String8          0    3    0 preceding     00 r[3]='preceding'
  40 String8          0    4    0 trigger       00 r[4]='trigger'
  41 Goto             0    1    0               00 
VDBE Trace:
   0 Init             0   38    0               00 Start at 38
  38 Transaction      0    1   11 0             01 usesStmtJournal=1
  39 String8          0    3    0 preceding     00 r[3]='preceding'
REG[3] =   t9[preceding](8)
  40 String8          0    4    0 trigger       00 r[4]='trigger'
REG[4] =   t7[trigger](8)
  41 Goto             0    1    0               00 
   1 Null             0    1    0               00 r[1]=NULL
REG[1] =  NULL
   2 OpenWrite        0    1    0 5             00 root=1 iDb=0; sqlite_master
   3 Explain          3    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   13    0               00 
   5 Column           0    2    2               00 r[2]=sqlite_master.tbl_name
REG[2] =   s2[t0](8)
   6 Ne               3   12    2 (BINARY)      52 if r[2]!=r[3] goto 12
REG[3] =   t9[preceding](8)
REG[2] =   s2[t0](8)
  12 Next             0    5    0               01 
   5 Column           0    2    2               00 r[2]=sqlite_master.tbl_name
REG[2] =   s15[sqlite_sequence](8)
   6 Ne               3   12    2 (BINARY)      52 if r[2]!=r[3] goto 12
REG[3] =   t9[preceding](8)
REG[2] =   s15[sqlite_sequence](8)
  12 Next             0    5    0               01 
   5 Column           0    2    2               00 r[2]=sqlite_master.tbl_name
REG[2] =   s2[v0](8)
   6 Ne               3   12    2 (BINARY)      52 if r[2]!=r[3] goto 12
REG[3] =   t9[preceding](8)
REG[2] =   s2[v0](8)
  12 Next             0    5    0               01 
   5 Column           0    2    2               00 r[2]=sqlite_master.tbl_name
REG[2] =   s9[preceding](8)
   6 Ne               3   12    2 (BINARY)      52 if r[2]!=r[3] goto 12
REG[3] =   t9[preceding](8)
REG[2] =   s9[preceding](8)
   7 Column           0    0    2               00 r[2]=sqlite_master.type
REG[2] =   s5[table](8)
   8 Eq               4   12    2 (BINARY)      52 if r[2]==r[4] goto 12
REG[4] =   t7[trigger](8)
REG[2] =   s5[table](8)
   9 Rowid            0    5    0               00 r[5]=rowid
REG[5] =  i:6
  10 Once             0   11    0               00 
  11 Delete           0    0    0               02 
  12 Next             0    5    0               01 
  13 Destroy          6    2    0               00 
REG[2] =  i:0
  14 Null             0    6    7               00 r[6..7]=NULL
REG[6] =  NULL
  15 IfNot            2   24    1               00 
REG[2] =  i:0
  24 OpenWrite        1    1    0 5             00 root=1 iDb=0; sqlite_master
  25 RowSetRead       6   35    7               00 r[7]=rowset(6)
REG[6] =  NULL
REG[7] =  NULL
  35 DropTable        0    0    0 preceding     00 
  36 SetCookie        0    1   12               00 
  37 Halt             0    0    0               00 
SQL: [;DROP TABLE IF EXISTS v0;]
VDBE Program Listing:
   0 Init             0   38    0               00 Start at 38
   1 Null             0    1    0               00 r[1]=NULL
   2 OpenWrite        0    1    0 5             00 root=1 iDb=0; sqlite_master
   3 Explain          3    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   13    0               00 
   5 Column           0    2    2               00 r[2]=sqlite_master.tbl_name
   6 Ne               3   12    2 (BINARY)      52 if r[2]!=r[3] goto 12
   7 Column           0    0    2               00 r[2]=sqlite_master.type
   8 Eq               4   12    2 (BINARY)      52 if r[2]==r[4] goto 12
   9 Rowid            0    5    0               00 r[5]=rowid
  10 Once             0   11    0               00 
  11 Delete           0    0    0               02 
  12 Next             0    5    0               01 
  13 Destroy          4    2    0               00 
  14 Null             0    6    7               00 r[6..7]=NULL
  15 IfNot            2   24    1               00 
  16 OpenRead         1    1    0 4             00 root=1 iDb=0; sqlite_master
  17 Explain         17    0    0 SCAN TABLE sqlite_master 00 
  18 Rewind           1   24    0               00 
  19 Column           1    3   13               00 r[13]=sqlite_master.rootpage
  20 Ne               2   23   13 (BINARY)      54 if r[13]!=r[2] goto 23
  21 Rowid            1    7    0               00 r[7]=rowid
  22 RowSetAdd        6    7    0               00 rowset(6)=r[7]
  23 Next             1   19    0               01 
  24 OpenWrite        1    1    0 5             00 root=1 iDb=0; sqlite_master
  25 RowSetRead       6   35    7               00 r[7]=rowset(6)
  26 NotExists        1   25    7               00 intkey=r[7]
  27 Column           1    0    8               00 r[8]=sqlite_master.type
  28 Column           1    1    9               00 r[9]=sqlite_master.name
  29 Column           1    2   10               00 r[10]=sqlite_master.tbl_name
  30 Integer          4   11    0               00 r[11]=4
  31 Column           1    4   12               00 r[12]=sqlite_master.sql
  32 MakeRecord       8    5   13 BBBDB         00 r[13]=mkrec(r[8..12])
  33 Insert           1   13    7               00 intkey=r[7] data=r[13]
  34 Goto             0   25    0               00 
  35 DropTable        0    0    0 v0            00 
  36 SetCookie        0    1   13               00 
  37 Halt             0    0    0               00 
  38 Transaction      0    1   12 0             01 usesStmtJournal=1
  39 String8          0    3    0 v0            00 r[3]='v0'
  40 String8          0    4    0 trigger       00 r[4]='trigger'
  41 Goto             0    1    0               00 
VDBE Trace:
   0 Init             0   38    0               00 Start at 38
  38 Transaction      0    1   12 0             01 usesStmtJournal=1
  39 String8          0    3    0 v0            00 r[3]='v0'
REG[3] =   t2[v0](8)
  40 String8          0    4    0 trigger       00 r[4]='trigger'
REG[4] =   t7[trigger](8)
  41 Goto             0    1    0               00 
   1 Null             0    1    0               00 r[1]=NULL
REG[1] =  NULL
   2 OpenWrite        0    1    0 5             00 root=1 iDb=0; sqlite_master
   3 Explain          3    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   13    0               00 
   5 Column           0    2    2               00 r[2]=sqlite_master.tbl_name
REG[2] =   s2[t0](8)
   6 Ne               3   12    2 (BINARY)      52 if r[2]!=r[3] goto 12
REG[3] =   t2[v0](8)
REG[2] =   s2[t0](8)
  12 Next             0    5    0               01 
   5 Column           0    2    2               00 r[2]=sqlite_master.tbl_name
REG[2] =   s15[sqlite_sequence](8)
   6 Ne               3   12    2 (BINARY)      52 if r[2]!=r[3] goto 12
REG[3] =   t2[v0](8)
REG[2] =   s15[sqlite_sequence](8)
  12 Next             0    5    0               01 
   5 Column           0    2    2               00 r[2]=sqlite_master.tbl_name
REG[2] =   s2[v0](8)
   6 Ne               3   12    2 (BINARY)      52 if r[2]!=r[3] goto 12
REG[3] =   t2[v0](8)
REG[2] =   s2[v0](8)
   7 Column           0    0    2               00 r[2]=sqlite_master.type
REG[2] =   s5[table](8)
   8 Eq               4   12    2 (BINARY)      52 if r[2]==r[4] goto 12
REG[4] =   t7[trigger](8)
REG[2] =   s5[table](8)
   9 Rowid            0    5    0               00 r[5]=rowid
REG[5] =  i:5
  10 Once             0   11    0               00 
  11 Delete           0    0    0               02 
  12 Next             0    5    0               01 
  13 Destroy          4    2    0               00 
REG[2] =  i:0
  14 Null             0    6    7               00 r[6..7]=NULL
REG[6] =  NULL
  15 IfNot            2   24    1               00 
REG[2] =  i:0
  24 OpenWrite        1    1    0 5             00 root=1 iDb=0; sqlite_master
  25 RowSetRead       6   35    7               00 r[7]=rowset(6)
REG[6] =  NULL
REG[7] =  NULL
  35 DropTable        0    0    0 v0            00 
  36 SetCookie        0    1   13               00 
  37 Halt             0    0    0               00 
SQL: [;CREATE TABLE v0(following, over);]
VDBE Program Listing:
   0 Init             0   28    0               00 Start at 28
   1 ReadCookie       0    3    2               00 
   2 If               3    5    0               00 
   3 SetCookie        0    2    4               00 
   4 SetCookie        0    5    1               00 
   5 CreateBtree      0    2    1               00 r[2]=root iDb=0 flags=1
   6 OpenWrite        0    1    0 5             00 root=1 iDb=0
   7 NewRowid         0    1    0               00 r[1]=rowid
   8 Blob             6    3    0              00 r[3]= (len=6)
   9 Insert           0    3    1               08 intkey=r[1] data=r[3]
  10 Close            0    0    0               00 
  11 Close            0    0    0               00 
  12 Null             0    4    5               00 r[4..5]=NULL
  13 OpenWrite        1    1    0 5             00 root=1 iDb=0; sqlite_master
  14 Explain         14    0    0 SEARCH TABLE sqlite_master USING INTEGER PRIMARY KEY (rowid=?) 00 
  15 SeekRowid        1   17    1               00 intkey=r[1]
  16 Rowid            1    5    0               00 r[5]=rowid
  17 IsNull           5   25    0               00 if r[5]==NULL goto 25
  18 String8          0    6    0 table         00 r[6]='table'
  19 String8          0    7    0 v0            00 r[7]='v0'
  20 String8          0    8    0 v0            00 r[8]='v0'
  21 Copy             2    9    0               00 r[9]=r[2]
  22 String8          0   10    0 CREATE TABLE v0(following, over) 00 r[10]='CREATE TABLE v0(following, over)'
  23 MakeRecord       6    5   11 BBBDB         00 r[11]=mkrec(r[6..10])
  24 Insert           1   11    5               00 intkey=r[5] data=r[11]
  25 SetCookie        0    1   14               00 
  26 ParseSchema      0    0    0 tbl_name='v0' AND type!='trigger' 00 
  27 Halt             0    0    0               00 
  28 Transaction      0    1   13 0             01 usesStmtJournal=0
  29 Goto             0    1    0               00 
VDBE Trace:
   0 Init             0   28    0               00 Start at 28
  28 Transaction      0    1   13 0             01 usesStmtJournal=0
  29 Goto             0    1    0               00 
   1 ReadCookie       0    3    2               00 
REG[3] =  i:4
   2 If               3    5    0               00 
REG[3] =  i:4
   5 CreateBtree      0    2    1               00 r[2]=root iDb=0 flags=1
REG[2] =  i:4
   6 OpenWrite        0    1    0 5             00 root=1 iDb=0
   7 NewRowid         0    1    0               00 r[1]=rowid
REG[1] =  i:5
   8 Blob             6    3    0              00 r[3]= (len=6)
REG[3] =  t6[060000000000......]
   9 Insert           0    3    1               08 intkey=r[1] data=r[3]
REG[3] =  t6[060000000000......]
REG[1] =  i:5
  10 Close            0    0    0               00 
  11 Close            0    0    0               00 
  12 Null             0    4    5               00 r[4..5]=NULL
REG[4] =  NULL
  13 OpenWrite        1    1    0 5             00 root=1 iDb=0; sqlite_master
  14 Explain         14    0    0 SEARCH TABLE sqlite_master USING INTEGER PRIMARY KEY (rowid=?) 00 
  15 SeekRowid        1   17    1               00 intkey=r[1]
REG[1] =  i:5
  16 Rowid            1    5    0               00 r[5]=rowid
REG[5] =  i:5
  17 IsNull           5   25    0               00 if r[5]==NULL goto 25
REG[5] =  i:5
  18 String8          0    6    0 table         00 r[6]='table'
REG[6] =   t5[table](8)
  19 String8          0    7    0 v0            00 r[7]='v0'
REG[7] =   t2[v0](8)
  20 String8          0    8    0 v0            00 r[8]='v0'
REG[8] =   t2[v0](8)
  21 Copy             2    9    0               00 r[9]=r[2]
REG[9] =  i:4
  22 String8          0   10    0 CREATE TABLE v0(following, over) 00 r[10]='CREATE TABLE v0(following, over)'
REG[10] =   t32[CREATE TABLE v0](8)
  23 MakeRecord       6    5   11 BBBDB         00 r[11]=mkrec(r[6..10])
REG[11] =  s48[06171111014D7461626C657630763004.....Mtablev0v0.]
  24 Insert           1   11    5               00 intkey=r[5] data=r[11]
REG[11] =  s48[06171111014D7461626C657630763004.....Mtablev0v0.]
REG[5] =  i:5
  25 SetCookie        0    1   14               00 
  26 ParseSchema      0    0    0 tbl_name='v0' AND type!='trigger' 00 
VDBE Program Listing:
   0 Init             0   15    0               00 Start at 15
   1 Noop             1    5    0               00 
   2 OpenRead         0    1    0 5             00 root=1 iDb=0; sqlite_master
   3 Explain          3    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   14    0               00 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
   6 Ne               2   13    1 (BINARY)      52 if r[1]!=r[2] goto 13
   7 Column           0    0    1               00 r[1]=sqlite_master.type
   8 Eq               3   13    1 (BINARY)      52 if r[1]==r[3] goto 13
   9 Column           0    1    4               00 r[4]=sqlite_master.name
  10 Column           0    3    5               00 r[5]=sqlite_master.rootpage
  11 Column           0    4    6               00 r[6]=sqlite_master.sql
  12 ResultRow        4    3    0               00 output=r[4..6]
  13 Next             0    5    0               01 
  14 Halt             0    0    0               00 
  15 Transaction      0    0   14 0             00 usesStmtJournal=0
  16 String8          0    2    0 v0            00 r[2]='v0'
  17 String8          0    3    0 trigger       00 r[3]='trigger'
  18 Goto             0    1    0               00 
VDBE Trace:
   0 Init             0   15    0               00 Start at 15
  15 Transaction      0    0   14 0             00 usesStmtJournal=0
  16 String8          0    2    0 v0            00 r[2]='v0'
REG[2] =   t2[v0](8)
  17 String8          0    3    0 trigger       00 r[3]='trigger'
REG[3] =   t7[trigger](8)
  18 Goto             0    1    0               00 
   1 Noop             1    5    0               00 
   2 OpenRead         0    1    0 5             00 root=1 iDb=0; sqlite_master
   3 Explain          3    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   14    0               00 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[t0](8)
   6 Ne               2   13    1 (BINARY)      52 if r[1]!=r[2] goto 13
REG[2] =   t2[v0](8)
REG[1] =   s2[t0](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s15[sqlite_sequence](8)
   6 Ne               2   13    1 (BINARY)      52 if r[1]!=r[2] goto 13
REG[2] =   t2[v0](8)
REG[1] =   s15[sqlite_sequence](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[v0](8)
   6 Ne               2   13    1 (BINARY)      52 if r[1]!=r[2] goto 13
REG[2] =   t2[v0](8)
REG[1] =   s2[v0](8)
   7 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[table](8)
   8 Eq               3   13    1 (BINARY)      52 if r[1]==r[3] goto 13
REG[3] =   t7[trigger](8)
REG[1] =   s5[table](8)
   9 Column           0    1    4               00 r[4]=sqlite_master.name
REG[4] =   s2[v0](8)
  10 Column           0    3    5               00 r[5]=sqlite_master.rootpage
REG[5] =  i:4
  11 Column           0    4    6               00 r[6]=sqlite_master.sql
REG[6] =   s32[CREATE TABLE v0](8)
  12 ResultRow        4    3    0               00 output=r[4..6]
REG[4] =   s2[v0](8)
REG[5] =  i:4
REG[6] =   s32[CREATE TABLE v0](8)
  13 Next             0    5    0               01 
  14 Halt             0    0    0               00 
  27 Halt             0    0    0               00 
SQL: [;CREATE INDEX preceding ON t0(c0 COLLATE NOCASE);]
VDBE Program Listing:
   0 Init             0   33    0               00 Start at 33
   1 Noop             0   32    0               00 
   2 CreateBtree      0    1    2               00 r[1]=root iDb=0 flags=2
   3 OpenWrite        0    1    0 5             00 root=1 iDb=0; sqlite_master
   4 NewRowid         0    2    0               00 r[2]=rowid
   5 String8          0    3    0 index         00 r[3]='index'
   6 String8          0    4    0 preceding     00 r[4]='preceding'
   7 String8          0    5    0 t0            00 r[5]='t0'
   8 Copy             1    6    0               00 r[6]=r[1]
   9 String8          0    7    0 CREATE INDEX preceding ON t0(c0 COLLATE NOCASE) 00 r[7]='CREATE INDEX preceding ON t0(c0 COLLATE NOCASE)'
  10 MakeRecord       3    5    8 BBBDB         00 r[8]=mkrec(r[3..7])
  11 Insert           0    8    2               18 intkey=r[2] data=r[8]
  12 SorterOpen       3    0    1 k(2,NOCASE,)  00 
  13 OpenRead         1    2    0 1             00 root=2 iDb=0; t0
  14 Rewind           1   20    0               00 
  15 Column           1    0   10               00 r[10]=t0.c0
  16 Rowid            1   11    0               00 r[11]=rowid
  17 MakeRecord      10    2    9               00 r[9]=mkrec(r[10..11])
  18 SorterInsert     3    9    0               00 key=r[9]
  19 Next             1   15    0               00 
  20 OpenWrite        2    1    0 k(2,NOCASE,)  11 root=1 iDb=0
  21 SorterSort       3   26    0               00 
  22 SorterData       3    9    2               00 r[9]=data
  23 SeekEnd          2    0    0               00 
  24 IdxInsert        2    9    0               10 key=r[9]
  25 SorterNext       3   22    0               00 
  26 Close            1    0    0               00 
  27 Close            2    0    0               00 
  28 Close            3    0    0               00 
  29 SetCookie        0    1   15               00 
  30 ParseSchema      0    0    0 name='preceding' AND type='index' 00 
  31 Expire           0    1    0               00 
  32 Halt             0    0    0               00 
  33 Transaction      0    1   14 0             01 usesStmtJournal=0
  34 Goto             0    1    0               00 
VDBE Trace:
   0 Init             0   33    0               00 Start at 33
  33 Transaction      0    1   14 0             01 usesStmtJournal=0
  34 Goto             0    1    0               00 
   1 Noop             0   32    0               00 
   2 CreateBtree      0    1    2               00 r[1]=root iDb=0 flags=2
REG[1] =  i:6
   3 OpenWrite        0    1    0 5             00 root=1 iDb=0; sqlite_master
   4 NewRowid         0    2    0               00 r[2]=rowid
REG[2] =  i:6
   5 String8          0    3    0 index         00 r[3]='index'
REG[3] =   t5[index](8)
   6 String8          0    4    0 preceding     00 r[4]='preceding'
REG[4] =   t9[preceding](8)
   7 String8          0    5    0 t0            00 r[5]='t0'
REG[5] =   t2[t0](8)
   8 Copy             1    6    0               00 r[6]=r[1]
REG[6] =  i:6
   9 String8          0    7    0 CREATE INDEX preceding ON t0(c0 COLLATE NOCASE) 00 r[7]='CREATE INDEX preceding ON t0(c0 COLLATE NOCASE)'
REG[7] =   t47[CREATE INDEX pr](8)
  10 MakeRecord       3    5    8 BBBDB         00 r[8]=mkrec(r[3..7])
REG[8] =  s70[06171F11016B696E6465787072656365.....kindexprece]
  11 Insert           0    8    2               18 intkey=r[2] data=r[8]
REG[8] =  s70[06171F11016B696E6465787072656365.....kindexprece]
REG[2] =  i:6
  12 SorterOpen       3    0    1 k(2,NOCASE,)  00 
  13 OpenRead         1    2    0 1             00 root=2 iDb=0; t0
  14 Rewind           1   20    0               00 
  15 Column           1    0   10               00 r[10]=t0.c0
REG[10] =  i:1
  16 Rowid            1   11    0               00 r[11]=rowid
REG[11] =  i:1
  17 MakeRecord      10    2    9               00 r[9]=mkrec(r[10..11])
REG[9] =  s3[030909...]
  18 SorterInsert     3    9    0               00 key=r[9]
REG[9] =  s3[030909...]
  19 Next             1   15    0               00 
  15 Column           1    0   10               00 r[10]=t0.c0
REG[10] =  i:2
  16 Rowid            1   11    0               00 r[11]=rowid
REG[11] =  i:2
  17 MakeRecord      10    2    9               00 r[9]=mkrec(r[10..11])
REG[9] =  s5[0301010202.....]
  18 SorterInsert     3    9    0               00 key=r[9]
REG[9] =  s5[0301010202.....]
  19 Next             1   15    0               00 
  15 Column           1    0   10               00 r[10]=t0.c0
REG[10] =  i:3
  16 Rowid            1   11    0               00 r[11]=rowid
REG[11] =  i:3
  17 MakeRecord      10    2    9               00 r[9]=mkrec(r[10..11])
REG[9] =  s5[0301010303.....]
  18 SorterInsert     3    9    0               00 key=r[9]
REG[9] =  s5[0301010303.....]
  19 Next             1   15    0               00 
  20 OpenWrite        2    1    0 k(2,NOCASE,)  11 root=1 iDb=0
  21 SorterSort       3   26    0               00 
  22 SorterData       3    9    2               00 r[9]=data
  23 SeekEnd          2    0    0               00 
  24 IdxInsert        2    9    0               10 key=r[9]
REG[9] =  s3[030909...]
  25 SorterNext       3   22    0               00 
  22 SorterData       3    9    2               00 r[9]=data
  23 SeekEnd          2    0    0               00 
  24 IdxInsert        2    9    0               10 key=r[9]
REG[9] =  s5[0301010202.....]
  25 SorterNext       3   22    0               00 
  22 SorterData       3    9    2               00 r[9]=data
  23 SeekEnd          2    0    0               00 
  24 IdxInsert        2    9    0               10 key=r[9]
REG[9] =  s5[0301010303.....]
  25 SorterNext       3   22    0               00 
  26 Close            1    0    0               00 
  27 Close            2    0    0               00 
  28 Close            3    0    0               00 
  29 SetCookie        0    1   15               00 
  30 ParseSchema      0    0    0 name='preceding' AND type='index' 00 
VDBE Program Listing:
   0 Init             0   15    0               00 Start at 15
   1 Noop             1    5    0               00 
   2 OpenRead         0    1    0 5             00 root=1 iDb=0; sqlite_master
   3 Explain          3    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   14    0               00 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
   6 Ne               2   13    1 (BINARY)      52 if r[1]!=r[2] goto 13
   7 Column           0    0    1               00 r[1]=sqlite_master.type
   8 Ne               3   13    1 (BINARY)      52 if r[1]!=r[3] goto 13
   9 Column           0    1    4               00 r[4]=sqlite_master.name
  10 Column           0    3    5               00 r[5]=sqlite_master.rootpage
  11 Column           0    4    6               00 r[6]=sqlite_master.sql
  12 ResultRow        4    3    0               00 output=r[4..6]
  13 Next             0    5    0               01 
  14 Halt             0    0    0               00 
  15 Transaction      0    0   15 0             00 usesStmtJournal=0
  16 String8          0    2    0 preceding     00 r[2]='preceding'
  17 String8          0    3    0 index         00 r[3]='index'
  18 Goto             0    1    0               00 
VDBE Trace:
   0 Init             0   15    0               00 Start at 15
  15 Transaction      0    0   15 0             00 usesStmtJournal=0
  16 String8          0    2    0 preceding     00 r[2]='preceding'
REG[2] =   t9[preceding](8)
  17 String8          0    3    0 index         00 r[3]='index'
REG[3] =   t5[index](8)
  18 Goto             0    1    0               00 
   1 Noop             1    5    0               00 
   2 OpenRead         0    1    0 5             00 root=1 iDb=0; sqlite_master
   3 Explain          3    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   14    0               00 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s2[t0](8)
   6 Ne               2   13    1 (BINARY)      52 if r[1]!=r[2] goto 13
REG[2] =   t9[preceding](8)
REG[1] =   s2[t0](8)
  13 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s15[sqlite_sequence](8)
   6 Ne               2   13    1 (BINARY)      52 if r[1]!=r[2] goto 13
REG[2] =   t9[preceding](8)
REG[1] =   s15[sqlite_sequence](8)
  13 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s2[v0](8)
   6 Ne               2   13    1 (BINARY)      52 if r[1]!=r[2] goto 13
REG[2] =   t9[preceding](8)
REG[1] =   s2[v0](8)
  13 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s9[preceding](8)
   6 Ne               2   13    1 (BINARY)      52 if r[1]!=r[2] goto 13
REG[2] =   t9[preceding](8)
REG[1] =   s9[preceding](8)
   7 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[index](8)
   8 Ne               3   13    1 (BINARY)      52 if r[1]!=r[3] goto 13
REG[3] =   t5[index](8)
REG[1] =   s5[index](8)
   9 Column           0    1    4               00 r[4]=sqlite_master.name
REG[4] =   s9[preceding](8)
  10 Column           0    3    5               00 r[5]=sqlite_master.rootpage
REG[5] =  i:6
  11 Column           0    4    6               00 r[6]=sqlite_master.sql
REG[6] =   s47[CREATE INDEX pr](8)
  12 ResultRow        4    3    0               00 output=r[4..6]
REG[4] =   s9[preceding](8)
REG[5] =  i:6
REG[6] =   s47[CREATE INDEX pr](8)
  13 Next             0    5    0               01 
  14 Halt             0    0    0               00 
  31 Expire           0    1    0               00 
  32 Halt             0    0    0               00 
SQL: [PRAGMA case_sensitive_like=on;]
VDBE Program Listing:
   0 Init             0    1    0               00 Start at 1
   1 Halt             0    0    0               00 
VDBE Trace:
   0 Init             0    1    0               00 Start at 1
   1 Halt             0    0    0               00 
SQL: [SELECT c0 FROM t0 WHERE c0 LIKE 'ABC%' ORDER BY 1
  
;]
VDBE Program Listing:
   0 Init             0   20    0               00 Start at 20
   1 SorterOpen       1    3    0 k(1,B)        00 
   2 OpenRead         0    2    0 1             00 root=2 iDb=0; t0
   3 Explain          3    0    0 SCAN TABLE t0 00 
   4 Rewind           0   12    0               00 
   5 Column           0    0    3               00 r[3]=t0.c0
   6 Function0        1    2    1 like(2)       02 r[1]=func(r[2..3])
   7 IfNot            1   11    1               00 
   8 Column           0    0    4               00 r[4]=t0.c0
   9 MakeRecord       4    1    6               00 r[6]=mkrec(r[4])
  10 SorterInsert     1    6    4 1             00 key=r[6]
  11 Next             0    5    0               01 
  12 Explain         12    0    0 USE TEMP B-TREE FOR ORDER BY 00 
  13 OpenPseudo       2    7    3               00 3 columns in r[7]
  14 SorterSort       1   19    0               00 
  15 SorterData       1    7    2               00 r[7]=data
  16 Column           2    0    5               00 r[5]=c0
  17 ResultRow        5    1    0               00 output=r[5]
  18 SorterNext       1   15    0               00 
  19 Halt             0    0    0               00 
  20 Transaction      0    0   15 0             01 usesStmtJournal=0
  21 String8          0    2    0 ABC%          00 r[2]='ABC%'
  22 Goto             0    1    0               00 
VDBE Trace:
   0 Init             0   20    0               00 Start at 20
  20 Transaction      0    0   15 0             01 usesStmtJournal=0
  21 String8          0    2    0 ABC%          00 r[2]='ABC%'
REG[2] =   t4[ABC%](8)
  22 Goto             0    1    0               00 
   1 SorterOpen       1    3    0 k(1,B)        00 
   2 OpenRead         0    2    0 1             00 root=2 iDb=0; t0
   3 Explain          3    0    0 SCAN TABLE t0 00 
   4 Rewind           0   12    0               00 
   5 Column           0    0    3               00 r[3]=t0.c0
REG[3] =  i:1
   6 Function0        1    2    1 like(2)       02 r[1]=func(r[2..3])
REG[2] =   t4[ABC%](8)
REG[3] =  i:1
REG[1] =  i:0
   7 IfNot            1   11    1               00 
REG[1] =  i:0
  11 Next             0    5    0               01 
   5 Column           0    0    3               00 r[3]=t0.c0
REG[3] =  i:2
   6 Function         1    2    1 like(2)       02 r[1]=func(r[2..3])
REG[2] =   t4[ABC%](8)
REG[3] =  i:2
REG[1] =  i:0
   7 IfNot            1   11    1               00 
REG[1] =  i:0
  11 Next             0    5    0               01 
   5 Column           0    0    3               00 r[3]=t0.c0
REG[3] =  i:3
   6 Function         1    2    1 like(2)       02 r[1]=func(r[2..3])
REG[2] =   t4[ABC%](8)
REG[3] =  i:3
REG[1] =  i:0
   7 IfNot            1   11    1               00 
REG[1] =  i:0
  11 Next             0    5    0               01 
  12 Explain         12    0    0 USE TEMP B-TREE FOR ORDER BY 00 
  13 OpenPseudo       2    7    3               00 3 columns in r[7]
  14 SorterSort       1   19    0               00 
  19 Halt             0    0    0               00 
SQL: [;INSERT INTO t0 SELECT c0 FROM t0;]
VDBE Program Listing:
   0 Init             0   31    0               00 Start at 31
   1 InitCoroutine    3    9    2               00 
   2 OpenRead         0    2    0 1             00 root=2 iDb=0; t0
   3 Explain          3    0    0 SCAN TABLE t0 00 
   4 Rewind           0    8    0               00 
   5 Column           0    0    2               00 r[2]=t0.c0
   6 Yield            3    0    0               00 
   7 Next             0    5    0               01 
   8 EndCoroutine     3    0    0               00 
   9 OpenEphemeral    1    1    0               00 nColumn=1
  10 Yield            3   15    0               00 
  11 MakeRecord       2    1    4               00 r[4]=mkrec(r[2])
  12 NewRowid         1    5    0               00 r[5]=rowid
  13 Insert           1    4    5               00 intkey=r[5] data=r[4]
  14 Goto             0   10    0               00 
  15 OpenWrite        2    2    0 1             00 root=2 iDb=0; t0
  16 OpenWrite        3    6    0 k(2,NOCASE,)  00 root=6 iDb=0; preceding
  17 Rewind           1   29    0               00 
  18 NewRowid         2    1    0               00 r[1]=rowid
  19 Column           1    0    2               00 r[2]=
  20 Affinity         2    1    0 D             00 affinity(r[2])
  21 Noop             0    0    0               00 uniqueness check for preceding
  22 SCopy            2    7    0               00 r[7]=r[2]; c0
  23 IntCopy          1    8    0               00 r[8]=r[1]; rowid
  24 MakeRecord       7    2    6               00 r[6]=mkrec(r[7..8]); for preceding
  25 IdxInsert        3    6    7 2             10 key=r[6]
  26 MakeRecord       2    1    5               00 r[5]=mkrec(r[2])
  27 Insert           2    5    1 t0            39 intkey=r[1] data=r[5]
  28 Next             1   18    0               00 
  29 Close            1    0    0               00 
  30 Halt             0    0    0               00 
  31 Transaction      0    1   15 0             01 usesStmtJournal=0
  32 Goto             0    1    0               00 
VDBE Trace:
   0 Init             0   31    0               00 Start at 31
  31 Transaction      0    1   15 0             01 usesStmtJournal=0
  32 Goto             0    1    0               00 
   1 InitCoroutine    3    9    2               00 
   9 OpenEphemeral    1    1    0               00 nColumn=1
  10 Yield            3   15    0               00 
REG[3] =  i:1
REG[3] =  i:10
   2 OpenRead         0    2    0 1             00 root=2 iDb=0; t0
   3 Explain          3    0    0 SCAN TABLE t0 00 
   4 Rewind           0    8    0               00 
   5 Column           0    0    2               00 r[2]=t0.c0
REG[2] =  i:1
   6 Yield            3    0    0               00 
REG[3] =  i:10
REG[3] =  i:6
  11 MakeRecord       2    1    4               00 r[4]=mkrec(r[2])
REG[4] =  s2[0209..]
  12 NewRowid         1    5    0               00 r[5]=rowid
REG[5] =  i:1
  13 Insert           1    4    5               00 intkey=r[5] data=r[4]
REG[4] =  s2[0209..]
REG[5] =  i:1
  14 Goto             0   10    0               00 
  10 Yield            3   15    0               00 
REG[3] =  i:6
REG[3] =  i:10
   7 Next             0    5    0               01 
   5 Column           0    0    2               00 r[2]=t0.c0
REG[2] =  i:2
   6 Yield            3    0    0               00 
REG[3] =  i:10
REG[3] =  i:6
  11 MakeRecord       2    1    4               00 r[4]=mkrec(r[2])
REG[4] =  s3[020102...]
  12 NewRowid         1    5    0               00 r[5]=rowid
REG[5] =  i:2
  13 Insert           1    4    5               00 intkey=r[5] data=r[4]
REG[4] =  s3[020102...]
REG[5] =  i:2
  14 Goto             0   10    0               00 
  10 Yield            3   15    0               00 
REG[3] =  i:6
REG[3] =  i:10
   7 Next             0    5    0               01 
   5 Column           0    0    2               00 r[2]=t0.c0
REG[2] =  i:3
   6 Yield            3    0    0               00 
REG[3] =  i:10
REG[3] =  i:6
  11 MakeRecord       2    1    4               00 r[4]=mkrec(r[2])
REG[4] =  s3[020103...]
  12 NewRowid         1    5    0               00 r[5]=rowid
REG[5] =  i:3
  13 Insert           1    4    5               00 intkey=r[5] data=r[4]
REG[4] =  s3[020103...]
REG[5] =  i:3
  14 Goto             0   10    0               00 
  10 Yield            3   15    0               00 
REG[3] =  i:6
REG[3] =  i:10
   7 Next             0    5    0               01 
   8 EndCoroutine     3    0    0               00 
REG[3] =  i:10
  15 OpenWrite        2    2    0 1             00 root=2 iDb=0; t0
  16 OpenWrite        3    6    0 k(2,NOCASE,)  00 root=6 iDb=0; preceding
  17 Rewind           1   29    0               00 
  18 NewRowid         2    1    0               00 r[1]=rowid
REG[1] =  i:4
  19 Column           1    0    2               00 r[2]=
REG[2] =  i:1
  20 Affinity         2    1    0 D             00 affinity(r[2])
  21 Noop             0    0    0               00 uniqueness check for preceding
  22 SCopy            2    7    0               00 r[7]=r[2]; c0
REG[7] =  i:1
  23 IntCopy          1    8    0               00 r[8]=r[1]; rowid
REG[8] =  i:4
  24 MakeRecord       7    2    6               00 r[6]=mkrec(r[7..8]); for preceding
REG[6] =  s4[03090104....]
  25 IdxInsert        3    6    7 2             10 key=r[6]
REG[6] =  s4[03090104....]
  26 MakeRecord       2    1    5               00 r[5]=mkrec(r[2])
REG[5] =  s2[0209..]
  27 Insert           2    5    1 t0            39 intkey=r[1] data=r[5]
REG[5] =  s2[0209..]
REG[1] =  i:4
  28 Next             1   18    0               00 
  18 NewRowid         2    1    0               00 r[1]=rowid
REG[1] =  i:5
  19 Column           1    0    2               00 r[2]=
REG[2] =  i:2
  20 Affinity         2    1    0 D             00 affinity(r[2])
  21 Noop             0    0    0               00 uniqueness check for preceding
  22 SCopy            2    7    0               00 r[7]=r[2]; c0
REG[7] =  i:2
  23 IntCopy          1    8    0               00 r[8]=r[1]; rowid
REG[8] =  i:5
  24 MakeRecord       7    2    6               00 r[6]=mkrec(r[7..8]); for preceding
REG[6] =  s5[0301010205.....]
  25 IdxInsert        3    6    7 2             10 key=r[6]
REG[6] =  s5[0301010205.....]
  26 MakeRecord       2    1    5               00 r[5]=mkrec(r[2])
REG[5] =  s3[020102...]
  27 Insert           2    5    1 t0            39 intkey=r[1] data=r[5]
REG[5] =  s3[020102...]
REG[1] =  i:5
  28 Next             1   18    0               00 
  18 NewRowid         2    1    0               00 r[1]=rowid
REG[1] =  i:6
  19 Column           1    0    2               00 r[2]=
REG[2] =  i:3
  20 Affinity         2    1    0 D             00 affinity(r[2])
  21 Noop             0    0    0               00 uniqueness check for preceding
  22 SCopy            2    7    0               00 r[7]=r[2]; c0
REG[7] =  i:3
  23 IntCopy          1    8    0               00 r[8]=r[1]; rowid
REG[8] =  i:6
  24 MakeRecord       7    2    6               00 r[6]=mkrec(r[7..8]); for preceding
REG[6] =  s5[0301010306.....]
  25 IdxInsert        3    6    7 2             10 key=r[6]
REG[6] =  s5[0301010306.....]
  26 MakeRecord       2    1    5               00 r[5]=mkrec(r[2])
REG[5] =  s3[020103...]
  27 Insert           2    5    1 t0            39 intkey=r[1] data=r[5]
REG[5] =  s3[020103...]
REG[1] =  i:6
  28 Next             1   18    0               00 
  29 Close            1    0    0               00 
  30 Halt             0    0    0               00 
SQL: [;
;SELECT max(c0), (SELECT count(*) FROM t0 WHERE c0=c0)
      FROM t0
     GROUP BY c0;]
VDBE Program Listing:
   0 Init             0   61    0               00 Start at 61
   1 SorterOpen       2    1    0 k(1,B)        00 
   2 Integer          0    4    0               00 r[4]=0; clear abort flag
   3 Null             0    7    7               00 r[7..7]=NULL
   4 Gosub            6   57    0               00 
   5 OpenRead         0    2    0 1             00 root=2 iDb=0; t0
   6 Explain          6    0    0 SCAN TABLE t0 00 
   7 Rewind           0   13    0               00 
   8 Explain          8    0    0 USE TEMP B-TREE FOR GROUP BY 00 
   9 Column           0    0    9               00 r[9]=t0.c0
  10 MakeRecord       9    1   10               00 r[10]=mkrec(r[9])
  11 SorterInsert     2   10    0               00 key=r[10]
  12 Next             0    8    0               01 
  13 OpenPseudo       3    9    1               00 1 columns in r[9]
  14 SorterSort       2   60    0               00 GROUP BY sort
  15 SorterData       2    9    3               00 r[9]=data
  16 Column           3    0    8               00 r[8]=
  17 Compare          7    8    1 k(1,B)        00 r[7] <-> r[8]
  18 Jump            19   23   19               00 
  19 Move             8    7    1               00 r[7]=r[8]
  20 Gosub            5   32    0               00 output one row
  21 IfPos            4   60    0               00 if r[4]>0 then r[4]-=0, goto 60; check abort flag
  22 Gosub            6   57    0               00 reset accumulator
  23 Column           3    0   10               00 r[10]=
  24 CollSeq          0    0    0 (BINARY)      00 
  25 AggStep          0   10    1 max(1)        01 accum=r[1] step(r[10])
  26 Integer          1    3    0               00 r[3]=1; indicate data in accumulator
  27 SorterNext       2   15    0               00 
  28 Gosub            5   32    0               00 output final row
  29 Goto             0   60    0               00 
  30 Integer          1    4    0               00 r[4]=1; set abort flag
  31 Return           5    0    0               00 
  32 IfPos            3   34    0               00 if r[3]>0 then r[3]-=0, goto 34; Groupby result generator entry point
  33 Return           5    0    0               00 
  34 AggFinal         1    1    0 max(1)        00 accum=r[1] N=1
  35 Copy             1   11    0               00 r[11]=r[1]
  36 Integer         53   13    0               00 r[13]=53; return address
  37 Once             0   53    0               00 
  38 Explain         38    0    0 SCALAR SUBQUERY 1 00 
  39 Null             0   14   14               00 r[14..14]=NULL; Init subquery result
  40 Integer          1   15    0               00 r[15]=1; LIMIT counter
  41 Null             0   16   16               00 r[16..16]=NULL
  42 OpenRead         1    2    0 1             00 root=2 iDb=0; t0
  43 Explain         43   38    0 SCAN TABLE t0 00 
  44 Rewind           1   50    0               00 
  45 Column           1    0   10               00 r[10]=t0.c0
  46 Column           1    0   17               00 r[17]=t0.c0
  47 Ne              17   49   10 (BINARY)      53 if r[10]!=r[17] goto 49
  48 AggStep          0    0   16 count(0)      00 accum=r[16] step(r[0])
  49 Next             1   45    0               01 
  50 AggFinal        16    0    0 count(0)      00 accum=r[16] N=0
  51 Copy            16   14    0               00 r[14]=r[16]
  52 DecrJumpZero    15   53    0               00 if (--r[15])==0 goto 53
  53 Return          13    0    0               00 
  54 Copy            14   12    0               00 r[12]=r[14]
  55 ResultRow       11    2    0               00 output=r[11..12]
  56 Return           5    0    0               00 end groupby result generator
  57 Null             0    1    2               00 r[1..2]=NULL
  58 Integer          0    3    0               00 r[3]=0; indicate accumulator empty
  59 Return           6    0    0               00 
  60 Halt             0    0    0               00 
  61 Transaction      0    0   15 0             01 usesStmtJournal=0
  62 Goto             0    1    0               00 
VDBE Trace:
   0 Init             0   61    0               00 Start at 61
  61 Transaction      0    0   15 0             01 usesStmtJournal=0
  62 Goto             0    1    0               00 
   1 SorterOpen       2    1    0 k(1,B)        00 
   2 Integer          0    4    0               00 r[4]=0; clear abort flag
REG[4] =  i:0
   3 Null             0    7    7               00 r[7..7]=NULL
REG[7] =  NULL
   4 Gosub            6   57    0               00 
REG[6] =  i:4
  57 Null             0    1    2               00 r[1..2]=NULL
REG[1] =  NULL
  58 Integer          0    3    0               00 r[3]=0; indicate accumulator empty
REG[3] =  i:0
  59 Return           6    0    0               00 
REG[6] =  i:4
   5 OpenRead         0    2    0 1             00 root=2 iDb=0; t0
   6 Explain          6    0    0 SCAN TABLE t0 00 
   7 Rewind           0   13    0               00 
   8 Explain          8    0    0 USE TEMP B-TREE FOR GROUP BY 00 
   9 Column           0    0    9               00 r[9]=t0.c0
REG[9] =  i:1
  10 MakeRecord       9    1   10               00 r[10]=mkrec(r[9])
REG[10] =  s2[0209..]
  11 SorterInsert     2   10    0               00 key=r[10]
REG[10] =  s2[0209..]
  12 Next             0    8    0               01 
   8 Explain          8    0    0 USE TEMP B-TREE FOR GROUP BY 00 
   9 Column           0    0    9               00 r[9]=t0.c0
REG[9] =  i:2
  10 MakeRecord       9    1   10               00 r[10]=mkrec(r[9])
REG[10] =  s3[020102...]
  11 SorterInsert     2   10    0               00 key=r[10]
REG[10] =  s3[020102...]
  12 Next             0    8    0               01 
   8 Explain          8    0    0 USE TEMP B-TREE FOR GROUP BY 00 
   9 Column           0    0    9               00 r[9]=t0.c0
REG[9] =  i:3
  10 MakeRecord       9    1   10               00 r[10]=mkrec(r[9])
REG[10] =  s3[020103...]
  11 SorterInsert     2   10    0               00 key=r[10]
REG[10] =  s3[020103...]
  12 Next             0    8    0               01 
   8 Explain          8    0    0 USE TEMP B-TREE FOR GROUP BY 00 
   9 Column           0    0    9               00 r[9]=t0.c0
REG[9] =  i:1
  10 MakeRecord       9    1   10               00 r[10]=mkrec(r[9])
REG[10] =  s2[0209..]
  11 SorterInsert     2   10    0               00 key=r[10]
REG[10] =  s2[0209..]
  12 Next             0    8    0               01 
   8 Explain          8    0    0 USE TEMP B-TREE FOR GROUP BY 00 
   9 Column           0    0    9               00 r[9]=t0.c0
REG[9] =  i:2
  10 MakeRecord       9    1   10               00 r[10]=mkrec(r[9])
REG[10] =  s3[020102...]
  11 SorterInsert     2   10    0               00 key=r[10]
REG[10] =  s3[020102...]
  12 Next             0    8    0               01 
   8 Explain          8    0    0 USE TEMP B-TREE FOR GROUP BY 00 
   9 Column           0    0    9               00 r[9]=t0.c0
REG[9] =  i:3
  10 MakeRecord       9    1   10               00 r[10]=mkrec(r[9])
REG[10] =  s3[020103...]
  11 SorterInsert     2   10    0               00 key=r[10]
REG[10] =  s3[020103...]
  12 Next             0    8    0               01 
  13 OpenPseudo       3    9    1               00 1 columns in r[9]
  14 SorterSort       2   60    0               00 GROUP BY sort
  15 SorterData       2    9    3               00 r[9]=data
  16 Column           3    0    8               00 r[8]=
REG[8] =  i:1
  17 Compare          7    8    1 k(1,B)        00 r[7] <-> r[8]
REG[7] =  NULL
REG[8] =  i:1
  18 Jump            19   23   19               00 
  19 Move             8    7    1               00 r[7]=r[8]
REG[7] =  i:1
  20 Gosub            5   32    0               00 output one row
REG[5] =  i:20
  32 IfPos            3   34    0               00 if r[3]>0 then r[3]-=0, goto 34; Groupby result generator entry point
REG[3] =  i:0
  33 Return           5    0    0               00 
REG[5] =  i:20
  21 IfPos            4   60    0               00 if r[4]>0 then r[4]-=0, goto 60; check abort flag
REG[4] =  i:0
  22 Gosub            6   57    0               00 reset accumulator
REG[6] =  i:22
  57 Null             0    1    2               00 r[1..2]=NULL
REG[1] =  NULL
  58 Integer          0    3    0               00 r[3]=0; indicate accumulator empty
REG[3] =  i:0
  59 Return           6    0    0               00 
REG[6] =  i:22
  23 Column           3    0   10               00 r[10]=
REG[10] =  i:1
  24 CollSeq          0    0    0 (BINARY)      00 
  25 AggStep          0   10    1 max(1)        01 accum=r[1] step(r[10])
REG[10] =  i:1
  26 Integer          1    3    0               00 r[3]=1; indicate data in accumulator
REG[3] =  i:1
  27 SorterNext       2   15    0               00 
  15 SorterData       2    9    3               00 r[9]=data
  16 Column           3    0    8               00 r[8]=
REG[8] =  i:1
  17 Compare          7    8    1 k(1,B)        00 r[7] <-> r[8]
REG[7] =  i:1
REG[8] =  i:1
  18 Jump            19   23   19               00 
  23 Column           3    0   10               00 r[10]=
REG[10] =  i:1
  24 CollSeq          0    0    0 (BINARY)      00 
  25 AggStep1         0   10    1 max(1)        01 accum=r[1] step(r[10])
REG[10] =  i:1
  26 Integer          1    3    0               00 r[3]=1; indicate data in accumulator
REG[3] =  i:1
  27 SorterNext       2   15    0               00 
  15 SorterData       2    9    3               00 r[9]=data
  16 Column           3    0    8               00 r[8]=
REG[8] =  i:2
  17 Compare          7    8    1 k(1,B)        00 r[7] <-> r[8]
REG[7] =  i:1
REG[8] =  i:2
  18 Jump            19   23   19               00 
  19 Move             8    7    1               00 r[7]=r[8]
REG[7] =  i:2
  20 Gosub            5   32    0               00 output one row
REG[5] =  i:20
  32 IfPos            3   34    0               00 if r[3]>0 then r[3]-=0, goto 34; Groupby result generator entry point
REG[3] =  i:1
  34 AggFinal         1    1    0 max(1)        00 accum=r[1] N=1
  35 Copy             1   11    0               00 r[11]=r[1]
REG[11] =  i:1
  36 Integer         53   13    0               00 r[13]=53; return address
REG[13] =  i:53
  37 Once             0   53    0               00 
  38 Explain         38    0    0 SCALAR SUBQUERY 1 00 
  39 Null             0   14   14               00 r[14..14]=NULL; Init subquery result
REG[14] =  NULL
  40 Integer          1   15    0               00 r[15]=1; LIMIT counter
REG[15] =  i:1
  41 Null             0   16   16               00 r[16..16]=NULL
REG[16] =  NULL
  42 OpenRead         1    2    0 1             00 root=2 iDb=0; t0
  43 Explain         43   38    0 SCAN TABLE t0 00 
  44 Rewind           1   50    0               00 
  45 Column           1    0   10               00 r[10]=t0.c0
REG[10] =  i:1
  46 Column           1    0   17               00 r[17]=t0.c0
REG[17] =  i:1
  47 Ne              17   49   10 (BINARY)      53 if r[10]!=r[17] goto 49
REG[17] =  i:1
REG[10] =  i:1
  48 AggStep          0    0   16 count(0)      00 accum=r[16] step(r[0])
  49 Next             1   45    0               01 
  45 Column           1    0   10               00 r[10]=t0.c0
REG[10] =  i:2
  46 Column           1    0   17               00 r[17]=t0.c0
REG[17] =  i:2
  47 Ne              17   49   10 (BINARY)      53 if r[10]!=r[17] goto 49
REG[17] =  i:2
REG[10] =  i:2
  48 AggStep1         0    0   16 count(0)      00 accum=r[16] step(r[0])
  49 Next             1   45    0               01 
  45 Column           1    0   10               00 r[10]=t0.c0
REG[10] =  i:3
  46 Column           1    0   17               00 r[17]=t0.c0
REG[17] =  i:3
  47 Ne              17   49   10 (BINARY)      53 if r[10]!=r[17] goto 49
REG[17] =  i:3
REG[10] =  i:3
  48 AggStep1         0    0   16 count(0)      00 accum=r[16] step(r[0])
  49 Next             1   45    0               01 
  45 Column           1    0   10               00 r[10]=t0.c0
REG[10] =  i:1
  46 Column           1    0   17               00 r[17]=t0.c0
REG[17] =  i:1
  47 Ne              17   49   10 (BINARY)      53 if r[10]!=r[17] goto 49
REG[17] =  i:1
REG[10] =  i:1
  48 AggStep1         0    0   16 count(0)      00 accum=r[16] step(r[0])
  49 Next             1   45    0               01 
  45 Column           1    0   10               00 r[10]=t0.c0
REG[10] =  i:2
  46 Column           1    0   17               00 r[17]=t0.c0
REG[17] =  i:2
  47 Ne              17   49   10 (BINARY)      53 if r[10]!=r[17] goto 49
REG[17] =  i:2
REG[10] =  i:2
  48 AggStep1         0    0   16 count(0)      00 accum=r[16] step(r[0])
  49 Next             1   45    0               01 
  45 Column           1    0   10               00 r[10]=t0.c0
REG[10] =  i:3
  46 Column           1    0   17               00 r[17]=t0.c0
REG[17] =  i:3
  47 Ne              17   49   10 (BINARY)      53 if r[10]!=r[17] goto 49
REG[17] =  i:3
REG[10] =  i:3
  48 AggStep1         0    0   16 count(0)      00 accum=r[16] step(r[0])
  49 Next             1   45    0               01 
  50 AggFinal        16    0    0 count(0)      00 accum=r[16] N=0
  51 Copy            16   14    0               00 r[14]=r[16]
REG[14] =  i:6
  52 DecrJumpZero    15   53    0               00 if (--r[15])==0 goto 53
REG[15] =  i:1
  53 Return          13    0    0               00 
REG[13] =  i:53
  54 Copy            14   12    0               00 r[12]=r[14]
REG[12] =  i:6
  55 ResultRow       11    2    0               00 output=r[11..12]
REG[11] =  i:1
REG[12] =  i:6
  56 Return           5    0    0               00 end groupby result generator
REG[5] =  i:20
  21 IfPos            4   60    0               00 if r[4]>0 then r[4]-=0, goto 60; check abort flag
REG[4] =  i:0
  22 Gosub            6   57    0               00 reset accumulator
REG[6] =  i:22
  57 Null             0    1    2               00 r[1..2]=NULL
REG[1] =  NULL
  58 Integer          0    3    0               00 r[3]=0; indicate accumulator empty
REG[3] =  i:0
  59 Return           6    0    0               00 
REG[6] =  i:22
  23 Column           3    0   10               00 r[10]=
REG[10] =  i:2
  24 CollSeq          0    0    0 (BINARY)      00 
  25 AggStep1         0   10    1 max(1)        01 accum=r[1] step(r[10])
REG[10] =  i:2
  26 Integer          1    3    0               00 r[3]=1; indicate data in accumulator
REG[3] =  i:1
  27 SorterNext       2   15    0               00 
  15 SorterData       2    9    3               00 r[9]=data
  16 Column           3    0    8               00 r[8]=
REG[8] =  i:2
  17 Compare          7    8    1 k(1,B)        00 r[7] <-> r[8]
REG[7] =  i:2
REG[8] =  i:2
  18 Jump            19   23   19               00 
  23 Column           3    0   10               00 r[10]=
REG[10] =  i:2
  24 CollSeq          0    0    0 (BINARY)      00 
  25 AggStep1         0   10    1 max(1)        01 accum=r[1] step(r[10])
REG[10] =  i:2
  26 Integer          1    3    0               00 r[3]=1; indicate data in accumulator
REG[3] =  i:1
  27 SorterNext       2   15    0               00 
  15 SorterData       2    9    3               00 r[9]=data
  16 Column           3    0    8               00 r[8]=
REG[8] =  i:3
  17 Compare          7    8    1 k(1,B)        00 r[7] <-> r[8]
REG[7] =  i:2
REG[8] =  i:3
  18 Jump            19   23   19               00 
  19 Move             8    7    1               00 r[7]=r[8]
REG[7] =  i:3
  20 Gosub            5   32    0               00 output one row
REG[5] =  i:20
  32 IfPos            3   34    0               00 if r[3]>0 then r[3]-=0, goto 34; Groupby result generator entry point
REG[3] =  i:1
  34 AggFinal         1    1    0 max(1)        00 accum=r[1] N=1
  35 Copy             1   11    0               00 r[11]=r[1]
REG[11] =  i:2
  36 Integer         53   13    0               00 r[13]=53; return address
REG[13] =  i:53
  37 Once             1   53    0               00 
  53 Return          13    0    0               00 
REG[13] =  i:53
  54 Copy            14   12    0               00 r[12]=r[14]
REG[12] =  i:6
  55 ResultRow       11    2    0               00 output=r[11..12]
REG[11] =  i:2
REG[12] =  i:6
  56 Return           5    0    0               00 end groupby result generator
REG[5] =  i:20
  21 IfPos            4   60    0               00 if r[4]>0 then r[4]-=0, goto 60; check abort flag
REG[4] =  i:0
  22 Gosub            6   57    0               00 reset accumulator
REG[6] =  i:22
  57 Null             0    1    2               00 r[1..2]=NULL
REG[1] =  NULL
  58 Integer          0    3    0               00 r[3]=0; indicate accumulator empty
REG[3] =  i:0
  59 Return           6    0    0               00 
REG[6] =  i:22
  23 Column           3    0   10               00 r[10]=
REG[10] =  i:3
  24 CollSeq          0    0    0 (BINARY)      00 
  25 AggStep1         0   10    1 max(1)        01 accum=r[1] step(r[10])
REG[10] =  i:3
  26 Integer          1    3    0               00 r[3]=1; indicate data in accumulator
REG[3] =  i:1
  27 SorterNext       2   15    0               00 
  15 SorterData       2    9    3               00 r[9]=data
  16 Column           3    0    8               00 r[8]=
REG[8] =  i:3
  17 Compare          7    8    1 k(1,B)        00 r[7] <-> r[8]
REG[7] =  i:3
REG[8] =  i:3
  18 Jump            19   23   19               00 
  23 Column           3    0   10               00 r[10]=
REG[10] =  i:3
  24 CollSeq          0    0    0 (BINARY)      00 
  25 AggStep1         0   10    1 max(1)        01 accum=r[1] step(r[10])
REG[10] =  i:3
  26 Integer          1    3    0               00 r[3]=1; indicate data in accumulator
REG[3] =  i:1
  27 SorterNext       2   15    0               00 
  28 Gosub            5   32    0               00 output final row
REG[5] =  i:28
  32 IfPos            3   34    0               00 if r[3]>0 then r[3]-=0, goto 34; Groupby result generator entry point
REG[3] =  i:1
  34 AggFinal         1    1    0 max(1)        00 accum=r[1] N=1
  35 Copy             1   11    0               00 r[11]=r[1]
REG[11] =  i:3
  36 Integer         53   13    0               00 r[13]=53; return address
REG[13] =  i:53
  37 Once             1   53    0               00 
  53 Return          13    0    0               00 
REG[13] =  i:53
  54 Copy            14   12    0               00 r[12]=r[14]
REG[12] =  i:6
  55 ResultRow       11    2    0               00 output=r[11..12]
REG[11] =  i:3
REG[12] =  i:6
  56 Return           5    0    0               00 end groupby result generator
REG[5] =  i:28
  29 Goto             0   60    0               00 
  60 Halt             0    0    0               00 
SQL: [;
;SELECT c0, (SELECT sum(c0=c0) FROM t0)
      FROM t0;]
VDBE Program Listing:
   0 Init             0   27    0               00 Start at 27
   1 OpenRead         0    2    0 1             00 root=2 iDb=0; t0
   2 Explain          2    0    0 SCAN TABLE t0 00 
   3 Rewind           0   26    0               00 
   4 Column           0    0    1               00 r[1]=t0.c0
   5 Integer         22    3    0               00 r[3]=22; return address
   6 Once             0   22    0               00 
   7 Explain          7    0    0 SCALAR SUBQUERY 1 00 
   8 Null             0    4    4               00 r[4..4]=NULL; Init subquery result
   9 Integer          1    5    0               00 r[5]=1; LIMIT counter
  10 Null             0    6    7               00 r[6..7]=NULL
  11 OpenRead         1    2    0 1             00 root=2 iDb=0; t0
  12 Explain         12    7    0 SCAN TABLE t0 00 
  13 Rewind           1   19    0               00 
  14 Column           1    0    9               00 r[9]=t0.c0
  15 Column           1    0   10               00 r[10]=t0.c0
  16 Eq              10    8    9 (BINARY)      63 r[8] = (r[9]==r[10])
  17 AggStep          0    8    6 sum(1)        01 accum=r[6] step(r[8])
  18 Next             1   14    0               01 
  19 AggFinal         6    1    0 sum(1)        00 accum=r[6] N=1
  20 Copy             6    4    0               00 r[4]=r[6]
  21 DecrJumpZero     5   22    0               00 if (--r[5])==0 goto 22
  22 Return           3    0    0               00 
  23 Copy             4    2    0               00 r[2]=r[4]
  24 ResultRow        1    2    0               00 output=r[1..2]
  25 Next             0    4    0               01 
  26 Halt             0    0    0               00 
  27 Transaction      0    0   15 0             01 usesStmtJournal=0
  28 Goto             0    1    0               00 
VDBE Trace:
   0 Init             0   27    0               00 Start at 27
  27 Transaction      0    0   15 0             01 usesStmtJournal=0
  28 Goto             0    1    0               00 
   1 OpenRead         0    2    0 1             00 root=2 iDb=0; t0
   2 Explain          2    0    0 SCAN TABLE t0 00 
   3 Rewind           0   26    0               00 
   4 Column           0    0    1               00 r[1]=t0.c0
REG[1] =  i:1
   5 Integer         22    3    0               00 r[3]=22; return address
REG[3] =  i:22
   6 Once             0   22    0               00 
   7 Explain          7    0    0 SCALAR SUBQUERY 1 00 
   8 Null             0    4    4               00 r[4..4]=NULL; Init subquery result
REG[4] =  NULL
   9 Integer          1    5    0               00 r[5]=1; LIMIT counter
REG[5] =  i:1
  10 Null             0    6    7               00 r[6..7]=NULL
REG[6] =  NULL
  11 OpenRead         1    2    0 1             00 root=2 iDb=0; t0
  12 Explain         12    7    0 SCAN TABLE t0 00 
  13 Rewind           1   19    0               00 
  14 Column           1    0    9               00 r[9]=t0.c0
REG[9] =  i:1
  15 Column           1    0   10               00 r[10]=t0.c0
REG[10] =  i:1
  16 Eq              10    8    9 (BINARY)      63 r[8] = (r[9]==r[10])
REG[10] =  i:1
REG[9] =  i:1
REG[8] =  i:1
  17 AggStep          0    8    6 sum(1)        01 accum=r[6] step(r[8])
REG[8] =  i:1
  18 Next             1   14    0               01 
  14 Column           1    0    9               00 r[9]=t0.c0
REG[9] =  i:2
  15 Column           1    0   10               00 r[10]=t0.c0
REG[10] =  i:2
  16 Eq              10    8    9 (BINARY)      63 r[8] = (r[9]==r[10])
REG[10] =  i:2
REG[9] =  i:2
REG[8] =  i:1
  17 AggStep1         0    8    6 sum(1)        01 accum=r[6] step(r[8])
REG[8] =  i:1
  18 Next             1   14    0               01 
  14 Column           1    0    9               00 r[9]=t0.c0
REG[9] =  i:3
  15 Column           1    0   10               00 r[10]=t0.c0
REG[10] =  i:3
  16 Eq              10    8    9 (BINARY)      63 r[8] = (r[9]==r[10])
REG[10] =  i:3
REG[9] =  i:3
REG[8] =  i:1
  17 AggStep1         0    8    6 sum(1)        01 accum=r[6] step(r[8])
REG[8] =  i:1
  18 Next             1   14    0               01 
  14 Column           1    0    9               00 r[9]=t0.c0
REG[9] =  i:1
  15 Column           1    0   10               00 r[10]=t0.c0
REG[10] =  i:1
  16 Eq              10    8    9 (BINARY)      63 r[8] = (r[9]==r[10])
REG[10] =  i:1
REG[9] =  i:1
REG[8] =  i:1
  17 AggStep1         0    8    6 sum(1)        01 accum=r[6] step(r[8])
REG[8] =  i:1
  18 Next             1   14    0               01 
  14 Column           1    0    9               00 r[9]=t0.c0
REG[9] =  i:2
  15 Column           1    0   10               00 r[10]=t0.c0
REG[10] =  i:2
  16 Eq              10    8    9 (BINARY)      63 r[8] = (r[9]==r[10])
REG[10] =  i:2
REG[9] =  i:2
REG[8] =  i:1
  17 AggStep1         0    8    6 sum(1)        01 accum=r[6] step(r[8])
REG[8] =  i:1
  18 Next             1   14    0               01 
  14 Column           1    0    9               00 r[9]=t0.c0
REG[9] =  i:3
  15 Column           1    0   10               00 r[10]=t0.c0
REG[10] =  i:3
  16 Eq              10    8    9 (BINARY)      63 r[8] = (r[9]==r[10])
REG[10] =  i:3
REG[9] =  i:3
REG[8] =  i:1
  17 AggStep1         0    8    6 sum(1)        01 accum=r[6] step(r[8])
REG[8] =  i:1
  18 Next             1   14    0               01 
  19 AggFinal         6    1    0 sum(1)        00 accum=r[6] N=1
  20 Copy             6    4    0               00 r[4]=r[6]
REG[4] =  i:6
  21 DecrJumpZero     5   22    0               00 if (--r[5])==0 goto 22
REG[5] =  i:1
  22 Return           3    0    0               00 
REG[3] =  i:22
  23 Copy             4    2    0               00 r[2]=r[4]
REG[2] =  i:6
  24 ResultRow        1    2    0               00 output=r[1..2]
REG[1] =  i:1
REG[2] =  i:6
  25 Next             0    4    0               01 
   4 Column           0    0    1               00 r[1]=t0.c0
REG[1] =  i:2
   5 Integer         22    3    0               00 r[3]=22; return address
REG[3] =  i:22
   6 Once             1   22    0               00 
  22 Return           3    0    0               00 
REG[3] =  i:22
  23 Copy             4    2    0               00 r[2]=r[4]
REG[2] =  i:6
  24 ResultRow        1    2    0               00 output=r[1..2]
REG[1] =  i:2
REG[2] =  i:6
  25 Next             0    4    0               01 
   4 Column           0    0    1               00 r[1]=t0.c0
REG[1] =  i:3
   5 Integer         22    3    0               00 r[3]=22; return address
REG[3] =  i:22
   6 Once             1   22    0               00 
  22 Return           3    0    0               00 
REG[3] =  i:22
  23 Copy             4    2    0               00 r[2]=r[4]
REG[2] =  i:6
  24 ResultRow        1    2    0               00 output=r[1..2]
REG[1] =  i:3
REG[2] =  i:6
  25 Next             0    4    0               01 
   4 Column           0    0    1               00 r[1]=t0.c0
REG[1] =  i:1
   5 Integer         22    3    0               00 r[3]=22; return address
REG[3] =  i:22
   6 Once             1   22    0               00 
  22 Return           3    0    0               00 
REG[3] =  i:22
  23 Copy             4    2    0               00 r[2]=r[4]
REG[2] =  i:6
  24 ResultRow        1    2    0               00 output=r[1..2]
REG[1] =  i:1
REG[2] =  i:6
  25 Next             0    4    0               01 
   4 Column           0    0    1               00 r[1]=t0.c0
REG[1] =  i:2
   5 Integer         22    3    0               00 r[3]=22; return address
REG[3] =  i:22
   6 Once             1   22    0               00 
  22 Return           3    0    0               00 
REG[3] =  i:22
  23 Copy             4    2    0               00 r[2]=r[4]
REG[2] =  i:6
  24 ResultRow        1    2    0               00 output=r[1..2]
REG[1] =  i:2
REG[2] =  i:6
  25 Next             0    4    0               01 
   4 Column           0    0    1               00 r[1]=t0.c0
REG[1] =  i:3
   5 Integer         22    3    0               00 r[3]=22; return address
REG[3] =  i:22
   6 Once             1   22    0               00 
  22 Return           3    0    0               00 
REG[3] =  i:22
  23 Copy             4    2    0               00 r[2]=r[4]
REG[2] =  i:6
  24 ResultRow        1    2    0               00 output=r[1..2]
REG[1] =  i:3
REG[2] =  i:6
  25 Next             0    4    0               01 
  26 Halt             0    0    0               00 
SQL: [;
;SELECT c0, (SELECT sum(c0=c0) FROM t0)
      FROM t0
     WHERE c0 IN (SELECT max(c0) FROM t0 GROUP BY c0);]
VDBE Program Listing:
   0 Init             0   78    0               00 Start at 78
   1 OpenRead         0    2    0 1             00 root=2 iDb=0; t0
   2 Explain          2    0    0 SCAN TABLE t0 00 
   3 Rewind           0   77    0               00 
   4 Noop             0    0    0               00 begin IN expr
   5 Integer         50    1    0               00 r[1]=50; return address
   6 Once             0   50    0               00 
   7 OpenEphemeral    3    1    0 k(1,B)        00 nColumn=1; Result of SELECT 2
   8 Explain          8    0    0 LIST SUBQUERY 2 00 
   9 SorterOpen       4    1    0 k(1,B)        00 
  10 Integer          0    5    0               00 r[5]=0; clear abort flag
  11 Null             0    8    8               00 r[8..8]=NULL
  12 Gosub            7   47    0               00 
  13 OpenRead         2    2    0 1             00 root=2 iDb=0; t0
  14 Explain         14    8    0 SCAN TABLE t0 00 
  15 Rewind           2   21    0               00 
  16 Explain         16    8    0 USE TEMP B-TREE FOR GROUP BY 00 
  17 Column           2    0   10               00 r[10]=t0.c0
  18 MakeRecord      10    1   11               00 r[11]=mkrec(r[10])
  19 SorterInsert     4   11    0               00 key=r[11]
  20 Next             2   16    0               01 
  21 OpenPseudo       5   10    1               00 1 columns in r[10]
  22 SorterSort       4   50    0               00 GROUP BY sort
  23 SorterData       4   10    5               00 r[10]=data
  24 Column           5    0    9               00 r[9]=
  25 Compare          8    9    1 k(1,B)        00 r[8] <-> r[9]
  26 Jump            27   31   27               00 
  27 Move             9    8    1               00 r[8]=r[9]
  28 Gosub            6   40    0               00 output one row
  29 IfPos            5   50    0               00 if r[5]>0 then r[5]-=0, goto 50; check abort flag
  30 Gosub            7   47    0               00 reset accumulator
  31 Column           5    0   11               00 r[11]=
  32 CollSeq          0    0    0 (BINARY)      00 
  33 AggStep          0   11    2 max(1)        01 accum=r[2] step(r[11])
  34 Integer          1    4    0               00 r[4]=1; indicate data in accumulator
  35 SorterNext       4   23    0               00 
  36 Gosub            6   40    0               00 output final row
  37 Goto             0   50    0               00 
  38 Integer          1    5    0               00 r[5]=1; set abort flag
  39 Return           6    0    0               00 
  40 IfPos            4   42    0               00 if r[4]>0 then r[4]-=0, goto 42; Groupby result generator entry point
  41 Return           6    0    0               00 
  42 AggFinal         2    1    0 max(1)        00 accum=r[2] N=1
  43 SCopy            2   12    0               00 r[12]=r[2]
  44 MakeRecord      12    1   11 D             00 r[11]=mkrec(r[12])
  45 IdxInsert        3   11   12 1             00 key=r[11]
  46 Return           6    0    0               00 end groupby result generator
  47 Null             0    2    3               00 r[2..3]=NULL
  48 Integer          0    4    0               00 r[4]=0; indicate accumulator empty
  49 Return           7    0    0               00 
  50 Return           1    0    0               00 
  51 Column           0    0   11               00 r[11]=t0.c0
  52 IsNull          11   76    0               00 if r[11]==NULL goto 76
  53 Affinity        11    1    0 D             00 affinity(r[11])
  54 NotFound         3   76   11 1             00 key=r[11]; end IN expr
  55 Column           0    0   13               00 r[13]=t0.c0
  56 Integer         73   15    0               00 r[15]=73; return address
  57 Once             0   73    0               00 
  58 Explain         58    0    0 SCALAR SUBQUERY 1 00 
  59 Null             0   16   16               00 r[16..16]=NULL; Init subquery result
  60 Integer          1   17    0               00 r[17]=1; LIMIT counter
  61 Null             0   18   19               00 r[18..19]=NULL
  62 OpenRead         1    2    0 1             00 root=2 iDb=0; t0
  63 Explain         63   58    0 SCAN TABLE t0 00 
  64 Rewind           1   70    0               00 
  65 Column           1    0   21               00 r[21]=t0.c0
  66 Column           1    0   22               00 r[22]=t0.c0
  67 Eq              22   20   21 (BINARY)      63 r[20] = (r[21]==r[22])
  68 AggStep          0   20   18 sum(1)        01 accum=r[18] step(r[20])
  69 Next             1   65    0               01 
  70 AggFinal        18    1    0 sum(1)        00 accum=r[18] N=1
  71 Copy            18   16    0               00 r[16]=r[18]
  72 DecrJumpZero    17   73    0               00 if (--r[17])==0 goto 73
  73 Return          15    0    0               00 
  74 Copy            16   14    0               00 r[14]=r[16]
  75 ResultRow       13    2    0               00 output=r[13..14]
  76 Next             0    4    0               01 
  77 Halt             0    0    0               00 
  78 Transaction      0    0   15 0             01 usesStmtJournal=0
  79 Goto             0    1    0               00 
VDBE Trace:
   0 Init             0   78    0               00 Start at 78
  78 Transaction      0    0   15 0             01 usesStmtJournal=0
  79 Goto             0    1    0               00 
   1 OpenRead         0    2    0 1             00 root=2 iDb=0; t0
   2 Explain          2    0    0 SCAN TABLE t0 00 
   3 Rewind           0   77    0               00 
   4 Noop             0    0    0               00 begin IN expr
   5 Integer         50    1    0               00 r[1]=50; return address
REG[1] =  i:50
   6 Once             0   50    0               00 
   7 OpenEphemeral    3    1    0 k(1,B)        00 nColumn=1; Result of SELECT 2
   8 Explain          8    0    0 LIST SUBQUERY 2 00 
   9 SorterOpen       4    1    0 k(1,B)        00 
  10 Integer          0    5    0               00 r[5]=0; clear abort flag
REG[5] =  i:0
  11 Null             0    8    8               00 r[8..8]=NULL
REG[8] =  NULL
  12 Gosub            7   47    0               00 
REG[7] =  i:12
  47 Null             0    2    3               00 r[2..3]=NULL
REG[2] =  NULL
  48 Integer          0    4    0               00 r[4]=0; indicate accumulator empty
REG[4] =  i:0
  49 Return           7    0    0               00 
REG[7] =  i:12
  13 OpenRead         2    2    0 1             00 root=2 iDb=0; t0
  14 Explain         14    8    0 SCAN TABLE t0 00 
  15 Rewind           2   21    0               00 
  16 Explain         16    8    0 USE TEMP B-TREE FOR GROUP BY 00 
  17 Column           2    0   10               00 r[10]=t0.c0
REG[10] =  i:1
  18 MakeRecord      10    1   11               00 r[11]=mkrec(r[10])
REG[11] =  s2[0209..]
  19 SorterInsert     4   11    0               00 key=r[11]
REG[11] =  s2[0209..]
  20 Next             2   16    0               01 
  16 Explain         16    8    0 USE TEMP B-TREE FOR GROUP BY 00 
  17 Column           2    0   10               00 r[10]=t0.c0
REG[10] =  i:2
  18 MakeRecord      10    1   11               00 r[11]=mkrec(r[10])
REG[11] =  s3[020102...]
  19 SorterInsert     4   11    0               00 key=r[11]
REG[11] =  s3[020102...]
  20 Next             2   16    0               01 
  16 Explain         16    8    0 USE TEMP B-TREE FOR GROUP BY 00 
  17 Column           2    0   10               00 r[10]=t0.c0
REG[10] =  i:3
  18 MakeRecord      10    1   11               00 r[11]=mkrec(r[10])
REG[11] =  s3[020103...]
  19 SorterInsert     4   11    0               00 key=r[11]
REG[11] =  s3[020103...]
  20 Next             2   16    0               01 
  16 Explain         16    8    0 USE TEMP B-TREE FOR GROUP BY 00 
  17 Column           2    0   10               00 r[10]=t0.c0
REG[10] =  i:1
  18 MakeRecord      10    1   11               00 r[11]=mkrec(r[10])
REG[11] =  s2[0209..]
  19 SorterInsert     4   11    0               00 key=r[11]
REG[11] =  s2[0209..]
  20 Next             2   16    0               01 
  16 Explain         16    8    0 USE TEMP B-TREE FOR GROUP BY 00 
  17 Column           2    0   10               00 r[10]=t0.c0
REG[10] =  i:2
  18 MakeRecord      10    1   11               00 r[11]=mkrec(r[10])
REG[11] =  s3[020102...]
  19 SorterInsert     4   11    0               00 key=r[11]
REG[11] =  s3[020102...]
  20 Next             2   16    0               01 
  16 Explain         16    8    0 USE TEMP B-TREE FOR GROUP BY 00 
  17 Column           2    0   10               00 r[10]=t0.c0
REG[10] =  i:3
  18 MakeRecord      10    1   11               00 r[11]=mkrec(r[10])
REG[11] =  s3[020103...]
  19 SorterInsert     4   11    0               00 key=r[11]
REG[11] =  s3[020103...]
  20 Next             2   16    0               01 
  21 OpenPseudo       5   10    1               00 1 columns in r[10]
  22 SorterSort       4   50    0               00 GROUP BY sort
  23 SorterData       4   10    5               00 r[10]=data
  24 Column           5    0    9               00 r[9]=
REG[9] =  i:1
  25 Compare          8    9    1 k(1,B)        00 r[8] <-> r[9]
REG[8] =  NULL
REG[9] =  i:1
  26 Jump            27   31   27               00 
  27 Move             9    8    1               00 r[8]=r[9]
REG[8] =  i:1
  28 Gosub            6   40    0               00 output one row
REG[6] =  i:28
  40 IfPos            4   42    0               00 if r[4]>0 then r[4]-=0, goto 42; Groupby result generator entry point
REG[4] =  i:0
  41 Return           6    0    0               00 
REG[6] =  i:28
  29 IfPos            5   50    0               00 if r[5]>0 then r[5]-=0, goto 50; check abort flag
REG[5] =  i:0
  30 Gosub            7   47    0               00 reset accumulator
REG[7] =  i:30
  47 Null             0    2    3               00 r[2..3]=NULL
REG[2] =  NULL
  48 Integer          0    4    0               00 r[4]=0; indicate accumulator empty
REG[4] =  i:0
  49 Return           7    0    0               00 
REG[7] =  i:30
  31 Column           5    0   11               00 r[11]=
REG[11] =  i:1
  32 CollSeq          0    0    0 (BINARY)      00 
  33 AggStep          0   11    2 max(1)        01 accum=r[2] step(r[11])
REG[11] =  i:1
  34 Integer          1    4    0               00 r[4]=1; indicate data in accumulator
REG[4] =  i:1
  35 SorterNext       4   23    0               00 
  23 SorterData       4   10    5               00 r[10]=data
  24 Column           5    0    9               00 r[9]=
REG[9] =  i:1
  25 Compare          8    9    1 k(1,B)        00 r[8] <-> r[9]
REG[8] =  i:1
REG[9] =  i:1
  26 Jump            27   31   27               00 
  31 Column           5    0   11               00 r[11]=
REG[11] =  i:1
  32 CollSeq          0    0    0 (BINARY)      00 
  33 AggStep1         0   11    2 max(1)        01 accum=r[2] step(r[11])
REG[11] =  i:1
  34 Integer          1    4    0               00 r[4]=1; indicate data in accumulator
REG[4] =  i:1
  35 SorterNext       4   23    0               00 
  23 SorterData       4   10    5               00 r[10]=data
  24 Column           5    0    9               00 r[9]=
REG[9] =  i:2
  25 Compare          8    9    1 k(1,B)        00 r[8] <-> r[9]
REG[8] =  i:1
REG[9] =  i:2
  26 Jump            27   31   27               00 
  27 Move             9    8    1               00 r[8]=r[9]
REG[8] =  i:2
  28 Gosub            6   40    0               00 output one row
REG[6] =  i:28
  40 IfPos            4   42    0               00 if r[4]>0 then r[4]-=0, goto 42; Groupby result generator entry point
REG[4] =  i:1
  42 AggFinal         2    1    0 max(1)        00 accum=r[2] N=1
  43 SCopy            2   12    0               00 r[12]=r[2]
REG[12] =  i:1
  44 MakeRecord      12    1   11 D             00 r[11]=mkrec(r[12])
REG[11] =  s2[0209..]
  45 IdxInsert        3   11   12 1             00 key=r[11]
REG[11] =  s2[0209..]
  46 Return           6    0    0               00 end groupby result generator
REG[6] =  i:28
  29 IfPos            5   50    0               00 if r[5]>0 then r[5]-=0, goto 50; check abort flag
REG[5] =  i:0
  30 Gosub            7   47    0               00 reset accumulator
REG[7] =  i:30
  47 Null             0    2    3               00 r[2..3]=NULL
REG[2] =  NULL
  48 Integer          0    4    0               00 r[4]=0; indicate accumulator empty
REG[4] =  i:0
  49 Return           7    0    0               00 
REG[7] =  i:30
  31 Column           5    0   11               00 r[11]=
REG[11] =  i:2
  32 CollSeq          0    0    0 (BINARY)      00 
  33 AggStep1         0   11    2 max(1)        01 accum=r[2] step(r[11])
REG[11] =  i:2
  34 Integer          1    4    0               00 r[4]=1; indicate data in accumulator
REG[4] =  i:1
  35 SorterNext       4   23    0               00 
  23 SorterData       4   10    5               00 r[10]=data
  24 Column           5    0    9               00 r[9]=
REG[9] =  i:2
  25 Compare          8    9    1 k(1,B)        00 r[8] <-> r[9]
REG[8] =  i:2
REG[9] =  i:2
  26 Jump            27   31   27               00 
  31 Column           5    0   11               00 r[11]=
REG[11] =  i:2
  32 CollSeq          0    0    0 (BINARY)      00 
  33 AggStep1         0   11    2 max(1)        01 accum=r[2] step(r[11])
REG[11] =  i:2
  34 Integer          1    4    0               00 r[4]=1; indicate data in accumulator
REG[4] =  i:1
  35 SorterNext       4   23    0               00 
  23 SorterData       4   10    5               00 r[10]=data
  24 Column           5    0    9               00 r[9]=
REG[9] =  i:3
  25 Compare          8    9    1 k(1,B)        00 r[8] <-> r[9]
REG[8] =  i:2
REG[9] =  i:3
  26 Jump            27   31   27               00 
  27 Move             9    8    1               00 r[8]=r[9]
REG[8] =  i:3
  28 Gosub            6   40    0               00 output one row
REG[6] =  i:28
  40 IfPos            4   42    0               00 if r[4]>0 then r[4]-=0, goto 42; Groupby result generator entry point
REG[4] =  i:1
  42 AggFinal         2    1    0 max(1)        00 accum=r[2] N=1
  43 SCopy            2   12    0               00 r[12]=r[2]
REG[12] =  i:2
  44 MakeRecord      12    1   11 D             00 r[11]=mkrec(r[12])
REG[11] =  s3[020102...]
  45 IdxInsert        3   11   12 1             00 key=r[11]
REG[11] =  s3[020102...]
  46 Return           6    0    0               00 end groupby result generator
REG[6] =  i:28
  29 IfPos            5   50    0               00 if r[5]>0 then r[5]-=0, goto 50; check abort flag
REG[5] =  i:0
  30 Gosub            7   47    0               00 reset accumulator
REG[7] =  i:30
  47 Null             0    2    3               00 r[2..3]=NULL
REG[2] =  NULL
  48 Integer          0    4    0               00 r[4]=0; indicate accumulator empty
REG[4] =  i:0
  49 Return           7    0    0               00 
REG[7] =  i:30
  31 Column           5    0   11               00 r[11]=
REG[11] =  i:3
  32 CollSeq          0    0    0 (BINARY)      00 
  33 AggStep1         0   11    2 max(1)        01 accum=r[2] step(r[11])
REG[11] =  i:3
  34 Integer          1    4    0               00 r[4]=1; indicate data in accumulator
REG[4] =  i:1
  35 SorterNext       4   23    0               00 
  23 SorterData       4   10    5               00 r[10]=data
  24 Column           5    0    9               00 r[9]=
REG[9] =  i:3
  25 Compare          8    9    1 k(1,B)        00 r[8] <-> r[9]
REG[8] =  i:3
REG[9] =  i:3
  26 Jump            27   31   27               00 
  31 Column           5    0   11               00 r[11]=
REG[11] =  i:3
  32 CollSeq          0    0    0 (BINARY)      00 
  33 AggStep1         0   11    2 max(1)        01 accum=r[2] step(r[11])
REG[11] =  i:3
  34 Integer          1    4    0               00 r[4]=1; indicate data in accumulator
REG[4] =  i:1
  35 SorterNext       4   23    0               00 
  36 Gosub            6   40    0               00 output final row
REG[6] =  i:36
  40 IfPos            4   42    0               00 if r[4]>0 then r[4]-=0, goto 42; Groupby result generator entry point
REG[4] =  i:1
  42 AggFinal         2    1    0 max(1)        00 accum=r[2] N=1
  43 SCopy            2   12    0               00 r[12]=r[2]
REG[12] =  i:3
  44 MakeRecord      12    1   11 D             00 r[11]=mkrec(r[12])
REG[11] =  s3[020103...]
  45 IdxInsert        3   11   12 1             00 key=r[11]
REG[11] =  s3[020103...]
  46 Return           6    0    0               00 end groupby result generator
REG[6] =  i:36
  37 Goto             0   50    0               00 
  50 Return           1    0    0               00 
REG[1] =  i:50
  51 Column           0    0   11               00 r[11]=t0.c0
REG[11] =  i:1
  52 IsNull          11   76    0               00 if r[11]==NULL goto 76
REG[11] =  i:1
  53 Affinity        11    1    0 D             00 affinity(r[11])
  54 NotFound         3   76   11 1             00 key=r[11]; end IN expr
REG[11] =  i:1
  55 Column           0    0   13               00 r[13]=t0.c0
REG[13] =  i:1
  56 Integer         73   15    0               00 r[15]=73; return address
REG[15] =  i:73
  57 Once             0   73    0               00 
  58 Explain         58    0    0 SCALAR SUBQUERY 1 00 
  59 Null             0   16   16               00 r[16..16]=NULL; Init subquery result
REG[16] =  NULL
  60 Integer          1   17    0               00 r[17]=1; LIMIT counter
REG[17] =  i:1
  61 Null             0   18   19               00 r[18..19]=NULL
REG[18] =  NULL
  62 OpenRead         1    2    0 1             00 root=2 iDb=0; t0
  63 Explain         63   58    0 SCAN TABLE t0 00 
  64 Rewind           1   70    0               00 
  65 Column           1    0   21               00 r[21]=t0.c0
REG[21] =  i:1
  66 Column           1    0   22               00 r[22]=t0.c0
REG[22] =  i:1
  67 Eq              22   20   21 (BINARY)      63 r[20] = (r[21]==r[22])
REG[22] =  i:1
REG[21] =  i:1
REG[20] =  i:1
  68 AggStep          0   20   18 sum(1)        01 accum=r[18] step(r[20])
REG[20] =  i:1
  69 Next             1   65    0               01 
  65 Column           1    0   21               00 r[21]=t0.c0
REG[21] =  i:2
  66 Column           1    0   22               00 r[22]=t0.c0
REG[22] =  i:2
  67 Eq              22   20   21 (BINARY)      63 r[20] = (r[21]==r[22])
REG[22] =  i:2
REG[21] =  i:2
REG[20] =  i:1
  68 AggStep1         0   20   18 sum(1)        01 accum=r[18] step(r[20])
REG[20] =  i:1
  69 Next             1   65    0               01 
  65 Column           1    0   21               00 r[21]=t0.c0
REG[21] =  i:3
  66 Column           1    0   22               00 r[22]=t0.c0
REG[22] =  i:3
  67 Eq              22   20   21 (BINARY)      63 r[20] = (r[21]==r[22])
REG[22] =  i:3
REG[21] =  i:3
REG[20] =  i:1
  68 AggStep1         0   20   18 sum(1)        01 accum=r[18] step(r[20])
REG[20] =  i:1
  69 Next             1   65    0               01 
  65 Column           1    0   21               00 r[21]=t0.c0
REG[21] =  i:1
  66 Column           1    0   22               00 r[22]=t0.c0
REG[22] =  i:1
  67 Eq              22   20   21 (BINARY)      63 r[20] = (r[21]==r[22])
REG[22] =  i:1
REG[21] =  i:1
REG[20] =  i:1
  68 AggStep1         0   20   18 sum(1)        01 accum=r[18] step(r[20])
REG[20] =  i:1
  69 Next             1   65    0               01 
  65 Column           1    0   21               00 r[21]=t0.c0
REG[21] =  i:2
  66 Column           1    0   22               00 r[22]=t0.c0
REG[22] =  i:2
  67 Eq              22   20   21 (BINARY)      63 r[20] = (r[21]==r[22])
REG[22] =  i:2
REG[21] =  i:2
REG[20] =  i:1
  68 AggStep1         0   20   18 sum(1)        01 accum=r[18] step(r[20])
REG[20] =  i:1
  69 Next             1   65    0               01 
  65 Column           1    0   21               00 r[21]=t0.c0
REG[21] =  i:3
  66 Column           1    0   22               00 r[22]=t0.c0
REG[22] =  i:3
  67 Eq              22   20   21 (BINARY)      63 r[20] = (r[21]==r[22])
REG[22] =  i:3
REG[21] =  i:3
REG[20] =  i:1
  68 AggStep1         0   20   18 sum(1)        01 accum=r[18] step(r[20])
REG[20] =  i:1
  69 Next             1   65    0               01 
  70 AggFinal        18    1    0 sum(1)        00 accum=r[18] N=1
  71 Copy            18   16    0               00 r[16]=r[18]
REG[16] =  i:6
  72 DecrJumpZero    17   73    0               00 if (--r[17])==0 goto 73
REG[17] =  i:1
  73 Return          15    0    0               00 
REG[15] =  i:73
  74 Copy            16   14    0               00 r[14]=r[16]
REG[14] =  i:6
  75 ResultRow       13    2    0               00 output=r[13..14]
REG[13] =  i:1
REG[14] =  i:6
  76 Next             0    4    0               01 
   4 Noop             0    0    0               00 begin IN expr
   5 Integer         50    1    0               00 r[1]=50; return address
REG[1] =  i:50
   6 Once             1   50    0               00 
  50 Return           1    0    0               00 
REG[1] =  i:50
  51 Column           0    0   11               00 r[11]=t0.c0
REG[11] =  i:2
  52 IsNull          11   76    0               00 if r[11]==NULL goto 76
REG[11] =  i:2
  53 Affinity        11    1    0 D             00 affinity(r[11])
  54 NotFound         3   76   11 1             00 key=r[11]; end IN expr
REG[11] =  i:2
  55 Column           0    0   13               00 r[13]=t0.c0
REG[13] =  i:2
  56 Integer         73   15    0               00 r[15]=73; return address
REG[15] =  i:73
  57 Once             1   73    0               00 
  73 Return          15    0    0               00 
REG[15] =  i:73
  74 Copy            16   14    0               00 r[14]=r[16]
REG[14] =  i:6
  75 ResultRow       13    2    0               00 output=r[13..14]
REG[13] =  i:2
REG[14] =  i:6
  76 Next             0    4    0               01 
   4 Noop             0    0    0               00 begin IN expr
   5 Integer         50    1    0               00 r[1]=50; return address
REG[1] =  i:50
   6 Once             1   50    0               00 
  50 Return           1    0    0               00 
REG[1] =  i:50
  51 Column           0    0   11               00 r[11]=t0.c0
REG[11] =  i:3
  52 IsNull          11   76    0               00 if r[11]==NULL goto 76
REG[11] =  i:3
  53 Affinity        11    1    0 D             00 affinity(r[11])
  54 NotFound         3   76   11 1             00 key=r[11]; end IN expr
REG[11] =  i:3
  55 Column           0    0   13               00 r[13]=t0.c0
REG[13] =  i:3
  56 Integer         73   15    0               00 r[15]=73; return address
REG[15] =  i:73
  57 Once             1   73    0               00 
  73 Return          15    0    0               00 
REG[15] =  i:73
  74 Copy            16   14    0               00 r[14]=r[16]
REG[14] =  i:6
  75 ResultRow       13    2    0               00 output=r[13..14]
REG[13] =  i:3
REG[14] =  i:6
  76 Next             0    4    0               01 
   4 Noop             0    0    0               00 begin IN expr
   5 Integer         50    1    0               00 r[1]=50; return address
REG[1] =  i:50
   6 Once             1   50    0               00 
  50 Return           1    0    0               00 
REG[1] =  i:50
  51 Column           0    0   11               00 r[11]=t0.c0
REG[11] =  i:1
  52 IsNull          11   76    0               00 if r[11]==NULL goto 76
REG[11] =  i:1
  53 Affinity        11    1    0 D             00 affinity(r[11])
  54 NotFound         3   76   11 1             00 key=r[11]; end IN expr
REG[11] =  i:1
  55 Column           0    0   13               00 r[13]=t0.c0
REG[13] =  i:1
  56 Integer         73   15    0               00 r[15]=73; return address
REG[15] =  i:73
  57 Once             1   73    0               00 
  73 Return          15    0    0               00 
REG[15] =  i:73
  74 Copy            16   14    0               00 r[14]=r[16]
REG[14] =  i:6
  75 ResultRow       13    2    0               00 output=r[13..14]
REG[13] =  i:1
REG[14] =  i:6
  76 Next             0    4    0               01 
   4 Noop             0    0    0               00 begin IN expr
   5 Integer         50    1    0               00 r[1]=50; return address
REG[1] =  i:50
   6 Once             1   50    0               00 
  50 Return           1    0    0               00 
REG[1] =  i:50
  51 Column           0    0   11               00 r[11]=t0.c0
REG[11] =  i:2
  52 IsNull          11   76    0               00 if r[11]==NULL goto 76
REG[11] =  i:2
  53 Affinity        11    1    0 D             00 affinity(r[11])
  54 NotFound         3   76   11 1             00 key=r[11]; end IN expr
REG[11] =  i:2
  55 Column           0    0   13               00 r[13]=t0.c0
REG[13] =  i:2
  56 Integer         73   15    0               00 r[15]=73; return address
REG[15] =  i:73
  57 Once             1   73    0               00 
  73 Return          15    0    0               00 
REG[15] =  i:73
  74 Copy            16   14    0               00 r[14]=r[16]
REG[14] =  i:6
  75 ResultRow       13    2    0               00 output=r[13..14]
REG[13] =  i:2
REG[14] =  i:6
  76 Next             0    4    0               01 
   4 Noop             0    0    0               00 begin IN expr
   5 Integer         50    1    0               00 r[1]=50; return address
REG[1] =  i:50
   6 Once             1   50    0               00 
  50 Return           1    0    0               00 
REG[1] =  i:50
  51 Column           0    0   11               00 r[11]=t0.c0
REG[11] =  i:3
  52 IsNull          11   76    0               00 if r[11]==NULL goto 76
REG[11] =  i:3
  53 Affinity        11    1    0 D             00 affinity(r[11])
  54 NotFound         3   76   11 1             00 key=r[11]; end IN expr
REG[11] =  i:3
  55 Column           0    0   13               00 r[13]=t0.c0
REG[13] =  i:3
  56 Integer         73   15    0               00 r[15]=73; return address
REG[15] =  i:73
  57 Once             1   73    0               00 
  73 Return          15    0    0               00 
REG[15] =  i:73
  74 Copy            16   14    0               00 r[14]=r[16]
REG[14] =  i:6
  75 ResultRow       13    2    0               00 output=r[13..14]
REG[13] =  i:3
REG[14] =  i:6
  76 Next             0    4    0               01 
  77 Halt             0    0    0               00 
SQL: [;
;SELECT c0 FROM t0 WHERE c0 GLOB 'ABC*' ORDER BY 1
  
;]
VDBE Program Listing:
   0 Init             0   20    0               00 Start at 20
   1 SorterOpen       1    3    0 k(1,B)        00 
   2 OpenRead         0    2    0 1             00 root=2 iDb=0; t0
   3 Explain          3    0    0 SCAN TABLE t0 00 
   4 Rewind           0   12    0               00 
   5 Column           0    0    3               00 r[3]=t0.c0
   6 Function0        1    2    1 glob(2)       02 r[1]=func(r[2..3])
   7 IfNot            1   11    1               00 
   8 Column           0    0    4               00 r[4]=t0.c0
   9 MakeRecord       4    1    6               00 r[6]=mkrec(r[4])
  10 SorterInsert     1    6    4 1             00 key=r[6]
  11 Next             0    5    0               01 
  12 Explain         12    0    0 USE TEMP B-TREE FOR ORDER BY 00 
  13 OpenPseudo       2    7    3               00 3 columns in r[7]
  14 SorterSort       1   19    0               00 
  15 SorterData       1    7    2               00 r[7]=data
  16 Column           2    0    5               00 r[5]=c0
  17 ResultRow        5    1    0               00 output=r[5]
  18 SorterNext       1   15    0               00 
  19 Halt             0    0    0               00 
  20 Transaction      0    0   15 0             01 usesStmtJournal=0
  21 String8          0    2    0 ABC*          00 r[2]='ABC*'
  22 Goto             0    1    0               00 
VDBE Trace:
   0 Init             0   20    0               00 Start at 20
  20 Transaction      0    0   15 0             01 usesStmtJournal=0
  21 String8          0    2    0 ABC*          00 r[2]='ABC*'
REG[2] =   t4[ABC*](8)
  22 Goto             0    1    0               00 
   1 SorterOpen       1    3    0 k(1,B)        00 
   2 OpenRead         0    2    0 1             00 root=2 iDb=0; t0
   3 Explain          3    0    0 SCAN TABLE t0 00 
   4 Rewind           0   12    0               00 
   5 Column           0    0    3               00 r[3]=t0.c0
REG[3] =  i:1
   6 Function0        1    2    1 glob(2)       02 r[1]=func(r[2..3])
REG[2] =   t4[ABC*](8)
REG[3] =  i:1
REG[1] =  i:0
   7 IfNot            1   11    1               00 
REG[1] =  i:0
  11 Next             0    5    0               01 
   5 Column           0    0    3               00 r[3]=t0.c0
REG[3] =  i:2
   6 Function         1    2    1 glob(2)       02 r[1]=func(r[2..3])
REG[2] =   t4[ABC*](8)
REG[3] =  i:2
REG[1] =  i:0
   7 IfNot            1   11    1               00 
REG[1] =  i:0
  11 Next             0    5    0               01 
   5 Column           0    0    3               00 r[3]=t0.c0
REG[3] =  i:3
   6 Function         1    2    1 glob(2)       02 r[1]=func(r[2..3])
REG[2] =   t4[ABC*](8)
REG[3] =  i:3
REG[1] =  i:0
   7 IfNot            1   11    1               00 
REG[1] =  i:0
  11 Next             0    5    0               01 
   5 Column           0    0    3               00 r[3]=t0.c0
REG[3] =  i:1
   6 Function         1    2    1 glob(2)       02 r[1]=func(r[2..3])
REG[2] =   t4[ABC*](8)
REG[3] =  i:1
REG[1] =  i:0
   7 IfNot            1   11    1               00 
REG[1] =  i:0
  11 Next             0    5    0               01 
   5 Column           0    0    3               00 r[3]=t0.c0
REG[3] =  i:2
   6 Function         1    2    1 glob(2)       02 r[1]=func(r[2..3])
REG[2] =   t4[ABC*](8)
REG[3] =  i:2
REG[1] =  i:0
   7 IfNot            1   11    1               00 
REG[1] =  i:0
  11 Next             0    5    0               01 
   5 Column           0    0    3               00 r[3]=t0.c0
REG[3] =  i:3
   6 Function         1    2    1 glob(2)       02 r[1]=func(r[2..3])
REG[2] =   t4[ABC*](8)
REG[3] =  i:3
REG[1] =  i:0
   7 IfNot            1   11    1               00 
REG[1] =  i:0
  11 Next             0    5    0               01 
  12 Explain         12    0    0 USE TEMP B-TREE FOR ORDER BY 00 
  13 OpenPseudo       2    7    3               00 3 columns in r[7]
  14 SorterSort       1   19    0               00 
  19 Halt             0    0    0               00 
SQL: [;CREATE TABLE t1(x INT);]
VDBE Program Listing:
   0 Init             0   28    0               00 Start at 28
   1 ReadCookie       0    3    2               00 
   2 If               3    5    0               00 
   3 SetCookie        0    2    4               00 
   4 SetCookie        0    5    1               00 
   5 CreateBtree      0    2    1               00 r[2]=root iDb=0 flags=1
   6 OpenWrite        0    1    0 5             00 root=1 iDb=0
   7 NewRowid         0    1    0               00 r[1]=rowid
   8 Blob             6    3    0              00 r[3]= (len=6)
   9 Insert           0    3    1               08 intkey=r[1] data=r[3]
  10 Close            0    0    0               00 
  11 Close            0    0    0               00 
  12 Null             0    4    5               00 r[4..5]=NULL
  13 OpenWrite        1    1    0 5             00 root=1 iDb=0; sqlite_master
  14 Explain         14    0    0 SEARCH TABLE sqlite_master USING INTEGER PRIMARY KEY (rowid=?) 00 
  15 SeekRowid        1   17    1               00 intkey=r[1]
  16 Rowid            1    5    0               00 r[5]=rowid
  17 IsNull           5   25    0               00 if r[5]==NULL goto 25
  18 String8          0    6    0 table         00 r[6]='table'
  19 String8          0    7    0 t1            00 r[7]='t1'
  20 String8          0    8    0 t1            00 r[8]='t1'
  21 Copy             2    9    0               00 r[9]=r[2]
  22 String8          0   10    0 CREATE TABLE t1(x INT) 00 r[10]='CREATE TABLE t1(x INT)'
  23 MakeRecord       6    5   11 BBBDB         00 r[11]=mkrec(r[6..10])
  24 Insert           1   11    5               00 intkey=r[5] data=r[11]
  25 SetCookie        0    1   16               00 
  26 ParseSchema      0    0    0 tbl_name='t1' AND type!='trigger' 00 
  27 Halt             0    0    0               00 
  28 Transaction      0    1   15 0             01 usesStmtJournal=0
  29 Goto             0    1    0               00 
VDBE Trace:
   0 Init             0   28    0               00 Start at 28
  28 Transaction      0    1   15 0             01 usesStmtJournal=0
  29 Goto             0    1    0               00 
   1 ReadCookie       0    3    2               00 
REG[3] =  i:4
   2 If               3    5    0               00 
REG[3] =  i:4
   5 CreateBtree      0    2    1               00 r[2]=root iDb=0 flags=1
REG[2] =  i:3
   6 OpenWrite        0    1    0 5             00 root=1 iDb=0
   7 NewRowid         0    1    0               00 r[1]=rowid
REG[1] =  i:7
   8 Blob             6    3    0              00 r[3]= (len=6)
REG[3] =  t6[060000000000......]
   9 Insert           0    3    1               08 intkey=r[1] data=r[3]
REG[3] =  t6[060000000000......]
REG[1] =  i:7
  10 Close            0    0    0               00 
  11 Close            0    0    0               00 
  12 Null             0    4    5               00 r[4..5]=NULL
REG[4] =  NULL
  13 OpenWrite        1    1    0 5             00 root=1 iDb=0; sqlite_master
  14 Explain         14    0    0 SEARCH TABLE sqlite_master USING INTEGER PRIMARY KEY (rowid=?) 00 
  15 SeekRowid        1   17    1               00 intkey=r[1]
REG[1] =  i:7
  16 Rowid            1    5    0               00 r[5]=rowid
REG[5] =  i:7
  17 IsNull           5   25    0               00 if r[5]==NULL goto 25
REG[5] =  i:7
  18 String8          0    6    0 table         00 r[6]='table'
REG[6] =   t5[table](8)
  19 String8          0    7    0 t1            00 r[7]='t1'
REG[7] =   t2[t1](8)
  20 String8          0    8    0 t1            00 r[8]='t1'
REG[8] =   t2[t1](8)
  21 Copy             2    9    0               00 r[9]=r[2]
REG[9] =  i:3
  22 String8          0   10    0 CREATE TABLE t1(x INT) 00 r[10]='CREATE TABLE t1(x INT)'
REG[10] =   t22[CREATE TABLE t1](8)
  23 MakeRecord       6    5   11 BBBDB         00 r[11]=mkrec(r[6..10])
REG[11] =  s38[0617111101397461626C657431743103.....9tablet1t1.]
  24 Insert           1   11    5               00 intkey=r[5] data=r[11]
REG[11] =  s38[0617111101397461626C657431743103.....9tablet1t1.]
REG[5] =  i:7
  25 SetCookie        0    1   16               00 
  26 ParseSchema      0    0    0 tbl_name='t1' AND type!='trigger' 00 
VDBE Program Listing:
   0 Init             0   15    0               00 Start at 15
   1 Noop             1    5    0               00 
   2 OpenRead         0    1    0 5             00 root=1 iDb=0; sqlite_master
   3 Explain          3    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   14    0               00 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
   6 Ne               2   13    1 (BINARY)      52 if r[1]!=r[2] goto 13
   7 Column           0    0    1               00 r[1]=sqlite_master.type
   8 Eq               3   13    1 (BINARY)      52 if r[1]==r[3] goto 13
   9 Column           0    1    4               00 r[4]=sqlite_master.name
  10 Column           0    3    5               00 r[5]=sqlite_master.rootpage
  11 Column           0    4    6               00 r[6]=sqlite_master.sql
  12 ResultRow        4    3    0               00 output=r[4..6]
  13 Next             0    5    0               01 
  14 Halt             0    0    0               00 
  15 Transaction      0    0   16 0             00 usesStmtJournal=0
  16 String8          0    2    0 t1            00 r[2]='t1'
  17 String8          0    3    0 trigger       00 r[3]='trigger'
  18 Goto             0    1    0               00 
VDBE Trace:
   0 Init             0   15    0               00 Start at 15
  15 Transaction      0    0   16 0             00 usesStmtJournal=0
  16 String8          0    2    0 t1            00 r[2]='t1'
REG[2] =   t2[t1](8)
  17 String8          0    3    0 trigger       00 r[3]='trigger'
REG[3] =   t7[trigger](8)
  18 Goto             0    1    0               00 
   1 Noop             1    5    0               00 
   2 OpenRead         0    1    0 5             00 root=1 iDb=0; sqlite_master
   3 Explain          3    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   14    0               00 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[t0](8)
   6 Ne               2   13    1 (BINARY)      52 if r[1]!=r[2] goto 13
REG[2] =   t2[t1](8)
REG[1] =   s2[t0](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s15[sqlite_sequence](8)
   6 Ne               2   13    1 (BINARY)      52 if r[1]!=r[2] goto 13
REG[2] =   t2[t1](8)
REG[1] =   s15[sqlite_sequence](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[v0](8)
   6 Ne               2   13    1 (BINARY)      52 if r[1]!=r[2] goto 13
REG[2] =   t2[t1](8)
REG[1] =   s2[v0](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[t0](8)
   6 Ne               2   13    1 (BINARY)      52 if r[1]!=r[2] goto 13
REG[2] =   t2[t1](8)
REG[1] =   s2[t0](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[t1](8)
   6 Ne               2   13    1 (BINARY)      52 if r[1]!=r[2] goto 13
REG[2] =   t2[t1](8)
REG[1] =   s2[t1](8)
   7 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[table](8)
   8 Eq               3   13    1 (BINARY)      52 if r[1]==r[3] goto 13
REG[3] =   t7[trigger](8)
REG[1] =   s5[table](8)
   9 Column           0    1    4               00 r[4]=sqlite_master.name
REG[4] =   s2[t1](8)
  10 Column           0    3    5               00 r[5]=sqlite_master.rootpage
REG[5] =  i:3
  11 Column           0    4    6               00 r[6]=sqlite_master.sql
REG[6] =   s22[CREATE TABLE t1](8)
  12 ResultRow        4    3    0               00 output=r[4..6]
REG[4] =   s2[t1](8)
REG[5] =  i:3
REG[6] =   s22[CREATE TABLE t1](8)
  13 Next             0    5    0               01 
  14 Halt             0    0    0               00 
  27 Halt             0    0    0               00 
SQL: [PRAGMA case_sensitive_like=off;]
VDBE Program Listing:
   0 Init             0    1    0               00 Start at 1
   1 Halt             0    0    0               00 
VDBE Trace:
   0 Init             0    1    0               00 Start at 1
   1 Halt             0    0    0               00 
SQL: [;INSERT INTO v0(over) VALUES(123);]
VDBE Program Listing:
   0 Init             0    7    0               00 Start at 7
   1 OpenWrite        0    4    0 2             00 root=4 iDb=0; v0
   2 NewRowid         0    1    0               00 r[1]=rowid
   3 Integer        123    3    0               00 r[3]=123
   4 MakeRecord       2    2    4               00 r[4]=mkrec(r[2..3])
   5 Insert           0    4    1 v0            39 intkey=r[1] data=r[4]
   6 Halt             0    0    0               00 
   7 Transaction      0    1   16 0             01 usesStmtJournal=0
   8 Null             0    2    0               00 r[2]=NULL
   9 Goto             0    1    0               00 
VDBE Trace:
   0 Init             0    7    0               00 Start at 7
   7 Transaction      0    1   16 0             01 usesStmtJournal=0
   8 Null             0    2    0               00 r[2]=NULL
REG[2] =  NULL
   9 Goto             0    1    0               00 
   1 OpenWrite        0    4    0 2             00 root=4 iDb=0; v0
   2 NewRowid         0    1    0               00 r[1]=rowid
REG[1] =  i:1
   3 Integer        123    3    0               00 r[3]=123
REG[3] =  i:123
   4 MakeRecord       2    2    4               00 r[4]=mkrec(r[2..3])
REG[4] =  s4[0300017B...{]
   5 Insert           0    4    1 v0            39 intkey=r[1] data=r[4]
REG[4] =  s4[0300017B...{]
REG[1] =  i:1
   6 Halt             0    0    0               00 
SQL: [;CREATE TABLE test001(last_field INT);]
VDBE Program Listing:
   0 Init             0   28    0               00 Start at 28
   1 ReadCookie       0    3    2               00 
   2 If               3    5    0               00 
   3 SetCookie        0    2    4               00 
   4 SetCookie        0    5    1               00 
   5 CreateBtree      0    2    1               00 r[2]=root iDb=0 flags=1
   6 OpenWrite        0    1    0 5             00 root=1 iDb=0
   7 NewRowid         0    1    0               00 r[1]=rowid
   8 Blob             6    3    0              00 r[3]= (len=6)
   9 Insert           0    3    1               08 intkey=r[1] data=r[3]
  10 Close            0    0    0               00 
  11 Close            0    0    0               00 
  12 Null             0    4    5               00 r[4..5]=NULL
  13 OpenWrite        1    1    0 5             00 root=1 iDb=0; sqlite_master
  14 Explain         14    0    0 SEARCH TABLE sqlite_master USING INTEGER PRIMARY KEY (rowid=?) 00 
  15 SeekRowid        1   17    1               00 intkey=r[1]
  16 Rowid            1    5    0               00 r[5]=rowid
  17 IsNull           5   25    0               00 if r[5]==NULL goto 25
  18 String8          0    6    0 table         00 r[6]='table'
  19 String8          0    7    0 test001       00 r[7]='test001'
  20 String8          0    8    0 test001       00 r[8]='test001'
  21 Copy             2    9    0               00 r[9]=r[2]
  22 String8          0   10    0 CREATE TABLE test001(last_field INT) 00 r[10]='CREATE TABLE test001(last_field INT)'
  23 MakeRecord       6    5   11 BBBDB         00 r[11]=mkrec(r[6..10])
  24 Insert           1   11    5               00 intkey=r[5] data=r[11]
  25 SetCookie        0    1   17               00 
  26 ParseSchema      0    0    0 tbl_name='test001' AND type!='trigger' 00 
  27 Halt             0    0    0               00 
  28 Transaction      0    1   16 0             01 usesStmtJournal=0
  29 Goto             0    1    0               00 
VDBE Trace:
   0 Init             0   28    0               00 Start at 28
  28 Transaction      0    1   16 0             01 usesStmtJournal=0
  29 Goto             0    1    0               00 
   1 ReadCookie       0    3    2               00 
REG[3] =  i:4
   2 If               3    5    0               00 
REG[3] =  i:4
   5 CreateBtree      0    2    1               00 r[2]=root iDb=0 flags=1
REG[2] =  i:7
   6 OpenWrite        0    1    0 5             00 root=1 iDb=0
   7 NewRowid         0    1    0               00 r[1]=rowid
REG[1] =  i:8
   8 Blob             6    3    0              00 r[3]= (len=6)
REG[3] =  t6[060000000000......]
   9 Insert           0    3    1               08 intkey=r[1] data=r[3]
REG[3] =  t6[060000000000......]
REG[1] =  i:8
  10 Close            0    0    0               00 
  11 Close            0    0    0               00 
  12 Null             0    4    5               00 r[4..5]=NULL
REG[4] =  NULL
  13 OpenWrite        1    1    0 5             00 root=1 iDb=0; sqlite_master
  14 Explain         14    0    0 SEARCH TABLE sqlite_master USING INTEGER PRIMARY KEY (rowid=?) 00 
  15 SeekRowid        1   17    1               00 intkey=r[1]
REG[1] =  i:8
  16 Rowid            1    5    0               00 r[5]=rowid
REG[5] =  i:8
  17 IsNull           5   25    0               00 if r[5]==NULL goto 25
REG[5] =  i:8
  18 String8          0    6    0 table         00 r[6]='table'
REG[6] =   t5[table](8)
  19 String8          0    7    0 test001       00 r[7]='test001'
REG[7] =   t7[test001](8)
  20 String8          0    8    0 test001       00 r[8]='test001'
REG[8] =   t7[test001](8)
  21 Copy             2    9    0               00 r[9]=r[2]
REG[9] =  i:7
  22 String8          0   10    0 CREATE TABLE test001(last_field INT) 00 r[10]='CREATE TABLE test001(last_field INT)'
REG[10] =   t36[CREATE TABLE te](8)
  23 MakeRecord       6    5   11 BBBDB         00 r[11]=mkrec(r[6..10])
REG[11] =  s62[06171B1B01557461626C657465737430.....Utabletest0]
  24 Insert           1   11    5               00 intkey=r[5] data=r[11]
REG[11] =  s62[06171B1B01557461626C657465737430.....Utabletest0]
REG[5] =  i:8
  25 SetCookie        0    1   17               00 
  26 ParseSchema      0    0    0 tbl_name='test001' AND type!='trigger' 00 
VDBE Program Listing:
   0 Init             0   15    0               00 Start at 15
   1 Noop             1    5    0               00 
   2 OpenRead         0    1    0 5             00 root=1 iDb=0; sqlite_master
   3 Explain          3    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   14    0               00 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
   6 Ne               2   13    1 (BINARY)      52 if r[1]!=r[2] goto 13
   7 Column           0    0    1               00 r[1]=sqlite_master.type
   8 Eq               3   13    1 (BINARY)      52 if r[1]==r[3] goto 13
   9 Column           0    1    4               00 r[4]=sqlite_master.name
  10 Column           0    3    5               00 r[5]=sqlite_master.rootpage
  11 Column           0    4    6               00 r[6]=sqlite_master.sql
  12 ResultRow        4    3    0               00 output=r[4..6]
  13 Next             0    5    0               01 
  14 Halt             0    0    0               00 
  15 Transaction      0    0   17 0             00 usesStmtJournal=0
  16 String8          0    2    0 test001       00 r[2]='test001'
  17 String8          0    3    0 trigger       00 r[3]='trigger'
  18 Goto             0    1    0               00 
VDBE Trace:
   0 Init             0   15    0               00 Start at 15
  15 Transaction      0    0   17 0             00 usesStmtJournal=0
  16 String8          0    2    0 test001       00 r[2]='test001'
REG[2] =   t7[test001](8)
  17 String8          0    3    0 trigger       00 r[3]='trigger'
REG[3] =   t7[trigger](8)
  18 Goto             0    1    0               00 
   1 Noop             1    5    0               00 
   2 OpenRead         0    1    0 5             00 root=1 iDb=0; sqlite_master
   3 Explain          3    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   14    0               00 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[t0](8)
   6 Ne               2   13    1 (BINARY)      52 if r[1]!=r[2] goto 13
REG[2] =   t7[test001](8)
REG[1] =   s2[t0](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s15[sqlite_sequence](8)
   6 Ne               2   13    1 (BINARY)      52 if r[1]!=r[2] goto 13
REG[2] =   t7[test001](8)
REG[1] =   s15[sqlite_sequence](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[v0](8)
   6 Ne               2   13    1 (BINARY)      52 if r[1]!=r[2] goto 13
REG[2] =   t7[test001](8)
REG[1] =   s2[v0](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[t0](8)
   6 Ne               2   13    1 (BINARY)      52 if r[1]!=r[2] goto 13
REG[2] =   t7[test001](8)
REG[1] =   s2[t0](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[t1](8)
   6 Ne               2   13    1 (BINARY)      52 if r[1]!=r[2] goto 13
REG[2] =   t7[test001](8)
REG[1] =   s2[t1](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s7[test001](8)
   6 Ne               2   13    1 (BINARY)      52 if r[1]!=r[2] goto 13
REG[2] =   t7[test001](8)
REG[1] =   s7[test001](8)
   7 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[table](8)
   8 Eq               3   13    1 (BINARY)      52 if r[1]==r[3] goto 13
REG[3] =   t7[trigger](8)
REG[1] =   s5[table](8)
   9 Column           0    1    4               00 r[4]=sqlite_master.name
REG[4] =   s7[test001](8)
  10 Column           0    3    5               00 r[5]=sqlite_master.rootpage
REG[5] =  i:7
  11 Column           0    4    6               00 r[6]=sqlite_master.sql
REG[6] =   s36[CREATE TABLE te](8)
  12 ResultRow        4    3    0               00 output=r[4..6]
REG[4] =   s7[test001](8)
REG[5] =  i:7
REG[6] =   s36[CREATE TABLE te](8)
  13 Next             0    5    0               01 
  14 Halt             0    0    0               00 
  27 Halt             0    0    0               00 
SQL: [;INSERT INTO test001(last_field) VALUES(456);]
VDBE Program Listing:
   0 Init             0    7    0               00 Start at 7
   1 OpenWrite        0    7    0 1             00 root=7 iDb=0; test001
   2 NewRowid         0    1    0               00 r[1]=rowid
   3 Integer        456    2    0               00 r[2]=456
   4 MakeRecord       2    1    3 D             00 r[3]=mkrec(r[2])
   5 Insert           0    3    1 test001       39 intkey=r[1] data=r[3]
   6 Halt             0    0    0               00 
   7 Transaction      0    1   17 0             01 usesStmtJournal=0
   8 Goto             0    1    0               00 
VDBE Trace:
   0 Init             0    7    0               00 Start at 7
   7 Transaction      0    1   17 0             01 usesStmtJournal=0
   8 Goto             0    1    0               00 
   1 OpenWrite        0    7    0 1             00 root=7 iDb=0; test001
   2 NewRowid         0    1    0               00 r[1]=rowid
REG[1] =  i:1
   3 Integer        456    2    0               00 r[2]=456
REG[2] =  i:456
   4 MakeRecord       2    1    3 D             00 r[3]=mkrec(r[2])
REG[3] =  s4[020201C8....]
   5 Insert           0    3    1 test001       39 intkey=r[1] data=r[3]
REG[3] =  s4[020201C8....]
REG[1] =  i:1
   6 Halt             0    0    0               00 
SQL: [;SELECT (SELECT sum(c0+(SELECT last_field)) FROM test001) FROM t0;]
VDBE Program Listing:
   0 Init             0   28    0               00 Start at 28
   1 Null             0    1    2               00 r[1..2]=NULL
   2 OpenRead         0    2    0 1             00 root=2 iDb=0; t0
   3 Explain          3    0    0 SCAN TABLE t0 00 
   4 Rewind           0   15    0               00 
   5 Column           0    0    4               00 r[4]=t0.c0
   6 Explain          6    0    0 CORRELATED SCALAR SUBQUERY 1 00 
   7 Null             0    6    6               00 r[6..6]=NULL; Init subquery result
   8 Integer          1    7    0               00 r[7]=1; LIMIT counter
   9 Explain          9    6    0 SCAN CONSTANT ROW 00 
  10 Column           1    0    6               00 r[6]=test001.last_field
  11 DecrJumpZero     7   12    0               00 if (--r[7])==0 goto 12
  12 Add              6    4    3               00 r[3]=r[6]+r[4]
  13 AggStep          0    3    1 sum(1)        01 accum=r[1] step(r[3])
  14 Next             0    5    0               01 
  15 AggFinal         1    1    0 sum(1)        00 accum=r[1] N=1
  16 Explain         16    0    0 CORRELATED SCALAR SUBQUERY 2 00 
  17 Null             0    9    9               00 r[9..9]=NULL; Init subquery result
  18 Integer          1   10    0               00 r[10]=1; LIMIT counter
  19 OpenRead         1    7    0 1             00 root=7 iDb=0; test001
  20 Explain         20   16    0 SCAN TABLE test001 00 
  21 Rewind           1   25    0               00 
  22 Copy             1    9    0               00 r[9]=r[1]
  23 DecrJumpZero    10   25    0               00 if (--r[10])==0 goto 25
  24 Next             1   22    0               01 
  25 Copy             9    8    0               00 r[8]=r[9]
  26 ResultRow        8    1    0               00 output=r[8]
  27 Halt             0    0    0               00 
  28 Transaction      0    0   17 0             01 usesStmtJournal=0
  29 Goto             0    1    0               00 
VDBE Trace:
   0 Init             0   28    0               00 Start at 28
  28 Transaction      0    0   17 0             01 usesStmtJournal=0
  29 Goto             0    1    0               00 
   1 Null             0    1    2               00 r[1..2]=NULL
REG[1] =  NULL
   2 OpenRead         0    2    0 1             00 root=2 iDb=0; t0
   3 Explain          3    0    0 SCAN TABLE t0 00 
   4 Rewind           0   15    0               00 
   5 Column           0    0    4               00 r[4]=t0.c0
REG[4] =  i:1
   6 Explain          6    0    0 CORRELATED SCALAR SUBQUERY 1 00 
   7 Null             0    6    6               00 r[6..6]=NULL; Init subquery result
REG[6] =  NULL
   8 Integer          1    7    0               00 r[7]=1; LIMIT counter
REG[7] =  i:1
   9 Explain          9    6    0 SCAN CONSTANT ROW 00 
  10 Column           1    0    6               00 r[6]=test001.last_field

Program received signal SIGSEGV, Segmentation fault.
0x00000000003e1e8f in sqlite3VdbeCursorMoveto (pp=0x7fff44ce3138, piCol=0x7fff44ce30c8) at sqlite3.c:79680
79680	  assert( p->eCurType==CURTYPE_BTREE || p->eCurType==CURTYPE_PSEUDO );
(gdb) #0  0x00000000003e1e8f in sqlite3VdbeCursorMoveto (pp=0x7fff44ce3138, piCol=0x7fff44ce30c8) at sqlite3.c:79680
#1  0x00000000003c7ccb in sqlite3VdbeExec (p=0x1aa9f00) at sqlite3.c:86079
#2  0x0000000000411104 in sqlite3Step (p=0x1aa9f00) at sqlite3.c:81930
#3  0x000000000029128d in sqlite3_step (pStmt=0x1aa9f00) at sqlite3.c:81995
#4  0x00000000002570b9 in main (argc=1, argv=0x7fff44ce3428) at target.cc:139
(gdb) quit
A debugging session is active.

	Inferior 1 [process 58843] will be killed.

Quit anyway? (y or n) [answered Y; input not from terminal]
