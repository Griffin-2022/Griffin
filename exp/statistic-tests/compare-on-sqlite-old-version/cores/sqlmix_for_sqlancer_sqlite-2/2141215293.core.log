GNU gdb (Ubuntu 9.2-0ubuntu1~20.04.1) 9.2
Copyright (C) 2020 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type "show copying" and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
    <http://www.gnu.org/software/gdb/documentation/>.

For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from /root/sqlite_driver_fast...
(gdb) Starting program: /root/sqlite_driver_fast < "/root/out/default/crashes/id:000230,sig:06,src:020508+020387,time:3536079,execs:600465,op:merge.so,pos:0"
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
SQL: [;PRAGMA vdbe_trace=on;]
VDBE Trace:
   0 Init             0    1    0               00 Start at 1
   1 Expire           0    0    0               00 
   2 Halt             0    0    0               00 
SQL: [;WITH RECURSIVE c(c0) AS (VALUES(1) UNION SELECT c0+1 FROM c WHERE c0<$::i)
        INSERT INTO t0(c0,c0) SELECT c0*10+1, printf('%04d%.800c',c0,'*') FROM c;]
VDBE Trace:
   0 Init             0   56    0               00 Start at 56
  56 Transaction      0    1    3 0             01 usesStmtJournal=1
  57 Variable         1   10    0 $::i          00 r[10]=parameter(1,$::i)
REG[10] =  NULL
  58 Integer          1   11    0               00 r[11]=1
REG[11] =  i:1
  59 Integer         10   16    0               00 r[16]=10
REG[16] =  i:10
  60 String8          0   17    0 %04d%.800c    00 r[17]='%04d%.800c'
REG[17] =   t10[%04d%.800c](8)
  61 String8          0   19    0 *             00 r[19]='*'
REG[19] =   t1[*](8)
  62 Goto             0    1    0               00 
   1 InitCoroutine    3   45    2               00 
  45 OpenWrite        4    2    0 1             00 root=2 iDb=0; t0
  46 Yield            3   55    0               00 
REG[3] =  i:1
REG[3] =  i:46
   2 InitCoroutine    4   34    3               00 c
  34 Explain         34    0    0 SCAN SUBQUERY 2 00 
  35 InitCoroutine    4    0    3               00 
  36 Yield            4   44    0               00 next row of c
REG[4] =  i:2
REG[4] =  i:36
   3 Explain          3    0    0 CO-ROUTINE 2  00 
   4 OpenPseudo       1    5    1               00 1 columns in r[5]
   5 OpenEphemeral    2    1    0               00 nColumn=1; Queue table
   6 OpenEphemeral    3    1    0 k(1,B)        00 nColumn=1
   7 Explain          7    3    0 SETUP         00 
   8 Explain          8    7    0 SCAN CONSTANT ROW 00 
   9 Integer          1    6    0               00 r[6]=1
REG[6] =  i:1
  10 MakeRecord       6    1    7               00 r[7]=mkrec(r[6])
REG[7] =  s2[0209..]
  11 Found            3   15    7 0             00 key=r[7]
REG[7] =  s2[0209..]
  12 IdxInsert        3    7    6 1             00 key=r[7]
REG[7] =  s2[0209..]
  13 NewRowid         2    8    0               00 r[8]=rowid
REG[8] =  i:1
  14 Insert           2    7    8               08 intkey=r[8] data=r[7]
REG[7] =  s2[0209..]
REG[8] =  i:1
  15 Rewind           2   33    0               00 
  16 NullRow          1    0    0               00 
  17 RowData          2    5    0               00 r[5]=data
REG[5] =  s2[0209..]
  18 Delete           2    0    0               00 
  19 Column           1    0    9               00 r[9]=
REG[9] =  i:1
  20 Yield            4    0    0               00 
REG[4] =  i:36
REG[4] =  i:20
  37 Copy             9   15    0               00 r[15]=r[9]; c.c0
REG[15] =  i:1
  38 Multiply        16   15   14               00 r[14]=r[16]*r[15]
REG[16] =  i:10
REG[15] =  i:1
REG[14] =  i:10
  39 Add             11   14   12               00 r[12]=r[11]+r[14]
REG[11] =  i:1
REG[14] =  i:10
REG[12] =  i:11
  40 Copy             9   18    0               00 r[18]=r[9]; c.c0
REG[18] =  i:1
  41 Function0        5   17   13 printf(-1)    03 r[13]=func(r[17..19])
REG[17] =   t10[%04d%.800c](8)
REG[18] =  i:1
REG[19] =   t1[*](8)
REG[13] =   s804[0001***********](8)
  42 Yield            3    0    0               00 
REG[3] =  i:46
REG[3] =  i:42
  47 NewRowid         4    1    0               00 r[1]=rowid
REG[1] =  i:1
  48 SCopy           12    2    0               00 r[2]=r[12]
REG[2] =  i:11
  49 Abortable        0    0    0               00 
  50 Eq               2   52    2 (BINARY)      52 if r[2]==r[2] goto 52

Program received signal SIGABRT, Aborted.
__GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:50
(gdb) #0  __GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:50
#1  0x00007f32b3890859 in __GI_abort () at abort.c:79
#2  0x00007f32b3890729 in __assert_fail_base (fmt=0x7f32b3a26588 "%s%s%s:%u: %s%sAssertion `%s' failed.\n%n", assertion=0x21d368 "pIn1!=pIn3", file=0x22873d "sqlite3.c", line=85580, function=<optimized out>) at assert.c:92
#3  0x00007f32b38a1fd6 in __GI___assert_fail (assertion=0x21d368 "pIn1!=pIn3", file=0x22873d "sqlite3.c", line=85580, function=0x216524 "int sqlite3VdbeExec(Vdbe *)") at assert.c:101
#4  0x00000000003c5c6a in sqlite3VdbeExec (p=0x2358970) at sqlite3.c:85580
#5  0x0000000000411104 in sqlite3Step (p=0x2358970) at sqlite3.c:81930
#6  0x000000000029128d in sqlite3_step (pStmt=0x2358970) at sqlite3.c:81995
#7  0x00000000002570b9 in main (argc=1, argv=0x7fff014f9818) at target.cc:139
(gdb) quit
A debugging session is active.

	Inferior 1 [process 56811] will be killed.

Quit anyway? (y or n) [answered Y; input not from terminal]
