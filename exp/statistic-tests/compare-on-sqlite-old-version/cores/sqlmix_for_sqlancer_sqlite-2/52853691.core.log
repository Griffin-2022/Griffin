GNU gdb (Ubuntu 9.2-0ubuntu1~20.04.1) 9.2
Copyright (C) 2020 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type "show copying" and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
    <http://www.gnu.org/software/gdb/documentation/>.

For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from /root/sqlite_driver_fast...
(gdb) Starting program: /root/sqlite_driver_fast < "/root/out/default/crashes/id:000111,sig:06,src:019785+012652,time:1442729,execs:168877,op:merge.so,pos:0"
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
parser: [[[CREATE TABLE t0(c0);;INSERT INTO t0 VALUES(1);SELECT (SELECT 1, 2, 3) == (SELECT 1, 2, 3)
;SELECT (1, 2, NULL) == (1, 2, 3)
;SELECT (1, 2, NULL) IS (1, 2, 3)
;SELECT (1, 2, NULL) IS NOT (1, 2, 3)
;SELECT (1, 2, NULL) != (1, 2, NULL)
;SELECT (1, 2, NULL) IS (1, 2, NULL)
;SELECT (SELECT 1, 2, NULL) == (SELECT 1, 2, NULL)
;SELECT (NULL, NULL, NULL) != (NULL, NULL, NULL)
;SELECT (SELECT NULL, NULL, NULL) != (SELECT NULL, NULL, NULL)
;SELECT (1, NULL, 1) != (1, 1, 1)
;SELECT (1, NULL, 1) IS (1, 1, 1)
;SELECT (SELECT 1, NULL, 1) == (SELECT 1, 1, 1)
;SELECT (SELECT 1, NULL, 1) != (SELECT 1, 1, 1)
;SELECT (1, NULL, 1) == (1, 1, 2)
;SELECT (1, NULL, 1) IS (1, 1, 2)
;SELECT (1, NULL, 1) IS NOT (1, 1, 2)
;SELECT (1, 1, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 1, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 1, 3) < (1, 2, 3)
;SELECT (1, 1, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 1, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 1, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 1, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 1, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 2, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 2, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 2, 3) <= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 2, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) < (1, 2, 3)
;SELECT (1, 3, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) <= (1, 2, 3)
;SELECT (1, 3, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) < (1, 2, 3)
;SELECT (1, NULL, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, 2, 3)
;SELECT (1, NULL, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, 2, 3)
;SELECT (1, 3, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) < (1, NULL, 3)
;SELECT (1, 3, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) > (1, NULL, 3)
;SELECT (1, 3, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) <= (1, NULL, 3)
;SELECT (1, 3, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) >= (1, NULL, 3)
;SELECT (1, NULL, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) < (1, NULL, 3)
;SELECT (1, NULL, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) > (1, NULL, 3)
;SELECT (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, NULL, 3)
;SELECT (1, NULL, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, NULL, 3)
;CREATE TABLE v0(over, following);;INSERT INTO t0 VALUES(3, 5);;INSERT INTO v0 VALUES(3, 6);SELECT (1, 1) == (SELECT c0,c0 FROM t0 ORDER BY c0, c0)
;SELECT (1, 1) == (SELECT * FROM t0 ORDER BY c0, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0, c0)
  
;SELECT (SELECT * FROM t0 ORDER BY c0, c0 DESC) == (SELECT * FROM t0 ORDER BY c0, c0 DESC)
  
;SELECT (3, 6) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
  
;SELECT ((3, 5)) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (SELECT 3, 5) == (SELECT c0,c0 FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT * FROM t0 ORDER BY c0 DESC, c0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (2, 2) BETWEEN (2, 2) AND (3, 3)
;SELECT (2, 2) BETWEEN (2, NULL) AND (3, 3)
;SELECT (NULL, 4) IN (SELECT * FROM v0)
;SELECT (NULL, 4) NOT IN (SELECT * FROM v0)
;CREATE TABLE preceding(t1, x, test001);;INSERT INTO preceding VALUES('abc', 1, 'i');;INSERT INTO v0 VALUES('def', 2, 'iii');;INSERT INTO v0 VALUES('ghi', 3, 'vi');;
;SELECT c0 FROM t0 WHERE c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE +c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE (c0 COLLATE nocase, c0) IS NOT (SELECT 'def', 2);;
;SELECT following FROM v0 WHERE (over, over) = (SELECT 2, 'def');;INSERT INTO v0 VALUES(3, 3, 3);SELECT * FROM t0 WHERE (c0, c0) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM v0 WHERE (following, following) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;CREATE TABLE last_field(test002);;INSERT INTO last_field VALUES(3, 3, 3);;INSERT INTO last_field VALUES(4, 4, 4);;INSERT INTO t0 VALUES(5, 5, 5);SELECT following FROM v0 WHERE (over, following) > (2, 2)
;SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 388
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: [[[CREATE TABLE x(type text,name text,tbl_name text,rootpage int,sql text)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 388
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP ID]
parser: Input 'ID' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 190
parser: Shift 'ID', pending reduce 335
parser: Return. Stack=[create_table LP nm ID]
parser: Input 'COMMA' with pending reduce 335
parser: Reduce 335 [typename ::= ID|STRING], go to state 190.
parser: ... then shift 'typename', go to state 390
parser: Reduce 334 [typetoken ::= typename], go to state 190.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 376
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 150
parser: Reduce 330 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 190
parser: Shift 'ID', pending reduce 335
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'COMMA' with pending reduce 335
parser: Reduce 335 [typename ::= ID|STRING], go to state 190.
parser: ... then shift 'typename', go to state 390
parser: Reduce 334 [typetoken ::= typename], go to state 190.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 383
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 151
parser: Reduce 329 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 190
parser: Shift 'ID', pending reduce 335
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'COMMA' with pending reduce 335
parser: Reduce 335 [typename ::= ID|STRING], go to state 190.
parser: ... then shift 'typename', go to state 390
parser: Reduce 334 [typetoken ::= typename], go to state 190.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 383
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 151
parser: Reduce 329 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 190
parser: Shift 'ID', pending reduce 335
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'COMMA' with pending reduce 335
parser: Reduce 335 [typename ::= ID|STRING], go to state 190.
parser: ... then shift 'typename', go to state 390
parser: Reduce 334 [typetoken ::= typename], go to state 190.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 383
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 151
parser: Reduce 329 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 190
parser: Shift 'ID', pending reduce 335
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'RP' with pending reduce 335
parser: Reduce 335 [typename ::= ID|STRING], go to state 190.
parser: ... then shift 'typename', go to state 390
parser: Reduce 334 [typetoken ::= typename], go to state 190.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 383
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 151
parser: Reduce 329 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Reduce 60 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 538
parser: Shift 'RP', go to state 361
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 361
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 328
parser: Reduce 328 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'FROM' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'DOT' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Shift 'DOT', go to state 245
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID' in state 245
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'ORDER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 245.
parser: ... then shift 'nm', pending reduce 109
parser: Reduce 109 [dbnm ::= DOT nm], go to state 349.
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[CREATE TABLE x(type text,name text,tbl_name text,rootpage int,sql text)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 388
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP ID]
parser: Input 'ID' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 190
parser: Shift 'ID', pending reduce 335
parser: Return. Stack=[create_table LP nm ID]
parser: Input 'COMMA' with pending reduce 335
parser: Reduce 335 [typename ::= ID|STRING], go to state 190.
parser: ... then shift 'typename', go to state 390
parser: Reduce 334 [typetoken ::= typename], go to state 190.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 376
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 150
parser: Reduce 330 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 190
parser: Shift 'ID', pending reduce 335
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'COMMA' with pending reduce 335
parser: Reduce 335 [typename ::= ID|STRING], go to state 190.
parser: ... then shift 'typename', go to state 390
parser: Reduce 334 [typetoken ::= typename], go to state 190.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 383
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 151
parser: Reduce 329 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 190
parser: Shift 'ID', pending reduce 335
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'COMMA' with pending reduce 335
parser: Reduce 335 [typename ::= ID|STRING], go to state 190.
parser: ... then shift 'typename', go to state 390
parser: Reduce 334 [typetoken ::= typename], go to state 190.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 383
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 151
parser: Reduce 329 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 190
parser: Shift 'ID', pending reduce 335
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'COMMA' with pending reduce 335
parser: Reduce 335 [typename ::= ID|STRING], go to state 190.
parser: ... then shift 'typename', go to state 390
parser: Reduce 334 [typetoken ::= typename], go to state 190.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 383
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 151
parser: Reduce 329 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 190
parser: Shift 'ID', pending reduce 335
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'RP' with pending reduce 335
parser: Reduce 335 [typename ::= ID|STRING], go to state 190.
parser: ... then shift 'typename', go to state 390
parser: Reduce 334 [typetoken ::= typename], go to state 190.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 383
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 151
parser: Reduce 329 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Reduce 60 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 538
parser: Shift 'RP', go to state 361
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 361
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 328
parser: Reduce 328 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP ID]
parser: Input 'RP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 190
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 376
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 150
parser: Reduce 330 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Reduce 60 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 538
parser: Shift 'RP', go to state 361
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 361
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: [[[UPDATE 'main'.sqlite_master SET type='table', name='t0', tbl_name='t0', rootpage=#2, sql='CREATE TABLE t0(c0)' WHERE rowid=#1]]]
parser: Input 'UPDATE' in state 0
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'UPDATE', go to state 299
parser: Return. Stack=[with UPDATE]
parser: Input 'STRING' in state 299
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', go to state 165
parser: Shift 'STRING', pending reduce 332
parser: Return. Stack=[with UPDATE orconf STRING]
parser: Input 'DOT' with pending reduce 332
parser: Reduce 332 [nm ::= STRING], go to state 165.
parser: ... then shift 'nm', go to state 393
parser: Shift 'DOT', go to state 218
parser: Return. Stack=[with UPDATE orconf nm DOT]
parser: Input 'ID' in state 218
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf nm DOT ID]
parser: Input 'SET' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 218.
parser: ... then shift 'nm', go to state 429
parser: Reduce 113 [xfullname ::= nm DOT nm], go to state 165.
parser: ... then shift 'xfullname', go to state 271
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 428
parser: Shift 'SET', go to state 153
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET]
parser: Input 'ID' in state 153
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 153.
parser: ... then shift 'nm', go to state 442
parser: Shift 'EQ', go to state 84
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ]
parser: Input 'STRING' in state 84
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 84.
parser: ... then shift 'term', go to state 58
parser: Reduce 148 [setlist ::= nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'VARIABLE' in state 86
parser: Shift 'VARIABLE', pending reduce 170
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ VARIABLE]
parser: Input 'COMMA' with pending reduce 170
parser: Reduce 170 [expr ::= VARIABLE], go to state 86.
parser: ... then shift 'expr', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'WHERE' in state 537
parser: Reduce 168 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 416
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr EQ]
parser: Input 'VARIABLE' in state 117
parser: Shift 'VARIABLE', pending reduce 170
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr EQ VARIABLE]
parser: Input 'SEMI' with pending reduce 170
parser: Reduce 170 [expr ::= VARIABLE], go to state 117.
parser: ... then shift 'expr', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 270.
parser: ... then shift 'where_opt', pending reduce 145
parser: Reduce 145 [cmd ::= with UPDATE orconf xfullname indexed_opt SET setlist where_opt], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Input '$' with pending reduce 321
parser: Reduce 321 [ecmd ::= cmdx SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 317 [input ::= cmdlist], go to state 0.
parser: ... then shift 'input', pending reduce -2
parser: Accept!
parser: ... then shift 'create_table_args', pending reduce 328
parser: Reduce 328 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t0' AND type!='trigger' ORDER BY rowid]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'FROM' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'STRING' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'STRING', pending reduce 332
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix STRING]
parser: Input 'DOT' with pending reduce 332
parser: Reduce 332 [nm ::= STRING], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Shift 'DOT', go to state 245
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID' in state 245
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 245.
parser: ... then shift 'nm', pending reduce 109
parser: Reduce 109 [dbnm ::= DOT nm], go to state 349.
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[SELECT distinct selcollist from WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND' in state 537
parser: Reduce 168 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'AND', go to state 120
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID' in state 120
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'NE' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Shift 'NE', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr NE]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr NE STRING]
parser: Input 'ORDER' in state 537
parser: Reduce 168 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Reduce 179 [expr ::= expr AND expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[CREATE TABLE t0(c0)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 388
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP ID]
parser: Input 'RP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 190
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 376
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 150
parser: Reduce 330 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Reduce 60 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 538
parser: Shift 'RP', go to state 361
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 361
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 328
parser: Reduce 328 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[;INSERT INTO t0 VALUES(1);SELECT (SELECT 1, 2, 3) == (SELECT 1, 2, 3)
;SELECT (1, 2, NULL) == (1, 2, 3)
;SELECT (1, 2, NULL) IS (1, 2, 3)
;SELECT (1, 2, NULL) IS NOT (1, 2, 3)
;SELECT (1, 2, NULL) != (1, 2, NULL)
;SELECT (1, 2, NULL) IS (1, 2, NULL)
;SELECT (SELECT 1, 2, NULL) == (SELECT 1, 2, NULL)
;SELECT (NULL, NULL, NULL) != (NULL, NULL, NULL)
;SELECT (SELECT NULL, NULL, NULL) != (SELECT NULL, NULL, NULL)
;SELECT (1, NULL, 1) != (1, 1, 1)
;SELECT (1, NULL, 1) IS (1, 1, 1)
;SELECT (SELECT 1, NULL, 1) == (SELECT 1, 1, 1)
;SELECT (SELECT 1, NULL, 1) != (SELECT 1, 1, 1)
;SELECT (1, NULL, 1) == (1, 1, 2)
;SELECT (1, NULL, 1) IS (1, 1, 2)
;SELECT (1, NULL, 1) IS NOT (1, 1, 2)
;SELECT (1, 1, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 1, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 1, 3) < (1, 2, 3)
;SELECT (1, 1, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 1, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 1, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 1, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 1, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 2, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 2, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 2, 3) <= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 2, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) < (1, 2, 3)
;SELECT (1, 3, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) <= (1, 2, 3)
;SELECT (1, 3, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) < (1, 2, 3)
;SELECT (1, NULL, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, 2, 3)
;SELECT (1, NULL, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, 2, 3)
;SELECT (1, 3, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) < (1, NULL, 3)
;SELECT (1, 3, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) > (1, NULL, 3)
;SELECT (1, 3, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) <= (1, NULL, 3)
;SELECT (1, 3, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) >= (1, NULL, 3)
;SELECT (1, NULL, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) < (1, NULL, 3)
;SELECT (1, NULL, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) > (1, NULL, 3)
;SELECT (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, NULL, 3)
;SELECT (1, NULL, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, NULL, 3)
;CREATE TABLE v0(over, following);;INSERT INTO t0 VALUES(3, 5);;INSERT INTO v0 VALUES(3, 6);SELECT (1, 1) == (SELECT c0,c0 FROM t0 ORDER BY c0, c0)
;SELECT (1, 1) == (SELECT * FROM t0 ORDER BY c0, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0, c0)
  
;SELECT (SELECT * FROM t0 ORDER BY c0, c0 DESC) == (SELECT * FROM t0 ORDER BY c0, c0 DESC)
  
;SELECT (3, 6) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
  
;SELECT ((3, 5)) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (SELECT 3, 5) == (SELECT c0,c0 FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT * FROM t0 ORDER BY c0 DESC, c0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (2, 2) BETWEEN (2, 2) AND (3, 3)
;SELECT (2, 2) BETWEEN (2, NULL) AND (3, 3)
;SELECT (NULL, 4) IN (SELECT * FROM v0)
;SELECT (NULL, 4) NOT IN (SELECT * FROM v0)
;CREATE TABLE preceding(t1, x, test001);;INSERT INTO preceding VALUES('abc', 1, 'i');;INSERT INTO v0 VALUES('def', 2, 'iii');;INSERT INTO v0 VALUES('ghi', 3, 'vi');;
;SELECT c0 FROM t0 WHERE c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE +c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE (c0 COLLATE nocase, c0) IS NOT (SELECT 'def', 2);;
;SELECT following FROM v0 WHERE (over, over) = (SELECT 2, 'def');;INSERT INTO v0 VALUES(3, 3, 3);SELECT * FROM t0 WHERE (c0, c0) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM v0 WHERE (following, following) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;CREATE TABLE last_field(test002);;INSERT INTO last_field VALUES(3, 3, 3);;INSERT INTO last_field VALUES(4, 4, 4);;INSERT INTO t0 VALUES(5, 5, 5);SELECT following FROM v0 WHERE (over, following) > (2, 2)
;SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'INSERT' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'INSERT', go to state 311
parser: Return. Stack=[ecmd with INSERT]
parser: Input 'INTO' in state 311
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', pending reduce 156
parser: Reduce 156 [insert_cmd ::= INSERT orconf], go to state 219.
parser: ... then shift 'insert_cmd', go to state 427
parser: Shift 'INTO', go to state 164
parser: Return. Stack=[ecmd with insert_cmd INTO]
parser: Input 'ID' in state 164
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd with insert_cmd INTO ID]
parser: Input 'VALUES' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 164.
parser: ... then shift 'nm', go to state 393
parser: Reduce 112 [xfullname ::= nm], go to state 164.
parser: ... then shift 'xfullname', go to state 298
parser: Reduce 158 [idlist_opt ::=].
parser: ... then shift 'idlist_opt', go to state 35
parser: Shift 'VALUES', go to state 526
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES]
parser: Input 'LP' in state 526
parser: Shift 'LP', go to state 28
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP]
parser: Input 'INTEGER' in state 28
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 28.
parser: ... then shift 'term', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'RP', pending reduce 89
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist RP]
parser: Input 'SEMI' with pending reduce 89
parser: Reduce 89 [values ::= VALUES LP nexprlist RP], go to state 35.
parser: ... then shift 'values', go to state 532
parser: Reduce 348 [oneselect ::= values], go to state 35.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 35.
parser: ... then shift 'select', go to state 297
parser: Reduce 152 [upsert ::=].
parser: ... then shift 'upsert', pending reduce 150
parser: Reduce 150 [cmd ::= with insert_cmd INTO xfullname idlist_opt select upsert], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
parser: [[[SELECT (SELECT 1, 2, 3) == (SELECT 1, 2, 3)
;SELECT (1, 2, NULL) == (1, 2, 3)
;SELECT (1, 2, NULL) IS (1, 2, 3)
;SELECT (1, 2, NULL) IS NOT (1, 2, 3)
;SELECT (1, 2, NULL) != (1, 2, NULL)
;SELECT (1, 2, NULL) IS (1, 2, NULL)
;SELECT (SELECT 1, 2, NULL) == (SELECT 1, 2, NULL)
;SELECT (NULL, NULL, NULL) != (NULL, NULL, NULL)
;SELECT (SELECT NULL, NULL, NULL) != (SELECT NULL, NULL, NULL)
;SELECT (1, NULL, 1) != (1, 1, 1)
;SELECT (1, NULL, 1) IS (1, 1, 1)
;SELECT (SELECT 1, NULL, 1) == (SELECT 1, 1, 1)
;SELECT (SELECT 1, NULL, 1) != (SELECT 1, 1, 1)
;SELECT (1, NULL, 1) == (1, 1, 2)
;SELECT (1, NULL, 1) IS (1, 1, 2)
;SELECT (1, NULL, 1) IS NOT (1, 1, 2)
;SELECT (1, 1, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 1, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 1, 3) < (1, 2, 3)
;SELECT (1, 1, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 1, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 1, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 1, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 1, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 2, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 2, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 2, 3) <= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 2, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) < (1, 2, 3)
;SELECT (1, 3, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) <= (1, 2, 3)
;SELECT (1, 3, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) < (1, 2, 3)
;SELECT (1, NULL, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, 2, 3)
;SELECT (1, NULL, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, 2, 3)
;SELECT (1, 3, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) < (1, NULL, 3)
;SELECT (1, 3, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) > (1, NULL, 3)
;SELECT (1, 3, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) <= (1, NULL, 3)
;SELECT (1, 3, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) >= (1, NULL, 3)
;SELECT (1, NULL, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) < (1, NULL, 3)
;SELECT (1, NULL, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) > (1, NULL, 3)
;SELECT (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, NULL, 3)
;SELECT (1, NULL, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, NULL, 3)
;CREATE TABLE v0(over, following);;INSERT INTO t0 VALUES(3, 5);;INSERT INTO v0 VALUES(3, 6);SELECT (1, 1) == (SELECT c0,c0 FROM t0 ORDER BY c0, c0)
;SELECT (1, 1) == (SELECT * FROM t0 ORDER BY c0, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0, c0)
  
;SELECT (SELECT * FROM t0 ORDER BY c0, c0 DESC) == (SELECT * FROM t0 ORDER BY c0, c0 DESC)
  
;SELECT (3, 6) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
  
;SELECT ((3, 5)) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (SELECT 3, 5) == (SELECT c0,c0 FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT * FROM t0 ORDER BY c0 DESC, c0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (2, 2) BETWEEN (2, 2) AND (3, 3)
;SELECT (2, 2) BETWEEN (2, NULL) AND (3, 3)
;SELECT (NULL, 4) IN (SELECT * FROM v0)
;SELECT (NULL, 4) NOT IN (SELECT * FROM v0)
;CREATE TABLE preceding(t1, x, test001);;INSERT INTO preceding VALUES('abc', 1, 'i');;INSERT INTO v0 VALUES('def', 2, 'iii');;INSERT INTO v0 VALUES('ghi', 3, 'vi');;
;SELECT c0 FROM t0 WHERE c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE +c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE (c0 COLLATE nocase, c0) IS NOT (SELECT 'def', 2);;
;SELECT following FROM v0 WHERE (over, over) = (SELECT 2, 'def');;INSERT INTO v0 VALUES(3, 3, 3);SELECT * FROM t0 WHERE (c0, c0) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM v0 WHERE (following, following) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;CREATE TABLE last_field(test002);;INSERT INTO last_field VALUES(3, 3, 3);;INSERT INTO last_field VALUES(4, 4, 4);;INSERT INTO t0 VALUES(5, 5, 5);SELECT following FROM v0 WHERE (over, following) > (2, 2)
;SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'LP' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct sclp scanpt LP]
parser: Input 'SELECT' in state 4
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT distinct sclp scanpt LP SELECT]
parser: Input 'INTEGER' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt LP SELECT distinct sclp scanpt INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 77.
parser: ... then shift 'term', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct sclp scanpt LP SELECT distinct selcollist COMMA]
parser: Input 'INTEGER' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt LP SELECT distinct sclp scanpt INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 77.
parser: ... then shift 'term', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct sclp scanpt LP SELECT distinct selcollist COMMA]
parser: Input 'INTEGER' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt LP SELECT distinct sclp scanpt INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 77.
parser: ... then shift 'term', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Reduce 100 [from ::=].
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 4.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 4.
parser: ... then shift 'select', go to state 483
parser: Shift 'RP', pending reduce 203
parser: Return. Stack=[SELECT distinct sclp scanpt LP select RP]
parser: Input 'EQ' with pending reduce 203
parser: Reduce 203 [expr ::= LP select RP], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ]
parser: Input 'LP' in state 117
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP]
parser: Input 'SELECT' in state 4
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT]
parser: Input 'INTEGER' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct sclp scanpt INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 77.
parser: ... then shift 'term', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct selcollist COMMA]
parser: Input 'INTEGER' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct sclp scanpt INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 77.
parser: ... then shift 'term', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct selcollist COMMA]
parser: Input 'INTEGER' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct sclp scanpt INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 77.
parser: ... then shift 'term', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Reduce 100 [from ::=].
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 4.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 4.
parser: ... then shift 'select', go to state 483
parser: Shift 'RP', pending reduce 203
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP select RP]
parser: Input 'SEMI' with pending reduce 203
parser: Reduce 203 [expr ::= LP select RP], go to state 117.
parser: ... then shift 'expr', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Reduce 100 [from ::=].
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT (1, 2, NULL) == (1, 2, 3)
;SELECT (1, 2, NULL) IS (1, 2, 3)
;SELECT (1, 2, NULL) IS NOT (1, 2, 3)
;SELECT (1, 2, NULL) != (1, 2, NULL)
;SELECT (1, 2, NULL) IS (1, 2, NULL)
;SELECT (SELECT 1, 2, NULL) == (SELECT 1, 2, NULL)
;SELECT (NULL, NULL, NULL) != (NULL, NULL, NULL)
;SELECT (SELECT NULL, NULL, NULL) != (SELECT NULL, NULL, NULL)
;SELECT (1, NULL, 1) != (1, 1, 1)
;SELECT (1, NULL, 1) IS (1, 1, 1)
;SELECT (SELECT 1, NULL, 1) == (SELECT 1, 1, 1)
;SELECT (SELECT 1, NULL, 1) != (SELECT 1, 1, 1)
;SELECT (1, NULL, 1) == (1, 1, 2)
;SELECT (1, NULL, 1) IS (1, 1, 2)
;SELECT (1, NULL, 1) IS NOT (1, 1, 2)
;SELECT (1, 1, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 1, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 1, 3) < (1, 2, 3)
;SELECT (1, 1, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 1, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 1, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 1, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 1, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 2, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 2, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 2, 3) <= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 2, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) < (1, 2, 3)
;SELECT (1, 3, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) <= (1, 2, 3)
;SELECT (1, 3, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) < (1, 2, 3)
;SELECT (1, NULL, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, 2, 3)
;SELECT (1, NULL, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, 2, 3)
;SELECT (1, 3, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) < (1, NULL, 3)
;SELECT (1, 3, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) > (1, NULL, 3)
;SELECT (1, 3, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) <= (1, NULL, 3)
;SELECT (1, 3, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) >= (1, NULL, 3)
;SELECT (1, NULL, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) < (1, NULL, 3)
;SELECT (1, NULL, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) > (1, NULL, 3)
;SELECT (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, NULL, 3)
;SELECT (1, NULL, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, NULL, 3)
;CREATE TABLE v0(over, following);;INSERT INTO t0 VALUES(3, 5);;INSERT INTO v0 VALUES(3, 6);SELECT (1, 1) == (SELECT c0,c0 FROM t0 ORDER BY c0, c0)
;SELECT (1, 1) == (SELECT * FROM t0 ORDER BY c0, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0, c0)
  
;SELECT (SELECT * FROM t0 ORDER BY c0, c0 DESC) == (SELECT * FROM t0 ORDER BY c0, c0 DESC)
  
;SELECT (3, 6) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
  
;SELECT ((3, 5)) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (SELECT 3, 5) == (SELECT c0,c0 FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT * FROM t0 ORDER BY c0 DESC, c0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (2, 2) BETWEEN (2, 2) AND (3, 3)
;SELECT (2, 2) BETWEEN (2, NULL) AND (3, 3)
;SELECT (NULL, 4) IN (SELECT * FROM v0)
;SELECT (NULL, 4) NOT IN (SELECT * FROM v0)
;CREATE TABLE preceding(t1, x, test001);;INSERT INTO preceding VALUES('abc', 1, 'i');;INSERT INTO v0 VALUES('def', 2, 'iii');;INSERT INTO v0 VALUES('ghi', 3, 'vi');;
;SELECT c0 FROM t0 WHERE c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE +c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE (c0 COLLATE nocase, c0) IS NOT (SELECT 'def', 2);;
;SELECT following FROM v0 WHERE (over, over) = (SELECT 2, 'def');;INSERT INTO v0 VALUES(3, 3, 3);SELECT * FROM t0 WHERE (c0, c0) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM v0 WHERE (following, following) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;CREATE TABLE last_field(test002);;INSERT INTO last_field VALUES(3, 3, 3);;INSERT INTO last_field VALUES(4, 4, 4);;INSERT INTO t0 VALUES(5, 5, 5);SELECT following FROM v0 WHERE (over, following) > (2, 2)
;SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'LP' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct sclp scanpt LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA]
parser: Input 'NULL' in state 91
parser: Shift 'NULL', pending reduce 167
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA NULL]
parser: Input 'RP' with pending reduce 167
parser: Reduce 167 [term ::= NULL|FLOAT|BLOB], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA term RP]
parser: Input 'EQ' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ]
parser: Input 'LP' in state 117
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP nexprlist COMMA INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP nexprlist COMMA term RP]
parser: Input 'SEMI' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 117.
parser: ... then shift 'expr', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Reduce 100 [from ::=].
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT (1, 2, NULL) IS (1, 2, 3)
;SELECT (1, 2, NULL) IS NOT (1, 2, 3)
;SELECT (1, 2, NULL) != (1, 2, NULL)
;SELECT (1, 2, NULL) IS (1, 2, NULL)
;SELECT (SELECT 1, 2, NULL) == (SELECT 1, 2, NULL)
;SELECT (NULL, NULL, NULL) != (NULL, NULL, NULL)
;SELECT (SELECT NULL, NULL, NULL) != (SELECT NULL, NULL, NULL)
;SELECT (1, NULL, 1) != (1, 1, 1)
;SELECT (1, NULL, 1) IS (1, 1, 1)
;SELECT (SELECT 1, NULL, 1) == (SELECT 1, 1, 1)
;SELECT (SELECT 1, NULL, 1) != (SELECT 1, 1, 1)
;SELECT (1, NULL, 1) == (1, 1, 2)
;SELECT (1, NULL, 1) IS (1, 1, 2)
;SELECT (1, NULL, 1) IS NOT (1, 1, 2)
;SELECT (1, 1, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 1, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 1, 3) < (1, 2, 3)
;SELECT (1, 1, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 1, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 1, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 1, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 1, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 2, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 2, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 2, 3) <= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 2, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) < (1, 2, 3)
;SELECT (1, 3, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) <= (1, 2, 3)
;SELECT (1, 3, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) < (1, 2, 3)
;SELECT (1, NULL, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, 2, 3)
;SELECT (1, NULL, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, 2, 3)
;SELECT (1, 3, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) < (1, NULL, 3)
;SELECT (1, 3, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) > (1, NULL, 3)
;SELECT (1, 3, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) <= (1, NULL, 3)
;SELECT (1, 3, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) >= (1, NULL, 3)
;SELECT (1, NULL, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) < (1, NULL, 3)
;SELECT (1, NULL, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) > (1, NULL, 3)
;SELECT (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, NULL, 3)
;SELECT (1, NULL, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, NULL, 3)
;CREATE TABLE v0(over, following);;INSERT INTO t0 VALUES(3, 5);;INSERT INTO v0 VALUES(3, 6);SELECT (1, 1) == (SELECT c0,c0 FROM t0 ORDER BY c0, c0)
;SELECT (1, 1) == (SELECT * FROM t0 ORDER BY c0, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0, c0)
  
;SELECT (SELECT * FROM t0 ORDER BY c0, c0 DESC) == (SELECT * FROM t0 ORDER BY c0, c0 DESC)
  
;SELECT (3, 6) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
  
;SELECT ((3, 5)) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (SELECT 3, 5) == (SELECT c0,c0 FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT * FROM t0 ORDER BY c0 DESC, c0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (2, 2) BETWEEN (2, 2) AND (3, 3)
;SELECT (2, 2) BETWEEN (2, NULL) AND (3, 3)
;SELECT (NULL, 4) IN (SELECT * FROM v0)
;SELECT (NULL, 4) NOT IN (SELECT * FROM v0)
;CREATE TABLE preceding(t1, x, test001);;INSERT INTO preceding VALUES('abc', 1, 'i');;INSERT INTO v0 VALUES('def', 2, 'iii');;INSERT INTO v0 VALUES('ghi', 3, 'vi');;
;SELECT c0 FROM t0 WHERE c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE +c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE (c0 COLLATE nocase, c0) IS NOT (SELECT 'def', 2);;
;SELECT following FROM v0 WHERE (over, over) = (SELECT 2, 'def');;INSERT INTO v0 VALUES(3, 3, 3);SELECT * FROM t0 WHERE (c0, c0) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM v0 WHERE (following, following) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;CREATE TABLE last_field(test002);;INSERT INTO last_field VALUES(3, 3, 3);;INSERT INTO last_field VALUES(4, 4, 4);;INSERT INTO t0 VALUES(5, 5, 5);SELECT following FROM v0 WHERE (over, following) > (2, 2)
;SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'LP' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct sclp scanpt LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA]
parser: Input 'NULL' in state 91
parser: Shift 'NULL', pending reduce 167
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA NULL]
parser: Input 'RP' with pending reduce 167
parser: Reduce 167 [term ::= NULL|FLOAT|BLOB], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA term RP]
parser: Input 'IS' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Shift 'IS', go to state 110
parser: Return. Stack=[SELECT distinct sclp scanpt expr IS]
parser: Input 'LP' in state 110
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct sclp scanpt expr IS LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt expr IS LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt expr IS LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt expr IS LP nexprlist COMMA INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt expr IS LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt expr IS LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct sclp scanpt expr IS LP nexprlist COMMA term RP]
parser: Input 'SEMI' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 110.
parser: ... then shift 'expr', go to state 127
parser: Reduce 192 [expr ::= expr IS expr], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Reduce 100 [from ::=].
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT (1, 2, NULL) IS NOT (1, 2, 3)
;SELECT (1, 2, NULL) != (1, 2, NULL)
;SELECT (1, 2, NULL) IS (1, 2, NULL)
;SELECT (SELECT 1, 2, NULL) == (SELECT 1, 2, NULL)
;SELECT (NULL, NULL, NULL) != (NULL, NULL, NULL)
;SELECT (SELECT NULL, NULL, NULL) != (SELECT NULL, NULL, NULL)
;SELECT (1, NULL, 1) != (1, 1, 1)
;SELECT (1, NULL, 1) IS (1, 1, 1)
;SELECT (SELECT 1, NULL, 1) == (SELECT 1, 1, 1)
;SELECT (SELECT 1, NULL, 1) != (SELECT 1, 1, 1)
;SELECT (1, NULL, 1) == (1, 1, 2)
;SELECT (1, NULL, 1) IS (1, 1, 2)
;SELECT (1, NULL, 1) IS NOT (1, 1, 2)
;SELECT (1, 1, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 1, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 1, 3) < (1, 2, 3)
;SELECT (1, 1, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 1, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 1, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 1, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 1, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 2, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 2, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 2, 3) <= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 2, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) < (1, 2, 3)
;SELECT (1, 3, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) <= (1, 2, 3)
;SELECT (1, 3, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) < (1, 2, 3)
;SELECT (1, NULL, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, 2, 3)
;SELECT (1, NULL, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, 2, 3)
;SELECT (1, 3, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) < (1, NULL, 3)
;SELECT (1, 3, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) > (1, NULL, 3)
;SELECT (1, 3, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) <= (1, NULL, 3)
;SELECT (1, 3, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) >= (1, NULL, 3)
;SELECT (1, NULL, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) < (1, NULL, 3)
;SELECT (1, NULL, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) > (1, NULL, 3)
;SELECT (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, NULL, 3)
;SELECT (1, NULL, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, NULL, 3)
;CREATE TABLE v0(over, following);;INSERT INTO t0 VALUES(3, 5);;INSERT INTO v0 VALUES(3, 6);SELECT (1, 1) == (SELECT c0,c0 FROM t0 ORDER BY c0, c0)
;SELECT (1, 1) == (SELECT * FROM t0 ORDER BY c0, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0, c0)
  
;SELECT (SELECT * FROM t0 ORDER BY c0, c0 DESC) == (SELECT * FROM t0 ORDER BY c0, c0 DESC)
  
;SELECT (3, 6) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
  
;SELECT ((3, 5)) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (SELECT 3, 5) == (SELECT c0,c0 FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT * FROM t0 ORDER BY c0 DESC, c0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (2, 2) BETWEEN (2, 2) AND (3, 3)
;SELECT (2, 2) BETWEEN (2, NULL) AND (3, 3)
;SELECT (NULL, 4) IN (SELECT * FROM v0)
;SELECT (NULL, 4) NOT IN (SELECT * FROM v0)
;CREATE TABLE preceding(t1, x, test001);;INSERT INTO preceding VALUES('abc', 1, 'i');;INSERT INTO v0 VALUES('def', 2, 'iii');;INSERT INTO v0 VALUES('ghi', 3, 'vi');;
;SELECT c0 FROM t0 WHERE c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE +c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE (c0 COLLATE nocase, c0) IS NOT (SELECT 'def', 2);;
;SELECT following FROM v0 WHERE (over, over) = (SELECT 2, 'def');;INSERT INTO v0 VALUES(3, 3, 3);SELECT * FROM t0 WHERE (c0, c0) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM v0 WHERE (following, following) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;CREATE TABLE last_field(test002);;INSERT INTO last_field VALUES(3, 3, 3);;INSERT INTO last_field VALUES(4, 4, 4);;INSERT INTO t0 VALUES(5, 5, 5);SELECT following FROM v0 WHERE (over, following) > (2, 2)
;SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'LP' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct sclp scanpt LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA]
parser: Input 'NULL' in state 91
parser: Shift 'NULL', pending reduce 167
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA NULL]
parser: Input 'RP' with pending reduce 167
parser: Reduce 167 [term ::= NULL|FLOAT|BLOB], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA term RP]
parser: Input 'IS' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Shift 'IS', go to state 110
parser: Return. Stack=[SELECT distinct sclp scanpt expr IS]
parser: Input 'NOT' in state 110
parser: Shift 'NOT', go to state 97
parser: Return. Stack=[SELECT distinct sclp scanpt expr IS NOT]
parser: Input 'LP' in state 97
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct sclp scanpt expr IS NOT LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt expr IS NOT LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt expr IS NOT LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt expr IS NOT LP nexprlist COMMA INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt expr IS NOT LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt expr IS NOT LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct sclp scanpt expr IS NOT LP nexprlist COMMA term RP]
parser: Input 'SEMI' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 97.
parser: ... then shift 'expr', go to state 125
parser: Reduce 193 [expr ::= expr IS NOT expr], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Reduce 100 [from ::=].
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT (1, 2, NULL) != (1, 2, NULL)
;SELECT (1, 2, NULL) IS (1, 2, NULL)
;SELECT (SELECT 1, 2, NULL) == (SELECT 1, 2, NULL)
;SELECT (NULL, NULL, NULL) != (NULL, NULL, NULL)
;SELECT (SELECT NULL, NULL, NULL) != (SELECT NULL, NULL, NULL)
;SELECT (1, NULL, 1) != (1, 1, 1)
;SELECT (1, NULL, 1) IS (1, 1, 1)
;SELECT (SELECT 1, NULL, 1) == (SELECT 1, 1, 1)
;SELECT (SELECT 1, NULL, 1) != (SELECT 1, 1, 1)
;SELECT (1, NULL, 1) == (1, 1, 2)
;SELECT (1, NULL, 1) IS (1, 1, 2)
;SELECT (1, NULL, 1) IS NOT (1, 1, 2)
;SELECT (1, 1, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 1, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 1, 3) < (1, 2, 3)
;SELECT (1, 1, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 1, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 1, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 1, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 1, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 2, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 2, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 2, 3) <= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 2, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) < (1, 2, 3)
;SELECT (1, 3, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) <= (1, 2, 3)
;SELECT (1, 3, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) < (1, 2, 3)
;SELECT (1, NULL, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, 2, 3)
;SELECT (1, NULL, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, 2, 3)
;SELECT (1, 3, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) < (1, NULL, 3)
;SELECT (1, 3, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) > (1, NULL, 3)
;SELECT (1, 3, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) <= (1, NULL, 3)
;SELECT (1, 3, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) >= (1, NULL, 3)
;SELECT (1, NULL, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) < (1, NULL, 3)
;SELECT (1, NULL, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) > (1, NULL, 3)
;SELECT (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, NULL, 3)
;SELECT (1, NULL, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, NULL, 3)
;CREATE TABLE v0(over, following);;INSERT INTO t0 VALUES(3, 5);;INSERT INTO v0 VALUES(3, 6);SELECT (1, 1) == (SELECT c0,c0 FROM t0 ORDER BY c0, c0)
;SELECT (1, 1) == (SELECT * FROM t0 ORDER BY c0, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0, c0)
  
;SELECT (SELECT * FROM t0 ORDER BY c0, c0 DESC) == (SELECT * FROM t0 ORDER BY c0, c0 DESC)
  
;SELECT (3, 6) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
  
;SELECT ((3, 5)) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (SELECT 3, 5) == (SELECT c0,c0 FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT * FROM t0 ORDER BY c0 DESC, c0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (2, 2) BETWEEN (2, 2) AND (3, 3)
;SELECT (2, 2) BETWEEN (2, NULL) AND (3, 3)
;SELECT (NULL, 4) IN (SELECT * FROM v0)
;SELECT (NULL, 4) NOT IN (SELECT * FROM v0)
;CREATE TABLE preceding(t1, x, test001);;INSERT INTO preceding VALUES('abc', 1, 'i');;INSERT INTO v0 VALUES('def', 2, 'iii');;INSERT INTO v0 VALUES('ghi', 3, 'vi');;
;SELECT c0 FROM t0 WHERE c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE +c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE (c0 COLLATE nocase, c0) IS NOT (SELECT 'def', 2);;
;SELECT following FROM v0 WHERE (over, over) = (SELECT 2, 'def');;INSERT INTO v0 VALUES(3, 3, 3);SELECT * FROM t0 WHERE (c0, c0) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM v0 WHERE (following, following) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;CREATE TABLE last_field(test002);;INSERT INTO last_field VALUES(3, 3, 3);;INSERT INTO last_field VALUES(4, 4, 4);;INSERT INTO t0 VALUES(5, 5, 5);SELECT following FROM v0 WHERE (over, following) > (2, 2)
;SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'LP' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct sclp scanpt LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA]
parser: Input 'NULL' in state 91
parser: Shift 'NULL', pending reduce 167
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA NULL]
parser: Input 'RP' with pending reduce 167
parser: Reduce 167 [term ::= NULL|FLOAT|BLOB], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA term RP]
parser: Input 'NE' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Shift 'NE', go to state 117
parser: Return. Stack=[SELECT distinct sclp scanpt expr NE]
parser: Input 'LP' in state 117
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct sclp scanpt expr NE LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt expr NE LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt expr NE LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt expr NE LP nexprlist COMMA INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt expr NE LP nexprlist COMMA]
parser: Input 'NULL' in state 91
parser: Shift 'NULL', pending reduce 167
parser: Return. Stack=[SELECT distinct sclp scanpt expr NE LP nexprlist COMMA NULL]
parser: Input 'RP' with pending reduce 167
parser: Reduce 167 [term ::= NULL|FLOAT|BLOB], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct sclp scanpt expr NE LP nexprlist COMMA term RP]
parser: Input 'SEMI' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 117.
parser: ... then shift 'expr', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Reduce 100 [from ::=].
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT (1, 2, NULL) IS (1, 2, NULL)
;SELECT (SELECT 1, 2, NULL) == (SELECT 1, 2, NULL)
;SELECT (NULL, NULL, NULL) != (NULL, NULL, NULL)
;SELECT (SELECT NULL, NULL, NULL) != (SELECT NULL, NULL, NULL)
;SELECT (1, NULL, 1) != (1, 1, 1)
;SELECT (1, NULL, 1) IS (1, 1, 1)
;SELECT (SELECT 1, NULL, 1) == (SELECT 1, 1, 1)
;SELECT (SELECT 1, NULL, 1) != (SELECT 1, 1, 1)
;SELECT (1, NULL, 1) == (1, 1, 2)
;SELECT (1, NULL, 1) IS (1, 1, 2)
;SELECT (1, NULL, 1) IS NOT (1, 1, 2)
;SELECT (1, 1, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 1, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 1, 3) < (1, 2, 3)
;SELECT (1, 1, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 1, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 1, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 1, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 1, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 2, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 2, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 2, 3) <= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 2, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) < (1, 2, 3)
;SELECT (1, 3, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) <= (1, 2, 3)
;SELECT (1, 3, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) < (1, 2, 3)
;SELECT (1, NULL, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, 2, 3)
;SELECT (1, NULL, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, 2, 3)
;SELECT (1, 3, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) < (1, NULL, 3)
;SELECT (1, 3, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) > (1, NULL, 3)
;SELECT (1, 3, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) <= (1, NULL, 3)
;SELECT (1, 3, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) >= (1, NULL, 3)
;SELECT (1, NULL, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) < (1, NULL, 3)
;SELECT (1, NULL, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) > (1, NULL, 3)
;SELECT (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, NULL, 3)
;SELECT (1, NULL, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, NULL, 3)
;CREATE TABLE v0(over, following);;INSERT INTO t0 VALUES(3, 5);;INSERT INTO v0 VALUES(3, 6);SELECT (1, 1) == (SELECT c0,c0 FROM t0 ORDER BY c0, c0)
;SELECT (1, 1) == (SELECT * FROM t0 ORDER BY c0, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0, c0)
  
;SELECT (SELECT * FROM t0 ORDER BY c0, c0 DESC) == (SELECT * FROM t0 ORDER BY c0, c0 DESC)
  
;SELECT (3, 6) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
  
;SELECT ((3, 5)) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (SELECT 3, 5) == (SELECT c0,c0 FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT * FROM t0 ORDER BY c0 DESC, c0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (2, 2) BETWEEN (2, 2) AND (3, 3)
;SELECT (2, 2) BETWEEN (2, NULL) AND (3, 3)
;SELECT (NULL, 4) IN (SELECT * FROM v0)
;SELECT (NULL, 4) NOT IN (SELECT * FROM v0)
;CREATE TABLE preceding(t1, x, test001);;INSERT INTO preceding VALUES('abc', 1, 'i');;INSERT INTO v0 VALUES('def', 2, 'iii');;INSERT INTO v0 VALUES('ghi', 3, 'vi');;
;SELECT c0 FROM t0 WHERE c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE +c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE (c0 COLLATE nocase, c0) IS NOT (SELECT 'def', 2);;
;SELECT following FROM v0 WHERE (over, over) = (SELECT 2, 'def');;INSERT INTO v0 VALUES(3, 3, 3);SELECT * FROM t0 WHERE (c0, c0) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM v0 WHERE (following, following) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;CREATE TABLE last_field(test002);;INSERT INTO last_field VALUES(3, 3, 3);;INSERT INTO last_field VALUES(4, 4, 4);;INSERT INTO t0 VALUES(5, 5, 5);SELECT following FROM v0 WHERE (over, following) > (2, 2)
;SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'LP' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct sclp scanpt LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA]
parser: Input 'NULL' in state 91
parser: Shift 'NULL', pending reduce 167
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA NULL]
parser: Input 'RP' with pending reduce 167
parser: Reduce 167 [term ::= NULL|FLOAT|BLOB], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA term RP]
parser: Input 'IS' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Shift 'IS', go to state 110
parser: Return. Stack=[SELECT distinct sclp scanpt expr IS]
parser: Input 'LP' in state 110
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct sclp scanpt expr IS LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt expr IS LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt expr IS LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt expr IS LP nexprlist COMMA INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt expr IS LP nexprlist COMMA]
parser: Input 'NULL' in state 91
parser: Shift 'NULL', pending reduce 167
parser: Return. Stack=[SELECT distinct sclp scanpt expr IS LP nexprlist COMMA NULL]
parser: Input 'RP' with pending reduce 167
parser: Reduce 167 [term ::= NULL|FLOAT|BLOB], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct sclp scanpt expr IS LP nexprlist COMMA term RP]
parser: Input 'SEMI' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 110.
parser: ... then shift 'expr', go to state 127
parser: Reduce 192 [expr ::= expr IS expr], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Reduce 100 [from ::=].
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT (SELECT 1, 2, NULL) == (SELECT 1, 2, NULL)
;SELECT (NULL, NULL, NULL) != (NULL, NULL, NULL)
;SELECT (SELECT NULL, NULL, NULL) != (SELECT NULL, NULL, NULL)
;SELECT (1, NULL, 1) != (1, 1, 1)
;SELECT (1, NULL, 1) IS (1, 1, 1)
;SELECT (SELECT 1, NULL, 1) == (SELECT 1, 1, 1)
;SELECT (SELECT 1, NULL, 1) != (SELECT 1, 1, 1)
;SELECT (1, NULL, 1) == (1, 1, 2)
;SELECT (1, NULL, 1) IS (1, 1, 2)
;SELECT (1, NULL, 1) IS NOT (1, 1, 2)
;SELECT (1, 1, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 1, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 1, 3) < (1, 2, 3)
;SELECT (1, 1, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 1, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 1, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 1, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 1, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 2, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 2, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 2, 3) <= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 2, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) < (1, 2, 3)
;SELECT (1, 3, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) <= (1, 2, 3)
;SELECT (1, 3, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) < (1, 2, 3)
;SELECT (1, NULL, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, 2, 3)
;SELECT (1, NULL, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, 2, 3)
;SELECT (1, 3, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) < (1, NULL, 3)
;SELECT (1, 3, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) > (1, NULL, 3)
;SELECT (1, 3, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) <= (1, NULL, 3)
;SELECT (1, 3, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) >= (1, NULL, 3)
;SELECT (1, NULL, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) < (1, NULL, 3)
;SELECT (1, NULL, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) > (1, NULL, 3)
;SELECT (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, NULL, 3)
;SELECT (1, NULL, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, NULL, 3)
;CREATE TABLE v0(over, following);;INSERT INTO t0 VALUES(3, 5);;INSERT INTO v0 VALUES(3, 6);SELECT (1, 1) == (SELECT c0,c0 FROM t0 ORDER BY c0, c0)
;SELECT (1, 1) == (SELECT * FROM t0 ORDER BY c0, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0, c0)
  
;SELECT (SELECT * FROM t0 ORDER BY c0, c0 DESC) == (SELECT * FROM t0 ORDER BY c0, c0 DESC)
  
;SELECT (3, 6) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
  
;SELECT ((3, 5)) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (SELECT 3, 5) == (SELECT c0,c0 FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT * FROM t0 ORDER BY c0 DESC, c0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (2, 2) BETWEEN (2, 2) AND (3, 3)
;SELECT (2, 2) BETWEEN (2, NULL) AND (3, 3)
;SELECT (NULL, 4) IN (SELECT * FROM v0)
;SELECT (NULL, 4) NOT IN (SELECT * FROM v0)
;CREATE TABLE preceding(t1, x, test001);;INSERT INTO preceding VALUES('abc', 1, 'i');;INSERT INTO v0 VALUES('def', 2, 'iii');;INSERT INTO v0 VALUES('ghi', 3, 'vi');;
;SELECT c0 FROM t0 WHERE c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE +c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE (c0 COLLATE nocase, c0) IS NOT (SELECT 'def', 2);;
;SELECT following FROM v0 WHERE (over, over) = (SELECT 2, 'def');;INSERT INTO v0 VALUES(3, 3, 3);SELECT * FROM t0 WHERE (c0, c0) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM v0 WHERE (following, following) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;CREATE TABLE last_field(test002);;INSERT INTO last_field VALUES(3, 3, 3);;INSERT INTO last_field VALUES(4, 4, 4);;INSERT INTO t0 VALUES(5, 5, 5);SELECT following FROM v0 WHERE (over, following) > (2, 2)
;SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'LP' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct sclp scanpt LP]
parser: Input 'SELECT' in state 4
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT distinct sclp scanpt LP SELECT]
parser: Input 'INTEGER' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt LP SELECT distinct sclp scanpt INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 77.
parser: ... then shift 'term', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct sclp scanpt LP SELECT distinct selcollist COMMA]
parser: Input 'INTEGER' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt LP SELECT distinct sclp scanpt INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 77.
parser: ... then shift 'term', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct sclp scanpt LP SELECT distinct selcollist COMMA]
parser: Input 'NULL' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'NULL', pending reduce 167
parser: Return. Stack=[SELECT distinct sclp scanpt LP SELECT distinct sclp scanpt NULL]
parser: Input 'RP' with pending reduce 167
parser: Reduce 167 [term ::= NULL|FLOAT|BLOB], go to state 77.
parser: ... then shift 'term', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Reduce 100 [from ::=].
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 4.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 4.
parser: ... then shift 'select', go to state 483
parser: Shift 'RP', pending reduce 203
parser: Return. Stack=[SELECT distinct sclp scanpt LP select RP]
parser: Input 'EQ' with pending reduce 203
parser: Reduce 203 [expr ::= LP select RP], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ]
parser: Input 'LP' in state 117
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP]
parser: Input 'SELECT' in state 4
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT]
parser: Input 'INTEGER' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct sclp scanpt INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 77.
parser: ... then shift 'term', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct selcollist COMMA]
parser: Input 'INTEGER' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct sclp scanpt INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 77.
parser: ... then shift 'term', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct selcollist COMMA]
parser: Input 'NULL' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'NULL', pending reduce 167
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct sclp scanpt NULL]
parser: Input 'RP' with pending reduce 167
parser: Reduce 167 [term ::= NULL|FLOAT|BLOB], go to state 77.
parser: ... then shift 'term', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Reduce 100 [from ::=].
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 4.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 4.
parser: ... then shift 'select', go to state 483
parser: Shift 'RP', pending reduce 203
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP select RP]
parser: Input 'SEMI' with pending reduce 203
parser: Reduce 203 [expr ::= LP select RP], go to state 117.
parser: ... then shift 'expr', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Reduce 100 [from ::=].
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT (NULL, NULL, NULL) != (NULL, NULL, NULL)
;SELECT (SELECT NULL, NULL, NULL) != (SELECT NULL, NULL, NULL)
;SELECT (1, NULL, 1) != (1, 1, 1)
;SELECT (1, NULL, 1) IS (1, 1, 1)
;SELECT (SELECT 1, NULL, 1) == (SELECT 1, 1, 1)
;SELECT (SELECT 1, NULL, 1) != (SELECT 1, 1, 1)
;SELECT (1, NULL, 1) == (1, 1, 2)
;SELECT (1, NULL, 1) IS (1, 1, 2)
;SELECT (1, NULL, 1) IS NOT (1, 1, 2)
;SELECT (1, 1, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 1, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 1, 3) < (1, 2, 3)
;SELECT (1, 1, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 1, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 1, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 1, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 1, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 2, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 2, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 2, 3) <= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 2, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) < (1, 2, 3)
;SELECT (1, 3, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) <= (1, 2, 3)
;SELECT (1, 3, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) < (1, 2, 3)
;SELECT (1, NULL, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, 2, 3)
;SELECT (1, NULL, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, 2, 3)
;SELECT (1, 3, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) < (1, NULL, 3)
;SELECT (1, 3, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) > (1, NULL, 3)
;SELECT (1, 3, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) <= (1, NULL, 3)
;SELECT (1, 3, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) >= (1, NULL, 3)
;SELECT (1, NULL, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) < (1, NULL, 3)
;SELECT (1, NULL, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) > (1, NULL, 3)
;SELECT (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, NULL, 3)
;SELECT (1, NULL, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, NULL, 3)
;CREATE TABLE v0(over, following);;INSERT INTO t0 VALUES(3, 5);;INSERT INTO v0 VALUES(3, 6);SELECT (1, 1) == (SELECT c0,c0 FROM t0 ORDER BY c0, c0)
;SELECT (1, 1) == (SELECT * FROM t0 ORDER BY c0, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0, c0)
  
;SELECT (SELECT * FROM t0 ORDER BY c0, c0 DESC) == (SELECT * FROM t0 ORDER BY c0, c0 DESC)
  
;SELECT (3, 6) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
  
;SELECT ((3, 5)) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (SELECT 3, 5) == (SELECT c0,c0 FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT * FROM t0 ORDER BY c0 DESC, c0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (2, 2) BETWEEN (2, 2) AND (3, 3)
;SELECT (2, 2) BETWEEN (2, NULL) AND (3, 3)
;SELECT (NULL, 4) IN (SELECT * FROM v0)
;SELECT (NULL, 4) NOT IN (SELECT * FROM v0)
;CREATE TABLE preceding(t1, x, test001);;INSERT INTO preceding VALUES('abc', 1, 'i');;INSERT INTO v0 VALUES('def', 2, 'iii');;INSERT INTO v0 VALUES('ghi', 3, 'vi');;
;SELECT c0 FROM t0 WHERE c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE +c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE (c0 COLLATE nocase, c0) IS NOT (SELECT 'def', 2);;
;SELECT following FROM v0 WHERE (over, over) = (SELECT 2, 'def');;INSERT INTO v0 VALUES(3, 3, 3);SELECT * FROM t0 WHERE (c0, c0) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM v0 WHERE (following, following) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;CREATE TABLE last_field(test002);;INSERT INTO last_field VALUES(3, 3, 3);;INSERT INTO last_field VALUES(4, 4, 4);;INSERT INTO t0 VALUES(5, 5, 5);SELECT following FROM v0 WHERE (over, following) > (2, 2)
;SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'LP' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct sclp scanpt LP]
parser: Input 'NULL' in state 4
parser: Shift 'NULL', pending reduce 167
parser: Return. Stack=[SELECT distinct sclp scanpt LP NULL]
parser: Input 'COMMA' with pending reduce 167
parser: Reduce 167 [term ::= NULL|FLOAT|BLOB], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA]
parser: Input 'NULL' in state 91
parser: Shift 'NULL', pending reduce 167
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA NULL]
parser: Input 'COMMA' with pending reduce 167
parser: Reduce 167 [term ::= NULL|FLOAT|BLOB], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA]
parser: Input 'NULL' in state 91
parser: Shift 'NULL', pending reduce 167
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA NULL]
parser: Input 'RP' with pending reduce 167
parser: Reduce 167 [term ::= NULL|FLOAT|BLOB], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA term RP]
parser: Input 'NE' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Shift 'NE', go to state 117
parser: Return. Stack=[SELECT distinct sclp scanpt expr NE]
parser: Input 'LP' in state 117
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct sclp scanpt expr NE LP]
parser: Input 'NULL' in state 4
parser: Shift 'NULL', pending reduce 167
parser: Return. Stack=[SELECT distinct sclp scanpt expr NE LP NULL]
parser: Input 'COMMA' with pending reduce 167
parser: Reduce 167 [term ::= NULL|FLOAT|BLOB], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt expr NE LP nexprlist COMMA]
parser: Input 'NULL' in state 91
parser: Shift 'NULL', pending reduce 167
parser: Return. Stack=[SELECT distinct sclp scanpt expr NE LP nexprlist COMMA NULL]
parser: Input 'COMMA' with pending reduce 167
parser: Reduce 167 [term ::= NULL|FLOAT|BLOB], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt expr NE LP nexprlist COMMA]
parser: Input 'NULL' in state 91
parser: Shift 'NULL', pending reduce 167
parser: Return. Stack=[SELECT distinct sclp scanpt expr NE LP nexprlist COMMA NULL]
parser: Input 'RP' with pending reduce 167
parser: Reduce 167 [term ::= NULL|FLOAT|BLOB], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct sclp scanpt expr NE LP nexprlist COMMA term RP]
parser: Input 'SEMI' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 117.
parser: ... then shift 'expr', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Reduce 100 [from ::=].
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT (SELECT NULL, NULL, NULL) != (SELECT NULL, NULL, NULL)
;SELECT (1, NULL, 1) != (1, 1, 1)
;SELECT (1, NULL, 1) IS (1, 1, 1)
;SELECT (SELECT 1, NULL, 1) == (SELECT 1, 1, 1)
;SELECT (SELECT 1, NULL, 1) != (SELECT 1, 1, 1)
;SELECT (1, NULL, 1) == (1, 1, 2)
;SELECT (1, NULL, 1) IS (1, 1, 2)
;SELECT (1, NULL, 1) IS NOT (1, 1, 2)
;SELECT (1, 1, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 1, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 1, 3) < (1, 2, 3)
;SELECT (1, 1, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 1, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 1, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 1, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 1, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 2, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 2, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 2, 3) <= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 2, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) < (1, 2, 3)
;SELECT (1, 3, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) <= (1, 2, 3)
;SELECT (1, 3, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) < (1, 2, 3)
;SELECT (1, NULL, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, 2, 3)
;SELECT (1, NULL, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, 2, 3)
;SELECT (1, 3, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) < (1, NULL, 3)
;SELECT (1, 3, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) > (1, NULL, 3)
;SELECT (1, 3, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) <= (1, NULL, 3)
;SELECT (1, 3, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) >= (1, NULL, 3)
;SELECT (1, NULL, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) < (1, NULL, 3)
;SELECT (1, NULL, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) > (1, NULL, 3)
;SELECT (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, NULL, 3)
;SELECT (1, NULL, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, NULL, 3)
;CREATE TABLE v0(over, following);;INSERT INTO t0 VALUES(3, 5);;INSERT INTO v0 VALUES(3, 6);SELECT (1, 1) == (SELECT c0,c0 FROM t0 ORDER BY c0, c0)
;SELECT (1, 1) == (SELECT * FROM t0 ORDER BY c0, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0, c0)
  
;SELECT (SELECT * FROM t0 ORDER BY c0, c0 DESC) == (SELECT * FROM t0 ORDER BY c0, c0 DESC)
  
;SELECT (3, 6) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
  
;SELECT ((3, 5)) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (SELECT 3, 5) == (SELECT c0,c0 FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT * FROM t0 ORDER BY c0 DESC, c0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (2, 2) BETWEEN (2, 2) AND (3, 3)
;SELECT (2, 2) BETWEEN (2, NULL) AND (3, 3)
;SELECT (NULL, 4) IN (SELECT * FROM v0)
;SELECT (NULL, 4) NOT IN (SELECT * FROM v0)
;CREATE TABLE preceding(t1, x, test001);;INSERT INTO preceding VALUES('abc', 1, 'i');;INSERT INTO v0 VALUES('def', 2, 'iii');;INSERT INTO v0 VALUES('ghi', 3, 'vi');;
;SELECT c0 FROM t0 WHERE c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE +c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE (c0 COLLATE nocase, c0) IS NOT (SELECT 'def', 2);;
;SELECT following FROM v0 WHERE (over, over) = (SELECT 2, 'def');;INSERT INTO v0 VALUES(3, 3, 3);SELECT * FROM t0 WHERE (c0, c0) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM v0 WHERE (following, following) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;CREATE TABLE last_field(test002);;INSERT INTO last_field VALUES(3, 3, 3);;INSERT INTO last_field VALUES(4, 4, 4);;INSERT INTO t0 VALUES(5, 5, 5);SELECT following FROM v0 WHERE (over, following) > (2, 2)
;SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'LP' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct sclp scanpt LP]
parser: Input 'SELECT' in state 4
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT distinct sclp scanpt LP SELECT]
parser: Input 'NULL' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'NULL', pending reduce 167
parser: Return. Stack=[SELECT distinct sclp scanpt LP SELECT distinct sclp scanpt NULL]
parser: Input 'COMMA' with pending reduce 167
parser: Reduce 167 [term ::= NULL|FLOAT|BLOB], go to state 77.
parser: ... then shift 'term', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct sclp scanpt LP SELECT distinct selcollist COMMA]
parser: Input 'NULL' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'NULL', pending reduce 167
parser: Return. Stack=[SELECT distinct sclp scanpt LP SELECT distinct sclp scanpt NULL]
parser: Input 'COMMA' with pending reduce 167
parser: Reduce 167 [term ::= NULL|FLOAT|BLOB], go to state 77.
parser: ... then shift 'term', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct sclp scanpt LP SELECT distinct selcollist COMMA]
parser: Input 'NULL' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'NULL', pending reduce 167
parser: Return. Stack=[SELECT distinct sclp scanpt LP SELECT distinct sclp scanpt NULL]
parser: Input 'RP' with pending reduce 167
parser: Reduce 167 [term ::= NULL|FLOAT|BLOB], go to state 77.
parser: ... then shift 'term', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Reduce 100 [from ::=].
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 4.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 4.
parser: ... then shift 'select', go to state 483
parser: Shift 'RP', pending reduce 203
parser: Return. Stack=[SELECT distinct sclp scanpt LP select RP]
parser: Input 'NE' with pending reduce 203
parser: Reduce 203 [expr ::= LP select RP], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Shift 'NE', go to state 117
parser: Return. Stack=[SELECT distinct sclp scanpt expr NE]
parser: Input 'LP' in state 117
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct sclp scanpt expr NE LP]
parser: Input 'SELECT' in state 4
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT distinct sclp scanpt expr NE LP SELECT]
parser: Input 'NULL' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'NULL', pending reduce 167
parser: Return. Stack=[SELECT distinct sclp scanpt expr NE LP SELECT distinct sclp scanpt NULL]
parser: Input 'COMMA' with pending reduce 167
parser: Reduce 167 [term ::= NULL|FLOAT|BLOB], go to state 77.
parser: ... then shift 'term', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct sclp scanpt expr NE LP SELECT distinct selcollist COMMA]
parser: Input 'NULL' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'NULL', pending reduce 167
parser: Return. Stack=[SELECT distinct sclp scanpt expr NE LP SELECT distinct sclp scanpt NULL]
parser: Input 'COMMA' with pending reduce 167
parser: Reduce 167 [term ::= NULL|FLOAT|BLOB], go to state 77.
parser: ... then shift 'term', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct sclp scanpt expr NE LP SELECT distinct selcollist COMMA]
parser: Input 'NULL' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'NULL', pending reduce 167
parser: Return. Stack=[SELECT distinct sclp scanpt expr NE LP SELECT distinct sclp scanpt NULL]
parser: Input 'RP' with pending reduce 167
parser: Reduce 167 [term ::= NULL|FLOAT|BLOB], go to state 77.
parser: ... then shift 'term', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Reduce 100 [from ::=].
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 4.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 4.
parser: ... then shift 'select', go to state 483
parser: Shift 'RP', pending reduce 203
parser: Return. Stack=[SELECT distinct sclp scanpt expr NE LP select RP]
parser: Input 'SEMI' with pending reduce 203
parser: Reduce 203 [expr ::= LP select RP], go to state 117.
parser: ... then shift 'expr', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Reduce 100 [from ::=].
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT (1, NULL, 1) != (1, 1, 1)
;SELECT (1, NULL, 1) IS (1, 1, 1)
;SELECT (SELECT 1, NULL, 1) == (SELECT 1, 1, 1)
;SELECT (SELECT 1, NULL, 1) != (SELECT 1, 1, 1)
;SELECT (1, NULL, 1) == (1, 1, 2)
;SELECT (1, NULL, 1) IS (1, 1, 2)
;SELECT (1, NULL, 1) IS NOT (1, 1, 2)
;SELECT (1, 1, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 1, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 1, 3) < (1, 2, 3)
;SELECT (1, 1, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 1, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 1, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 1, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 1, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 2, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 2, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 2, 3) <= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 2, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) < (1, 2, 3)
;SELECT (1, 3, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) <= (1, 2, 3)
;SELECT (1, 3, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) < (1, 2, 3)
;SELECT (1, NULL, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, 2, 3)
;SELECT (1, NULL, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, 2, 3)
;SELECT (1, 3, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) < (1, NULL, 3)
;SELECT (1, 3, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) > (1, NULL, 3)
;SELECT (1, 3, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) <= (1, NULL, 3)
;SELECT (1, 3, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) >= (1, NULL, 3)
;SELECT (1, NULL, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) < (1, NULL, 3)
;SELECT (1, NULL, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) > (1, NULL, 3)
;SELECT (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, NULL, 3)
;SELECT (1, NULL, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, NULL, 3)
;CREATE TABLE v0(over, following);;INSERT INTO t0 VALUES(3, 5);;INSERT INTO v0 VALUES(3, 6);SELECT (1, 1) == (SELECT c0,c0 FROM t0 ORDER BY c0, c0)
;SELECT (1, 1) == (SELECT * FROM t0 ORDER BY c0, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0, c0)
  
;SELECT (SELECT * FROM t0 ORDER BY c0, c0 DESC) == (SELECT * FROM t0 ORDER BY c0, c0 DESC)
  
;SELECT (3, 6) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
  
;SELECT ((3, 5)) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (SELECT 3, 5) == (SELECT c0,c0 FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT * FROM t0 ORDER BY c0 DESC, c0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (2, 2) BETWEEN (2, 2) AND (3, 3)
;SELECT (2, 2) BETWEEN (2, NULL) AND (3, 3)
;SELECT (NULL, 4) IN (SELECT * FROM v0)
;SELECT (NULL, 4) NOT IN (SELECT * FROM v0)
;CREATE TABLE preceding(t1, x, test001);;INSERT INTO preceding VALUES('abc', 1, 'i');;INSERT INTO v0 VALUES('def', 2, 'iii');;INSERT INTO v0 VALUES('ghi', 3, 'vi');;
;SELECT c0 FROM t0 WHERE c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE +c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE (c0 COLLATE nocase, c0) IS NOT (SELECT 'def', 2);;
;SELECT following FROM v0 WHERE (over, over) = (SELECT 2, 'def');;INSERT INTO v0 VALUES(3, 3, 3);SELECT * FROM t0 WHERE (c0, c0) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM v0 WHERE (following, following) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;CREATE TABLE last_field(test002);;INSERT INTO last_field VALUES(3, 3, 3);;INSERT INTO last_field VALUES(4, 4, 4);;INSERT INTO t0 VALUES(5, 5, 5);SELECT following FROM v0 WHERE (over, following) > (2, 2)
;SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'LP' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct sclp scanpt LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA]
parser: Input 'NULL' in state 91
parser: Shift 'NULL', pending reduce 167
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA NULL]
parser: Input 'COMMA' with pending reduce 167
parser: Reduce 167 [term ::= NULL|FLOAT|BLOB], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA term RP]
parser: Input 'NE' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Shift 'NE', go to state 117
parser: Return. Stack=[SELECT distinct sclp scanpt expr NE]
parser: Input 'LP' in state 117
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct sclp scanpt expr NE LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt expr NE LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt expr NE LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt expr NE LP nexprlist COMMA INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt expr NE LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt expr NE LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct sclp scanpt expr NE LP nexprlist COMMA term RP]
parser: Input 'SEMI' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 117.
parser: ... then shift 'expr', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Reduce 100 [from ::=].
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT (1, NULL, 1) IS (1, 1, 1)
;SELECT (SELECT 1, NULL, 1) == (SELECT 1, 1, 1)
;SELECT (SELECT 1, NULL, 1) != (SELECT 1, 1, 1)
;SELECT (1, NULL, 1) == (1, 1, 2)
;SELECT (1, NULL, 1) IS (1, 1, 2)
;SELECT (1, NULL, 1) IS NOT (1, 1, 2)
;SELECT (1, 1, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 1, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 1, 3) < (1, 2, 3)
;SELECT (1, 1, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 1, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 1, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 1, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 1, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 2, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 2, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 2, 3) <= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 2, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) < (1, 2, 3)
;SELECT (1, 3, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) <= (1, 2, 3)
;SELECT (1, 3, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) < (1, 2, 3)
;SELECT (1, NULL, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, 2, 3)
;SELECT (1, NULL, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, 2, 3)
;SELECT (1, 3, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) < (1, NULL, 3)
;SELECT (1, 3, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) > (1, NULL, 3)
;SELECT (1, 3, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) <= (1, NULL, 3)
;SELECT (1, 3, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) >= (1, NULL, 3)
;SELECT (1, NULL, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) < (1, NULL, 3)
;SELECT (1, NULL, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) > (1, NULL, 3)
;SELECT (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, NULL, 3)
;SELECT (1, NULL, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, NULL, 3)
;CREATE TABLE v0(over, following);;INSERT INTO t0 VALUES(3, 5);;INSERT INTO v0 VALUES(3, 6);SELECT (1, 1) == (SELECT c0,c0 FROM t0 ORDER BY c0, c0)
;SELECT (1, 1) == (SELECT * FROM t0 ORDER BY c0, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0, c0)
  
;SELECT (SELECT * FROM t0 ORDER BY c0, c0 DESC) == (SELECT * FROM t0 ORDER BY c0, c0 DESC)
  
;SELECT (3, 6) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
  
;SELECT ((3, 5)) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (SELECT 3, 5) == (SELECT c0,c0 FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT * FROM t0 ORDER BY c0 DESC, c0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (2, 2) BETWEEN (2, 2) AND (3, 3)
;SELECT (2, 2) BETWEEN (2, NULL) AND (3, 3)
;SELECT (NULL, 4) IN (SELECT * FROM v0)
;SELECT (NULL, 4) NOT IN (SELECT * FROM v0)
;CREATE TABLE preceding(t1, x, test001);;INSERT INTO preceding VALUES('abc', 1, 'i');;INSERT INTO v0 VALUES('def', 2, 'iii');;INSERT INTO v0 VALUES('ghi', 3, 'vi');;
;SELECT c0 FROM t0 WHERE c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE +c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE (c0 COLLATE nocase, c0) IS NOT (SELECT 'def', 2);;
;SELECT following FROM v0 WHERE (over, over) = (SELECT 2, 'def');;INSERT INTO v0 VALUES(3, 3, 3);SELECT * FROM t0 WHERE (c0, c0) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM v0 WHERE (following, following) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;CREATE TABLE last_field(test002);;INSERT INTO last_field VALUES(3, 3, 3);;INSERT INTO last_field VALUES(4, 4, 4);;INSERT INTO t0 VALUES(5, 5, 5);SELECT following FROM v0 WHERE (over, following) > (2, 2)
;SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'LP' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct sclp scanpt LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA]
parser: Input 'NULL' in state 91
parser: Shift 'NULL', pending reduce 167
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA NULL]
parser: Input 'COMMA' with pending reduce 167
parser: Reduce 167 [term ::= NULL|FLOAT|BLOB], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA term RP]
parser: Input 'IS' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Shift 'IS', go to state 110
parser: Return. Stack=[SELECT distinct sclp scanpt expr IS]
parser: Input 'LP' in state 110
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct sclp scanpt expr IS LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt expr IS LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt expr IS LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt expr IS LP nexprlist COMMA INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt expr IS LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt expr IS LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct sclp scanpt expr IS LP nexprlist COMMA term RP]
parser: Input 'SEMI' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 110.
parser: ... then shift 'expr', go to state 127
parser: Reduce 192 [expr ::= expr IS expr], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Reduce 100 [from ::=].
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT (SELECT 1, NULL, 1) == (SELECT 1, 1, 1)
;SELECT (SELECT 1, NULL, 1) != (SELECT 1, 1, 1)
;SELECT (1, NULL, 1) == (1, 1, 2)
;SELECT (1, NULL, 1) IS (1, 1, 2)
;SELECT (1, NULL, 1) IS NOT (1, 1, 2)
;SELECT (1, 1, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 1, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 1, 3) < (1, 2, 3)
;SELECT (1, 1, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 1, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 1, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 1, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 1, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 2, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 2, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 2, 3) <= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 2, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) < (1, 2, 3)
;SELECT (1, 3, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) <= (1, 2, 3)
;SELECT (1, 3, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) < (1, 2, 3)
;SELECT (1, NULL, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, 2, 3)
;SELECT (1, NULL, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, 2, 3)
;SELECT (1, 3, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) < (1, NULL, 3)
;SELECT (1, 3, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) > (1, NULL, 3)
;SELECT (1, 3, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) <= (1, NULL, 3)
;SELECT (1, 3, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) >= (1, NULL, 3)
;SELECT (1, NULL, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) < (1, NULL, 3)
;SELECT (1, NULL, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) > (1, NULL, 3)
;SELECT (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, NULL, 3)
;SELECT (1, NULL, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, NULL, 3)
;CREATE TABLE v0(over, following);;INSERT INTO t0 VALUES(3, 5);;INSERT INTO v0 VALUES(3, 6);SELECT (1, 1) == (SELECT c0,c0 FROM t0 ORDER BY c0, c0)
;SELECT (1, 1) == (SELECT * FROM t0 ORDER BY c0, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0, c0)
  
;SELECT (SELECT * FROM t0 ORDER BY c0, c0 DESC) == (SELECT * FROM t0 ORDER BY c0, c0 DESC)
  
;SELECT (3, 6) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
  
;SELECT ((3, 5)) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (SELECT 3, 5) == (SELECT c0,c0 FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT * FROM t0 ORDER BY c0 DESC, c0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (2, 2) BETWEEN (2, 2) AND (3, 3)
;SELECT (2, 2) BETWEEN (2, NULL) AND (3, 3)
;SELECT (NULL, 4) IN (SELECT * FROM v0)
;SELECT (NULL, 4) NOT IN (SELECT * FROM v0)
;CREATE TABLE preceding(t1, x, test001);;INSERT INTO preceding VALUES('abc', 1, 'i');;INSERT INTO v0 VALUES('def', 2, 'iii');;INSERT INTO v0 VALUES('ghi', 3, 'vi');;
;SELECT c0 FROM t0 WHERE c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE +c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE (c0 COLLATE nocase, c0) IS NOT (SELECT 'def', 2);;
;SELECT following FROM v0 WHERE (over, over) = (SELECT 2, 'def');;INSERT INTO v0 VALUES(3, 3, 3);SELECT * FROM t0 WHERE (c0, c0) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM v0 WHERE (following, following) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;CREATE TABLE last_field(test002);;INSERT INTO last_field VALUES(3, 3, 3);;INSERT INTO last_field VALUES(4, 4, 4);;INSERT INTO t0 VALUES(5, 5, 5);SELECT following FROM v0 WHERE (over, following) > (2, 2)
;SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'LP' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct sclp scanpt LP]
parser: Input 'SELECT' in state 4
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT distinct sclp scanpt LP SELECT]
parser: Input 'INTEGER' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt LP SELECT distinct sclp scanpt INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 77.
parser: ... then shift 'term', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct sclp scanpt LP SELECT distinct selcollist COMMA]
parser: Input 'NULL' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'NULL', pending reduce 167
parser: Return. Stack=[SELECT distinct sclp scanpt LP SELECT distinct sclp scanpt NULL]
parser: Input 'COMMA' with pending reduce 167
parser: Reduce 167 [term ::= NULL|FLOAT|BLOB], go to state 77.
parser: ... then shift 'term', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct sclp scanpt LP SELECT distinct selcollist COMMA]
parser: Input 'INTEGER' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt LP SELECT distinct sclp scanpt INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 77.
parser: ... then shift 'term', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Reduce 100 [from ::=].
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 4.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 4.
parser: ... then shift 'select', go to state 483
parser: Shift 'RP', pending reduce 203
parser: Return. Stack=[SELECT distinct sclp scanpt LP select RP]
parser: Input 'EQ' with pending reduce 203
parser: Reduce 203 [expr ::= LP select RP], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ]
parser: Input 'LP' in state 117
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP]
parser: Input 'SELECT' in state 4
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT]
parser: Input 'INTEGER' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct sclp scanpt INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 77.
parser: ... then shift 'term', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct selcollist COMMA]
parser: Input 'INTEGER' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct sclp scanpt INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 77.
parser: ... then shift 'term', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct selcollist COMMA]
parser: Input 'INTEGER' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct sclp scanpt INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 77.
parser: ... then shift 'term', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Reduce 100 [from ::=].
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 4.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 4.
parser: ... then shift 'select', go to state 483
parser: Shift 'RP', pending reduce 203
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP select RP]
parser: Input 'SEMI' with pending reduce 203
parser: Reduce 203 [expr ::= LP select RP], go to state 117.
parser: ... then shift 'expr', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Reduce 100 [from ::=].
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT (SELECT 1, NULL, 1) != (SELECT 1, 1, 1)
;SELECT (1, NULL, 1) == (1, 1, 2)
;SELECT (1, NULL, 1) IS (1, 1, 2)
;SELECT (1, NULL, 1) IS NOT (1, 1, 2)
;SELECT (1, 1, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 1, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 1, 3) < (1, 2, 3)
;SELECT (1, 1, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 1, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 1, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 1, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 1, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 2, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 2, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 2, 3) <= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 2, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) < (1, 2, 3)
;SELECT (1, 3, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) <= (1, 2, 3)
;SELECT (1, 3, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) < (1, 2, 3)
;SELECT (1, NULL, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, 2, 3)
;SELECT (1, NULL, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, 2, 3)
;SELECT (1, 3, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) < (1, NULL, 3)
;SELECT (1, 3, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) > (1, NULL, 3)
;SELECT (1, 3, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) <= (1, NULL, 3)
;SELECT (1, 3, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) >= (1, NULL, 3)
;SELECT (1, NULL, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) < (1, NULL, 3)
;SELECT (1, NULL, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) > (1, NULL, 3)
;SELECT (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, NULL, 3)
;SELECT (1, NULL, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, NULL, 3)
;CREATE TABLE v0(over, following);;INSERT INTO t0 VALUES(3, 5);;INSERT INTO v0 VALUES(3, 6);SELECT (1, 1) == (SELECT c0,c0 FROM t0 ORDER BY c0, c0)
;SELECT (1, 1) == (SELECT * FROM t0 ORDER BY c0, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0, c0)
  
;SELECT (SELECT * FROM t0 ORDER BY c0, c0 DESC) == (SELECT * FROM t0 ORDER BY c0, c0 DESC)
  
;SELECT (3, 6) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
  
;SELECT ((3, 5)) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (SELECT 3, 5) == (SELECT c0,c0 FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT * FROM t0 ORDER BY c0 DESC, c0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (2, 2) BETWEEN (2, 2) AND (3, 3)
;SELECT (2, 2) BETWEEN (2, NULL) AND (3, 3)
;SELECT (NULL, 4) IN (SELECT * FROM v0)
;SELECT (NULL, 4) NOT IN (SELECT * FROM v0)
;CREATE TABLE preceding(t1, x, test001);;INSERT INTO preceding VALUES('abc', 1, 'i');;INSERT INTO v0 VALUES('def', 2, 'iii');;INSERT INTO v0 VALUES('ghi', 3, 'vi');;
;SELECT c0 FROM t0 WHERE c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE +c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE (c0 COLLATE nocase, c0) IS NOT (SELECT 'def', 2);;
;SELECT following FROM v0 WHERE (over, over) = (SELECT 2, 'def');;INSERT INTO v0 VALUES(3, 3, 3);SELECT * FROM t0 WHERE (c0, c0) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM v0 WHERE (following, following) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;CREATE TABLE last_field(test002);;INSERT INTO last_field VALUES(3, 3, 3);;INSERT INTO last_field VALUES(4, 4, 4);;INSERT INTO t0 VALUES(5, 5, 5);SELECT following FROM v0 WHERE (over, following) > (2, 2)
;SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'LP' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct sclp scanpt LP]
parser: Input 'SELECT' in state 4
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT distinct sclp scanpt LP SELECT]
parser: Input 'INTEGER' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt LP SELECT distinct sclp scanpt INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 77.
parser: ... then shift 'term', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct sclp scanpt LP SELECT distinct selcollist COMMA]
parser: Input 'NULL' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'NULL', pending reduce 167
parser: Return. Stack=[SELECT distinct sclp scanpt LP SELECT distinct sclp scanpt NULL]
parser: Input 'COMMA' with pending reduce 167
parser: Reduce 167 [term ::= NULL|FLOAT|BLOB], go to state 77.
parser: ... then shift 'term', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct sclp scanpt LP SELECT distinct selcollist COMMA]
parser: Input 'INTEGER' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt LP SELECT distinct sclp scanpt INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 77.
parser: ... then shift 'term', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Reduce 100 [from ::=].
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 4.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 4.
parser: ... then shift 'select', go to state 483
parser: Shift 'RP', pending reduce 203
parser: Return. Stack=[SELECT distinct sclp scanpt LP select RP]
parser: Input 'NE' with pending reduce 203
parser: Reduce 203 [expr ::= LP select RP], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Shift 'NE', go to state 117
parser: Return. Stack=[SELECT distinct sclp scanpt expr NE]
parser: Input 'LP' in state 117
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct sclp scanpt expr NE LP]
parser: Input 'SELECT' in state 4
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT distinct sclp scanpt expr NE LP SELECT]
parser: Input 'INTEGER' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt expr NE LP SELECT distinct sclp scanpt INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 77.
parser: ... then shift 'term', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct sclp scanpt expr NE LP SELECT distinct selcollist COMMA]
parser: Input 'INTEGER' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt expr NE LP SELECT distinct sclp scanpt INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 77.
parser: ... then shift 'term', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct sclp scanpt expr NE LP SELECT distinct selcollist COMMA]
parser: Input 'INTEGER' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt expr NE LP SELECT distinct sclp scanpt INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 77.
parser: ... then shift 'term', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Reduce 100 [from ::=].
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 4.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 4.
parser: ... then shift 'select', go to state 483
parser: Shift 'RP', pending reduce 203
parser: Return. Stack=[SELECT distinct sclp scanpt expr NE LP select RP]
parser: Input 'SEMI' with pending reduce 203
parser: Reduce 203 [expr ::= LP select RP], go to state 117.
parser: ... then shift 'expr', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Reduce 100 [from ::=].
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT (1, NULL, 1) == (1, 1, 2)
;SELECT (1, NULL, 1) IS (1, 1, 2)
;SELECT (1, NULL, 1) IS NOT (1, 1, 2)
;SELECT (1, 1, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 1, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 1, 3) < (1, 2, 3)
;SELECT (1, 1, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 1, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 1, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 1, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 1, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 2, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 2, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 2, 3) <= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 2, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) < (1, 2, 3)
;SELECT (1, 3, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) <= (1, 2, 3)
;SELECT (1, 3, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) < (1, 2, 3)
;SELECT (1, NULL, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, 2, 3)
;SELECT (1, NULL, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, 2, 3)
;SELECT (1, 3, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) < (1, NULL, 3)
;SELECT (1, 3, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) > (1, NULL, 3)
;SELECT (1, 3, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) <= (1, NULL, 3)
;SELECT (1, 3, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) >= (1, NULL, 3)
;SELECT (1, NULL, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) < (1, NULL, 3)
;SELECT (1, NULL, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) > (1, NULL, 3)
;SELECT (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, NULL, 3)
;SELECT (1, NULL, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, NULL, 3)
;CREATE TABLE v0(over, following);;INSERT INTO t0 VALUES(3, 5);;INSERT INTO v0 VALUES(3, 6);SELECT (1, 1) == (SELECT c0,c0 FROM t0 ORDER BY c0, c0)
;SELECT (1, 1) == (SELECT * FROM t0 ORDER BY c0, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0, c0)
  
;SELECT (SELECT * FROM t0 ORDER BY c0, c0 DESC) == (SELECT * FROM t0 ORDER BY c0, c0 DESC)
  
;SELECT (3, 6) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
  
;SELECT ((3, 5)) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (SELECT 3, 5) == (SELECT c0,c0 FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT * FROM t0 ORDER BY c0 DESC, c0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (2, 2) BETWEEN (2, 2) AND (3, 3)
;SELECT (2, 2) BETWEEN (2, NULL) AND (3, 3)
;SELECT (NULL, 4) IN (SELECT * FROM v0)
;SELECT (NULL, 4) NOT IN (SELECT * FROM v0)
;CREATE TABLE preceding(t1, x, test001);;INSERT INTO preceding VALUES('abc', 1, 'i');;INSERT INTO v0 VALUES('def', 2, 'iii');;INSERT INTO v0 VALUES('ghi', 3, 'vi');;
;SELECT c0 FROM t0 WHERE c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE +c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE (c0 COLLATE nocase, c0) IS NOT (SELECT 'def', 2);;
;SELECT following FROM v0 WHERE (over, over) = (SELECT 2, 'def');;INSERT INTO v0 VALUES(3, 3, 3);SELECT * FROM t0 WHERE (c0, c0) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM v0 WHERE (following, following) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;CREATE TABLE last_field(test002);;INSERT INTO last_field VALUES(3, 3, 3);;INSERT INTO last_field VALUES(4, 4, 4);;INSERT INTO t0 VALUES(5, 5, 5);SELECT following FROM v0 WHERE (over, following) > (2, 2)
;SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'LP' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct sclp scanpt LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA]
parser: Input 'NULL' in state 91
parser: Shift 'NULL', pending reduce 167
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA NULL]
parser: Input 'COMMA' with pending reduce 167
parser: Reduce 167 [term ::= NULL|FLOAT|BLOB], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA term RP]
parser: Input 'EQ' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ]
parser: Input 'LP' in state 117
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP nexprlist COMMA INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP nexprlist COMMA term RP]
parser: Input 'SEMI' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 117.
parser: ... then shift 'expr', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Reduce 100 [from ::=].
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT (1, NULL, 1) IS (1, 1, 2)
;SELECT (1, NULL, 1) IS NOT (1, 1, 2)
;SELECT (1, 1, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 1, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 1, 3) < (1, 2, 3)
;SELECT (1, 1, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 1, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 1, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 1, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 1, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 2, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 2, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 2, 3) <= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 2, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) < (1, 2, 3)
;SELECT (1, 3, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) <= (1, 2, 3)
;SELECT (1, 3, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) < (1, 2, 3)
;SELECT (1, NULL, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, 2, 3)
;SELECT (1, NULL, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, 2, 3)
;SELECT (1, 3, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) < (1, NULL, 3)
;SELECT (1, 3, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) > (1, NULL, 3)
;SELECT (1, 3, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) <= (1, NULL, 3)
;SELECT (1, 3, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) >= (1, NULL, 3)
;SELECT (1, NULL, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) < (1, NULL, 3)
;SELECT (1, NULL, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) > (1, NULL, 3)
;SELECT (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, NULL, 3)
;SELECT (1, NULL, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, NULL, 3)
;CREATE TABLE v0(over, following);;INSERT INTO t0 VALUES(3, 5);;INSERT INTO v0 VALUES(3, 6);SELECT (1, 1) == (SELECT c0,c0 FROM t0 ORDER BY c0, c0)
;SELECT (1, 1) == (SELECT * FROM t0 ORDER BY c0, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0, c0)
  
;SELECT (SELECT * FROM t0 ORDER BY c0, c0 DESC) == (SELECT * FROM t0 ORDER BY c0, c0 DESC)
  
;SELECT (3, 6) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
  
;SELECT ((3, 5)) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (SELECT 3, 5) == (SELECT c0,c0 FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT * FROM t0 ORDER BY c0 DESC, c0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (2, 2) BETWEEN (2, 2) AND (3, 3)
;SELECT (2, 2) BETWEEN (2, NULL) AND (3, 3)
;SELECT (NULL, 4) IN (SELECT * FROM v0)
;SELECT (NULL, 4) NOT IN (SELECT * FROM v0)
;CREATE TABLE preceding(t1, x, test001);;INSERT INTO preceding VALUES('abc', 1, 'i');;INSERT INTO v0 VALUES('def', 2, 'iii');;INSERT INTO v0 VALUES('ghi', 3, 'vi');;
;SELECT c0 FROM t0 WHERE c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE +c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE (c0 COLLATE nocase, c0) IS NOT (SELECT 'def', 2);;
;SELECT following FROM v0 WHERE (over, over) = (SELECT 2, 'def');;INSERT INTO v0 VALUES(3, 3, 3);SELECT * FROM t0 WHERE (c0, c0) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM v0 WHERE (following, following) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;CREATE TABLE last_field(test002);;INSERT INTO last_field VALUES(3, 3, 3);;INSERT INTO last_field VALUES(4, 4, 4);;INSERT INTO t0 VALUES(5, 5, 5);SELECT following FROM v0 WHERE (over, following) > (2, 2)
;SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'LP' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct sclp scanpt LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA]
parser: Input 'NULL' in state 91
parser: Shift 'NULL', pending reduce 167
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA NULL]
parser: Input 'COMMA' with pending reduce 167
parser: Reduce 167 [term ::= NULL|FLOAT|BLOB], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA term RP]
parser: Input 'IS' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Shift 'IS', go to state 110
parser: Return. Stack=[SELECT distinct sclp scanpt expr IS]
parser: Input 'LP' in state 110
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct sclp scanpt expr IS LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt expr IS LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt expr IS LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt expr IS LP nexprlist COMMA INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt expr IS LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt expr IS LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct sclp scanpt expr IS LP nexprlist COMMA term RP]
parser: Input 'SEMI' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 110.
parser: ... then shift 'expr', go to state 127
parser: Reduce 192 [expr ::= expr IS expr], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Reduce 100 [from ::=].
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT (1, NULL, 1) IS NOT (1, 1, 2)
;SELECT (1, 1, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 1, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 1, 3) < (1, 2, 3)
;SELECT (1, 1, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 1, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 1, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 1, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 1, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 2, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 2, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 2, 3) <= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 2, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) < (1, 2, 3)
;SELECT (1, 3, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) <= (1, 2, 3)
;SELECT (1, 3, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) < (1, 2, 3)
;SELECT (1, NULL, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, 2, 3)
;SELECT (1, NULL, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, 2, 3)
;SELECT (1, 3, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) < (1, NULL, 3)
;SELECT (1, 3, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) > (1, NULL, 3)
;SELECT (1, 3, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) <= (1, NULL, 3)
;SELECT (1, 3, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) >= (1, NULL, 3)
;SELECT (1, NULL, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) < (1, NULL, 3)
;SELECT (1, NULL, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) > (1, NULL, 3)
;SELECT (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, NULL, 3)
;SELECT (1, NULL, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, NULL, 3)
;CREATE TABLE v0(over, following);;INSERT INTO t0 VALUES(3, 5);;INSERT INTO v0 VALUES(3, 6);SELECT (1, 1) == (SELECT c0,c0 FROM t0 ORDER BY c0, c0)
;SELECT (1, 1) == (SELECT * FROM t0 ORDER BY c0, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0, c0)
  
;SELECT (SELECT * FROM t0 ORDER BY c0, c0 DESC) == (SELECT * FROM t0 ORDER BY c0, c0 DESC)
  
;SELECT (3, 6) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
  
;SELECT ((3, 5)) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (SELECT 3, 5) == (SELECT c0,c0 FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT * FROM t0 ORDER BY c0 DESC, c0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (2, 2) BETWEEN (2, 2) AND (3, 3)
;SELECT (2, 2) BETWEEN (2, NULL) AND (3, 3)
;SELECT (NULL, 4) IN (SELECT * FROM v0)
;SELECT (NULL, 4) NOT IN (SELECT * FROM v0)
;CREATE TABLE preceding(t1, x, test001);;INSERT INTO preceding VALUES('abc', 1, 'i');;INSERT INTO v0 VALUES('def', 2, 'iii');;INSERT INTO v0 VALUES('ghi', 3, 'vi');;
;SELECT c0 FROM t0 WHERE c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE +c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE (c0 COLLATE nocase, c0) IS NOT (SELECT 'def', 2);;
;SELECT following FROM v0 WHERE (over, over) = (SELECT 2, 'def');;INSERT INTO v0 VALUES(3, 3, 3);SELECT * FROM t0 WHERE (c0, c0) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM v0 WHERE (following, following) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;CREATE TABLE last_field(test002);;INSERT INTO last_field VALUES(3, 3, 3);;INSERT INTO last_field VALUES(4, 4, 4);;INSERT INTO t0 VALUES(5, 5, 5);SELECT following FROM v0 WHERE (over, following) > (2, 2)
;SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'LP' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct sclp scanpt LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA]
parser: Input 'NULL' in state 91
parser: Shift 'NULL', pending reduce 167
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA NULL]
parser: Input 'COMMA' with pending reduce 167
parser: Reduce 167 [term ::= NULL|FLOAT|BLOB], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA term RP]
parser: Input 'IS' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Shift 'IS', go to state 110
parser: Return. Stack=[SELECT distinct sclp scanpt expr IS]
parser: Input 'NOT' in state 110
parser: Shift 'NOT', go to state 97
parser: Return. Stack=[SELECT distinct sclp scanpt expr IS NOT]
parser: Input 'LP' in state 97
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct sclp scanpt expr IS NOT LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt expr IS NOT LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt expr IS NOT LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt expr IS NOT LP nexprlist COMMA INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt expr IS NOT LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt expr IS NOT LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct sclp scanpt expr IS NOT LP nexprlist COMMA term RP]
parser: Input 'SEMI' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 97.
parser: ... then shift 'expr', go to state 125
parser: Reduce 193 [expr ::= expr IS NOT expr], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Reduce 100 [from ::=].
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT (1, 1, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 1, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 1, 3) < (1, 2, 3)
;SELECT (1, 1, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 1, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 1, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 1, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 1, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 2, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 2, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 2, 3) <= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 2, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) < (1, 2, 3)
;SELECT (1, 3, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) <= (1, 2, 3)
;SELECT (1, 3, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) < (1, 2, 3)
;SELECT (1, NULL, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, 2, 3)
;SELECT (1, NULL, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, 2, 3)
;SELECT (1, 3, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) < (1, NULL, 3)
;SELECT (1, 3, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) > (1, NULL, 3)
;SELECT (1, 3, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) <= (1, NULL, 3)
;SELECT (1, 3, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) >= (1, NULL, 3)
;SELECT (1, NULL, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) < (1, NULL, 3)
;SELECT (1, NULL, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) > (1, NULL, 3)
;SELECT (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, NULL, 3)
;SELECT (1, NULL, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, NULL, 3)
;CREATE TABLE v0(over, following);;INSERT INTO t0 VALUES(3, 5);;INSERT INTO v0 VALUES(3, 6);SELECT (1, 1) == (SELECT c0,c0 FROM t0 ORDER BY c0, c0)
;SELECT (1, 1) == (SELECT * FROM t0 ORDER BY c0, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0, c0)
  
;SELECT (SELECT * FROM t0 ORDER BY c0, c0 DESC) == (SELECT * FROM t0 ORDER BY c0, c0 DESC)
  
;SELECT (3, 6) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
  
;SELECT ((3, 5)) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (SELECT 3, 5) == (SELECT c0,c0 FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT * FROM t0 ORDER BY c0 DESC, c0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (2, 2) BETWEEN (2, 2) AND (3, 3)
;SELECT (2, 2) BETWEEN (2, NULL) AND (3, 3)
;SELECT (NULL, 4) IN (SELECT * FROM v0)
;SELECT (NULL, 4) NOT IN (SELECT * FROM v0)
;CREATE TABLE preceding(t1, x, test001);;INSERT INTO preceding VALUES('abc', 1, 'i');;INSERT INTO v0 VALUES('def', 2, 'iii');;INSERT INTO v0 VALUES('ghi', 3, 'vi');;
;SELECT c0 FROM t0 WHERE c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE +c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE (c0 COLLATE nocase, c0) IS NOT (SELECT 'def', 2);;
;SELECT following FROM v0 WHERE (over, over) = (SELECT 2, 'def');;INSERT INTO v0 VALUES(3, 3, 3);SELECT * FROM t0 WHERE (c0, c0) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM v0 WHERE (following, following) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;CREATE TABLE last_field(test002);;INSERT INTO last_field VALUES(3, 3, 3);;INSERT INTO last_field VALUES(4, 4, 4);;INSERT INTO t0 VALUES(5, 5, 5);SELECT following FROM v0 WHERE (over, following) > (2, 2)
;SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'LP' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct sclp scanpt LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA term RP]
parser: Input 'LT' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Shift 'LT', go to state 118
parser: Return. Stack=[SELECT distinct sclp scanpt expr LT]
parser: Input 'LP' in state 118
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct sclp scanpt expr LT LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt expr LT LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt expr LT LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt expr LT LP nexprlist COMMA INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt expr LT LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt expr LT LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct sclp scanpt expr LT LP nexprlist COMMA term RP]
parser: Input 'SEMI' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 118.
parser: ... then shift 'expr', go to state 130
parser: Reduce 181 [expr ::= expr LT|GT|GE|LE expr], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Reduce 100 [from ::=].
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT * FROM t0 WHERE (1, 1, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 1, 3) < (1, 2, 3)
;SELECT (1, 1, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 1, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 1, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 1, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 1, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 2, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 2, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 2, 3) <= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 2, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) < (1, 2, 3)
;SELECT (1, 3, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) <= (1, 2, 3)
;SELECT (1, 3, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) < (1, 2, 3)
;SELECT (1, NULL, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, 2, 3)
;SELECT (1, NULL, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, 2, 3)
;SELECT (1, 3, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) < (1, NULL, 3)
;SELECT (1, 3, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) > (1, NULL, 3)
;SELECT (1, 3, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) <= (1, NULL, 3)
;SELECT (1, 3, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) >= (1, NULL, 3)
;SELECT (1, NULL, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) < (1, NULL, 3)
;SELECT (1, NULL, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) > (1, NULL, 3)
;SELECT (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, NULL, 3)
;SELECT (1, NULL, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, NULL, 3)
;CREATE TABLE v0(over, following);;INSERT INTO t0 VALUES(3, 5);;INSERT INTO v0 VALUES(3, 6);SELECT (1, 1) == (SELECT c0,c0 FROM t0 ORDER BY c0, c0)
;SELECT (1, 1) == (SELECT * FROM t0 ORDER BY c0, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0, c0)
  
;SELECT (SELECT * FROM t0 ORDER BY c0, c0 DESC) == (SELECT * FROM t0 ORDER BY c0, c0 DESC)
  
;SELECT (3, 6) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
  
;SELECT ((3, 5)) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (SELECT 3, 5) == (SELECT c0,c0 FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT * FROM t0 ORDER BY c0 DESC, c0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (2, 2) BETWEEN (2, 2) AND (3, 3)
;SELECT (2, 2) BETWEEN (2, NULL) AND (3, 3)
;SELECT (NULL, 4) IN (SELECT * FROM v0)
;SELECT (NULL, 4) NOT IN (SELECT * FROM v0)
;CREATE TABLE preceding(t1, x, test001);;INSERT INTO preceding VALUES('abc', 1, 'i');;INSERT INTO v0 VALUES('def', 2, 'iii');;INSERT INTO v0 VALUES('ghi', 3, 'vi');;
;SELECT c0 FROM t0 WHERE c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE +c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE (c0 COLLATE nocase, c0) IS NOT (SELECT 'def', 2);;
;SELECT following FROM v0 WHERE (over, over) = (SELECT 2, 'def');;INSERT INTO v0 VALUES(3, 3, 3);SELECT * FROM t0 WHERE (c0, c0) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM v0 WHERE (following, following) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;CREATE TABLE last_field(test002);;INSERT INTO last_field VALUES(3, 3, 3);;INSERT INTO last_field VALUES(4, 4, 4);;INSERT INTO t0 VALUES(5, 5, 5);SELECT following FROM v0 WHERE (over, following) > (2, 2)
;SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 96
parser: Return. Stack=[SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[SELECT distinct selcollist from WHERE]
parser: Input 'LP' in state 93
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP nexprlist COMMA INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP nexprlist COMMA term RP]
parser: Input 'LT' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'LT', go to state 118
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LT]
parser: Input 'LP' in state 118
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LT LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LT LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LT LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LT LP nexprlist COMMA INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LT LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LT LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LT LP nexprlist COMMA term RP]
parser: Input 'SEMI' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 118.
parser: ... then shift 'expr', go to state 130
parser: Reduce 181 [expr ::= expr LT|GT|GE|LE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT * FROM t0 WHERE NOT (1, 1, 3) < (1, 2, 3)
;SELECT (1, 1, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 1, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 1, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 1, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 1, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 2, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 2, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 2, 3) <= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 2, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) < (1, 2, 3)
;SELECT (1, 3, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) <= (1, 2, 3)
;SELECT (1, 3, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) < (1, 2, 3)
;SELECT (1, NULL, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, 2, 3)
;SELECT (1, NULL, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, 2, 3)
;SELECT (1, 3, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) < (1, NULL, 3)
;SELECT (1, 3, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) > (1, NULL, 3)
;SELECT (1, 3, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) <= (1, NULL, 3)
;SELECT (1, 3, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) >= (1, NULL, 3)
;SELECT (1, NULL, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) < (1, NULL, 3)
;SELECT (1, NULL, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) > (1, NULL, 3)
;SELECT (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, NULL, 3)
;SELECT (1, NULL, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, NULL, 3)
;CREATE TABLE v0(over, following);;INSERT INTO t0 VALUES(3, 5);;INSERT INTO v0 VALUES(3, 6);SELECT (1, 1) == (SELECT c0,c0 FROM t0 ORDER BY c0, c0)
;SELECT (1, 1) == (SELECT * FROM t0 ORDER BY c0, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0, c0)
  
;SELECT (SELECT * FROM t0 ORDER BY c0, c0 DESC) == (SELECT * FROM t0 ORDER BY c0, c0 DESC)
  
;SELECT (3, 6) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
  
;SELECT ((3, 5)) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (SELECT 3, 5) == (SELECT c0,c0 FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT * FROM t0 ORDER BY c0 DESC, c0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (2, 2) BETWEEN (2, 2) AND (3, 3)
;SELECT (2, 2) BETWEEN (2, NULL) AND (3, 3)
;SELECT (NULL, 4) IN (SELECT * FROM v0)
;SELECT (NULL, 4) NOT IN (SELECT * FROM v0)
;CREATE TABLE preceding(t1, x, test001);;INSERT INTO preceding VALUES('abc', 1, 'i');;INSERT INTO v0 VALUES('def', 2, 'iii');;INSERT INTO v0 VALUES('ghi', 3, 'vi');;
;SELECT c0 FROM t0 WHERE c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE +c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE (c0 COLLATE nocase, c0) IS NOT (SELECT 'def', 2);;
;SELECT following FROM v0 WHERE (over, over) = (SELECT 2, 'def');;INSERT INTO v0 VALUES(3, 3, 3);SELECT * FROM t0 WHERE (c0, c0) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM v0 WHERE (following, following) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;CREATE TABLE last_field(test002);;INSERT INTO last_field VALUES(3, 3, 3);;INSERT INTO last_field VALUES(4, 4, 4);;INSERT INTO t0 VALUES(5, 5, 5);SELECT following FROM v0 WHERE (over, following) > (2, 2)
;SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 96
parser: Return. Stack=[SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[SELECT distinct selcollist from WHERE]
parser: Input 'NOT' in state 93
parser: Shift 'NOT', go to state 105
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT]
parser: Input 'LP' in state 105
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP nexprlist COMMA INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP nexprlist COMMA term RP]
parser: Input 'LT' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 105.
parser: ... then shift 'expr', go to state 75
parser: Shift 'LT', go to state 118
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr LT]
parser: Input 'LP' in state 118
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr LT LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr LT LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr LT LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr LT LP nexprlist COMMA INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr LT LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr LT LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr LT LP nexprlist COMMA term RP]
parser: Input 'SEMI' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 118.
parser: ... then shift 'expr', go to state 130
parser: Reduce 181 [expr ::= expr LT|GT|GE|LE expr], go to state 105.
parser: ... then shift 'expr', go to state 75
parser: Reduce 194 [expr ::= NOT expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT (1, 1, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 1, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 1, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 1, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 1, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 2, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 2, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 2, 3) <= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 2, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) < (1, 2, 3)
;SELECT (1, 3, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) <= (1, 2, 3)
;SELECT (1, 3, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) < (1, 2, 3)
;SELECT (1, NULL, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, 2, 3)
;SELECT (1, NULL, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, 2, 3)
;SELECT (1, 3, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) < (1, NULL, 3)
;SELECT (1, 3, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) > (1, NULL, 3)
;SELECT (1, 3, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) <= (1, NULL, 3)
;SELECT (1, 3, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) >= (1, NULL, 3)
;SELECT (1, NULL, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) < (1, NULL, 3)
;SELECT (1, NULL, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) > (1, NULL, 3)
;SELECT (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, NULL, 3)
;SELECT (1, NULL, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, NULL, 3)
;CREATE TABLE v0(over, following);;INSERT INTO t0 VALUES(3, 5);;INSERT INTO v0 VALUES(3, 6);SELECT (1, 1) == (SELECT c0,c0 FROM t0 ORDER BY c0, c0)
;SELECT (1, 1) == (SELECT * FROM t0 ORDER BY c0, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0, c0)
  
;SELECT (SELECT * FROM t0 ORDER BY c0, c0 DESC) == (SELECT * FROM t0 ORDER BY c0, c0 DESC)
  
;SELECT (3, 6) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
  
;SELECT ((3, 5)) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (SELECT 3, 5) == (SELECT c0,c0 FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT * FROM t0 ORDER BY c0 DESC, c0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (2, 2) BETWEEN (2, 2) AND (3, 3)
;SELECT (2, 2) BETWEEN (2, NULL) AND (3, 3)
;SELECT (NULL, 4) IN (SELECT * FROM v0)
;SELECT (NULL, 4) NOT IN (SELECT * FROM v0)
;CREATE TABLE preceding(t1, x, test001);;INSERT INTO preceding VALUES('abc', 1, 'i');;INSERT INTO v0 VALUES('def', 2, 'iii');;INSERT INTO v0 VALUES('ghi', 3, 'vi');;
;SELECT c0 FROM t0 WHERE c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE +c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE (c0 COLLATE nocase, c0) IS NOT (SELECT 'def', 2);;
;SELECT following FROM v0 WHERE (over, over) = (SELECT 2, 'def');;INSERT INTO v0 VALUES(3, 3, 3);SELECT * FROM t0 WHERE (c0, c0) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM v0 WHERE (following, following) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;CREATE TABLE last_field(test002);;INSERT INTO last_field VALUES(3, 3, 3);;INSERT INTO last_field VALUES(4, 4, 4);;INSERT INTO t0 VALUES(5, 5, 5);SELECT following FROM v0 WHERE (over, following) > (2, 2)
;SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'LP' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct sclp scanpt LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA term RP]
parser: Input 'GT' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Shift 'GT', go to state 118
parser: Return. Stack=[SELECT distinct sclp scanpt expr GT]
parser: Input 'LP' in state 118
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct sclp scanpt expr GT LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt expr GT LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt expr GT LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt expr GT LP nexprlist COMMA INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt expr GT LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt expr GT LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct sclp scanpt expr GT LP nexprlist COMMA term RP]
parser: Input 'SEMI' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 118.
parser: ... then shift 'expr', go to state 130
parser: Reduce 181 [expr ::= expr LT|GT|GE|LE expr], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Reduce 100 [from ::=].
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT * FROM t0 WHERE (1, 1, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 1, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 1, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 1, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 2, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 2, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 2, 3) <= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 2, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) < (1, 2, 3)
;SELECT (1, 3, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) <= (1, 2, 3)
;SELECT (1, 3, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) < (1, 2, 3)
;SELECT (1, NULL, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, 2, 3)
;SELECT (1, NULL, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, 2, 3)
;SELECT (1, 3, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) < (1, NULL, 3)
;SELECT (1, 3, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) > (1, NULL, 3)
;SELECT (1, 3, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) <= (1, NULL, 3)
;SELECT (1, 3, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) >= (1, NULL, 3)
;SELECT (1, NULL, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) < (1, NULL, 3)
;SELECT (1, NULL, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) > (1, NULL, 3)
;SELECT (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, NULL, 3)
;SELECT (1, NULL, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, NULL, 3)
;CREATE TABLE v0(over, following);;INSERT INTO t0 VALUES(3, 5);;INSERT INTO v0 VALUES(3, 6);SELECT (1, 1) == (SELECT c0,c0 FROM t0 ORDER BY c0, c0)
;SELECT (1, 1) == (SELECT * FROM t0 ORDER BY c0, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0, c0)
  
;SELECT (SELECT * FROM t0 ORDER BY c0, c0 DESC) == (SELECT * FROM t0 ORDER BY c0, c0 DESC)
  
;SELECT (3, 6) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
  
;SELECT ((3, 5)) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (SELECT 3, 5) == (SELECT c0,c0 FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT * FROM t0 ORDER BY c0 DESC, c0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (2, 2) BETWEEN (2, 2) AND (3, 3)
;SELECT (2, 2) BETWEEN (2, NULL) AND (3, 3)
;SELECT (NULL, 4) IN (SELECT * FROM v0)
;SELECT (NULL, 4) NOT IN (SELECT * FROM v0)
;CREATE TABLE preceding(t1, x, test001);;INSERT INTO preceding VALUES('abc', 1, 'i');;INSERT INTO v0 VALUES('def', 2, 'iii');;INSERT INTO v0 VALUES('ghi', 3, 'vi');;
;SELECT c0 FROM t0 WHERE c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE +c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE (c0 COLLATE nocase, c0) IS NOT (SELECT 'def', 2);;
;SELECT following FROM v0 WHERE (over, over) = (SELECT 2, 'def');;INSERT INTO v0 VALUES(3, 3, 3);SELECT * FROM t0 WHERE (c0, c0) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM v0 WHERE (following, following) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;CREATE TABLE last_field(test002);;INSERT INTO last_field VALUES(3, 3, 3);;INSERT INTO last_field VALUES(4, 4, 4);;INSERT INTO t0 VALUES(5, 5, 5);SELECT following FROM v0 WHERE (over, following) > (2, 2)
;SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 96
parser: Return. Stack=[SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[SELECT distinct selcollist from WHERE]
parser: Input 'LP' in state 93
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP nexprlist COMMA INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP nexprlist COMMA term RP]
parser: Input 'GT' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'GT', go to state 118
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr GT]
parser: Input 'LP' in state 118
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr GT LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr GT LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr GT LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr GT LP nexprlist COMMA INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr GT LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr GT LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr GT LP nexprlist COMMA term RP]
parser: Input 'SEMI' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 118.
parser: ... then shift 'expr', go to state 130
parser: Reduce 181 [expr ::= expr LT|GT|GE|LE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT * FROM t0 WHERE NOT (1, 1, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 1, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 1, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 2, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 2, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 2, 3) <= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 2, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) < (1, 2, 3)
;SELECT (1, 3, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) <= (1, 2, 3)
;SELECT (1, 3, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) < (1, 2, 3)
;SELECT (1, NULL, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, 2, 3)
;SELECT (1, NULL, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, 2, 3)
;SELECT (1, 3, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) < (1, NULL, 3)
;SELECT (1, 3, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) > (1, NULL, 3)
;SELECT (1, 3, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) <= (1, NULL, 3)
;SELECT (1, 3, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) >= (1, NULL, 3)
;SELECT (1, NULL, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) < (1, NULL, 3)
;SELECT (1, NULL, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) > (1, NULL, 3)
;SELECT (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, NULL, 3)
;SELECT (1, NULL, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, NULL, 3)
;CREATE TABLE v0(over, following);;INSERT INTO t0 VALUES(3, 5);;INSERT INTO v0 VALUES(3, 6);SELECT (1, 1) == (SELECT c0,c0 FROM t0 ORDER BY c0, c0)
;SELECT (1, 1) == (SELECT * FROM t0 ORDER BY c0, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0, c0)
  
;SELECT (SELECT * FROM t0 ORDER BY c0, c0 DESC) == (SELECT * FROM t0 ORDER BY c0, c0 DESC)
  
;SELECT (3, 6) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
  
;SELECT ((3, 5)) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (SELECT 3, 5) == (SELECT c0,c0 FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT * FROM t0 ORDER BY c0 DESC, c0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (2, 2) BETWEEN (2, 2) AND (3, 3)
;SELECT (2, 2) BETWEEN (2, NULL) AND (3, 3)
;SELECT (NULL, 4) IN (SELECT * FROM v0)
;SELECT (NULL, 4) NOT IN (SELECT * FROM v0)
;CREATE TABLE preceding(t1, x, test001);;INSERT INTO preceding VALUES('abc', 1, 'i');;INSERT INTO v0 VALUES('def', 2, 'iii');;INSERT INTO v0 VALUES('ghi', 3, 'vi');;
;SELECT c0 FROM t0 WHERE c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE +c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE (c0 COLLATE nocase, c0) IS NOT (SELECT 'def', 2);;
;SELECT following FROM v0 WHERE (over, over) = (SELECT 2, 'def');;INSERT INTO v0 VALUES(3, 3, 3);SELECT * FROM t0 WHERE (c0, c0) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM v0 WHERE (following, following) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;CREATE TABLE last_field(test002);;INSERT INTO last_field VALUES(3, 3, 3);;INSERT INTO last_field VALUES(4, 4, 4);;INSERT INTO t0 VALUES(5, 5, 5);SELECT following FROM v0 WHERE (over, following) > (2, 2)
;SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 96
parser: Return. Stack=[SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[SELECT distinct selcollist from WHERE]
parser: Input 'NOT' in state 93
parser: Shift 'NOT', go to state 105
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT]
parser: Input 'LP' in state 105
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP nexprlist COMMA INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP nexprlist COMMA term RP]
parser: Input 'GT' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 105.
parser: ... then shift 'expr', go to state 75
parser: Shift 'GT', go to state 118
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr GT]
parser: Input 'LP' in state 118
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr GT LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr GT LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr GT LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr GT LP nexprlist COMMA INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr GT LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr GT LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr GT LP nexprlist COMMA term RP]
parser: Input 'SEMI' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 118.
parser: ... then shift 'expr', go to state 130
parser: Reduce 181 [expr ::= expr LT|GT|GE|LE expr], go to state 105.
parser: ... then shift 'expr', go to state 75
parser: Reduce 194 [expr ::= NOT expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT * FROM t0 WHERE (1, 1, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 1, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 2, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 2, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 2, 3) <= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 2, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) < (1, 2, 3)
;SELECT (1, 3, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) <= (1, 2, 3)
;SELECT (1, 3, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) < (1, 2, 3)
;SELECT (1, NULL, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, 2, 3)
;SELECT (1, NULL, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, 2, 3)
;SELECT (1, 3, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) < (1, NULL, 3)
;SELECT (1, 3, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) > (1, NULL, 3)
;SELECT (1, 3, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) <= (1, NULL, 3)
;SELECT (1, 3, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) >= (1, NULL, 3)
;SELECT (1, NULL, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) < (1, NULL, 3)
;SELECT (1, NULL, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) > (1, NULL, 3)
;SELECT (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, NULL, 3)
;SELECT (1, NULL, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, NULL, 3)
;CREATE TABLE v0(over, following);;INSERT INTO t0 VALUES(3, 5);;INSERT INTO v0 VALUES(3, 6);SELECT (1, 1) == (SELECT c0,c0 FROM t0 ORDER BY c0, c0)
;SELECT (1, 1) == (SELECT * FROM t0 ORDER BY c0, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0, c0)
  
;SELECT (SELECT * FROM t0 ORDER BY c0, c0 DESC) == (SELECT * FROM t0 ORDER BY c0, c0 DESC)
  
;SELECT (3, 6) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
  
;SELECT ((3, 5)) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (SELECT 3, 5) == (SELECT c0,c0 FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT * FROM t0 ORDER BY c0 DESC, c0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (2, 2) BETWEEN (2, 2) AND (3, 3)
;SELECT (2, 2) BETWEEN (2, NULL) AND (3, 3)
;SELECT (NULL, 4) IN (SELECT * FROM v0)
;SELECT (NULL, 4) NOT IN (SELECT * FROM v0)
;CREATE TABLE preceding(t1, x, test001);;INSERT INTO preceding VALUES('abc', 1, 'i');;INSERT INTO v0 VALUES('def', 2, 'iii');;INSERT INTO v0 VALUES('ghi', 3, 'vi');;
;SELECT c0 FROM t0 WHERE c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE +c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE (c0 COLLATE nocase, c0) IS NOT (SELECT 'def', 2);;
;SELECT following FROM v0 WHERE (over, over) = (SELECT 2, 'def');;INSERT INTO v0 VALUES(3, 3, 3);SELECT * FROM t0 WHERE (c0, c0) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM v0 WHERE (following, following) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;CREATE TABLE last_field(test002);;INSERT INTO last_field VALUES(3, 3, 3);;INSERT INTO last_field VALUES(4, 4, 4);;INSERT INTO t0 VALUES(5, 5, 5);SELECT following FROM v0 WHERE (over, following) > (2, 2)
;SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 96
parser: Return. Stack=[SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[SELECT distinct selcollist from WHERE]
parser: Input 'LP' in state 93
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP nexprlist COMMA INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP nexprlist COMMA term RP]
parser: Input 'GE' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'GE', go to state 118
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr GE]
parser: Input 'LP' in state 118
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr GE LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr GE LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr GE LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr GE LP nexprlist COMMA INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr GE LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr GE LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr GE LP nexprlist COMMA term RP]
parser: Input 'SEMI' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 118.
parser: ... then shift 'expr', go to state 130
parser: Reduce 181 [expr ::= expr LT|GT|GE|LE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT * FROM t0 WHERE NOT (1, 1, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 2, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 2, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 2, 3) <= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 2, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) < (1, 2, 3)
;SELECT (1, 3, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) <= (1, 2, 3)
;SELECT (1, 3, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) < (1, 2, 3)
;SELECT (1, NULL, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, 2, 3)
;SELECT (1, NULL, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, 2, 3)
;SELECT (1, 3, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) < (1, NULL, 3)
;SELECT (1, 3, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) > (1, NULL, 3)
;SELECT (1, 3, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) <= (1, NULL, 3)
;SELECT (1, 3, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) >= (1, NULL, 3)
;SELECT (1, NULL, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) < (1, NULL, 3)
;SELECT (1, NULL, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) > (1, NULL, 3)
;SELECT (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, NULL, 3)
;SELECT (1, NULL, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, NULL, 3)
;CREATE TABLE v0(over, following);;INSERT INTO t0 VALUES(3, 5);;INSERT INTO v0 VALUES(3, 6);SELECT (1, 1) == (SELECT c0,c0 FROM t0 ORDER BY c0, c0)
;SELECT (1, 1) == (SELECT * FROM t0 ORDER BY c0, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0, c0)
  
;SELECT (SELECT * FROM t0 ORDER BY c0, c0 DESC) == (SELECT * FROM t0 ORDER BY c0, c0 DESC)
  
;SELECT (3, 6) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
  
;SELECT ((3, 5)) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (SELECT 3, 5) == (SELECT c0,c0 FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT * FROM t0 ORDER BY c0 DESC, c0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (2, 2) BETWEEN (2, 2) AND (3, 3)
;SELECT (2, 2) BETWEEN (2, NULL) AND (3, 3)
;SELECT (NULL, 4) IN (SELECT * FROM v0)
;SELECT (NULL, 4) NOT IN (SELECT * FROM v0)
;CREATE TABLE preceding(t1, x, test001);;INSERT INTO preceding VALUES('abc', 1, 'i');;INSERT INTO v0 VALUES('def', 2, 'iii');;INSERT INTO v0 VALUES('ghi', 3, 'vi');;
;SELECT c0 FROM t0 WHERE c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE +c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE (c0 COLLATE nocase, c0) IS NOT (SELECT 'def', 2);;
;SELECT following FROM v0 WHERE (over, over) = (SELECT 2, 'def');;INSERT INTO v0 VALUES(3, 3, 3);SELECT * FROM t0 WHERE (c0, c0) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM v0 WHERE (following, following) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;CREATE TABLE last_field(test002);;INSERT INTO last_field VALUES(3, 3, 3);;INSERT INTO last_field VALUES(4, 4, 4);;INSERT INTO t0 VALUES(5, 5, 5);SELECT following FROM v0 WHERE (over, following) > (2, 2)
;SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 96
parser: Return. Stack=[SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[SELECT distinct selcollist from WHERE]
parser: Input 'NOT' in state 93
parser: Shift 'NOT', go to state 105
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT]
parser: Input 'LP' in state 105
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP nexprlist COMMA INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP nexprlist COMMA term RP]
parser: Input 'GE' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 105.
parser: ... then shift 'expr', go to state 75
parser: Shift 'GE', go to state 118
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr GE]
parser: Input 'LP' in state 118
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr GE LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr GE LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr GE LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr GE LP nexprlist COMMA INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr GE LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr GE LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr GE LP nexprlist COMMA term RP]
parser: Input 'SEMI' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 118.
parser: ... then shift 'expr', go to state 130
parser: Reduce 181 [expr ::= expr LT|GT|GE|LE expr], go to state 105.
parser: ... then shift 'expr', go to state 75
parser: Reduce 194 [expr ::= NOT expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT * FROM t0 WHERE (1, 2, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 2, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 2, 3) <= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 2, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) < (1, 2, 3)
;SELECT (1, 3, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) <= (1, 2, 3)
;SELECT (1, 3, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) < (1, 2, 3)
;SELECT (1, NULL, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, 2, 3)
;SELECT (1, NULL, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, 2, 3)
;SELECT (1, 3, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) < (1, NULL, 3)
;SELECT (1, 3, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) > (1, NULL, 3)
;SELECT (1, 3, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) <= (1, NULL, 3)
;SELECT (1, 3, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) >= (1, NULL, 3)
;SELECT (1, NULL, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) < (1, NULL, 3)
;SELECT (1, NULL, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) > (1, NULL, 3)
;SELECT (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, NULL, 3)
;SELECT (1, NULL, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, NULL, 3)
;CREATE TABLE v0(over, following);;INSERT INTO t0 VALUES(3, 5);;INSERT INTO v0 VALUES(3, 6);SELECT (1, 1) == (SELECT c0,c0 FROM t0 ORDER BY c0, c0)
;SELECT (1, 1) == (SELECT * FROM t0 ORDER BY c0, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0, c0)
  
;SELECT (SELECT * FROM t0 ORDER BY c0, c0 DESC) == (SELECT * FROM t0 ORDER BY c0, c0 DESC)
  
;SELECT (3, 6) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
  
;SELECT ((3, 5)) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (SELECT 3, 5) == (SELECT c0,c0 FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT * FROM t0 ORDER BY c0 DESC, c0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (2, 2) BETWEEN (2, 2) AND (3, 3)
;SELECT (2, 2) BETWEEN (2, NULL) AND (3, 3)
;SELECT (NULL, 4) IN (SELECT * FROM v0)
;SELECT (NULL, 4) NOT IN (SELECT * FROM v0)
;CREATE TABLE preceding(t1, x, test001);;INSERT INTO preceding VALUES('abc', 1, 'i');;INSERT INTO v0 VALUES('def', 2, 'iii');;INSERT INTO v0 VALUES('ghi', 3, 'vi');;
;SELECT c0 FROM t0 WHERE c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE +c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE (c0 COLLATE nocase, c0) IS NOT (SELECT 'def', 2);;
;SELECT following FROM v0 WHERE (over, over) = (SELECT 2, 'def');;INSERT INTO v0 VALUES(3, 3, 3);SELECT * FROM t0 WHERE (c0, c0) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM v0 WHERE (following, following) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;CREATE TABLE last_field(test002);;INSERT INTO last_field VALUES(3, 3, 3);;INSERT INTO last_field VALUES(4, 4, 4);;INSERT INTO t0 VALUES(5, 5, 5);SELECT following FROM v0 WHERE (over, following) > (2, 2)
;SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 96
parser: Return. Stack=[SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[SELECT distinct selcollist from WHERE]
parser: Input 'LP' in state 93
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP nexprlist COMMA INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP nexprlist COMMA term RP]
parser: Input 'LT' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'LT', go to state 118
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LT]
parser: Input 'LP' in state 118
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LT LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LT LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LT LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LT LP nexprlist COMMA INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LT LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LT LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LT LP nexprlist COMMA term RP]
parser: Input 'SEMI' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 118.
parser: ... then shift 'expr', go to state 130
parser: Reduce 181 [expr ::= expr LT|GT|GE|LE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT * FROM t0 WHERE NOT (1, 2, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 2, 3) <= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 2, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) < (1, 2, 3)
;SELECT (1, 3, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) <= (1, 2, 3)
;SELECT (1, 3, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) < (1, 2, 3)
;SELECT (1, NULL, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, 2, 3)
;SELECT (1, NULL, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, 2, 3)
;SELECT (1, 3, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) < (1, NULL, 3)
;SELECT (1, 3, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) > (1, NULL, 3)
;SELECT (1, 3, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) <= (1, NULL, 3)
;SELECT (1, 3, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) >= (1, NULL, 3)
;SELECT (1, NULL, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) < (1, NULL, 3)
;SELECT (1, NULL, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) > (1, NULL, 3)
;SELECT (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, NULL, 3)
;SELECT (1, NULL, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, NULL, 3)
;CREATE TABLE v0(over, following);;INSERT INTO t0 VALUES(3, 5);;INSERT INTO v0 VALUES(3, 6);SELECT (1, 1) == (SELECT c0,c0 FROM t0 ORDER BY c0, c0)
;SELECT (1, 1) == (SELECT * FROM t0 ORDER BY c0, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0, c0)
  
;SELECT (SELECT * FROM t0 ORDER BY c0, c0 DESC) == (SELECT * FROM t0 ORDER BY c0, c0 DESC)
  
;SELECT (3, 6) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
  
;SELECT ((3, 5)) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (SELECT 3, 5) == (SELECT c0,c0 FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT * FROM t0 ORDER BY c0 DESC, c0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (2, 2) BETWEEN (2, 2) AND (3, 3)
;SELECT (2, 2) BETWEEN (2, NULL) AND (3, 3)
;SELECT (NULL, 4) IN (SELECT * FROM v0)
;SELECT (NULL, 4) NOT IN (SELECT * FROM v0)
;CREATE TABLE preceding(t1, x, test001);;INSERT INTO preceding VALUES('abc', 1, 'i');;INSERT INTO v0 VALUES('def', 2, 'iii');;INSERT INTO v0 VALUES('ghi', 3, 'vi');;
;SELECT c0 FROM t0 WHERE c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE +c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE (c0 COLLATE nocase, c0) IS NOT (SELECT 'def', 2);;
;SELECT following FROM v0 WHERE (over, over) = (SELECT 2, 'def');;INSERT INTO v0 VALUES(3, 3, 3);SELECT * FROM t0 WHERE (c0, c0) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM v0 WHERE (following, following) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;CREATE TABLE last_field(test002);;INSERT INTO last_field VALUES(3, 3, 3);;INSERT INTO last_field VALUES(4, 4, 4);;INSERT INTO t0 VALUES(5, 5, 5);SELECT following FROM v0 WHERE (over, following) > (2, 2)
;SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 96
parser: Return. Stack=[SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[SELECT distinct selcollist from WHERE]
parser: Input 'NOT' in state 93
parser: Shift 'NOT', go to state 105
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT]
parser: Input 'LP' in state 105
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP nexprlist COMMA INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP nexprlist COMMA term RP]
parser: Input 'LT' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 105.
parser: ... then shift 'expr', go to state 75
parser: Shift 'LT', go to state 118
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr LT]
parser: Input 'LP' in state 118
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr LT LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr LT LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr LT LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr LT LP nexprlist COMMA INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr LT LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr LT LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr LT LP nexprlist COMMA term RP]
parser: Input 'SEMI' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 118.
parser: ... then shift 'expr', go to state 130
parser: Reduce 181 [expr ::= expr LT|GT|GE|LE expr], go to state 105.
parser: ... then shift 'expr', go to state 75
parser: Reduce 194 [expr ::= NOT expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT * FROM t0 WHERE (1, 2, 3) <= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 2, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) < (1, 2, 3)
;SELECT (1, 3, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) <= (1, 2, 3)
;SELECT (1, 3, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) < (1, 2, 3)
;SELECT (1, NULL, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, 2, 3)
;SELECT (1, NULL, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, 2, 3)
;SELECT (1, 3, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) < (1, NULL, 3)
;SELECT (1, 3, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) > (1, NULL, 3)
;SELECT (1, 3, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) <= (1, NULL, 3)
;SELECT (1, 3, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) >= (1, NULL, 3)
;SELECT (1, NULL, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) < (1, NULL, 3)
;SELECT (1, NULL, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) > (1, NULL, 3)
;SELECT (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, NULL, 3)
;SELECT (1, NULL, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, NULL, 3)
;CREATE TABLE v0(over, following);;INSERT INTO t0 VALUES(3, 5);;INSERT INTO v0 VALUES(3, 6);SELECT (1, 1) == (SELECT c0,c0 FROM t0 ORDER BY c0, c0)
;SELECT (1, 1) == (SELECT * FROM t0 ORDER BY c0, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0, c0)
  
;SELECT (SELECT * FROM t0 ORDER BY c0, c0 DESC) == (SELECT * FROM t0 ORDER BY c0, c0 DESC)
  
;SELECT (3, 6) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
  
;SELECT ((3, 5)) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (SELECT 3, 5) == (SELECT c0,c0 FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT * FROM t0 ORDER BY c0 DESC, c0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (2, 2) BETWEEN (2, 2) AND (3, 3)
;SELECT (2, 2) BETWEEN (2, NULL) AND (3, 3)
;SELECT (NULL, 4) IN (SELECT * FROM v0)
;SELECT (NULL, 4) NOT IN (SELECT * FROM v0)
;CREATE TABLE preceding(t1, x, test001);;INSERT INTO preceding VALUES('abc', 1, 'i');;INSERT INTO v0 VALUES('def', 2, 'iii');;INSERT INTO v0 VALUES('ghi', 3, 'vi');;
;SELECT c0 FROM t0 WHERE c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE +c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE (c0 COLLATE nocase, c0) IS NOT (SELECT 'def', 2);;
;SELECT following FROM v0 WHERE (over, over) = (SELECT 2, 'def');;INSERT INTO v0 VALUES(3, 3, 3);SELECT * FROM t0 WHERE (c0, c0) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM v0 WHERE (following, following) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;CREATE TABLE last_field(test002);;INSERT INTO last_field VALUES(3, 3, 3);;INSERT INTO last_field VALUES(4, 4, 4);;INSERT INTO t0 VALUES(5, 5, 5);SELECT following FROM v0 WHERE (over, following) > (2, 2)
;SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 96
parser: Return. Stack=[SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[SELECT distinct selcollist from WHERE]
parser: Input 'LP' in state 93
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP nexprlist COMMA INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP nexprlist COMMA term RP]
parser: Input 'LE' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'LE', go to state 118
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LE]
parser: Input 'LP' in state 118
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LE LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LE LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LE LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LE LP nexprlist COMMA INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LE LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LE LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LE LP nexprlist COMMA term RP]
parser: Input 'SEMI' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 118.
parser: ... then shift 'expr', go to state 130
parser: Reduce 181 [expr ::= expr LT|GT|GE|LE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT * FROM t0 WHERE NOT (1, 2, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) < (1, 2, 3)
;SELECT (1, 3, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) <= (1, 2, 3)
;SELECT (1, 3, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) < (1, 2, 3)
;SELECT (1, NULL, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, 2, 3)
;SELECT (1, NULL, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, 2, 3)
;SELECT (1, 3, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) < (1, NULL, 3)
;SELECT (1, 3, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) > (1, NULL, 3)
;SELECT (1, 3, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) <= (1, NULL, 3)
;SELECT (1, 3, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) >= (1, NULL, 3)
;SELECT (1, NULL, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) < (1, NULL, 3)
;SELECT (1, NULL, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) > (1, NULL, 3)
;SELECT (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, NULL, 3)
;SELECT (1, NULL, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, NULL, 3)
;CREATE TABLE v0(over, following);;INSERT INTO t0 VALUES(3, 5);;INSERT INTO v0 VALUES(3, 6);SELECT (1, 1) == (SELECT c0,c0 FROM t0 ORDER BY c0, c0)
;SELECT (1, 1) == (SELECT * FROM t0 ORDER BY c0, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0, c0)
  
;SELECT (SELECT * FROM t0 ORDER BY c0, c0 DESC) == (SELECT * FROM t0 ORDER BY c0, c0 DESC)
  
;SELECT (3, 6) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
  
;SELECT ((3, 5)) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (SELECT 3, 5) == (SELECT c0,c0 FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT * FROM t0 ORDER BY c0 DESC, c0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (2, 2) BETWEEN (2, 2) AND (3, 3)
;SELECT (2, 2) BETWEEN (2, NULL) AND (3, 3)
;SELECT (NULL, 4) IN (SELECT * FROM v0)
;SELECT (NULL, 4) NOT IN (SELECT * FROM v0)
;CREATE TABLE preceding(t1, x, test001);;INSERT INTO preceding VALUES('abc', 1, 'i');;INSERT INTO v0 VALUES('def', 2, 'iii');;INSERT INTO v0 VALUES('ghi', 3, 'vi');;
;SELECT c0 FROM t0 WHERE c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE +c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE (c0 COLLATE nocase, c0) IS NOT (SELECT 'def', 2);;
;SELECT following FROM v0 WHERE (over, over) = (SELECT 2, 'def');;INSERT INTO v0 VALUES(3, 3, 3);SELECT * FROM t0 WHERE (c0, c0) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM v0 WHERE (following, following) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;CREATE TABLE last_field(test002);;INSERT INTO last_field VALUES(3, 3, 3);;INSERT INTO last_field VALUES(4, 4, 4);;INSERT INTO t0 VALUES(5, 5, 5);SELECT following FROM v0 WHERE (over, following) > (2, 2)
;SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 96
parser: Return. Stack=[SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[SELECT distinct selcollist from WHERE]
parser: Input 'NOT' in state 93
parser: Shift 'NOT', go to state 105
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT]
parser: Input 'LP' in state 105
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP nexprlist COMMA INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP nexprlist COMMA term RP]
parser: Input 'GE' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 105.
parser: ... then shift 'expr', go to state 75
parser: Shift 'GE', go to state 118
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr GE]
parser: Input 'LP' in state 118
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr GE LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr GE LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr GE LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr GE LP nexprlist COMMA INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr GE LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr GE LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr GE LP nexprlist COMMA term RP]
parser: Input 'SEMI' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 118.
parser: ... then shift 'expr', go to state 130
parser: Reduce 181 [expr ::= expr LT|GT|GE|LE expr], go to state 105.
parser: ... then shift 'expr', go to state 75
parser: Reduce 194 [expr ::= NOT expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT * FROM t0 WHERE (1, 3, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) < (1, 2, 3)
;SELECT (1, 3, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) <= (1, 2, 3)
;SELECT (1, 3, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) < (1, 2, 3)
;SELECT (1, NULL, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, 2, 3)
;SELECT (1, NULL, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, 2, 3)
;SELECT (1, 3, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) < (1, NULL, 3)
;SELECT (1, 3, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) > (1, NULL, 3)
;SELECT (1, 3, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) <= (1, NULL, 3)
;SELECT (1, 3, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) >= (1, NULL, 3)
;SELECT (1, NULL, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) < (1, NULL, 3)
;SELECT (1, NULL, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) > (1, NULL, 3)
;SELECT (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, NULL, 3)
;SELECT (1, NULL, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, NULL, 3)
;CREATE TABLE v0(over, following);;INSERT INTO t0 VALUES(3, 5);;INSERT INTO v0 VALUES(3, 6);SELECT (1, 1) == (SELECT c0,c0 FROM t0 ORDER BY c0, c0)
;SELECT (1, 1) == (SELECT * FROM t0 ORDER BY c0, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0, c0)
  
;SELECT (SELECT * FROM t0 ORDER BY c0, c0 DESC) == (SELECT * FROM t0 ORDER BY c0, c0 DESC)
  
;SELECT (3, 6) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
  
;SELECT ((3, 5)) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (SELECT 3, 5) == (SELECT c0,c0 FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT * FROM t0 ORDER BY c0 DESC, c0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (2, 2) BETWEEN (2, 2) AND (3, 3)
;SELECT (2, 2) BETWEEN (2, NULL) AND (3, 3)
;SELECT (NULL, 4) IN (SELECT * FROM v0)
;SELECT (NULL, 4) NOT IN (SELECT * FROM v0)
;CREATE TABLE preceding(t1, x, test001);;INSERT INTO preceding VALUES('abc', 1, 'i');;INSERT INTO v0 VALUES('def', 2, 'iii');;INSERT INTO v0 VALUES('ghi', 3, 'vi');;
;SELECT c0 FROM t0 WHERE c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE +c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE (c0 COLLATE nocase, c0) IS NOT (SELECT 'def', 2);;
;SELECT following FROM v0 WHERE (over, over) = (SELECT 2, 'def');;INSERT INTO v0 VALUES(3, 3, 3);SELECT * FROM t0 WHERE (c0, c0) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM v0 WHERE (following, following) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;CREATE TABLE last_field(test002);;INSERT INTO last_field VALUES(3, 3, 3);;INSERT INTO last_field VALUES(4, 4, 4);;INSERT INTO t0 VALUES(5, 5, 5);SELECT following FROM v0 WHERE (over, following) > (2, 2)
;SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 96
parser: Return. Stack=[SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[SELECT distinct selcollist from WHERE]
parser: Input 'LP' in state 93
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP nexprlist COMMA INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP nexprlist COMMA term RP]
parser: Input 'LT' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'LT', go to state 118
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LT]
parser: Input 'LP' in state 118
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LT LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LT LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LT LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LT LP nexprlist COMMA INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LT LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LT LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LT LP nexprlist COMMA term RP]
parser: Input 'SEMI' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 118.
parser: ... then shift 'expr', go to state 130
parser: Reduce 181 [expr ::= expr LT|GT|GE|LE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT * FROM t0 WHERE NOT (1, 3, 3) < (1, 2, 3)
;SELECT (1, 3, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) <= (1, 2, 3)
;SELECT (1, 3, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) < (1, 2, 3)
;SELECT (1, NULL, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, 2, 3)
;SELECT (1, NULL, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, 2, 3)
;SELECT (1, 3, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) < (1, NULL, 3)
;SELECT (1, 3, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) > (1, NULL, 3)
;SELECT (1, 3, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) <= (1, NULL, 3)
;SELECT (1, 3, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) >= (1, NULL, 3)
;SELECT (1, NULL, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) < (1, NULL, 3)
;SELECT (1, NULL, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) > (1, NULL, 3)
;SELECT (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, NULL, 3)
;SELECT (1, NULL, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, NULL, 3)
;CREATE TABLE v0(over, following);;INSERT INTO t0 VALUES(3, 5);;INSERT INTO v0 VALUES(3, 6);SELECT (1, 1) == (SELECT c0,c0 FROM t0 ORDER BY c0, c0)
;SELECT (1, 1) == (SELECT * FROM t0 ORDER BY c0, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0, c0)
  
;SELECT (SELECT * FROM t0 ORDER BY c0, c0 DESC) == (SELECT * FROM t0 ORDER BY c0, c0 DESC)
  
;SELECT (3, 6) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
  
;SELECT ((3, 5)) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (SELECT 3, 5) == (SELECT c0,c0 FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT * FROM t0 ORDER BY c0 DESC, c0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (2, 2) BETWEEN (2, 2) AND (3, 3)
;SELECT (2, 2) BETWEEN (2, NULL) AND (3, 3)
;SELECT (NULL, 4) IN (SELECT * FROM v0)
;SELECT (NULL, 4) NOT IN (SELECT * FROM v0)
;CREATE TABLE preceding(t1, x, test001);;INSERT INTO preceding VALUES('abc', 1, 'i');;INSERT INTO v0 VALUES('def', 2, 'iii');;INSERT INTO v0 VALUES('ghi', 3, 'vi');;
;SELECT c0 FROM t0 WHERE c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE +c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE (c0 COLLATE nocase, c0) IS NOT (SELECT 'def', 2);;
;SELECT following FROM v0 WHERE (over, over) = (SELECT 2, 'def');;INSERT INTO v0 VALUES(3, 3, 3);SELECT * FROM t0 WHERE (c0, c0) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM v0 WHERE (following, following) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;CREATE TABLE last_field(test002);;INSERT INTO last_field VALUES(3, 3, 3);;INSERT INTO last_field VALUES(4, 4, 4);;INSERT INTO t0 VALUES(5, 5, 5);SELECT following FROM v0 WHERE (over, following) > (2, 2)
;SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 96
parser: Return. Stack=[SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[SELECT distinct selcollist from WHERE]
parser: Input 'NOT' in state 93
parser: Shift 'NOT', go to state 105
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT]
parser: Input 'LP' in state 105
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP nexprlist COMMA INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP nexprlist COMMA term RP]
parser: Input 'LT' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 105.
parser: ... then shift 'expr', go to state 75
parser: Shift 'LT', go to state 118
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr LT]
parser: Input 'LP' in state 118
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr LT LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr LT LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr LT LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr LT LP nexprlist COMMA INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr LT LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr LT LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr LT LP nexprlist COMMA term RP]
parser: Input 'SEMI' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 118.
parser: ... then shift 'expr', go to state 130
parser: Reduce 181 [expr ::= expr LT|GT|GE|LE expr], go to state 105.
parser: ... then shift 'expr', go to state 75
parser: Reduce 194 [expr ::= NOT expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT (1, 3, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) <= (1, 2, 3)
;SELECT (1, 3, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) < (1, 2, 3)
;SELECT (1, NULL, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, 2, 3)
;SELECT (1, NULL, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, 2, 3)
;SELECT (1, 3, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) < (1, NULL, 3)
;SELECT (1, 3, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) > (1, NULL, 3)
;SELECT (1, 3, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) <= (1, NULL, 3)
;SELECT (1, 3, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) >= (1, NULL, 3)
;SELECT (1, NULL, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) < (1, NULL, 3)
;SELECT (1, NULL, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) > (1, NULL, 3)
;SELECT (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, NULL, 3)
;SELECT (1, NULL, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, NULL, 3)
;CREATE TABLE v0(over, following);;INSERT INTO t0 VALUES(3, 5);;INSERT INTO v0 VALUES(3, 6);SELECT (1, 1) == (SELECT c0,c0 FROM t0 ORDER BY c0, c0)
;SELECT (1, 1) == (SELECT * FROM t0 ORDER BY c0, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0, c0)
  
;SELECT (SELECT * FROM t0 ORDER BY c0, c0 DESC) == (SELECT * FROM t0 ORDER BY c0, c0 DESC)
  
;SELECT (3, 6) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
  
;SELECT ((3, 5)) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (SELECT 3, 5) == (SELECT c0,c0 FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT * FROM t0 ORDER BY c0 DESC, c0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (2, 2) BETWEEN (2, 2) AND (3, 3)
;SELECT (2, 2) BETWEEN (2, NULL) AND (3, 3)
;SELECT (NULL, 4) IN (SELECT * FROM v0)
;SELECT (NULL, 4) NOT IN (SELECT * FROM v0)
;CREATE TABLE preceding(t1, x, test001);;INSERT INTO preceding VALUES('abc', 1, 'i');;INSERT INTO v0 VALUES('def', 2, 'iii');;INSERT INTO v0 VALUES('ghi', 3, 'vi');;
;SELECT c0 FROM t0 WHERE c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE +c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE (c0 COLLATE nocase, c0) IS NOT (SELECT 'def', 2);;
;SELECT following FROM v0 WHERE (over, over) = (SELECT 2, 'def');;INSERT INTO v0 VALUES(3, 3, 3);SELECT * FROM t0 WHERE (c0, c0) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM v0 WHERE (following, following) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;CREATE TABLE last_field(test002);;INSERT INTO last_field VALUES(3, 3, 3);;INSERT INTO last_field VALUES(4, 4, 4);;INSERT INTO t0 VALUES(5, 5, 5);SELECT following FROM v0 WHERE (over, following) > (2, 2)
;SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'LP' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct sclp scanpt LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA term RP]
parser: Input 'GT' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Shift 'GT', go to state 118
parser: Return. Stack=[SELECT distinct sclp scanpt expr GT]
parser: Input 'LP' in state 118
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct sclp scanpt expr GT LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt expr GT LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt expr GT LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt expr GT LP nexprlist COMMA INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt expr GT LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt expr GT LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct sclp scanpt expr GT LP nexprlist COMMA term RP]
parser: Input 'SEMI' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 118.
parser: ... then shift 'expr', go to state 130
parser: Reduce 181 [expr ::= expr LT|GT|GE|LE expr], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Reduce 100 [from ::=].
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT * FROM t0 WHERE (1, 3, 3) <= (1, 2, 3)
;SELECT (1, 3, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) < (1, 2, 3)
;SELECT (1, NULL, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, 2, 3)
;SELECT (1, NULL, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, 2, 3)
;SELECT (1, 3, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) < (1, NULL, 3)
;SELECT (1, 3, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) > (1, NULL, 3)
;SELECT (1, 3, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) <= (1, NULL, 3)
;SELECT (1, 3, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) >= (1, NULL, 3)
;SELECT (1, NULL, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) < (1, NULL, 3)
;SELECT (1, NULL, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) > (1, NULL, 3)
;SELECT (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, NULL, 3)
;SELECT (1, NULL, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, NULL, 3)
;CREATE TABLE v0(over, following);;INSERT INTO t0 VALUES(3, 5);;INSERT INTO v0 VALUES(3, 6);SELECT (1, 1) == (SELECT c0,c0 FROM t0 ORDER BY c0, c0)
;SELECT (1, 1) == (SELECT * FROM t0 ORDER BY c0, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0, c0)
  
;SELECT (SELECT * FROM t0 ORDER BY c0, c0 DESC) == (SELECT * FROM t0 ORDER BY c0, c0 DESC)
  
;SELECT (3, 6) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
  
;SELECT ((3, 5)) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (SELECT 3, 5) == (SELECT c0,c0 FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT * FROM t0 ORDER BY c0 DESC, c0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (2, 2) BETWEEN (2, 2) AND (3, 3)
;SELECT (2, 2) BETWEEN (2, NULL) AND (3, 3)
;SELECT (NULL, 4) IN (SELECT * FROM v0)
;SELECT (NULL, 4) NOT IN (SELECT * FROM v0)
;CREATE TABLE preceding(t1, x, test001);;INSERT INTO preceding VALUES('abc', 1, 'i');;INSERT INTO v0 VALUES('def', 2, 'iii');;INSERT INTO v0 VALUES('ghi', 3, 'vi');;
;SELECT c0 FROM t0 WHERE c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE +c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE (c0 COLLATE nocase, c0) IS NOT (SELECT 'def', 2);;
;SELECT following FROM v0 WHERE (over, over) = (SELECT 2, 'def');;INSERT INTO v0 VALUES(3, 3, 3);SELECT * FROM t0 WHERE (c0, c0) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM v0 WHERE (following, following) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;CREATE TABLE last_field(test002);;INSERT INTO last_field VALUES(3, 3, 3);;INSERT INTO last_field VALUES(4, 4, 4);;INSERT INTO t0 VALUES(5, 5, 5);SELECT following FROM v0 WHERE (over, following) > (2, 2)
;SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 96
parser: Return. Stack=[SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[SELECT distinct selcollist from WHERE]
parser: Input 'LP' in state 93
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP nexprlist COMMA INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP nexprlist COMMA term RP]
parser: Input 'LE' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'LE', go to state 118
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LE]
parser: Input 'LP' in state 118
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LE LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LE LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LE LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LE LP nexprlist COMMA INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LE LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LE LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LE LP nexprlist COMMA term RP]
parser: Input 'SEMI' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 118.
parser: ... then shift 'expr', go to state 130
parser: Reduce 181 [expr ::= expr LT|GT|GE|LE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT (1, 3, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) < (1, 2, 3)
;SELECT (1, NULL, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, 2, 3)
;SELECT (1, NULL, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, 2, 3)
;SELECT (1, 3, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) < (1, NULL, 3)
;SELECT (1, 3, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) > (1, NULL, 3)
;SELECT (1, 3, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) <= (1, NULL, 3)
;SELECT (1, 3, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) >= (1, NULL, 3)
;SELECT (1, NULL, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) < (1, NULL, 3)
;SELECT (1, NULL, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) > (1, NULL, 3)
;SELECT (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, NULL, 3)
;SELECT (1, NULL, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, NULL, 3)
;CREATE TABLE v0(over, following);;INSERT INTO t0 VALUES(3, 5);;INSERT INTO v0 VALUES(3, 6);SELECT (1, 1) == (SELECT c0,c0 FROM t0 ORDER BY c0, c0)
;SELECT (1, 1) == (SELECT * FROM t0 ORDER BY c0, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0, c0)
  
;SELECT (SELECT * FROM t0 ORDER BY c0, c0 DESC) == (SELECT * FROM t0 ORDER BY c0, c0 DESC)
  
;SELECT (3, 6) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
  
;SELECT ((3, 5)) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (SELECT 3, 5) == (SELECT c0,c0 FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT * FROM t0 ORDER BY c0 DESC, c0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (2, 2) BETWEEN (2, 2) AND (3, 3)
;SELECT (2, 2) BETWEEN (2, NULL) AND (3, 3)
;SELECT (NULL, 4) IN (SELECT * FROM v0)
;SELECT (NULL, 4) NOT IN (SELECT * FROM v0)
;CREATE TABLE preceding(t1, x, test001);;INSERT INTO preceding VALUES('abc', 1, 'i');;INSERT INTO v0 VALUES('def', 2, 'iii');;INSERT INTO v0 VALUES('ghi', 3, 'vi');;
;SELECT c0 FROM t0 WHERE c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE +c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE (c0 COLLATE nocase, c0) IS NOT (SELECT 'def', 2);;
;SELECT following FROM v0 WHERE (over, over) = (SELECT 2, 'def');;INSERT INTO v0 VALUES(3, 3, 3);SELECT * FROM t0 WHERE (c0, c0) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM v0 WHERE (following, following) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;CREATE TABLE last_field(test002);;INSERT INTO last_field VALUES(3, 3, 3);;INSERT INTO last_field VALUES(4, 4, 4);;INSERT INTO t0 VALUES(5, 5, 5);SELECT following FROM v0 WHERE (over, following) > (2, 2)
;SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'LP' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct sclp scanpt LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA term RP]
parser: Input 'GE' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Shift 'GE', go to state 118
parser: Return. Stack=[SELECT distinct sclp scanpt expr GE]
parser: Input 'LP' in state 118
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct sclp scanpt expr GE LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt expr GE LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt expr GE LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt expr GE LP nexprlist COMMA INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt expr GE LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt expr GE LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct sclp scanpt expr GE LP nexprlist COMMA term RP]
parser: Input 'SEMI' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 118.
parser: ... then shift 'expr', go to state 130
parser: Reduce 181 [expr ::= expr LT|GT|GE|LE expr], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Reduce 100 [from ::=].
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT * FROM t0 WHERE (1, NULL, 3) < (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) < (1, 2, 3)
;SELECT (1, NULL, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, 2, 3)
;SELECT (1, NULL, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, 2, 3)
;SELECT (1, 3, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) < (1, NULL, 3)
;SELECT (1, 3, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) > (1, NULL, 3)
;SELECT (1, 3, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) <= (1, NULL, 3)
;SELECT (1, 3, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) >= (1, NULL, 3)
;SELECT (1, NULL, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) < (1, NULL, 3)
;SELECT (1, NULL, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) > (1, NULL, 3)
;SELECT (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, NULL, 3)
;SELECT (1, NULL, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, NULL, 3)
;CREATE TABLE v0(over, following);;INSERT INTO t0 VALUES(3, 5);;INSERT INTO v0 VALUES(3, 6);SELECT (1, 1) == (SELECT c0,c0 FROM t0 ORDER BY c0, c0)
;SELECT (1, 1) == (SELECT * FROM t0 ORDER BY c0, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0, c0)
  
;SELECT (SELECT * FROM t0 ORDER BY c0, c0 DESC) == (SELECT * FROM t0 ORDER BY c0, c0 DESC)
  
;SELECT (3, 6) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
  
;SELECT ((3, 5)) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (SELECT 3, 5) == (SELECT c0,c0 FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT * FROM t0 ORDER BY c0 DESC, c0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (2, 2) BETWEEN (2, 2) AND (3, 3)
;SELECT (2, 2) BETWEEN (2, NULL) AND (3, 3)
;SELECT (NULL, 4) IN (SELECT * FROM v0)
;SELECT (NULL, 4) NOT IN (SELECT * FROM v0)
;CREATE TABLE preceding(t1, x, test001);;INSERT INTO preceding VALUES('abc', 1, 'i');;INSERT INTO v0 VALUES('def', 2, 'iii');;INSERT INTO v0 VALUES('ghi', 3, 'vi');;
;SELECT c0 FROM t0 WHERE c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE +c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE (c0 COLLATE nocase, c0) IS NOT (SELECT 'def', 2);;
;SELECT following FROM v0 WHERE (over, over) = (SELECT 2, 'def');;INSERT INTO v0 VALUES(3, 3, 3);SELECT * FROM t0 WHERE (c0, c0) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM v0 WHERE (following, following) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;CREATE TABLE last_field(test002);;INSERT INTO last_field VALUES(3, 3, 3);;INSERT INTO last_field VALUES(4, 4, 4);;INSERT INTO t0 VALUES(5, 5, 5);SELECT following FROM v0 WHERE (over, following) > (2, 2)
;SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 96
parser: Return. Stack=[SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[SELECT distinct selcollist from WHERE]
parser: Input 'LP' in state 93
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP nexprlist COMMA]
parser: Input 'NULL' in state 91
parser: Shift 'NULL', pending reduce 167
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP nexprlist COMMA NULL]
parser: Input 'COMMA' with pending reduce 167
parser: Reduce 167 [term ::= NULL|FLOAT|BLOB], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP nexprlist COMMA term RP]
parser: Input 'LT' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'LT', go to state 118
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LT]
parser: Input 'LP' in state 118
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LT LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LT LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LT LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LT LP nexprlist COMMA INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LT LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LT LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LT LP nexprlist COMMA term RP]
parser: Input 'SEMI' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 118.
parser: ... then shift 'expr', go to state 130
parser: Reduce 181 [expr ::= expr LT|GT|GE|LE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT * FROM t0 WHERE NOT (1, NULL, 3) < (1, 2, 3)
;SELECT (1, NULL, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, 2, 3)
;SELECT (1, NULL, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, 2, 3)
;SELECT (1, 3, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) < (1, NULL, 3)
;SELECT (1, 3, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) > (1, NULL, 3)
;SELECT (1, 3, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) <= (1, NULL, 3)
;SELECT (1, 3, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) >= (1, NULL, 3)
;SELECT (1, NULL, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) < (1, NULL, 3)
;SELECT (1, NULL, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) > (1, NULL, 3)
;SELECT (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, NULL, 3)
;SELECT (1, NULL, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, NULL, 3)
;CREATE TABLE v0(over, following);;INSERT INTO t0 VALUES(3, 5);;INSERT INTO v0 VALUES(3, 6);SELECT (1, 1) == (SELECT c0,c0 FROM t0 ORDER BY c0, c0)
;SELECT (1, 1) == (SELECT * FROM t0 ORDER BY c0, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0, c0)
  
;SELECT (SELECT * FROM t0 ORDER BY c0, c0 DESC) == (SELECT * FROM t0 ORDER BY c0, c0 DESC)
  
;SELECT (3, 6) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
  
;SELECT ((3, 5)) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (SELECT 3, 5) == (SELECT c0,c0 FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT * FROM t0 ORDER BY c0 DESC, c0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (2, 2) BETWEEN (2, 2) AND (3, 3)
;SELECT (2, 2) BETWEEN (2, NULL) AND (3, 3)
;SELECT (NULL, 4) IN (SELECT * FROM v0)
;SELECT (NULL, 4) NOT IN (SELECT * FROM v0)
;CREATE TABLE preceding(t1, x, test001);;INSERT INTO preceding VALUES('abc', 1, 'i');;INSERT INTO v0 VALUES('def', 2, 'iii');;INSERT INTO v0 VALUES('ghi', 3, 'vi');;
;SELECT c0 FROM t0 WHERE c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE +c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE (c0 COLLATE nocase, c0) IS NOT (SELECT 'def', 2);;
;SELECT following FROM v0 WHERE (over, over) = (SELECT 2, 'def');;INSERT INTO v0 VALUES(3, 3, 3);SELECT * FROM t0 WHERE (c0, c0) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM v0 WHERE (following, following) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;CREATE TABLE last_field(test002);;INSERT INTO last_field VALUES(3, 3, 3);;INSERT INTO last_field VALUES(4, 4, 4);;INSERT INTO t0 VALUES(5, 5, 5);SELECT following FROM v0 WHERE (over, following) > (2, 2)
;SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 96
parser: Return. Stack=[SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[SELECT distinct selcollist from WHERE]
parser: Input 'NOT' in state 93
parser: Shift 'NOT', go to state 105
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT]
parser: Input 'LP' in state 105
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP nexprlist COMMA]
parser: Input 'NULL' in state 91
parser: Shift 'NULL', pending reduce 167
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP nexprlist COMMA NULL]
parser: Input 'COMMA' with pending reduce 167
parser: Reduce 167 [term ::= NULL|FLOAT|BLOB], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP nexprlist COMMA term RP]
parser: Input 'LT' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 105.
parser: ... then shift 'expr', go to state 75
parser: Shift 'LT', go to state 118
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr LT]
parser: Input 'LP' in state 118
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr LT LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr LT LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr LT LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr LT LP nexprlist COMMA INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr LT LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr LT LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr LT LP nexprlist COMMA term RP]
parser: Input 'SEMI' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 118.
parser: ... then shift 'expr', go to state 130
parser: Reduce 181 [expr ::= expr LT|GT|GE|LE expr], go to state 105.
parser: ... then shift 'expr', go to state 75
parser: Reduce 194 [expr ::= NOT expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT (1, NULL, 3) > (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, 2, 3)
;SELECT (1, NULL, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, 2, 3)
;SELECT (1, 3, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) < (1, NULL, 3)
;SELECT (1, 3, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) > (1, NULL, 3)
;SELECT (1, 3, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) <= (1, NULL, 3)
;SELECT (1, 3, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) >= (1, NULL, 3)
;SELECT (1, NULL, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) < (1, NULL, 3)
;SELECT (1, NULL, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) > (1, NULL, 3)
;SELECT (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, NULL, 3)
;SELECT (1, NULL, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, NULL, 3)
;CREATE TABLE v0(over, following);;INSERT INTO t0 VALUES(3, 5);;INSERT INTO v0 VALUES(3, 6);SELECT (1, 1) == (SELECT c0,c0 FROM t0 ORDER BY c0, c0)
;SELECT (1, 1) == (SELECT * FROM t0 ORDER BY c0, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0, c0)
  
;SELECT (SELECT * FROM t0 ORDER BY c0, c0 DESC) == (SELECT * FROM t0 ORDER BY c0, c0 DESC)
  
;SELECT (3, 6) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
  
;SELECT ((3, 5)) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (SELECT 3, 5) == (SELECT c0,c0 FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT * FROM t0 ORDER BY c0 DESC, c0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (2, 2) BETWEEN (2, 2) AND (3, 3)
;SELECT (2, 2) BETWEEN (2, NULL) AND (3, 3)
;SELECT (NULL, 4) IN (SELECT * FROM v0)
;SELECT (NULL, 4) NOT IN (SELECT * FROM v0)
;CREATE TABLE preceding(t1, x, test001);;INSERT INTO preceding VALUES('abc', 1, 'i');;INSERT INTO v0 VALUES('def', 2, 'iii');;INSERT INTO v0 VALUES('ghi', 3, 'vi');;
;SELECT c0 FROM t0 WHERE c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE +c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE (c0 COLLATE nocase, c0) IS NOT (SELECT 'def', 2);;
;SELECT following FROM v0 WHERE (over, over) = (SELECT 2, 'def');;INSERT INTO v0 VALUES(3, 3, 3);SELECT * FROM t0 WHERE (c0, c0) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM v0 WHERE (following, following) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;CREATE TABLE last_field(test002);;INSERT INTO last_field VALUES(3, 3, 3);;INSERT INTO last_field VALUES(4, 4, 4);;INSERT INTO t0 VALUES(5, 5, 5);SELECT following FROM v0 WHERE (over, following) > (2, 2)
;SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'LP' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct sclp scanpt LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA]
parser: Input 'NULL' in state 91
parser: Shift 'NULL', pending reduce 167
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA NULL]
parser: Input 'COMMA' with pending reduce 167
parser: Reduce 167 [term ::= NULL|FLOAT|BLOB], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA term RP]
parser: Input 'GT' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Shift 'GT', go to state 118
parser: Return. Stack=[SELECT distinct sclp scanpt expr GT]
parser: Input 'LP' in state 118
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct sclp scanpt expr GT LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt expr GT LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt expr GT LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt expr GT LP nexprlist COMMA INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt expr GT LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt expr GT LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct sclp scanpt expr GT LP nexprlist COMMA term RP]
parser: Input 'SEMI' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 118.
parser: ... then shift 'expr', go to state 130
parser: Reduce 181 [expr ::= expr LT|GT|GE|LE expr], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Reduce 100 [from ::=].
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, 2, 3)
;SELECT (1, NULL, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, 2, 3)
;SELECT (1, 3, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) < (1, NULL, 3)
;SELECT (1, 3, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) > (1, NULL, 3)
;SELECT (1, 3, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) <= (1, NULL, 3)
;SELECT (1, 3, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) >= (1, NULL, 3)
;SELECT (1, NULL, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) < (1, NULL, 3)
;SELECT (1, NULL, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) > (1, NULL, 3)
;SELECT (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, NULL, 3)
;SELECT (1, NULL, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, NULL, 3)
;CREATE TABLE v0(over, following);;INSERT INTO t0 VALUES(3, 5);;INSERT INTO v0 VALUES(3, 6);SELECT (1, 1) == (SELECT c0,c0 FROM t0 ORDER BY c0, c0)
;SELECT (1, 1) == (SELECT * FROM t0 ORDER BY c0, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0, c0)
  
;SELECT (SELECT * FROM t0 ORDER BY c0, c0 DESC) == (SELECT * FROM t0 ORDER BY c0, c0 DESC)
  
;SELECT (3, 6) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
  
;SELECT ((3, 5)) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (SELECT 3, 5) == (SELECT c0,c0 FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT * FROM t0 ORDER BY c0 DESC, c0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (2, 2) BETWEEN (2, 2) AND (3, 3)
;SELECT (2, 2) BETWEEN (2, NULL) AND (3, 3)
;SELECT (NULL, 4) IN (SELECT * FROM v0)
;SELECT (NULL, 4) NOT IN (SELECT * FROM v0)
;CREATE TABLE preceding(t1, x, test001);;INSERT INTO preceding VALUES('abc', 1, 'i');;INSERT INTO v0 VALUES('def', 2, 'iii');;INSERT INTO v0 VALUES('ghi', 3, 'vi');;
;SELECT c0 FROM t0 WHERE c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE +c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE (c0 COLLATE nocase, c0) IS NOT (SELECT 'def', 2);;
;SELECT following FROM v0 WHERE (over, over) = (SELECT 2, 'def');;INSERT INTO v0 VALUES(3, 3, 3);SELECT * FROM t0 WHERE (c0, c0) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM v0 WHERE (following, following) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;CREATE TABLE last_field(test002);;INSERT INTO last_field VALUES(3, 3, 3);;INSERT INTO last_field VALUES(4, 4, 4);;INSERT INTO t0 VALUES(5, 5, 5);SELECT following FROM v0 WHERE (over, following) > (2, 2)
;SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 96
parser: Return. Stack=[SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[SELECT distinct selcollist from WHERE]
parser: Input 'LP' in state 93
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP nexprlist COMMA]
parser: Input 'NULL' in state 91
parser: Shift 'NULL', pending reduce 167
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP nexprlist COMMA NULL]
parser: Input 'COMMA' with pending reduce 167
parser: Reduce 167 [term ::= NULL|FLOAT|BLOB], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP nexprlist COMMA term RP]
parser: Input 'LE' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'LE', go to state 118
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LE]
parser: Input 'LP' in state 118
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LE LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LE LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LE LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LE LP nexprlist COMMA INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LE LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LE LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LE LP nexprlist COMMA term RP]
parser: Input 'SEMI' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 118.
parser: ... then shift 'expr', go to state 130
parser: Reduce 181 [expr ::= expr LT|GT|GE|LE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, 2, 3)
;SELECT (1, NULL, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, 2, 3)
;SELECT (1, 3, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) < (1, NULL, 3)
;SELECT (1, 3, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) > (1, NULL, 3)
;SELECT (1, 3, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) <= (1, NULL, 3)
;SELECT (1, 3, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) >= (1, NULL, 3)
;SELECT (1, NULL, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) < (1, NULL, 3)
;SELECT (1, NULL, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) > (1, NULL, 3)
;SELECT (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, NULL, 3)
;SELECT (1, NULL, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, NULL, 3)
;CREATE TABLE v0(over, following);;INSERT INTO t0 VALUES(3, 5);;INSERT INTO v0 VALUES(3, 6);SELECT (1, 1) == (SELECT c0,c0 FROM t0 ORDER BY c0, c0)
;SELECT (1, 1) == (SELECT * FROM t0 ORDER BY c0, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0, c0)
  
;SELECT (SELECT * FROM t0 ORDER BY c0, c0 DESC) == (SELECT * FROM t0 ORDER BY c0, c0 DESC)
  
;SELECT (3, 6) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
  
;SELECT ((3, 5)) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (SELECT 3, 5) == (SELECT c0,c0 FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT * FROM t0 ORDER BY c0 DESC, c0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (2, 2) BETWEEN (2, 2) AND (3, 3)
;SELECT (2, 2) BETWEEN (2, NULL) AND (3, 3)
;SELECT (NULL, 4) IN (SELECT * FROM v0)
;SELECT (NULL, 4) NOT IN (SELECT * FROM v0)
;CREATE TABLE preceding(t1, x, test001);;INSERT INTO preceding VALUES('abc', 1, 'i');;INSERT INTO v0 VALUES('def', 2, 'iii');;INSERT INTO v0 VALUES('ghi', 3, 'vi');;
;SELECT c0 FROM t0 WHERE c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE +c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE (c0 COLLATE nocase, c0) IS NOT (SELECT 'def', 2);;
;SELECT following FROM v0 WHERE (over, over) = (SELECT 2, 'def');;INSERT INTO v0 VALUES(3, 3, 3);SELECT * FROM t0 WHERE (c0, c0) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM v0 WHERE (following, following) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;CREATE TABLE last_field(test002);;INSERT INTO last_field VALUES(3, 3, 3);;INSERT INTO last_field VALUES(4, 4, 4);;INSERT INTO t0 VALUES(5, 5, 5);SELECT following FROM v0 WHERE (over, following) > (2, 2)
;SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 96
parser: Return. Stack=[SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[SELECT distinct selcollist from WHERE]
parser: Input 'NOT' in state 93
parser: Shift 'NOT', go to state 105
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT]
parser: Input 'LP' in state 105
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP nexprlist COMMA]
parser: Input 'NULL' in state 91
parser: Shift 'NULL', pending reduce 167
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP nexprlist COMMA NULL]
parser: Input 'COMMA' with pending reduce 167
parser: Reduce 167 [term ::= NULL|FLOAT|BLOB], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP nexprlist COMMA term RP]
parser: Input 'LE' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 105.
parser: ... then shift 'expr', go to state 75
parser: Shift 'LE', go to state 118
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr LE]
parser: Input 'LP' in state 118
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr LE LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr LE LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr LE LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr LE LP nexprlist COMMA INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr LE LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr LE LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr LE LP nexprlist COMMA term RP]
parser: Input 'SEMI' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 118.
parser: ... then shift 'expr', go to state 130
parser: Reduce 181 [expr ::= expr LT|GT|GE|LE expr], go to state 105.
parser: ... then shift 'expr', go to state 75
parser: Reduce 194 [expr ::= NOT expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT (1, NULL, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, 2, 3)
;SELECT (1, 3, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) < (1, NULL, 3)
;SELECT (1, 3, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) > (1, NULL, 3)
;SELECT (1, 3, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) <= (1, NULL, 3)
;SELECT (1, 3, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) >= (1, NULL, 3)
;SELECT (1, NULL, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) < (1, NULL, 3)
;SELECT (1, NULL, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) > (1, NULL, 3)
;SELECT (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, NULL, 3)
;SELECT (1, NULL, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, NULL, 3)
;CREATE TABLE v0(over, following);;INSERT INTO t0 VALUES(3, 5);;INSERT INTO v0 VALUES(3, 6);SELECT (1, 1) == (SELECT c0,c0 FROM t0 ORDER BY c0, c0)
;SELECT (1, 1) == (SELECT * FROM t0 ORDER BY c0, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0, c0)
  
;SELECT (SELECT * FROM t0 ORDER BY c0, c0 DESC) == (SELECT * FROM t0 ORDER BY c0, c0 DESC)
  
;SELECT (3, 6) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
  
;SELECT ((3, 5)) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (SELECT 3, 5) == (SELECT c0,c0 FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT * FROM t0 ORDER BY c0 DESC, c0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (2, 2) BETWEEN (2, 2) AND (3, 3)
;SELECT (2, 2) BETWEEN (2, NULL) AND (3, 3)
;SELECT (NULL, 4) IN (SELECT * FROM v0)
;SELECT (NULL, 4) NOT IN (SELECT * FROM v0)
;CREATE TABLE preceding(t1, x, test001);;INSERT INTO preceding VALUES('abc', 1, 'i');;INSERT INTO v0 VALUES('def', 2, 'iii');;INSERT INTO v0 VALUES('ghi', 3, 'vi');;
;SELECT c0 FROM t0 WHERE c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE +c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE (c0 COLLATE nocase, c0) IS NOT (SELECT 'def', 2);;
;SELECT following FROM v0 WHERE (over, over) = (SELECT 2, 'def');;INSERT INTO v0 VALUES(3, 3, 3);SELECT * FROM t0 WHERE (c0, c0) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM v0 WHERE (following, following) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;CREATE TABLE last_field(test002);;INSERT INTO last_field VALUES(3, 3, 3);;INSERT INTO last_field VALUES(4, 4, 4);;INSERT INTO t0 VALUES(5, 5, 5);SELECT following FROM v0 WHERE (over, following) > (2, 2)
;SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'LP' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct sclp scanpt LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA]
parser: Input 'NULL' in state 91
parser: Shift 'NULL', pending reduce 167
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA NULL]
parser: Input 'COMMA' with pending reduce 167
parser: Reduce 167 [term ::= NULL|FLOAT|BLOB], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA term RP]
parser: Input 'GE' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Shift 'GE', go to state 118
parser: Return. Stack=[SELECT distinct sclp scanpt expr GE]
parser: Input 'LP' in state 118
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct sclp scanpt expr GE LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt expr GE LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt expr GE LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt expr GE LP nexprlist COMMA INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt expr GE LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt expr GE LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct sclp scanpt expr GE LP nexprlist COMMA term RP]
parser: Input 'SEMI' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 118.
parser: ... then shift 'expr', go to state 130
parser: Reduce 181 [expr ::= expr LT|GT|GE|LE expr], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Reduce 100 [from ::=].
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT * FROM t0 WHERE (1, NULL, 3) >= (1, 2, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, 2, 3)
;SELECT (1, 3, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) < (1, NULL, 3)
;SELECT (1, 3, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) > (1, NULL, 3)
;SELECT (1, 3, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) <= (1, NULL, 3)
;SELECT (1, 3, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) >= (1, NULL, 3)
;SELECT (1, NULL, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) < (1, NULL, 3)
;SELECT (1, NULL, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) > (1, NULL, 3)
;SELECT (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, NULL, 3)
;SELECT (1, NULL, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, NULL, 3)
;CREATE TABLE v0(over, following);;INSERT INTO t0 VALUES(3, 5);;INSERT INTO v0 VALUES(3, 6);SELECT (1, 1) == (SELECT c0,c0 FROM t0 ORDER BY c0, c0)
;SELECT (1, 1) == (SELECT * FROM t0 ORDER BY c0, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0, c0)
  
;SELECT (SELECT * FROM t0 ORDER BY c0, c0 DESC) == (SELECT * FROM t0 ORDER BY c0, c0 DESC)
  
;SELECT (3, 6) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
  
;SELECT ((3, 5)) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (SELECT 3, 5) == (SELECT c0,c0 FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT * FROM t0 ORDER BY c0 DESC, c0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (2, 2) BETWEEN (2, 2) AND (3, 3)
;SELECT (2, 2) BETWEEN (2, NULL) AND (3, 3)
;SELECT (NULL, 4) IN (SELECT * FROM v0)
;SELECT (NULL, 4) NOT IN (SELECT * FROM v0)
;CREATE TABLE preceding(t1, x, test001);;INSERT INTO preceding VALUES('abc', 1, 'i');;INSERT INTO v0 VALUES('def', 2, 'iii');;INSERT INTO v0 VALUES('ghi', 3, 'vi');;
;SELECT c0 FROM t0 WHERE c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE +c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE (c0 COLLATE nocase, c0) IS NOT (SELECT 'def', 2);;
;SELECT following FROM v0 WHERE (over, over) = (SELECT 2, 'def');;INSERT INTO v0 VALUES(3, 3, 3);SELECT * FROM t0 WHERE (c0, c0) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM v0 WHERE (following, following) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;CREATE TABLE last_field(test002);;INSERT INTO last_field VALUES(3, 3, 3);;INSERT INTO last_field VALUES(4, 4, 4);;INSERT INTO t0 VALUES(5, 5, 5);SELECT following FROM v0 WHERE (over, following) > (2, 2)
;SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 96
parser: Return. Stack=[SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[SELECT distinct selcollist from WHERE]
parser: Input 'LP' in state 93
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP nexprlist COMMA]
parser: Input 'NULL' in state 91
parser: Shift 'NULL', pending reduce 167
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP nexprlist COMMA NULL]
parser: Input 'COMMA' with pending reduce 167
parser: Reduce 167 [term ::= NULL|FLOAT|BLOB], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP nexprlist COMMA term RP]
parser: Input 'GE' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'GE', go to state 118
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr GE]
parser: Input 'LP' in state 118
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr GE LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr GE LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr GE LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr GE LP nexprlist COMMA INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr GE LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr GE LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr GE LP nexprlist COMMA term RP]
parser: Input 'SEMI' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 118.
parser: ... then shift 'expr', go to state 130
parser: Reduce 181 [expr ::= expr LT|GT|GE|LE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, 2, 3)
;SELECT (1, 3, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) < (1, NULL, 3)
;SELECT (1, 3, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) > (1, NULL, 3)
;SELECT (1, 3, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) <= (1, NULL, 3)
;SELECT (1, 3, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) >= (1, NULL, 3)
;SELECT (1, NULL, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) < (1, NULL, 3)
;SELECT (1, NULL, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) > (1, NULL, 3)
;SELECT (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, NULL, 3)
;SELECT (1, NULL, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, NULL, 3)
;CREATE TABLE v0(over, following);;INSERT INTO t0 VALUES(3, 5);;INSERT INTO v0 VALUES(3, 6);SELECT (1, 1) == (SELECT c0,c0 FROM t0 ORDER BY c0, c0)
;SELECT (1, 1) == (SELECT * FROM t0 ORDER BY c0, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0, c0)
  
;SELECT (SELECT * FROM t0 ORDER BY c0, c0 DESC) == (SELECT * FROM t0 ORDER BY c0, c0 DESC)
  
;SELECT (3, 6) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
  
;SELECT ((3, 5)) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (SELECT 3, 5) == (SELECT c0,c0 FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT * FROM t0 ORDER BY c0 DESC, c0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (2, 2) BETWEEN (2, 2) AND (3, 3)
;SELECT (2, 2) BETWEEN (2, NULL) AND (3, 3)
;SELECT (NULL, 4) IN (SELECT * FROM v0)
;SELECT (NULL, 4) NOT IN (SELECT * FROM v0)
;CREATE TABLE preceding(t1, x, test001);;INSERT INTO preceding VALUES('abc', 1, 'i');;INSERT INTO v0 VALUES('def', 2, 'iii');;INSERT INTO v0 VALUES('ghi', 3, 'vi');;
;SELECT c0 FROM t0 WHERE c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE +c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE (c0 COLLATE nocase, c0) IS NOT (SELECT 'def', 2);;
;SELECT following FROM v0 WHERE (over, over) = (SELECT 2, 'def');;INSERT INTO v0 VALUES(3, 3, 3);SELECT * FROM t0 WHERE (c0, c0) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM v0 WHERE (following, following) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;CREATE TABLE last_field(test002);;INSERT INTO last_field VALUES(3, 3, 3);;INSERT INTO last_field VALUES(4, 4, 4);;INSERT INTO t0 VALUES(5, 5, 5);SELECT following FROM v0 WHERE (over, following) > (2, 2)
;SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 96
parser: Return. Stack=[SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[SELECT distinct selcollist from WHERE]
parser: Input 'NOT' in state 93
parser: Shift 'NOT', go to state 105
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT]
parser: Input 'LP' in state 105
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP nexprlist COMMA]
parser: Input 'NULL' in state 91
parser: Shift 'NULL', pending reduce 167
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP nexprlist COMMA NULL]
parser: Input 'COMMA' with pending reduce 167
parser: Reduce 167 [term ::= NULL|FLOAT|BLOB], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP nexprlist COMMA term RP]
parser: Input 'GE' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 105.
parser: ... then shift 'expr', go to state 75
parser: Shift 'GE', go to state 118
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr GE]
parser: Input 'LP' in state 118
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr GE LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr GE LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr GE LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr GE LP nexprlist COMMA INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr GE LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr GE LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr GE LP nexprlist COMMA term RP]
parser: Input 'SEMI' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 118.
parser: ... then shift 'expr', go to state 130
parser: Reduce 181 [expr ::= expr LT|GT|GE|LE expr], go to state 105.
parser: ... then shift 'expr', go to state 75
parser: Reduce 194 [expr ::= NOT expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT (1, 3, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) < (1, NULL, 3)
;SELECT (1, 3, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) > (1, NULL, 3)
;SELECT (1, 3, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) <= (1, NULL, 3)
;SELECT (1, 3, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) >= (1, NULL, 3)
;SELECT (1, NULL, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) < (1, NULL, 3)
;SELECT (1, NULL, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) > (1, NULL, 3)
;SELECT (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, NULL, 3)
;SELECT (1, NULL, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, NULL, 3)
;CREATE TABLE v0(over, following);;INSERT INTO t0 VALUES(3, 5);;INSERT INTO v0 VALUES(3, 6);SELECT (1, 1) == (SELECT c0,c0 FROM t0 ORDER BY c0, c0)
;SELECT (1, 1) == (SELECT * FROM t0 ORDER BY c0, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0, c0)
  
;SELECT (SELECT * FROM t0 ORDER BY c0, c0 DESC) == (SELECT * FROM t0 ORDER BY c0, c0 DESC)
  
;SELECT (3, 6) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
  
;SELECT ((3, 5)) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (SELECT 3, 5) == (SELECT c0,c0 FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT * FROM t0 ORDER BY c0 DESC, c0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (2, 2) BETWEEN (2, 2) AND (3, 3)
;SELECT (2, 2) BETWEEN (2, NULL) AND (3, 3)
;SELECT (NULL, 4) IN (SELECT * FROM v0)
;SELECT (NULL, 4) NOT IN (SELECT * FROM v0)
;CREATE TABLE preceding(t1, x, test001);;INSERT INTO preceding VALUES('abc', 1, 'i');;INSERT INTO v0 VALUES('def', 2, 'iii');;INSERT INTO v0 VALUES('ghi', 3, 'vi');;
;SELECT c0 FROM t0 WHERE c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE +c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE (c0 COLLATE nocase, c0) IS NOT (SELECT 'def', 2);;
;SELECT following FROM v0 WHERE (over, over) = (SELECT 2, 'def');;INSERT INTO v0 VALUES(3, 3, 3);SELECT * FROM t0 WHERE (c0, c0) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM v0 WHERE (following, following) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;CREATE TABLE last_field(test002);;INSERT INTO last_field VALUES(3, 3, 3);;INSERT INTO last_field VALUES(4, 4, 4);;INSERT INTO t0 VALUES(5, 5, 5);SELECT following FROM v0 WHERE (over, following) > (2, 2)
;SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'LP' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct sclp scanpt LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA term RP]
parser: Input 'LT' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Shift 'LT', go to state 118
parser: Return. Stack=[SELECT distinct sclp scanpt expr LT]
parser: Input 'LP' in state 118
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct sclp scanpt expr LT LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt expr LT LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt expr LT LP nexprlist COMMA]
parser: Input 'NULL' in state 91
parser: Shift 'NULL', pending reduce 167
parser: Return. Stack=[SELECT distinct sclp scanpt expr LT LP nexprlist COMMA NULL]
parser: Input 'COMMA' with pending reduce 167
parser: Reduce 167 [term ::= NULL|FLOAT|BLOB], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt expr LT LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt expr LT LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct sclp scanpt expr LT LP nexprlist COMMA term RP]
parser: Input 'SEMI' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 118.
parser: ... then shift 'expr', go to state 130
parser: Reduce 181 [expr ::= expr LT|GT|GE|LE expr], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Reduce 100 [from ::=].
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT * FROM t0 WHERE (1, 3, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) < (1, NULL, 3)
;SELECT (1, 3, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) > (1, NULL, 3)
;SELECT (1, 3, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) <= (1, NULL, 3)
;SELECT (1, 3, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) >= (1, NULL, 3)
;SELECT (1, NULL, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) < (1, NULL, 3)
;SELECT (1, NULL, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) > (1, NULL, 3)
;SELECT (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, NULL, 3)
;SELECT (1, NULL, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, NULL, 3)
;CREATE TABLE v0(over, following);;INSERT INTO t0 VALUES(3, 5);;INSERT INTO v0 VALUES(3, 6);SELECT (1, 1) == (SELECT c0,c0 FROM t0 ORDER BY c0, c0)
;SELECT (1, 1) == (SELECT * FROM t0 ORDER BY c0, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0, c0)
  
;SELECT (SELECT * FROM t0 ORDER BY c0, c0 DESC) == (SELECT * FROM t0 ORDER BY c0, c0 DESC)
  
;SELECT (3, 6) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
  
;SELECT ((3, 5)) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (SELECT 3, 5) == (SELECT c0,c0 FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT * FROM t0 ORDER BY c0 DESC, c0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (2, 2) BETWEEN (2, 2) AND (3, 3)
;SELECT (2, 2) BETWEEN (2, NULL) AND (3, 3)
;SELECT (NULL, 4) IN (SELECT * FROM v0)
;SELECT (NULL, 4) NOT IN (SELECT * FROM v0)
;CREATE TABLE preceding(t1, x, test001);;INSERT INTO preceding VALUES('abc', 1, 'i');;INSERT INTO v0 VALUES('def', 2, 'iii');;INSERT INTO v0 VALUES('ghi', 3, 'vi');;
;SELECT c0 FROM t0 WHERE c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE +c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE (c0 COLLATE nocase, c0) IS NOT (SELECT 'def', 2);;
;SELECT following FROM v0 WHERE (over, over) = (SELECT 2, 'def');;INSERT INTO v0 VALUES(3, 3, 3);SELECT * FROM t0 WHERE (c0, c0) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM v0 WHERE (following, following) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;CREATE TABLE last_field(test002);;INSERT INTO last_field VALUES(3, 3, 3);;INSERT INTO last_field VALUES(4, 4, 4);;INSERT INTO t0 VALUES(5, 5, 5);SELECT following FROM v0 WHERE (over, following) > (2, 2)
;SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 96
parser: Return. Stack=[SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[SELECT distinct selcollist from WHERE]
parser: Input 'LP' in state 93
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP nexprlist COMMA INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP nexprlist COMMA term RP]
parser: Input 'LT' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'LT', go to state 118
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LT]
parser: Input 'LP' in state 118
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LT LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LT LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LT LP nexprlist COMMA]
parser: Input 'NULL' in state 91
parser: Shift 'NULL', pending reduce 167
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LT LP nexprlist COMMA NULL]
parser: Input 'COMMA' with pending reduce 167
parser: Reduce 167 [term ::= NULL|FLOAT|BLOB], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LT LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LT LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LT LP nexprlist COMMA term RP]
parser: Input 'SEMI' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 118.
parser: ... then shift 'expr', go to state 130
parser: Reduce 181 [expr ::= expr LT|GT|GE|LE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT * FROM t0 WHERE NOT (1, 3, 3) < (1, NULL, 3)
;SELECT (1, 3, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) > (1, NULL, 3)
;SELECT (1, 3, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) <= (1, NULL, 3)
;SELECT (1, 3, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) >= (1, NULL, 3)
;SELECT (1, NULL, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) < (1, NULL, 3)
;SELECT (1, NULL, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) > (1, NULL, 3)
;SELECT (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, NULL, 3)
;SELECT (1, NULL, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, NULL, 3)
;CREATE TABLE v0(over, following);;INSERT INTO t0 VALUES(3, 5);;INSERT INTO v0 VALUES(3, 6);SELECT (1, 1) == (SELECT c0,c0 FROM t0 ORDER BY c0, c0)
;SELECT (1, 1) == (SELECT * FROM t0 ORDER BY c0, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0, c0)
  
;SELECT (SELECT * FROM t0 ORDER BY c0, c0 DESC) == (SELECT * FROM t0 ORDER BY c0, c0 DESC)
  
;SELECT (3, 6) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
  
;SELECT ((3, 5)) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (SELECT 3, 5) == (SELECT c0,c0 FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT * FROM t0 ORDER BY c0 DESC, c0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (2, 2) BETWEEN (2, 2) AND (3, 3)
;SELECT (2, 2) BETWEEN (2, NULL) AND (3, 3)
;SELECT (NULL, 4) IN (SELECT * FROM v0)
;SELECT (NULL, 4) NOT IN (SELECT * FROM v0)
;CREATE TABLE preceding(t1, x, test001);;INSERT INTO preceding VALUES('abc', 1, 'i');;INSERT INTO v0 VALUES('def', 2, 'iii');;INSERT INTO v0 VALUES('ghi', 3, 'vi');;
;SELECT c0 FROM t0 WHERE c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE +c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE (c0 COLLATE nocase, c0) IS NOT (SELECT 'def', 2);;
;SELECT following FROM v0 WHERE (over, over) = (SELECT 2, 'def');;INSERT INTO v0 VALUES(3, 3, 3);SELECT * FROM t0 WHERE (c0, c0) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM v0 WHERE (following, following) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;CREATE TABLE last_field(test002);;INSERT INTO last_field VALUES(3, 3, 3);;INSERT INTO last_field VALUES(4, 4, 4);;INSERT INTO t0 VALUES(5, 5, 5);SELECT following FROM v0 WHERE (over, following) > (2, 2)
;SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 96
parser: Return. Stack=[SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[SELECT distinct selcollist from WHERE]
parser: Input 'NOT' in state 93
parser: Shift 'NOT', go to state 105
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT]
parser: Input 'LP' in state 105
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP nexprlist COMMA INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP nexprlist COMMA term RP]
parser: Input 'LT' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 105.
parser: ... then shift 'expr', go to state 75
parser: Shift 'LT', go to state 118
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr LT]
parser: Input 'LP' in state 118
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr LT LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr LT LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr LT LP nexprlist COMMA]
parser: Input 'NULL' in state 91
parser: Shift 'NULL', pending reduce 167
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr LT LP nexprlist COMMA NULL]
parser: Input 'COMMA' with pending reduce 167
parser: Reduce 167 [term ::= NULL|FLOAT|BLOB], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr LT LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr LT LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr LT LP nexprlist COMMA term RP]
parser: Input 'SEMI' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 118.
parser: ... then shift 'expr', go to state 130
parser: Reduce 181 [expr ::= expr LT|GT|GE|LE expr], go to state 105.
parser: ... then shift 'expr', go to state 75
parser: Reduce 194 [expr ::= NOT expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT (1, 3, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, 3, 3) > (1, NULL, 3)
;SELECT (1, 3, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) <= (1, NULL, 3)
;SELECT (1, 3, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) >= (1, NULL, 3)
;SELECT (1, NULL, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) < (1, NULL, 3)
;SELECT (1, NULL, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) > (1, NULL, 3)
;SELECT (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, NULL, 3)
;SELECT (1, NULL, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, NULL, 3)
;CREATE TABLE v0(over, following);;INSERT INTO t0 VALUES(3, 5);;INSERT INTO v0 VALUES(3, 6);SELECT (1, 1) == (SELECT c0,c0 FROM t0 ORDER BY c0, c0)
;SELECT (1, 1) == (SELECT * FROM t0 ORDER BY c0, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0, c0)
  
;SELECT (SELECT * FROM t0 ORDER BY c0, c0 DESC) == (SELECT * FROM t0 ORDER BY c0, c0 DESC)
  
;SELECT (3, 6) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
  
;SELECT ((3, 5)) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (SELECT 3, 5) == (SELECT c0,c0 FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT * FROM t0 ORDER BY c0 DESC, c0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (2, 2) BETWEEN (2, 2) AND (3, 3)
;SELECT (2, 2) BETWEEN (2, NULL) AND (3, 3)
;SELECT (NULL, 4) IN (SELECT * FROM v0)
;SELECT (NULL, 4) NOT IN (SELECT * FROM v0)
;CREATE TABLE preceding(t1, x, test001);;INSERT INTO preceding VALUES('abc', 1, 'i');;INSERT INTO v0 VALUES('def', 2, 'iii');;INSERT INTO v0 VALUES('ghi', 3, 'vi');;
;SELECT c0 FROM t0 WHERE c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE +c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE (c0 COLLATE nocase, c0) IS NOT (SELECT 'def', 2);;
;SELECT following FROM v0 WHERE (over, over) = (SELECT 2, 'def');;INSERT INTO v0 VALUES(3, 3, 3);SELECT * FROM t0 WHERE (c0, c0) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM v0 WHERE (following, following) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;CREATE TABLE last_field(test002);;INSERT INTO last_field VALUES(3, 3, 3);;INSERT INTO last_field VALUES(4, 4, 4);;INSERT INTO t0 VALUES(5, 5, 5);SELECT following FROM v0 WHERE (over, following) > (2, 2)
;SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'LP' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct sclp scanpt LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA term RP]
parser: Input 'GT' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Shift 'GT', go to state 118
parser: Return. Stack=[SELECT distinct sclp scanpt expr GT]
parser: Input 'LP' in state 118
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct sclp scanpt expr GT LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt expr GT LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt expr GT LP nexprlist COMMA]
parser: Input 'NULL' in state 91
parser: Shift 'NULL', pending reduce 167
parser: Return. Stack=[SELECT distinct sclp scanpt expr GT LP nexprlist COMMA NULL]
parser: Input 'COMMA' with pending reduce 167
parser: Reduce 167 [term ::= NULL|FLOAT|BLOB], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt expr GT LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt expr GT LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct sclp scanpt expr GT LP nexprlist COMMA term RP]
parser: Input 'SEMI' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 118.
parser: ... then shift 'expr', go to state 130
parser: Reduce 181 [expr ::= expr LT|GT|GE|LE expr], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Reduce 100 [from ::=].
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT * FROM t0 WHERE (1, 3, 3) > (1, NULL, 3)
;SELECT (1, 3, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) <= (1, NULL, 3)
;SELECT (1, 3, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) >= (1, NULL, 3)
;SELECT (1, NULL, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) < (1, NULL, 3)
;SELECT (1, NULL, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) > (1, NULL, 3)
;SELECT (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, NULL, 3)
;SELECT (1, NULL, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, NULL, 3)
;CREATE TABLE v0(over, following);;INSERT INTO t0 VALUES(3, 5);;INSERT INTO v0 VALUES(3, 6);SELECT (1, 1) == (SELECT c0,c0 FROM t0 ORDER BY c0, c0)
;SELECT (1, 1) == (SELECT * FROM t0 ORDER BY c0, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0, c0)
  
;SELECT (SELECT * FROM t0 ORDER BY c0, c0 DESC) == (SELECT * FROM t0 ORDER BY c0, c0 DESC)
  
;SELECT (3, 6) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
  
;SELECT ((3, 5)) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (SELECT 3, 5) == (SELECT c0,c0 FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT * FROM t0 ORDER BY c0 DESC, c0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (2, 2) BETWEEN (2, 2) AND (3, 3)
;SELECT (2, 2) BETWEEN (2, NULL) AND (3, 3)
;SELECT (NULL, 4) IN (SELECT * FROM v0)
;SELECT (NULL, 4) NOT IN (SELECT * FROM v0)
;CREATE TABLE preceding(t1, x, test001);;INSERT INTO preceding VALUES('abc', 1, 'i');;INSERT INTO v0 VALUES('def', 2, 'iii');;INSERT INTO v0 VALUES('ghi', 3, 'vi');;
;SELECT c0 FROM t0 WHERE c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE +c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE (c0 COLLATE nocase, c0) IS NOT (SELECT 'def', 2);;
;SELECT following FROM v0 WHERE (over, over) = (SELECT 2, 'def');;INSERT INTO v0 VALUES(3, 3, 3);SELECT * FROM t0 WHERE (c0, c0) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM v0 WHERE (following, following) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;CREATE TABLE last_field(test002);;INSERT INTO last_field VALUES(3, 3, 3);;INSERT INTO last_field VALUES(4, 4, 4);;INSERT INTO t0 VALUES(5, 5, 5);SELECT following FROM v0 WHERE (over, following) > (2, 2)
;SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 96
parser: Return. Stack=[SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[SELECT distinct selcollist from WHERE]
parser: Input 'LP' in state 93
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP nexprlist COMMA INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP nexprlist COMMA term RP]
parser: Input 'GT' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'GT', go to state 118
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr GT]
parser: Input 'LP' in state 118
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr GT LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr GT LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr GT LP nexprlist COMMA]
parser: Input 'NULL' in state 91
parser: Shift 'NULL', pending reduce 167
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr GT LP nexprlist COMMA NULL]
parser: Input 'COMMA' with pending reduce 167
parser: Reduce 167 [term ::= NULL|FLOAT|BLOB], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr GT LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr GT LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr GT LP nexprlist COMMA term RP]
parser: Input 'SEMI' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 118.
parser: ... then shift 'expr', go to state 130
parser: Reduce 181 [expr ::= expr LT|GT|GE|LE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT (1, 3, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) <= (1, NULL, 3)
;SELECT (1, 3, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) >= (1, NULL, 3)
;SELECT (1, NULL, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) < (1, NULL, 3)
;SELECT (1, NULL, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) > (1, NULL, 3)
;SELECT (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, NULL, 3)
;SELECT (1, NULL, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, NULL, 3)
;CREATE TABLE v0(over, following);;INSERT INTO t0 VALUES(3, 5);;INSERT INTO v0 VALUES(3, 6);SELECT (1, 1) == (SELECT c0,c0 FROM t0 ORDER BY c0, c0)
;SELECT (1, 1) == (SELECT * FROM t0 ORDER BY c0, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0, c0)
  
;SELECT (SELECT * FROM t0 ORDER BY c0, c0 DESC) == (SELECT * FROM t0 ORDER BY c0, c0 DESC)
  
;SELECT (3, 6) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
  
;SELECT ((3, 5)) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (SELECT 3, 5) == (SELECT c0,c0 FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT * FROM t0 ORDER BY c0 DESC, c0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (2, 2) BETWEEN (2, 2) AND (3, 3)
;SELECT (2, 2) BETWEEN (2, NULL) AND (3, 3)
;SELECT (NULL, 4) IN (SELECT * FROM v0)
;SELECT (NULL, 4) NOT IN (SELECT * FROM v0)
;CREATE TABLE preceding(t1, x, test001);;INSERT INTO preceding VALUES('abc', 1, 'i');;INSERT INTO v0 VALUES('def', 2, 'iii');;INSERT INTO v0 VALUES('ghi', 3, 'vi');;
;SELECT c0 FROM t0 WHERE c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE +c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE (c0 COLLATE nocase, c0) IS NOT (SELECT 'def', 2);;
;SELECT following FROM v0 WHERE (over, over) = (SELECT 2, 'def');;INSERT INTO v0 VALUES(3, 3, 3);SELECT * FROM t0 WHERE (c0, c0) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM v0 WHERE (following, following) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;CREATE TABLE last_field(test002);;INSERT INTO last_field VALUES(3, 3, 3);;INSERT INTO last_field VALUES(4, 4, 4);;INSERT INTO t0 VALUES(5, 5, 5);SELECT following FROM v0 WHERE (over, following) > (2, 2)
;SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'LP' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct sclp scanpt LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA term RP]
parser: Input 'LE' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Shift 'LE', go to state 118
parser: Return. Stack=[SELECT distinct sclp scanpt expr LE]
parser: Input 'LP' in state 118
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct sclp scanpt expr LE LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt expr LE LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt expr LE LP nexprlist COMMA]
parser: Input 'NULL' in state 91
parser: Shift 'NULL', pending reduce 167
parser: Return. Stack=[SELECT distinct sclp scanpt expr LE LP nexprlist COMMA NULL]
parser: Input 'COMMA' with pending reduce 167
parser: Reduce 167 [term ::= NULL|FLOAT|BLOB], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt expr LE LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt expr LE LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct sclp scanpt expr LE LP nexprlist COMMA term RP]
parser: Input 'SEMI' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 118.
parser: ... then shift 'expr', go to state 130
parser: Reduce 181 [expr ::= expr LT|GT|GE|LE expr], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Reduce 100 [from ::=].
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT * FROM t0 WHERE NOT (1, 3, 3) <= (1, NULL, 3)
;SELECT (1, 3, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) >= (1, NULL, 3)
;SELECT (1, NULL, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) < (1, NULL, 3)
;SELECT (1, NULL, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) > (1, NULL, 3)
;SELECT (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, NULL, 3)
;SELECT (1, NULL, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, NULL, 3)
;CREATE TABLE v0(over, following);;INSERT INTO t0 VALUES(3, 5);;INSERT INTO v0 VALUES(3, 6);SELECT (1, 1) == (SELECT c0,c0 FROM t0 ORDER BY c0, c0)
;SELECT (1, 1) == (SELECT * FROM t0 ORDER BY c0, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0, c0)
  
;SELECT (SELECT * FROM t0 ORDER BY c0, c0 DESC) == (SELECT * FROM t0 ORDER BY c0, c0 DESC)
  
;SELECT (3, 6) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
  
;SELECT ((3, 5)) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (SELECT 3, 5) == (SELECT c0,c0 FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT * FROM t0 ORDER BY c0 DESC, c0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (2, 2) BETWEEN (2, 2) AND (3, 3)
;SELECT (2, 2) BETWEEN (2, NULL) AND (3, 3)
;SELECT (NULL, 4) IN (SELECT * FROM v0)
;SELECT (NULL, 4) NOT IN (SELECT * FROM v0)
;CREATE TABLE preceding(t1, x, test001);;INSERT INTO preceding VALUES('abc', 1, 'i');;INSERT INTO v0 VALUES('def', 2, 'iii');;INSERT INTO v0 VALUES('ghi', 3, 'vi');;
;SELECT c0 FROM t0 WHERE c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE +c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE (c0 COLLATE nocase, c0) IS NOT (SELECT 'def', 2);;
;SELECT following FROM v0 WHERE (over, over) = (SELECT 2, 'def');;INSERT INTO v0 VALUES(3, 3, 3);SELECT * FROM t0 WHERE (c0, c0) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM v0 WHERE (following, following) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;CREATE TABLE last_field(test002);;INSERT INTO last_field VALUES(3, 3, 3);;INSERT INTO last_field VALUES(4, 4, 4);;INSERT INTO t0 VALUES(5, 5, 5);SELECT following FROM v0 WHERE (over, following) > (2, 2)
;SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 96
parser: Return. Stack=[SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[SELECT distinct selcollist from WHERE]
parser: Input 'NOT' in state 93
parser: Shift 'NOT', go to state 105
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT]
parser: Input 'LP' in state 105
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP nexprlist COMMA INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP nexprlist COMMA term RP]
parser: Input 'LE' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 105.
parser: ... then shift 'expr', go to state 75
parser: Shift 'LE', go to state 118
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr LE]
parser: Input 'LP' in state 118
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr LE LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr LE LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr LE LP nexprlist COMMA]
parser: Input 'NULL' in state 91
parser: Shift 'NULL', pending reduce 167
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr LE LP nexprlist COMMA NULL]
parser: Input 'COMMA' with pending reduce 167
parser: Reduce 167 [term ::= NULL|FLOAT|BLOB], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr LE LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr LE LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr LE LP nexprlist COMMA term RP]
parser: Input 'SEMI' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 118.
parser: ... then shift 'expr', go to state 130
parser: Reduce 181 [expr ::= expr LT|GT|GE|LE expr], go to state 105.
parser: ... then shift 'expr', go to state 75
parser: Reduce 194 [expr ::= NOT expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT (1, 3, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, 3, 3) >= (1, NULL, 3)
;SELECT (1, NULL, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) < (1, NULL, 3)
;SELECT (1, NULL, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) > (1, NULL, 3)
;SELECT (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, NULL, 3)
;SELECT (1, NULL, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, NULL, 3)
;CREATE TABLE v0(over, following);;INSERT INTO t0 VALUES(3, 5);;INSERT INTO v0 VALUES(3, 6);SELECT (1, 1) == (SELECT c0,c0 FROM t0 ORDER BY c0, c0)
;SELECT (1, 1) == (SELECT * FROM t0 ORDER BY c0, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0, c0)
  
;SELECT (SELECT * FROM t0 ORDER BY c0, c0 DESC) == (SELECT * FROM t0 ORDER BY c0, c0 DESC)
  
;SELECT (3, 6) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
  
;SELECT ((3, 5)) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (SELECT 3, 5) == (SELECT c0,c0 FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT * FROM t0 ORDER BY c0 DESC, c0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (2, 2) BETWEEN (2, 2) AND (3, 3)
;SELECT (2, 2) BETWEEN (2, NULL) AND (3, 3)
;SELECT (NULL, 4) IN (SELECT * FROM v0)
;SELECT (NULL, 4) NOT IN (SELECT * FROM v0)
;CREATE TABLE preceding(t1, x, test001);;INSERT INTO preceding VALUES('abc', 1, 'i');;INSERT INTO v0 VALUES('def', 2, 'iii');;INSERT INTO v0 VALUES('ghi', 3, 'vi');;
;SELECT c0 FROM t0 WHERE c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE +c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE (c0 COLLATE nocase, c0) IS NOT (SELECT 'def', 2);;
;SELECT following FROM v0 WHERE (over, over) = (SELECT 2, 'def');;INSERT INTO v0 VALUES(3, 3, 3);SELECT * FROM t0 WHERE (c0, c0) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM v0 WHERE (following, following) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;CREATE TABLE last_field(test002);;INSERT INTO last_field VALUES(3, 3, 3);;INSERT INTO last_field VALUES(4, 4, 4);;INSERT INTO t0 VALUES(5, 5, 5);SELECT following FROM v0 WHERE (over, following) > (2, 2)
;SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'LP' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct sclp scanpt LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA term RP]
parser: Input 'GE' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Shift 'GE', go to state 118
parser: Return. Stack=[SELECT distinct sclp scanpt expr GE]
parser: Input 'LP' in state 118
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct sclp scanpt expr GE LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt expr GE LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt expr GE LP nexprlist COMMA]
parser: Input 'NULL' in state 91
parser: Shift 'NULL', pending reduce 167
parser: Return. Stack=[SELECT distinct sclp scanpt expr GE LP nexprlist COMMA NULL]
parser: Input 'COMMA' with pending reduce 167
parser: Reduce 167 [term ::= NULL|FLOAT|BLOB], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt expr GE LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt expr GE LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct sclp scanpt expr GE LP nexprlist COMMA term RP]
parser: Input 'SEMI' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 118.
parser: ... then shift 'expr', go to state 130
parser: Reduce 181 [expr ::= expr LT|GT|GE|LE expr], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Reduce 100 [from ::=].
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT * FROM t0 WHERE NOT (1, 3, 3) >= (1, NULL, 3)
;SELECT (1, NULL, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) < (1, NULL, 3)
;SELECT (1, NULL, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) > (1, NULL, 3)
;SELECT (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, NULL, 3)
;SELECT (1, NULL, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, NULL, 3)
;CREATE TABLE v0(over, following);;INSERT INTO t0 VALUES(3, 5);;INSERT INTO v0 VALUES(3, 6);SELECT (1, 1) == (SELECT c0,c0 FROM t0 ORDER BY c0, c0)
;SELECT (1, 1) == (SELECT * FROM t0 ORDER BY c0, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0, c0)
  
;SELECT (SELECT * FROM t0 ORDER BY c0, c0 DESC) == (SELECT * FROM t0 ORDER BY c0, c0 DESC)
  
;SELECT (3, 6) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
  
;SELECT ((3, 5)) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (SELECT 3, 5) == (SELECT c0,c0 FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT * FROM t0 ORDER BY c0 DESC, c0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (2, 2) BETWEEN (2, 2) AND (3, 3)
;SELECT (2, 2) BETWEEN (2, NULL) AND (3, 3)
;SELECT (NULL, 4) IN (SELECT * FROM v0)
;SELECT (NULL, 4) NOT IN (SELECT * FROM v0)
;CREATE TABLE preceding(t1, x, test001);;INSERT INTO preceding VALUES('abc', 1, 'i');;INSERT INTO v0 VALUES('def', 2, 'iii');;INSERT INTO v0 VALUES('ghi', 3, 'vi');;
;SELECT c0 FROM t0 WHERE c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE +c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE (c0 COLLATE nocase, c0) IS NOT (SELECT 'def', 2);;
;SELECT following FROM v0 WHERE (over, over) = (SELECT 2, 'def');;INSERT INTO v0 VALUES(3, 3, 3);SELECT * FROM t0 WHERE (c0, c0) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM v0 WHERE (following, following) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;CREATE TABLE last_field(test002);;INSERT INTO last_field VALUES(3, 3, 3);;INSERT INTO last_field VALUES(4, 4, 4);;INSERT INTO t0 VALUES(5, 5, 5);SELECT following FROM v0 WHERE (over, following) > (2, 2)
;SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 96
parser: Return. Stack=[SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[SELECT distinct selcollist from WHERE]
parser: Input 'NOT' in state 93
parser: Shift 'NOT', go to state 105
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT]
parser: Input 'LP' in state 105
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP nexprlist COMMA INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP nexprlist COMMA term RP]
parser: Input 'GE' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 105.
parser: ... then shift 'expr', go to state 75
parser: Shift 'GE', go to state 118
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr GE]
parser: Input 'LP' in state 118
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr GE LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr GE LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr GE LP nexprlist COMMA]
parser: Input 'NULL' in state 91
parser: Shift 'NULL', pending reduce 167
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr GE LP nexprlist COMMA NULL]
parser: Input 'COMMA' with pending reduce 167
parser: Reduce 167 [term ::= NULL|FLOAT|BLOB], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr GE LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr GE LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr GE LP nexprlist COMMA term RP]
parser: Input 'SEMI' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 118.
parser: ... then shift 'expr', go to state 130
parser: Reduce 181 [expr ::= expr LT|GT|GE|LE expr], go to state 105.
parser: ... then shift 'expr', go to state 75
parser: Reduce 194 [expr ::= NOT expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT (1, NULL, 3) < (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) < (1, NULL, 3)
;SELECT (1, NULL, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) > (1, NULL, 3)
;SELECT (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, NULL, 3)
;SELECT (1, NULL, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, NULL, 3)
;CREATE TABLE v0(over, following);;INSERT INTO t0 VALUES(3, 5);;INSERT INTO v0 VALUES(3, 6);SELECT (1, 1) == (SELECT c0,c0 FROM t0 ORDER BY c0, c0)
;SELECT (1, 1) == (SELECT * FROM t0 ORDER BY c0, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0, c0)
  
;SELECT (SELECT * FROM t0 ORDER BY c0, c0 DESC) == (SELECT * FROM t0 ORDER BY c0, c0 DESC)
  
;SELECT (3, 6) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
  
;SELECT ((3, 5)) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (SELECT 3, 5) == (SELECT c0,c0 FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT * FROM t0 ORDER BY c0 DESC, c0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (2, 2) BETWEEN (2, 2) AND (3, 3)
;SELECT (2, 2) BETWEEN (2, NULL) AND (3, 3)
;SELECT (NULL, 4) IN (SELECT * FROM v0)
;SELECT (NULL, 4) NOT IN (SELECT * FROM v0)
;CREATE TABLE preceding(t1, x, test001);;INSERT INTO preceding VALUES('abc', 1, 'i');;INSERT INTO v0 VALUES('def', 2, 'iii');;INSERT INTO v0 VALUES('ghi', 3, 'vi');;
;SELECT c0 FROM t0 WHERE c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE +c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE (c0 COLLATE nocase, c0) IS NOT (SELECT 'def', 2);;
;SELECT following FROM v0 WHERE (over, over) = (SELECT 2, 'def');;INSERT INTO v0 VALUES(3, 3, 3);SELECT * FROM t0 WHERE (c0, c0) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM v0 WHERE (following, following) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;CREATE TABLE last_field(test002);;INSERT INTO last_field VALUES(3, 3, 3);;INSERT INTO last_field VALUES(4, 4, 4);;INSERT INTO t0 VALUES(5, 5, 5);SELECT following FROM v0 WHERE (over, following) > (2, 2)
;SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'LP' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct sclp scanpt LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA]
parser: Input 'NULL' in state 91
parser: Shift 'NULL', pending reduce 167
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA NULL]
parser: Input 'COMMA' with pending reduce 167
parser: Reduce 167 [term ::= NULL|FLOAT|BLOB], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA term RP]
parser: Input 'LT' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Shift 'LT', go to state 118
parser: Return. Stack=[SELECT distinct sclp scanpt expr LT]
parser: Input 'LP' in state 118
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct sclp scanpt expr LT LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt expr LT LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt expr LT LP nexprlist COMMA]
parser: Input 'NULL' in state 91
parser: Shift 'NULL', pending reduce 167
parser: Return. Stack=[SELECT distinct sclp scanpt expr LT LP nexprlist COMMA NULL]
parser: Input 'COMMA' with pending reduce 167
parser: Reduce 167 [term ::= NULL|FLOAT|BLOB], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt expr LT LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt expr LT LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct sclp scanpt expr LT LP nexprlist COMMA term RP]
parser: Input 'SEMI' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 118.
parser: ... then shift 'expr', go to state 130
parser: Reduce 181 [expr ::= expr LT|GT|GE|LE expr], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Reduce 100 [from ::=].
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT * FROM t0 WHERE (1, NULL, 3) < (1, NULL, 3)
;SELECT (1, NULL, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) > (1, NULL, 3)
;SELECT (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, NULL, 3)
;SELECT (1, NULL, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, NULL, 3)
;CREATE TABLE v0(over, following);;INSERT INTO t0 VALUES(3, 5);;INSERT INTO v0 VALUES(3, 6);SELECT (1, 1) == (SELECT c0,c0 FROM t0 ORDER BY c0, c0)
;SELECT (1, 1) == (SELECT * FROM t0 ORDER BY c0, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0, c0)
  
;SELECT (SELECT * FROM t0 ORDER BY c0, c0 DESC) == (SELECT * FROM t0 ORDER BY c0, c0 DESC)
  
;SELECT (3, 6) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
  
;SELECT ((3, 5)) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (SELECT 3, 5) == (SELECT c0,c0 FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT * FROM t0 ORDER BY c0 DESC, c0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (2, 2) BETWEEN (2, 2) AND (3, 3)
;SELECT (2, 2) BETWEEN (2, NULL) AND (3, 3)
;SELECT (NULL, 4) IN (SELECT * FROM v0)
;SELECT (NULL, 4) NOT IN (SELECT * FROM v0)
;CREATE TABLE preceding(t1, x, test001);;INSERT INTO preceding VALUES('abc', 1, 'i');;INSERT INTO v0 VALUES('def', 2, 'iii');;INSERT INTO v0 VALUES('ghi', 3, 'vi');;
;SELECT c0 FROM t0 WHERE c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE +c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE (c0 COLLATE nocase, c0) IS NOT (SELECT 'def', 2);;
;SELECT following FROM v0 WHERE (over, over) = (SELECT 2, 'def');;INSERT INTO v0 VALUES(3, 3, 3);SELECT * FROM t0 WHERE (c0, c0) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM v0 WHERE (following, following) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;CREATE TABLE last_field(test002);;INSERT INTO last_field VALUES(3, 3, 3);;INSERT INTO last_field VALUES(4, 4, 4);;INSERT INTO t0 VALUES(5, 5, 5);SELECT following FROM v0 WHERE (over, following) > (2, 2)
;SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 96
parser: Return. Stack=[SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[SELECT distinct selcollist from WHERE]
parser: Input 'LP' in state 93
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP nexprlist COMMA]
parser: Input 'NULL' in state 91
parser: Shift 'NULL', pending reduce 167
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP nexprlist COMMA NULL]
parser: Input 'COMMA' with pending reduce 167
parser: Reduce 167 [term ::= NULL|FLOAT|BLOB], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP nexprlist COMMA term RP]
parser: Input 'LT' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'LT', go to state 118
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LT]
parser: Input 'LP' in state 118
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LT LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LT LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LT LP nexprlist COMMA]
parser: Input 'NULL' in state 91
parser: Shift 'NULL', pending reduce 167
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LT LP nexprlist COMMA NULL]
parser: Input 'COMMA' with pending reduce 167
parser: Reduce 167 [term ::= NULL|FLOAT|BLOB], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LT LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LT LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LT LP nexprlist COMMA term RP]
parser: Input 'SEMI' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 118.
parser: ... then shift 'expr', go to state 130
parser: Reduce 181 [expr ::= expr LT|GT|GE|LE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT (1, NULL, 3) > (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) > (1, NULL, 3)
;SELECT (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, NULL, 3)
;SELECT (1, NULL, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, NULL, 3)
;CREATE TABLE v0(over, following);;INSERT INTO t0 VALUES(3, 5);;INSERT INTO v0 VALUES(3, 6);SELECT (1, 1) == (SELECT c0,c0 FROM t0 ORDER BY c0, c0)
;SELECT (1, 1) == (SELECT * FROM t0 ORDER BY c0, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0, c0)
  
;SELECT (SELECT * FROM t0 ORDER BY c0, c0 DESC) == (SELECT * FROM t0 ORDER BY c0, c0 DESC)
  
;SELECT (3, 6) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
  
;SELECT ((3, 5)) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (SELECT 3, 5) == (SELECT c0,c0 FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT * FROM t0 ORDER BY c0 DESC, c0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (2, 2) BETWEEN (2, 2) AND (3, 3)
;SELECT (2, 2) BETWEEN (2, NULL) AND (3, 3)
;SELECT (NULL, 4) IN (SELECT * FROM v0)
;SELECT (NULL, 4) NOT IN (SELECT * FROM v0)
;CREATE TABLE preceding(t1, x, test001);;INSERT INTO preceding VALUES('abc', 1, 'i');;INSERT INTO v0 VALUES('def', 2, 'iii');;INSERT INTO v0 VALUES('ghi', 3, 'vi');;
;SELECT c0 FROM t0 WHERE c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE +c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE (c0 COLLATE nocase, c0) IS NOT (SELECT 'def', 2);;
;SELECT following FROM v0 WHERE (over, over) = (SELECT 2, 'def');;INSERT INTO v0 VALUES(3, 3, 3);SELECT * FROM t0 WHERE (c0, c0) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM v0 WHERE (following, following) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;CREATE TABLE last_field(test002);;INSERT INTO last_field VALUES(3, 3, 3);;INSERT INTO last_field VALUES(4, 4, 4);;INSERT INTO t0 VALUES(5, 5, 5);SELECT following FROM v0 WHERE (over, following) > (2, 2)
;SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'LP' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct sclp scanpt LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA]
parser: Input 'NULL' in state 91
parser: Shift 'NULL', pending reduce 167
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA NULL]
parser: Input 'COMMA' with pending reduce 167
parser: Reduce 167 [term ::= NULL|FLOAT|BLOB], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA term RP]
parser: Input 'GT' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Shift 'GT', go to state 118
parser: Return. Stack=[SELECT distinct sclp scanpt expr GT]
parser: Input 'LP' in state 118
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct sclp scanpt expr GT LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt expr GT LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt expr GT LP nexprlist COMMA]
parser: Input 'NULL' in state 91
parser: Shift 'NULL', pending reduce 167
parser: Return. Stack=[SELECT distinct sclp scanpt expr GT LP nexprlist COMMA NULL]
parser: Input 'COMMA' with pending reduce 167
parser: Reduce 167 [term ::= NULL|FLOAT|BLOB], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt expr GT LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt expr GT LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct sclp scanpt expr GT LP nexprlist COMMA term RP]
parser: Input 'SEMI' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 118.
parser: ... then shift 'expr', go to state 130
parser: Reduce 181 [expr ::= expr LT|GT|GE|LE expr], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Reduce 100 [from ::=].
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT * FROM t0 WHERE NOT (1, NULL, 3) > (1, NULL, 3)
;SELECT (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, NULL, 3)
;SELECT (1, NULL, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, NULL, 3)
;CREATE TABLE v0(over, following);;INSERT INTO t0 VALUES(3, 5);;INSERT INTO v0 VALUES(3, 6);SELECT (1, 1) == (SELECT c0,c0 FROM t0 ORDER BY c0, c0)
;SELECT (1, 1) == (SELECT * FROM t0 ORDER BY c0, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0, c0)
  
;SELECT (SELECT * FROM t0 ORDER BY c0, c0 DESC) == (SELECT * FROM t0 ORDER BY c0, c0 DESC)
  
;SELECT (3, 6) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
  
;SELECT ((3, 5)) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (SELECT 3, 5) == (SELECT c0,c0 FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT * FROM t0 ORDER BY c0 DESC, c0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (2, 2) BETWEEN (2, 2) AND (3, 3)
;SELECT (2, 2) BETWEEN (2, NULL) AND (3, 3)
;SELECT (NULL, 4) IN (SELECT * FROM v0)
;SELECT (NULL, 4) NOT IN (SELECT * FROM v0)
;CREATE TABLE preceding(t1, x, test001);;INSERT INTO preceding VALUES('abc', 1, 'i');;INSERT INTO v0 VALUES('def', 2, 'iii');;INSERT INTO v0 VALUES('ghi', 3, 'vi');;
;SELECT c0 FROM t0 WHERE c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE +c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE (c0 COLLATE nocase, c0) IS NOT (SELECT 'def', 2);;
;SELECT following FROM v0 WHERE (over, over) = (SELECT 2, 'def');;INSERT INTO v0 VALUES(3, 3, 3);SELECT * FROM t0 WHERE (c0, c0) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM v0 WHERE (following, following) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;CREATE TABLE last_field(test002);;INSERT INTO last_field VALUES(3, 3, 3);;INSERT INTO last_field VALUES(4, 4, 4);;INSERT INTO t0 VALUES(5, 5, 5);SELECT following FROM v0 WHERE (over, following) > (2, 2)
;SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 96
parser: Return. Stack=[SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[SELECT distinct selcollist from WHERE]
parser: Input 'NOT' in state 93
parser: Shift 'NOT', go to state 105
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT]
parser: Input 'LP' in state 105
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP nexprlist COMMA]
parser: Input 'NULL' in state 91
parser: Shift 'NULL', pending reduce 167
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP nexprlist COMMA NULL]
parser: Input 'COMMA' with pending reduce 167
parser: Reduce 167 [term ::= NULL|FLOAT|BLOB], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP nexprlist COMMA term RP]
parser: Input 'GT' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 105.
parser: ... then shift 'expr', go to state 75
parser: Shift 'GT', go to state 118
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr GT]
parser: Input 'LP' in state 118
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr GT LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr GT LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr GT LP nexprlist COMMA]
parser: Input 'NULL' in state 91
parser: Shift 'NULL', pending reduce 167
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr GT LP nexprlist COMMA NULL]
parser: Input 'COMMA' with pending reduce 167
parser: Reduce 167 [term ::= NULL|FLOAT|BLOB], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr GT LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr GT LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr GT LP nexprlist COMMA term RP]
parser: Input 'SEMI' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 118.
parser: ... then shift 'expr', go to state 130
parser: Reduce 181 [expr ::= expr LT|GT|GE|LE expr], go to state 105.
parser: ... then shift 'expr', go to state 75
parser: Reduce 194 [expr ::= NOT expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, NULL, 3)
;SELECT (1, NULL, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, NULL, 3)
;CREATE TABLE v0(over, following);;INSERT INTO t0 VALUES(3, 5);;INSERT INTO v0 VALUES(3, 6);SELECT (1, 1) == (SELECT c0,c0 FROM t0 ORDER BY c0, c0)
;SELECT (1, 1) == (SELECT * FROM t0 ORDER BY c0, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0, c0)
  
;SELECT (SELECT * FROM t0 ORDER BY c0, c0 DESC) == (SELECT * FROM t0 ORDER BY c0, c0 DESC)
  
;SELECT (3, 6) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
  
;SELECT ((3, 5)) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (SELECT 3, 5) == (SELECT c0,c0 FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT * FROM t0 ORDER BY c0 DESC, c0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (2, 2) BETWEEN (2, 2) AND (3, 3)
;SELECT (2, 2) BETWEEN (2, NULL) AND (3, 3)
;SELECT (NULL, 4) IN (SELECT * FROM v0)
;SELECT (NULL, 4) NOT IN (SELECT * FROM v0)
;CREATE TABLE preceding(t1, x, test001);;INSERT INTO preceding VALUES('abc', 1, 'i');;INSERT INTO v0 VALUES('def', 2, 'iii');;INSERT INTO v0 VALUES('ghi', 3, 'vi');;
;SELECT c0 FROM t0 WHERE c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE +c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE (c0 COLLATE nocase, c0) IS NOT (SELECT 'def', 2);;
;SELECT following FROM v0 WHERE (over, over) = (SELECT 2, 'def');;INSERT INTO v0 VALUES(3, 3, 3);SELECT * FROM t0 WHERE (c0, c0) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM v0 WHERE (following, following) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;CREATE TABLE last_field(test002);;INSERT INTO last_field VALUES(3, 3, 3);;INSERT INTO last_field VALUES(4, 4, 4);;INSERT INTO t0 VALUES(5, 5, 5);SELECT following FROM v0 WHERE (over, following) > (2, 2)
;SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'LP' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct sclp scanpt LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA]
parser: Input 'NULL' in state 91
parser: Shift 'NULL', pending reduce 167
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA NULL]
parser: Input 'COMMA' with pending reduce 167
parser: Reduce 167 [term ::= NULL|FLOAT|BLOB], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA term RP]
parser: Input 'LE' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Shift 'LE', go to state 118
parser: Return. Stack=[SELECT distinct sclp scanpt expr LE]
parser: Input 'LP' in state 118
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct sclp scanpt expr LE LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt expr LE LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt expr LE LP nexprlist COMMA]
parser: Input 'NULL' in state 91
parser: Shift 'NULL', pending reduce 167
parser: Return. Stack=[SELECT distinct sclp scanpt expr LE LP nexprlist COMMA NULL]
parser: Input 'COMMA' with pending reduce 167
parser: Reduce 167 [term ::= NULL|FLOAT|BLOB], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt expr LE LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt expr LE LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct sclp scanpt expr LE LP nexprlist COMMA term RP]
parser: Input 'SEMI' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 118.
parser: ... then shift 'expr', go to state 130
parser: Reduce 181 [expr ::= expr LT|GT|GE|LE expr], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Reduce 100 [from ::=].
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT * FROM t0 WHERE (1, NULL, 3) <= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, NULL, 3)
;SELECT (1, NULL, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, NULL, 3)
;CREATE TABLE v0(over, following);;INSERT INTO t0 VALUES(3, 5);;INSERT INTO v0 VALUES(3, 6);SELECT (1, 1) == (SELECT c0,c0 FROM t0 ORDER BY c0, c0)
;SELECT (1, 1) == (SELECT * FROM t0 ORDER BY c0, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0, c0)
  
;SELECT (SELECT * FROM t0 ORDER BY c0, c0 DESC) == (SELECT * FROM t0 ORDER BY c0, c0 DESC)
  
;SELECT (3, 6) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
  
;SELECT ((3, 5)) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (SELECT 3, 5) == (SELECT c0,c0 FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT * FROM t0 ORDER BY c0 DESC, c0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (2, 2) BETWEEN (2, 2) AND (3, 3)
;SELECT (2, 2) BETWEEN (2, NULL) AND (3, 3)
;SELECT (NULL, 4) IN (SELECT * FROM v0)
;SELECT (NULL, 4) NOT IN (SELECT * FROM v0)
;CREATE TABLE preceding(t1, x, test001);;INSERT INTO preceding VALUES('abc', 1, 'i');;INSERT INTO v0 VALUES('def', 2, 'iii');;INSERT INTO v0 VALUES('ghi', 3, 'vi');;
;SELECT c0 FROM t0 WHERE c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE +c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE (c0 COLLATE nocase, c0) IS NOT (SELECT 'def', 2);;
;SELECT following FROM v0 WHERE (over, over) = (SELECT 2, 'def');;INSERT INTO v0 VALUES(3, 3, 3);SELECT * FROM t0 WHERE (c0, c0) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM v0 WHERE (following, following) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;CREATE TABLE last_field(test002);;INSERT INTO last_field VALUES(3, 3, 3);;INSERT INTO last_field VALUES(4, 4, 4);;INSERT INTO t0 VALUES(5, 5, 5);SELECT following FROM v0 WHERE (over, following) > (2, 2)
;SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 96
parser: Return. Stack=[SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[SELECT distinct selcollist from WHERE]
parser: Input 'LP' in state 93
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP nexprlist COMMA]
parser: Input 'NULL' in state 91
parser: Shift 'NULL', pending reduce 167
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP nexprlist COMMA NULL]
parser: Input 'COMMA' with pending reduce 167
parser: Reduce 167 [term ::= NULL|FLOAT|BLOB], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP nexprlist COMMA term RP]
parser: Input 'LE' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'LE', go to state 118
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LE]
parser: Input 'LP' in state 118
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LE LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LE LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LE LP nexprlist COMMA]
parser: Input 'NULL' in state 91
parser: Shift 'NULL', pending reduce 167
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LE LP nexprlist COMMA NULL]
parser: Input 'COMMA' with pending reduce 167
parser: Reduce 167 [term ::= NULL|FLOAT|BLOB], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LE LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LE LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LE LP nexprlist COMMA term RP]
parser: Input 'SEMI' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 118.
parser: ... then shift 'expr', go to state 130
parser: Reduce 181 [expr ::= expr LT|GT|GE|LE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT * FROM t0 WHERE NOT (1, NULL, 3) <= (1, NULL, 3)
;SELECT (1, NULL, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, NULL, 3)
;CREATE TABLE v0(over, following);;INSERT INTO t0 VALUES(3, 5);;INSERT INTO v0 VALUES(3, 6);SELECT (1, 1) == (SELECT c0,c0 FROM t0 ORDER BY c0, c0)
;SELECT (1, 1) == (SELECT * FROM t0 ORDER BY c0, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0, c0)
  
;SELECT (SELECT * FROM t0 ORDER BY c0, c0 DESC) == (SELECT * FROM t0 ORDER BY c0, c0 DESC)
  
;SELECT (3, 6) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
  
;SELECT ((3, 5)) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (SELECT 3, 5) == (SELECT c0,c0 FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT * FROM t0 ORDER BY c0 DESC, c0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (2, 2) BETWEEN (2, 2) AND (3, 3)
;SELECT (2, 2) BETWEEN (2, NULL) AND (3, 3)
;SELECT (NULL, 4) IN (SELECT * FROM v0)
;SELECT (NULL, 4) NOT IN (SELECT * FROM v0)
;CREATE TABLE preceding(t1, x, test001);;INSERT INTO preceding VALUES('abc', 1, 'i');;INSERT INTO v0 VALUES('def', 2, 'iii');;INSERT INTO v0 VALUES('ghi', 3, 'vi');;
;SELECT c0 FROM t0 WHERE c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE +c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE (c0 COLLATE nocase, c0) IS NOT (SELECT 'def', 2);;
;SELECT following FROM v0 WHERE (over, over) = (SELECT 2, 'def');;INSERT INTO v0 VALUES(3, 3, 3);SELECT * FROM t0 WHERE (c0, c0) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM v0 WHERE (following, following) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;CREATE TABLE last_field(test002);;INSERT INTO last_field VALUES(3, 3, 3);;INSERT INTO last_field VALUES(4, 4, 4);;INSERT INTO t0 VALUES(5, 5, 5);SELECT following FROM v0 WHERE (over, following) > (2, 2)
;SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 96
parser: Return. Stack=[SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[SELECT distinct selcollist from WHERE]
parser: Input 'NOT' in state 93
parser: Shift 'NOT', go to state 105
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT]
parser: Input 'LP' in state 105
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP nexprlist COMMA]
parser: Input 'NULL' in state 91
parser: Shift 'NULL', pending reduce 167
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP nexprlist COMMA NULL]
parser: Input 'COMMA' with pending reduce 167
parser: Reduce 167 [term ::= NULL|FLOAT|BLOB], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP nexprlist COMMA term RP]
parser: Input 'LE' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 105.
parser: ... then shift 'expr', go to state 75
parser: Shift 'LE', go to state 118
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr LE]
parser: Input 'LP' in state 118
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr LE LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr LE LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr LE LP nexprlist COMMA]
parser: Input 'NULL' in state 91
parser: Shift 'NULL', pending reduce 167
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr LE LP nexprlist COMMA NULL]
parser: Input 'COMMA' with pending reduce 167
parser: Reduce 167 [term ::= NULL|FLOAT|BLOB], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr LE LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr LE LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr LE LP nexprlist COMMA term RP]
parser: Input 'SEMI' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 118.
parser: ... then shift 'expr', go to state 130
parser: Reduce 181 [expr ::= expr LT|GT|GE|LE expr], go to state 105.
parser: ... then shift 'expr', go to state 75
parser: Reduce 194 [expr ::= NOT expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT (1, NULL, 3) >= (1, NULL, 3)
;SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, NULL, 3)
;CREATE TABLE v0(over, following);;INSERT INTO t0 VALUES(3, 5);;INSERT INTO v0 VALUES(3, 6);SELECT (1, 1) == (SELECT c0,c0 FROM t0 ORDER BY c0, c0)
;SELECT (1, 1) == (SELECT * FROM t0 ORDER BY c0, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0, c0)
  
;SELECT (SELECT * FROM t0 ORDER BY c0, c0 DESC) == (SELECT * FROM t0 ORDER BY c0, c0 DESC)
  
;SELECT (3, 6) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
  
;SELECT ((3, 5)) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (SELECT 3, 5) == (SELECT c0,c0 FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT * FROM t0 ORDER BY c0 DESC, c0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (2, 2) BETWEEN (2, 2) AND (3, 3)
;SELECT (2, 2) BETWEEN (2, NULL) AND (3, 3)
;SELECT (NULL, 4) IN (SELECT * FROM v0)
;SELECT (NULL, 4) NOT IN (SELECT * FROM v0)
;CREATE TABLE preceding(t1, x, test001);;INSERT INTO preceding VALUES('abc', 1, 'i');;INSERT INTO v0 VALUES('def', 2, 'iii');;INSERT INTO v0 VALUES('ghi', 3, 'vi');;
;SELECT c0 FROM t0 WHERE c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE +c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE (c0 COLLATE nocase, c0) IS NOT (SELECT 'def', 2);;
;SELECT following FROM v0 WHERE (over, over) = (SELECT 2, 'def');;INSERT INTO v0 VALUES(3, 3, 3);SELECT * FROM t0 WHERE (c0, c0) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM v0 WHERE (following, following) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;CREATE TABLE last_field(test002);;INSERT INTO last_field VALUES(3, 3, 3);;INSERT INTO last_field VALUES(4, 4, 4);;INSERT INTO t0 VALUES(5, 5, 5);SELECT following FROM v0 WHERE (over, following) > (2, 2)
;SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'LP' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct sclp scanpt LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA]
parser: Input 'NULL' in state 91
parser: Shift 'NULL', pending reduce 167
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA NULL]
parser: Input 'COMMA' with pending reduce 167
parser: Reduce 167 [term ::= NULL|FLOAT|BLOB], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA term RP]
parser: Input 'GE' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Shift 'GE', go to state 118
parser: Return. Stack=[SELECT distinct sclp scanpt expr GE]
parser: Input 'LP' in state 118
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct sclp scanpt expr GE LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt expr GE LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt expr GE LP nexprlist COMMA]
parser: Input 'NULL' in state 91
parser: Shift 'NULL', pending reduce 167
parser: Return. Stack=[SELECT distinct sclp scanpt expr GE LP nexprlist COMMA NULL]
parser: Input 'COMMA' with pending reduce 167
parser: Reduce 167 [term ::= NULL|FLOAT|BLOB], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt expr GE LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt expr GE LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct sclp scanpt expr GE LP nexprlist COMMA term RP]
parser: Input 'SEMI' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 118.
parser: ... then shift 'expr', go to state 130
parser: Reduce 181 [expr ::= expr LT|GT|GE|LE expr], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Reduce 100 [from ::=].
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT * FROM t0 WHERE NOT (1, NULL, 3) >= (1, NULL, 3)
;CREATE TABLE v0(over, following);;INSERT INTO t0 VALUES(3, 5);;INSERT INTO v0 VALUES(3, 6);SELECT (1, 1) == (SELECT c0,c0 FROM t0 ORDER BY c0, c0)
;SELECT (1, 1) == (SELECT * FROM t0 ORDER BY c0, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0, c0)
  
;SELECT (SELECT * FROM t0 ORDER BY c0, c0 DESC) == (SELECT * FROM t0 ORDER BY c0, c0 DESC)
  
;SELECT (3, 6) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
  
;SELECT ((3, 5)) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (SELECT 3, 5) == (SELECT c0,c0 FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT * FROM t0 ORDER BY c0 DESC, c0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (2, 2) BETWEEN (2, 2) AND (3, 3)
;SELECT (2, 2) BETWEEN (2, NULL) AND (3, 3)
;SELECT (NULL, 4) IN (SELECT * FROM v0)
;SELECT (NULL, 4) NOT IN (SELECT * FROM v0)
;CREATE TABLE preceding(t1, x, test001);;INSERT INTO preceding VALUES('abc', 1, 'i');;INSERT INTO v0 VALUES('def', 2, 'iii');;INSERT INTO v0 VALUES('ghi', 3, 'vi');;
;SELECT c0 FROM t0 WHERE c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE +c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE (c0 COLLATE nocase, c0) IS NOT (SELECT 'def', 2);;
;SELECT following FROM v0 WHERE (over, over) = (SELECT 2, 'def');;INSERT INTO v0 VALUES(3, 3, 3);SELECT * FROM t0 WHERE (c0, c0) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM v0 WHERE (following, following) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;CREATE TABLE last_field(test002);;INSERT INTO last_field VALUES(3, 3, 3);;INSERT INTO last_field VALUES(4, 4, 4);;INSERT INTO t0 VALUES(5, 5, 5);SELECT following FROM v0 WHERE (over, following) > (2, 2)
;SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 96
parser: Return. Stack=[SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[SELECT distinct selcollist from WHERE]
parser: Input 'NOT' in state 93
parser: Shift 'NOT', go to state 105
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT]
parser: Input 'LP' in state 105
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP nexprlist COMMA]
parser: Input 'NULL' in state 91
parser: Shift 'NULL', pending reduce 167
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP nexprlist COMMA NULL]
parser: Input 'COMMA' with pending reduce 167
parser: Reduce 167 [term ::= NULL|FLOAT|BLOB], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT LP nexprlist COMMA term RP]
parser: Input 'GE' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 105.
parser: ... then shift 'expr', go to state 75
parser: Shift 'GE', go to state 118
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr GE]
parser: Input 'LP' in state 118
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr GE LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr GE LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr GE LP nexprlist COMMA]
parser: Input 'NULL' in state 91
parser: Shift 'NULL', pending reduce 167
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr GE LP nexprlist COMMA NULL]
parser: Input 'COMMA' with pending reduce 167
parser: Reduce 167 [term ::= NULL|FLOAT|BLOB], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr GE LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr GE LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct selcollist from WHERE NOT expr GE LP nexprlist COMMA term RP]
parser: Input 'SEMI' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 118.
parser: ... then shift 'expr', go to state 130
parser: Reduce 181 [expr ::= expr LT|GT|GE|LE expr], go to state 105.
parser: ... then shift 'expr', go to state 75
parser: Reduce 194 [expr ::= NOT expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[CREATE TABLE v0(over, following);;INSERT INTO t0 VALUES(3, 5);;INSERT INTO v0 VALUES(3, 6);SELECT (1, 1) == (SELECT c0,c0 FROM t0 ORDER BY c0, c0)
;SELECT (1, 1) == (SELECT * FROM t0 ORDER BY c0, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0, c0)
  
;SELECT (SELECT * FROM t0 ORDER BY c0, c0 DESC) == (SELECT * FROM t0 ORDER BY c0, c0 DESC)
  
;SELECT (3, 6) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
  
;SELECT ((3, 5)) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (SELECT 3, 5) == (SELECT c0,c0 FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT * FROM t0 ORDER BY c0 DESC, c0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (2, 2) BETWEEN (2, 2) AND (3, 3)
;SELECT (2, 2) BETWEEN (2, NULL) AND (3, 3)
;SELECT (NULL, 4) IN (SELECT * FROM v0)
;SELECT (NULL, 4) NOT IN (SELECT * FROM v0)
;CREATE TABLE preceding(t1, x, test001);;INSERT INTO preceding VALUES('abc', 1, 'i');;INSERT INTO v0 VALUES('def', 2, 'iii');;INSERT INTO v0 VALUES('ghi', 3, 'vi');;
;SELECT c0 FROM t0 WHERE c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE +c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE (c0 COLLATE nocase, c0) IS NOT (SELECT 'def', 2);;
;SELECT following FROM v0 WHERE (over, over) = (SELECT 2, 'def');;INSERT INTO v0 VALUES(3, 3, 3);SELECT * FROM t0 WHERE (c0, c0) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM v0 WHERE (following, following) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;CREATE TABLE last_field(test002);;INSERT INTO last_field VALUES(3, 3, 3);;INSERT INTO last_field VALUES(4, 4, 4);;INSERT INTO t0 VALUES(5, 5, 5);SELECT following FROM v0 WHERE (over, following) > (2, 2)
;SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 388
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP ID]
parser: Input 'COMMA' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 190
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 376
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 150
parser: Reduce 330 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'FOLLOWING' in state 34
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', pending reduce 331
parser: Return. Stack=[create_table LP columnlist COMMA FOLLOWING]
parser: Input 'RP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 190
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 383
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 151
parser: Reduce 329 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Reduce 60 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 538
parser: Shift 'RP', go to state 361
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 361
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: [[[UPDATE 'main'.sqlite_master SET type='table', name='v0', tbl_name='v0', rootpage=#2, sql='CREATE TABLE v0(over, following)' WHERE rowid=#1]]]
parser: Input 'UPDATE' in state 0
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'UPDATE', go to state 299
parser: Return. Stack=[with UPDATE]
parser: Input 'STRING' in state 299
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', go to state 165
parser: Shift 'STRING', pending reduce 332
parser: Return. Stack=[with UPDATE orconf STRING]
parser: Input 'DOT' with pending reduce 332
parser: Reduce 332 [nm ::= STRING], go to state 165.
parser: ... then shift 'nm', go to state 393
parser: Shift 'DOT', go to state 218
parser: Return. Stack=[with UPDATE orconf nm DOT]
parser: Input 'ID' in state 218
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf nm DOT ID]
parser: Input 'SET' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 218.
parser: ... then shift 'nm', go to state 429
parser: Reduce 113 [xfullname ::= nm DOT nm], go to state 165.
parser: ... then shift 'xfullname', go to state 271
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 428
parser: Shift 'SET', go to state 153
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET]
parser: Input 'ID' in state 153
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 153.
parser: ... then shift 'nm', go to state 442
parser: Shift 'EQ', go to state 84
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ]
parser: Input 'STRING' in state 84
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 84.
parser: ... then shift 'term', go to state 58
parser: Reduce 148 [setlist ::= nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'VARIABLE' in state 86
parser: Shift 'VARIABLE', pending reduce 170
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ VARIABLE]
parser: Input 'COMMA' with pending reduce 170
parser: Reduce 170 [expr ::= VARIABLE], go to state 86.
parser: ... then shift 'expr', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'WHERE' in state 537
parser: Reduce 168 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 416
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr EQ]
parser: Input 'VARIABLE' in state 117
parser: Shift 'VARIABLE', pending reduce 170
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr EQ VARIABLE]
parser: Input 'SEMI' with pending reduce 170
parser: Reduce 170 [expr ::= VARIABLE], go to state 117.
parser: ... then shift 'expr', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 270.
parser: ... then shift 'where_opt', pending reduce 145
parser: Reduce 145 [cmd ::= with UPDATE orconf xfullname indexed_opt SET setlist where_opt], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Input '$' with pending reduce 321
parser: Reduce 321 [ecmd ::= cmdx SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 317 [input ::= cmdlist], go to state 0.
parser: ... then shift 'input', pending reduce -2
parser: Accept!
parser: ... then shift 'create_table_args', pending reduce 328
parser: Reduce 328 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='v0' AND type!='trigger' ORDER BY rowid]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'FROM' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'STRING' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'STRING', pending reduce 332
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix STRING]
parser: Input 'DOT' with pending reduce 332
parser: Reduce 332 [nm ::= STRING], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Shift 'DOT', go to state 245
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID' in state 245
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 245.
parser: ... then shift 'nm', pending reduce 109
parser: Reduce 109 [dbnm ::= DOT nm], go to state 349.
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[SELECT distinct selcollist from WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND' in state 537
parser: Reduce 168 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'AND', go to state 120
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID' in state 120
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'NE' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Shift 'NE', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr NE]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr NE STRING]
parser: Input 'ORDER' in state 537
parser: Reduce 168 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Reduce 179 [expr ::= expr AND expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[CREATE TABLE v0(over, following)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 388
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP ID]
parser: Input 'COMMA' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 190
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 376
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 150
parser: Reduce 330 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'FOLLOWING' in state 34
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', pending reduce 331
parser: Return. Stack=[create_table LP columnlist COMMA FOLLOWING]
parser: Input 'RP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 190
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 383
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 151
parser: Reduce 329 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Reduce 60 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 538
parser: Shift 'RP', go to state 361
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 361
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 328
parser: Reduce 328 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[;INSERT INTO t0 VALUES(3, 5);;INSERT INTO v0 VALUES(3, 6);SELECT (1, 1) == (SELECT c0,c0 FROM t0 ORDER BY c0, c0)
;SELECT (1, 1) == (SELECT * FROM t0 ORDER BY c0, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0, c0)
  
;SELECT (SELECT * FROM t0 ORDER BY c0, c0 DESC) == (SELECT * FROM t0 ORDER BY c0, c0 DESC)
  
;SELECT (3, 6) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
  
;SELECT ((3, 5)) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (SELECT 3, 5) == (SELECT c0,c0 FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT * FROM t0 ORDER BY c0 DESC, c0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (2, 2) BETWEEN (2, 2) AND (3, 3)
;SELECT (2, 2) BETWEEN (2, NULL) AND (3, 3)
;SELECT (NULL, 4) IN (SELECT * FROM v0)
;SELECT (NULL, 4) NOT IN (SELECT * FROM v0)
;CREATE TABLE preceding(t1, x, test001);;INSERT INTO preceding VALUES('abc', 1, 'i');;INSERT INTO v0 VALUES('def', 2, 'iii');;INSERT INTO v0 VALUES('ghi', 3, 'vi');;
;SELECT c0 FROM t0 WHERE c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE +c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE (c0 COLLATE nocase, c0) IS NOT (SELECT 'def', 2);;
;SELECT following FROM v0 WHERE (over, over) = (SELECT 2, 'def');;INSERT INTO v0 VALUES(3, 3, 3);SELECT * FROM t0 WHERE (c0, c0) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM v0 WHERE (following, following) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;CREATE TABLE last_field(test002);;INSERT INTO last_field VALUES(3, 3, 3);;INSERT INTO last_field VALUES(4, 4, 4);;INSERT INTO t0 VALUES(5, 5, 5);SELECT following FROM v0 WHERE (over, following) > (2, 2)
;SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'INSERT' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'INSERT', go to state 311
parser: Return. Stack=[ecmd with INSERT]
parser: Input 'INTO' in state 311
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', pending reduce 156
parser: Reduce 156 [insert_cmd ::= INSERT orconf], go to state 219.
parser: ... then shift 'insert_cmd', go to state 427
parser: Shift 'INTO', go to state 164
parser: Return. Stack=[ecmd with insert_cmd INTO]
parser: Input 'ID' in state 164
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd with insert_cmd INTO ID]
parser: Input 'VALUES' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 164.
parser: ... then shift 'nm', go to state 393
parser: Reduce 112 [xfullname ::= nm], go to state 164.
parser: ... then shift 'xfullname', go to state 298
parser: Reduce 158 [idlist_opt ::=].
parser: ... then shift 'idlist_opt', go to state 35
parser: Shift 'VALUES', go to state 526
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES]
parser: Input 'LP' in state 526
parser: Shift 'LP', go to state 28
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP]
parser: Input 'INTEGER' in state 28
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 28.
parser: ... then shift 'term', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'INTEGER' in state 107
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'RP', pending reduce 89
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist RP]
parser: Input 'SEMI' with pending reduce 89
parser: Reduce 89 [values ::= VALUES LP nexprlist RP], go to state 35.
parser: ... then shift 'values', go to state 532
parser: Reduce 348 [oneselect ::= values], go to state 35.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 35.
parser: ... then shift 'select', go to state 297
parser: Reduce 152 [upsert ::=].
parser: ... then shift 'upsert', pending reduce 150
parser: Reduce 150 [cmd ::= with insert_cmd INTO xfullname idlist_opt select upsert], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
parser: [[[;INSERT INTO v0 VALUES(3, 6);SELECT (1, 1) == (SELECT c0,c0 FROM t0 ORDER BY c0, c0)
;SELECT (1, 1) == (SELECT * FROM t0 ORDER BY c0, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0, c0)
  
;SELECT (SELECT * FROM t0 ORDER BY c0, c0 DESC) == (SELECT * FROM t0 ORDER BY c0, c0 DESC)
  
;SELECT (3, 6) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
  
;SELECT ((3, 5)) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (SELECT 3, 5) == (SELECT c0,c0 FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT * FROM t0 ORDER BY c0 DESC, c0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (2, 2) BETWEEN (2, 2) AND (3, 3)
;SELECT (2, 2) BETWEEN (2, NULL) AND (3, 3)
;SELECT (NULL, 4) IN (SELECT * FROM v0)
;SELECT (NULL, 4) NOT IN (SELECT * FROM v0)
;CREATE TABLE preceding(t1, x, test001);;INSERT INTO preceding VALUES('abc', 1, 'i');;INSERT INTO v0 VALUES('def', 2, 'iii');;INSERT INTO v0 VALUES('ghi', 3, 'vi');;
;SELECT c0 FROM t0 WHERE c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE +c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE (c0 COLLATE nocase, c0) IS NOT (SELECT 'def', 2);;
;SELECT following FROM v0 WHERE (over, over) = (SELECT 2, 'def');;INSERT INTO v0 VALUES(3, 3, 3);SELECT * FROM t0 WHERE (c0, c0) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM v0 WHERE (following, following) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;CREATE TABLE last_field(test002);;INSERT INTO last_field VALUES(3, 3, 3);;INSERT INTO last_field VALUES(4, 4, 4);;INSERT INTO t0 VALUES(5, 5, 5);SELECT following FROM v0 WHERE (over, following) > (2, 2)
;SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'INSERT' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'INSERT', go to state 311
parser: Return. Stack=[ecmd with INSERT]
parser: Input 'INTO' in state 311
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', pending reduce 156
parser: Reduce 156 [insert_cmd ::= INSERT orconf], go to state 219.
parser: ... then shift 'insert_cmd', go to state 427
parser: Shift 'INTO', go to state 164
parser: Return. Stack=[ecmd with insert_cmd INTO]
parser: Input 'ID' in state 164
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd with insert_cmd INTO ID]
parser: Input 'VALUES' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 164.
parser: ... then shift 'nm', go to state 393
parser: Reduce 112 [xfullname ::= nm], go to state 164.
parser: ... then shift 'xfullname', go to state 298
parser: Reduce 158 [idlist_opt ::=].
parser: ... then shift 'idlist_opt', go to state 35
parser: Shift 'VALUES', go to state 526
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES]
parser: Input 'LP' in state 526
parser: Shift 'LP', go to state 28
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP]
parser: Input 'INTEGER' in state 28
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 28.
parser: ... then shift 'term', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'INTEGER' in state 107
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'RP', pending reduce 89
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist RP]
parser: Input 'SEMI' with pending reduce 89
parser: Reduce 89 [values ::= VALUES LP nexprlist RP], go to state 35.
parser: ... then shift 'values', go to state 532
parser: Reduce 348 [oneselect ::= values], go to state 35.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 35.
parser: ... then shift 'select', go to state 297
parser: Reduce 152 [upsert ::=].
parser: ... then shift 'upsert', pending reduce 150
parser: Reduce 150 [cmd ::= with insert_cmd INTO xfullname idlist_opt select upsert], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
parser: [[[SELECT (1, 1) == (SELECT c0,c0 FROM t0 ORDER BY c0, c0)
;SELECT (1, 1) == (SELECT * FROM t0 ORDER BY c0, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0, c0)
  
;SELECT (SELECT * FROM t0 ORDER BY c0, c0 DESC) == (SELECT * FROM t0 ORDER BY c0, c0 DESC)
  
;SELECT (3, 6) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
  
;SELECT ((3, 5)) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (SELECT 3, 5) == (SELECT c0,c0 FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT * FROM t0 ORDER BY c0 DESC, c0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (2, 2) BETWEEN (2, 2) AND (3, 3)
;SELECT (2, 2) BETWEEN (2, NULL) AND (3, 3)
;SELECT (NULL, 4) IN (SELECT * FROM v0)
;SELECT (NULL, 4) NOT IN (SELECT * FROM v0)
;CREATE TABLE preceding(t1, x, test001);;INSERT INTO preceding VALUES('abc', 1, 'i');;INSERT INTO v0 VALUES('def', 2, 'iii');;INSERT INTO v0 VALUES('ghi', 3, 'vi');;
;SELECT c0 FROM t0 WHERE c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE +c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE (c0 COLLATE nocase, c0) IS NOT (SELECT 'def', 2);;
;SELECT following FROM v0 WHERE (over, over) = (SELECT 2, 'def');;INSERT INTO v0 VALUES(3, 3, 3);SELECT * FROM t0 WHERE (c0, c0) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM v0 WHERE (following, following) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;CREATE TABLE last_field(test002);;INSERT INTO last_field VALUES(3, 3, 3);;INSERT INTO last_field VALUES(4, 4, 4);;INSERT INTO t0 VALUES(5, 5, 5);SELECT following FROM v0 WHERE (over, following) > (2, 2)
;SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'LP' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct sclp scanpt LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA term RP]
parser: Input 'EQ' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ]
parser: Input 'LP' in state 117
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP]
parser: Input 'SELECT' in state 4
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct sclp scanpt ID]
parser: Input 'FROM' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ORDER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Shift 'COMMA', go to state 95
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY sortlist COMMA]
parser: Input 'ID' in state 95
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY sortlist COMMA ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 95.
parser: ... then shift 'expr', go to state 14
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 129
parser: Reduce 129 [sortlist ::= sortlist COMMA expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 4.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 4.
parser: ... then shift 'select', go to state 483
parser: Shift 'RP', pending reduce 203
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP select RP]
parser: Input 'SEMI' with pending reduce 203
parser: Reduce 203 [expr ::= LP select RP], go to state 117.
parser: ... then shift 'expr', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Reduce 100 [from ::=].
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT (1, 1) == (SELECT * FROM t0 ORDER BY c0, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0, c0)
  
;SELECT (SELECT * FROM t0 ORDER BY c0, c0 DESC) == (SELECT * FROM t0 ORDER BY c0, c0 DESC)
  
;SELECT (3, 6) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
  
;SELECT ((3, 5)) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (SELECT 3, 5) == (SELECT c0,c0 FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT * FROM t0 ORDER BY c0 DESC, c0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (2, 2) BETWEEN (2, 2) AND (3, 3)
;SELECT (2, 2) BETWEEN (2, NULL) AND (3, 3)
;SELECT (NULL, 4) IN (SELECT * FROM v0)
;SELECT (NULL, 4) NOT IN (SELECT * FROM v0)
;CREATE TABLE preceding(t1, x, test001);;INSERT INTO preceding VALUES('abc', 1, 'i');;INSERT INTO v0 VALUES('def', 2, 'iii');;INSERT INTO v0 VALUES('ghi', 3, 'vi');;
;SELECT c0 FROM t0 WHERE c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE +c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE (c0 COLLATE nocase, c0) IS NOT (SELECT 'def', 2);;
;SELECT following FROM v0 WHERE (over, over) = (SELECT 2, 'def');;INSERT INTO v0 VALUES(3, 3, 3);SELECT * FROM t0 WHERE (c0, c0) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM v0 WHERE (following, following) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;CREATE TABLE last_field(test002);;INSERT INTO last_field VALUES(3, 3, 3);;INSERT INTO last_field VALUES(4, 4, 4);;INSERT INTO t0 VALUES(5, 5, 5);SELECT following FROM v0 WHERE (over, following) > (2, 2)
;SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'LP' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct sclp scanpt LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA term RP]
parser: Input 'EQ' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ]
parser: Input 'LP' in state 117
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP]
parser: Input 'SELECT' in state 4
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 96
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ORDER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Shift 'COMMA', go to state 95
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY sortlist COMMA]
parser: Input 'ID' in state 95
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY sortlist COMMA ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 95.
parser: ... then shift 'expr', go to state 14
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 129
parser: Reduce 129 [sortlist ::= sortlist COMMA expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 4.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 4.
parser: ... then shift 'select', go to state 483
parser: Shift 'RP', pending reduce 203
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP select RP]
parser: Input 'SEMI' with pending reduce 203
parser: Reduce 203 [expr ::= LP select RP], go to state 117.
parser: ... then shift 'expr', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Reduce 100 [from ::=].
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0, c0)
  
;SELECT (SELECT * FROM t0 ORDER BY c0, c0 DESC) == (SELECT * FROM t0 ORDER BY c0, c0 DESC)
  
;SELECT (3, 6) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
  
;SELECT ((3, 5)) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (SELECT 3, 5) == (SELECT c0,c0 FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT * FROM t0 ORDER BY c0 DESC, c0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (2, 2) BETWEEN (2, 2) AND (3, 3)
;SELECT (2, 2) BETWEEN (2, NULL) AND (3, 3)
;SELECT (NULL, 4) IN (SELECT * FROM v0)
;SELECT (NULL, 4) NOT IN (SELECT * FROM v0)
;CREATE TABLE preceding(t1, x, test001);;INSERT INTO preceding VALUES('abc', 1, 'i');;INSERT INTO v0 VALUES('def', 2, 'iii');;INSERT INTO v0 VALUES('ghi', 3, 'vi');;
;SELECT c0 FROM t0 WHERE c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE +c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE (c0 COLLATE nocase, c0) IS NOT (SELECT 'def', 2);;
;SELECT following FROM v0 WHERE (over, over) = (SELECT 2, 'def');;INSERT INTO v0 VALUES(3, 3, 3);SELECT * FROM t0 WHERE (c0, c0) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM v0 WHERE (following, following) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;CREATE TABLE last_field(test002);;INSERT INTO last_field VALUES(3, 3, 3);;INSERT INTO last_field VALUES(4, 4, 4);;INSERT INTO t0 VALUES(5, 5, 5);SELECT following FROM v0 WHERE (over, following) > (2, 2)
;SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'LP' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct sclp scanpt LP]
parser: Input 'SELECT' in state 4
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT distinct sclp scanpt LP SELECT]
parser: Input 'INTEGER' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt LP SELECT distinct sclp scanpt INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 77.
parser: ... then shift 'term', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct sclp scanpt LP SELECT distinct selcollist COMMA]
parser: Input 'INTEGER' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt LP SELECT distinct sclp scanpt INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 77.
parser: ... then shift 'term', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Reduce 100 [from ::=].
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 4.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 4.
parser: ... then shift 'select', go to state 483
parser: Shift 'RP', pending reduce 203
parser: Return. Stack=[SELECT distinct sclp scanpt LP select RP]
parser: Input 'EQ' with pending reduce 203
parser: Reduce 203 [expr ::= LP select RP], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ]
parser: Input 'LP' in state 117
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP]
parser: Input 'SELECT' in state 4
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 96
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ORDER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Shift 'COMMA', go to state 95
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY sortlist COMMA]
parser: Input 'ID' in state 95
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY sortlist COMMA ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 95.
parser: ... then shift 'expr', go to state 14
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 129
parser: Reduce 129 [sortlist ::= sortlist COMMA expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 4.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 4.
parser: ... then shift 'select', go to state 483
parser: Shift 'RP', pending reduce 203
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP select RP]
parser: Input 'SEMI' with pending reduce 203
parser: Reduce 203 [expr ::= LP select RP], go to state 117.
parser: ... then shift 'expr', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Reduce 100 [from ::=].
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT (SELECT * FROM t0 ORDER BY c0, c0 DESC) == (SELECT * FROM t0 ORDER BY c0, c0 DESC)
  
;SELECT (3, 6) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
  
;SELECT ((3, 5)) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (SELECT 3, 5) == (SELECT c0,c0 FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT * FROM t0 ORDER BY c0 DESC, c0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (2, 2) BETWEEN (2, 2) AND (3, 3)
;SELECT (2, 2) BETWEEN (2, NULL) AND (3, 3)
;SELECT (NULL, 4) IN (SELECT * FROM v0)
;SELECT (NULL, 4) NOT IN (SELECT * FROM v0)
;CREATE TABLE preceding(t1, x, test001);;INSERT INTO preceding VALUES('abc', 1, 'i');;INSERT INTO v0 VALUES('def', 2, 'iii');;INSERT INTO v0 VALUES('ghi', 3, 'vi');;
;SELECT c0 FROM t0 WHERE c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE +c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE (c0 COLLATE nocase, c0) IS NOT (SELECT 'def', 2);;
;SELECT following FROM v0 WHERE (over, over) = (SELECT 2, 'def');;INSERT INTO v0 VALUES(3, 3, 3);SELECT * FROM t0 WHERE (c0, c0) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM v0 WHERE (following, following) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;CREATE TABLE last_field(test002);;INSERT INTO last_field VALUES(3, 3, 3);;INSERT INTO last_field VALUES(4, 4, 4);;INSERT INTO t0 VALUES(5, 5, 5);SELECT following FROM v0 WHERE (over, following) > (2, 2)
;SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'LP' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct sclp scanpt LP]
parser: Input 'SELECT' in state 4
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT distinct sclp scanpt LP SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 96
parser: Return. Stack=[SELECT distinct sclp scanpt LP SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct sclp scanpt LP SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct sclp scanpt LP SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ORDER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt LP SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt LP SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt LP SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Shift 'COMMA', go to state 95
parser: Return. Stack=[SELECT distinct sclp scanpt LP SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY sortlist COMMA]
parser: Input 'ID' in state 95
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt LP SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY sortlist COMMA ID]
parser: Input 'DESC' in state 416
parser: FALLBACK DESC => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 95.
parser: ... then shift 'expr', go to state 14
parser: Shift 'DESC', pending reduce 132
parser: Return. Stack=[SELECT distinct sclp scanpt LP SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY sortlist COMMA expr DESC]
parser: Input 'RP' with pending reduce 132
parser: Reduce 132 [sortorder ::= DESC], go to state 14.
parser: ... then shift 'sortorder', pending reduce 129
parser: Reduce 129 [sortlist ::= sortlist COMMA expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 4.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 4.
parser: ... then shift 'select', go to state 483
parser: Shift 'RP', pending reduce 203
parser: Return. Stack=[SELECT distinct sclp scanpt LP select RP]
parser: Input 'EQ' with pending reduce 203
parser: Reduce 203 [expr ::= LP select RP], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ]
parser: Input 'LP' in state 117
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP]
parser: Input 'SELECT' in state 4
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 96
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ORDER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Shift 'COMMA', go to state 95
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY sortlist COMMA]
parser: Input 'ID' in state 95
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY sortlist COMMA ID]
parser: Input 'DESC' in state 416
parser: FALLBACK DESC => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 95.
parser: ... then shift 'expr', go to state 14
parser: Shift 'DESC', pending reduce 132
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY sortlist COMMA expr DESC]
parser: Input 'RP' with pending reduce 132
parser: Reduce 132 [sortorder ::= DESC], go to state 14.
parser: ... then shift 'sortorder', pending reduce 129
parser: Reduce 129 [sortlist ::= sortlist COMMA expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 4.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 4.
parser: ... then shift 'select', go to state 483
parser: Shift 'RP', pending reduce 203
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP select RP]
parser: Input 'SEMI' with pending reduce 203
parser: Reduce 203 [expr ::= LP select RP], go to state 117.
parser: ... then shift 'expr', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Reduce 100 [from ::=].
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT (3, 6) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
  
;SELECT ((3, 5)) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (SELECT 3, 5) == (SELECT c0,c0 FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT * FROM t0 ORDER BY c0 DESC, c0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (2, 2) BETWEEN (2, 2) AND (3, 3)
;SELECT (2, 2) BETWEEN (2, NULL) AND (3, 3)
;SELECT (NULL, 4) IN (SELECT * FROM v0)
;SELECT (NULL, 4) NOT IN (SELECT * FROM v0)
;CREATE TABLE preceding(t1, x, test001);;INSERT INTO preceding VALUES('abc', 1, 'i');;INSERT INTO v0 VALUES('def', 2, 'iii');;INSERT INTO v0 VALUES('ghi', 3, 'vi');;
;SELECT c0 FROM t0 WHERE c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE +c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE (c0 COLLATE nocase, c0) IS NOT (SELECT 'def', 2);;
;SELECT following FROM v0 WHERE (over, over) = (SELECT 2, 'def');;INSERT INTO v0 VALUES(3, 3, 3);SELECT * FROM t0 WHERE (c0, c0) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM v0 WHERE (following, following) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;CREATE TABLE last_field(test002);;INSERT INTO last_field VALUES(3, 3, 3);;INSERT INTO last_field VALUES(4, 4, 4);;INSERT INTO t0 VALUES(5, 5, 5);SELECT following FROM v0 WHERE (over, following) > (2, 2)
;SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'LP' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct sclp scanpt LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA term RP]
parser: Input 'EQ' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ]
parser: Input 'LP' in state 117
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP]
parser: Input 'SELECT' in state 4
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 96
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ORDER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'DESC' in state 416
parser: FALLBACK DESC => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Shift 'DESC', pending reduce 132
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY expr DESC]
parser: Input 'COMMA' with pending reduce 132
parser: Reduce 132 [sortorder ::= DESC], go to state 13.
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Shift 'COMMA', go to state 95
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY sortlist COMMA]
parser: Input 'ID' in state 95
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY sortlist COMMA ID]
parser: Input 'DESC' in state 416
parser: FALLBACK DESC => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 95.
parser: ... then shift 'expr', go to state 14
parser: Shift 'DESC', pending reduce 132
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY sortlist COMMA expr DESC]
parser: Input 'RP' with pending reduce 132
parser: Reduce 132 [sortorder ::= DESC], go to state 14.
parser: ... then shift 'sortorder', pending reduce 129
parser: Reduce 129 [sortlist ::= sortlist COMMA expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 4.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 4.
parser: ... then shift 'select', go to state 483
parser: Shift 'RP', pending reduce 203
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP select RP]
parser: Input 'SEMI' with pending reduce 203
parser: Reduce 203 [expr ::= LP select RP], go to state 117.
parser: ... then shift 'expr', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Reduce 100 [from ::=].
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0 DESC)
  
;SELECT ((3, 5)) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (SELECT 3, 5) == (SELECT c0,c0 FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT * FROM t0 ORDER BY c0 DESC, c0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (2, 2) BETWEEN (2, 2) AND (3, 3)
;SELECT (2, 2) BETWEEN (2, NULL) AND (3, 3)
;SELECT (NULL, 4) IN (SELECT * FROM v0)
;SELECT (NULL, 4) NOT IN (SELECT * FROM v0)
;CREATE TABLE preceding(t1, x, test001);;INSERT INTO preceding VALUES('abc', 1, 'i');;INSERT INTO v0 VALUES('def', 2, 'iii');;INSERT INTO v0 VALUES('ghi', 3, 'vi');;
;SELECT c0 FROM t0 WHERE c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE +c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE (c0 COLLATE nocase, c0) IS NOT (SELECT 'def', 2);;
;SELECT following FROM v0 WHERE (over, over) = (SELECT 2, 'def');;INSERT INTO v0 VALUES(3, 3, 3);SELECT * FROM t0 WHERE (c0, c0) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM v0 WHERE (following, following) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;CREATE TABLE last_field(test002);;INSERT INTO last_field VALUES(3, 3, 3);;INSERT INTO last_field VALUES(4, 4, 4);;INSERT INTO t0 VALUES(5, 5, 5);SELECT following FROM v0 WHERE (over, following) > (2, 2)
;SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'LP' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct sclp scanpt LP]
parser: Input 'SELECT' in state 4
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT distinct sclp scanpt LP SELECT]
parser: Input 'INTEGER' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt LP SELECT distinct sclp scanpt INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 77.
parser: ... then shift 'term', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct sclp scanpt LP SELECT distinct selcollist COMMA]
parser: Input 'INTEGER' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt LP SELECT distinct sclp scanpt INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 77.
parser: ... then shift 'term', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Reduce 100 [from ::=].
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 4.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 4.
parser: ... then shift 'select', go to state 483
parser: Shift 'RP', pending reduce 203
parser: Return. Stack=[SELECT distinct sclp scanpt LP select RP]
parser: Input 'EQ' with pending reduce 203
parser: Reduce 203 [expr ::= LP select RP], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ]
parser: Input 'LP' in state 117
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP]
parser: Input 'SELECT' in state 4
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 96
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ORDER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'DESC' in state 416
parser: FALLBACK DESC => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Shift 'DESC', pending reduce 132
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY expr DESC]
parser: Input 'COMMA' with pending reduce 132
parser: Reduce 132 [sortorder ::= DESC], go to state 13.
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Shift 'COMMA', go to state 95
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY sortlist COMMA]
parser: Input 'ID' in state 95
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY sortlist COMMA ID]
parser: Input 'DESC' in state 416
parser: FALLBACK DESC => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 95.
parser: ... then shift 'expr', go to state 14
parser: Shift 'DESC', pending reduce 132
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY sortlist COMMA expr DESC]
parser: Input 'RP' with pending reduce 132
parser: Reduce 132 [sortorder ::= DESC], go to state 14.
parser: ... then shift 'sortorder', pending reduce 129
parser: Reduce 129 [sortlist ::= sortlist COMMA expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 4.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 4.
parser: ... then shift 'select', go to state 483
parser: Shift 'RP', pending reduce 203
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP select RP]
parser: Input 'SEMI' with pending reduce 203
parser: Reduce 203 [expr ::= LP select RP], go to state 117.
parser: ... then shift 'expr', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Reduce 100 [from ::=].
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT ((3, 5)) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (SELECT 3, 5) == (SELECT c0,c0 FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT * FROM t0 ORDER BY c0 DESC, c0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (2, 2) BETWEEN (2, 2) AND (3, 3)
;SELECT (2, 2) BETWEEN (2, NULL) AND (3, 3)
;SELECT (NULL, 4) IN (SELECT * FROM v0)
;SELECT (NULL, 4) NOT IN (SELECT * FROM v0)
;CREATE TABLE preceding(t1, x, test001);;INSERT INTO preceding VALUES('abc', 1, 'i');;INSERT INTO v0 VALUES('def', 2, 'iii');;INSERT INTO v0 VALUES('ghi', 3, 'vi');;
;SELECT c0 FROM t0 WHERE c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE +c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE (c0 COLLATE nocase, c0) IS NOT (SELECT 'def', 2);;
;SELECT following FROM v0 WHERE (over, over) = (SELECT 2, 'def');;INSERT INTO v0 VALUES(3, 3, 3);SELECT * FROM t0 WHERE (c0, c0) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM v0 WHERE (following, following) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;CREATE TABLE last_field(test002);;INSERT INTO last_field VALUES(3, 3, 3);;INSERT INTO last_field VALUES(4, 4, 4);;INSERT INTO t0 VALUES(5, 5, 5);SELECT following FROM v0 WHERE (over, following) > (2, 2)
;SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'LP' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct sclp scanpt LP]
parser: Input 'LP' in state 4
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct sclp scanpt LP LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt LP LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt LP LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt LP LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct sclp scanpt LP LP nexprlist COMMA term RP]
parser: Input 'RP' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 4.
parser: ... then shift 'expr', go to state 50
parser: Shift 'RP', pending reduce 162
parser: Return. Stack=[SELECT distinct sclp scanpt LP expr RP]
parser: Input 'EQ' with pending reduce 162
parser: Reduce 162 [expr ::= LP expr RP], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ]
parser: Input 'LP' in state 117
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP]
parser: Input 'SELECT' in state 4
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 96
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ORDER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'DESC' in state 416
parser: FALLBACK DESC => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Shift 'DESC', pending reduce 132
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY expr DESC]
parser: Input 'COMMA' with pending reduce 132
parser: Reduce 132 [sortorder ::= DESC], go to state 13.
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Shift 'COMMA', go to state 95
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY sortlist COMMA]
parser: Input 'ID' in state 95
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY sortlist COMMA ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 95.
parser: ... then shift 'expr', go to state 14
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 129
parser: Reduce 129 [sortlist ::= sortlist COMMA expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 4.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 4.
parser: ... then shift 'select', go to state 483
parser: Shift 'RP', pending reduce 203
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP select RP]
parser: Input 'SEMI' with pending reduce 203
parser: Reduce 203 [expr ::= LP select RP], go to state 117.
parser: ... then shift 'expr', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Reduce 100 [from ::=].
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (SELECT 3, 5) == (SELECT c0,c0 FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT * FROM t0 ORDER BY c0 DESC, c0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (2, 2) BETWEEN (2, 2) AND (3, 3)
;SELECT (2, 2) BETWEEN (2, NULL) AND (3, 3)
;SELECT (NULL, 4) IN (SELECT * FROM v0)
;SELECT (NULL, 4) NOT IN (SELECT * FROM v0)
;CREATE TABLE preceding(t1, x, test001);;INSERT INTO preceding VALUES('abc', 1, 'i');;INSERT INTO v0 VALUES('def', 2, 'iii');;INSERT INTO v0 VALUES('ghi', 3, 'vi');;
;SELECT c0 FROM t0 WHERE c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE +c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE (c0 COLLATE nocase, c0) IS NOT (SELECT 'def', 2);;
;SELECT following FROM v0 WHERE (over, over) = (SELECT 2, 'def');;INSERT INTO v0 VALUES(3, 3, 3);SELECT * FROM t0 WHERE (c0, c0) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM v0 WHERE (following, following) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;CREATE TABLE last_field(test002);;INSERT INTO last_field VALUES(3, 3, 3);;INSERT INTO last_field VALUES(4, 4, 4);;INSERT INTO t0 VALUES(5, 5, 5);SELECT following FROM v0 WHERE (over, following) > (2, 2)
;SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'LP' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct sclp scanpt LP]
parser: Input 'SELECT' in state 4
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT distinct sclp scanpt LP SELECT]
parser: Input 'INTEGER' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt LP SELECT distinct sclp scanpt INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 77.
parser: ... then shift 'term', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct sclp scanpt LP SELECT distinct selcollist COMMA]
parser: Input 'INTEGER' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt LP SELECT distinct sclp scanpt INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 77.
parser: ... then shift 'term', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Reduce 100 [from ::=].
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 4.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 4.
parser: ... then shift 'select', go to state 483
parser: Shift 'RP', pending reduce 203
parser: Return. Stack=[SELECT distinct sclp scanpt LP select RP]
parser: Input 'EQ' with pending reduce 203
parser: Reduce 203 [expr ::= LP select RP], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ]
parser: Input 'LP' in state 117
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP]
parser: Input 'SELECT' in state 4
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 96
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ORDER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'DESC' in state 416
parser: FALLBACK DESC => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Shift 'DESC', pending reduce 132
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY expr DESC]
parser: Input 'COMMA' with pending reduce 132
parser: Reduce 132 [sortorder ::= DESC], go to state 13.
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Shift 'COMMA', go to state 95
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY sortlist COMMA]
parser: Input 'ID' in state 95
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY sortlist COMMA ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 95.
parser: ... then shift 'expr', go to state 14
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 129
parser: Reduce 129 [sortlist ::= sortlist COMMA expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 4.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 4.
parser: ... then shift 'select', go to state 483
parser: Shift 'RP', pending reduce 203
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP select RP]
parser: Input 'SEMI' with pending reduce 203
parser: Reduce 203 [expr ::= LP select RP], go to state 117.
parser: ... then shift 'expr', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Reduce 100 [from ::=].
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT (SELECT 3, 5) == (SELECT c0,c0 FROM t0 ORDER BY c0 DESC, c0)
;SELECT (SELECT * FROM t0 ORDER BY c0 DESC, c0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (2, 2) BETWEEN (2, 2) AND (3, 3)
;SELECT (2, 2) BETWEEN (2, NULL) AND (3, 3)
;SELECT (NULL, 4) IN (SELECT * FROM v0)
;SELECT (NULL, 4) NOT IN (SELECT * FROM v0)
;CREATE TABLE preceding(t1, x, test001);;INSERT INTO preceding VALUES('abc', 1, 'i');;INSERT INTO v0 VALUES('def', 2, 'iii');;INSERT INTO v0 VALUES('ghi', 3, 'vi');;
;SELECT c0 FROM t0 WHERE c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE +c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE (c0 COLLATE nocase, c0) IS NOT (SELECT 'def', 2);;
;SELECT following FROM v0 WHERE (over, over) = (SELECT 2, 'def');;INSERT INTO v0 VALUES(3, 3, 3);SELECT * FROM t0 WHERE (c0, c0) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM v0 WHERE (following, following) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;CREATE TABLE last_field(test002);;INSERT INTO last_field VALUES(3, 3, 3);;INSERT INTO last_field VALUES(4, 4, 4);;INSERT INTO t0 VALUES(5, 5, 5);SELECT following FROM v0 WHERE (over, following) > (2, 2)
;SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'LP' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct sclp scanpt LP]
parser: Input 'SELECT' in state 4
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT distinct sclp scanpt LP SELECT]
parser: Input 'INTEGER' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt LP SELECT distinct sclp scanpt INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 77.
parser: ... then shift 'term', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct sclp scanpt LP SELECT distinct selcollist COMMA]
parser: Input 'INTEGER' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt LP SELECT distinct sclp scanpt INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 77.
parser: ... then shift 'term', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Reduce 100 [from ::=].
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 4.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 4.
parser: ... then shift 'select', go to state 483
parser: Shift 'RP', pending reduce 203
parser: Return. Stack=[SELECT distinct sclp scanpt LP select RP]
parser: Input 'EQ' with pending reduce 203
parser: Reduce 203 [expr ::= LP select RP], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ]
parser: Input 'LP' in state 117
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP]
parser: Input 'SELECT' in state 4
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct sclp scanpt ID]
parser: Input 'FROM' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ORDER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'DESC' in state 416
parser: FALLBACK DESC => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Shift 'DESC', pending reduce 132
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY expr DESC]
parser: Input 'COMMA' with pending reduce 132
parser: Reduce 132 [sortorder ::= DESC], go to state 13.
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Shift 'COMMA', go to state 95
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY sortlist COMMA]
parser: Input 'ID' in state 95
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY sortlist COMMA ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 95.
parser: ... then shift 'expr', go to state 14
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 129
parser: Reduce 129 [sortlist ::= sortlist COMMA expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 4.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 4.
parser: ... then shift 'select', go to state 483
parser: Shift 'RP', pending reduce 203
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP select RP]
parser: Input 'SEMI' with pending reduce 203
parser: Reduce 203 [expr ::= LP select RP], go to state 117.
parser: ... then shift 'expr', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Reduce 100 [from ::=].
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT (SELECT * FROM t0 ORDER BY c0 DESC, c0) == (SELECT * FROM t0 ORDER BY c0 DESC, c0)
  
;SELECT (2, 2) BETWEEN (2, 2) AND (3, 3)
;SELECT (2, 2) BETWEEN (2, NULL) AND (3, 3)
;SELECT (NULL, 4) IN (SELECT * FROM v0)
;SELECT (NULL, 4) NOT IN (SELECT * FROM v0)
;CREATE TABLE preceding(t1, x, test001);;INSERT INTO preceding VALUES('abc', 1, 'i');;INSERT INTO v0 VALUES('def', 2, 'iii');;INSERT INTO v0 VALUES('ghi', 3, 'vi');;
;SELECT c0 FROM t0 WHERE c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE +c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE (c0 COLLATE nocase, c0) IS NOT (SELECT 'def', 2);;
;SELECT following FROM v0 WHERE (over, over) = (SELECT 2, 'def');;INSERT INTO v0 VALUES(3, 3, 3);SELECT * FROM t0 WHERE (c0, c0) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM v0 WHERE (following, following) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;CREATE TABLE last_field(test002);;INSERT INTO last_field VALUES(3, 3, 3);;INSERT INTO last_field VALUES(4, 4, 4);;INSERT INTO t0 VALUES(5, 5, 5);SELECT following FROM v0 WHERE (over, following) > (2, 2)
;SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'LP' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct sclp scanpt LP]
parser: Input 'SELECT' in state 4
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT distinct sclp scanpt LP SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 96
parser: Return. Stack=[SELECT distinct sclp scanpt LP SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct sclp scanpt LP SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct sclp scanpt LP SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ORDER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt LP SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt LP SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt LP SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'DESC' in state 416
parser: FALLBACK DESC => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Shift 'DESC', pending reduce 132
parser: Return. Stack=[SELECT distinct sclp scanpt LP SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY expr DESC]
parser: Input 'COMMA' with pending reduce 132
parser: Reduce 132 [sortorder ::= DESC], go to state 13.
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Shift 'COMMA', go to state 95
parser: Return. Stack=[SELECT distinct sclp scanpt LP SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY sortlist COMMA]
parser: Input 'ID' in state 95
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt LP SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY sortlist COMMA ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 95.
parser: ... then shift 'expr', go to state 14
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 129
parser: Reduce 129 [sortlist ::= sortlist COMMA expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 4.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 4.
parser: ... then shift 'select', go to state 483
parser: Shift 'RP', pending reduce 203
parser: Return. Stack=[SELECT distinct sclp scanpt LP select RP]
parser: Input 'EQ' with pending reduce 203
parser: Reduce 203 [expr ::= LP select RP], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ]
parser: Input 'LP' in state 117
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP]
parser: Input 'SELECT' in state 4
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 96
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ORDER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'DESC' in state 416
parser: FALLBACK DESC => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Shift 'DESC', pending reduce 132
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY expr DESC]
parser: Input 'COMMA' with pending reduce 132
parser: Reduce 132 [sortorder ::= DESC], go to state 13.
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Shift 'COMMA', go to state 95
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY sortlist COMMA]
parser: Input 'ID' in state 95
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY sortlist COMMA ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 95.
parser: ... then shift 'expr', go to state 14
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 129
parser: Reduce 129 [sortlist ::= sortlist COMMA expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 4.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 4.
parser: ... then shift 'select', go to state 483
parser: Shift 'RP', pending reduce 203
parser: Return. Stack=[SELECT distinct sclp scanpt expr EQ LP select RP]
parser: Input 'SEMI' with pending reduce 203
parser: Reduce 203 [expr ::= LP select RP], go to state 117.
parser: ... then shift 'expr', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Reduce 100 [from ::=].
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT (2, 2) BETWEEN (2, 2) AND (3, 3)
;SELECT (2, 2) BETWEEN (2, NULL) AND (3, 3)
;SELECT (NULL, 4) IN (SELECT * FROM v0)
;SELECT (NULL, 4) NOT IN (SELECT * FROM v0)
;CREATE TABLE preceding(t1, x, test001);;INSERT INTO preceding VALUES('abc', 1, 'i');;INSERT INTO v0 VALUES('def', 2, 'iii');;INSERT INTO v0 VALUES('ghi', 3, 'vi');;
;SELECT c0 FROM t0 WHERE c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE +c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE (c0 COLLATE nocase, c0) IS NOT (SELECT 'def', 2);;
;SELECT following FROM v0 WHERE (over, over) = (SELECT 2, 'def');;INSERT INTO v0 VALUES(3, 3, 3);SELECT * FROM t0 WHERE (c0, c0) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM v0 WHERE (following, following) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;CREATE TABLE last_field(test002);;INSERT INTO last_field VALUES(3, 3, 3);;INSERT INTO last_field VALUES(4, 4, 4);;INSERT INTO t0 VALUES(5, 5, 5);SELECT following FROM v0 WHERE (over, following) > (2, 2)
;SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'LP' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct sclp scanpt LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA term RP]
parser: Input 'BETWEEN' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Shift 'BETWEEN', pending reduce 197
parser: Return. Stack=[SELECT distinct sclp scanpt expr BETWEEN]
parser: Input 'LP' with pending reduce 197
parser: Reduce 197 [between_op ::= BETWEEN], go to state 16.
parser: ... then shift 'between_op', go to state 109
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct sclp scanpt expr between_op LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt expr between_op LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt expr between_op LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt expr between_op LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct sclp scanpt expr between_op LP nexprlist COMMA term RP]
parser: Input 'AND' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 109.
parser: ... then shift 'expr', go to state 72
parser: Shift 'AND', go to state 108
parser: Return. Stack=[SELECT distinct sclp scanpt expr between_op expr AND]
parser: Input 'LP' in state 108
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct sclp scanpt expr between_op expr AND LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt expr between_op expr AND LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt expr between_op expr AND LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt expr between_op expr AND LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct sclp scanpt expr between_op expr AND LP nexprlist COMMA term RP]
parser: Input 'SEMI' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 108.
parser: ... then shift 'expr', go to state 126
parser: Reduce 199 [expr ::= expr between_op expr AND expr], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Reduce 100 [from ::=].
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT (2, 2) BETWEEN (2, NULL) AND (3, 3)
;SELECT (NULL, 4) IN (SELECT * FROM v0)
;SELECT (NULL, 4) NOT IN (SELECT * FROM v0)
;CREATE TABLE preceding(t1, x, test001);;INSERT INTO preceding VALUES('abc', 1, 'i');;INSERT INTO v0 VALUES('def', 2, 'iii');;INSERT INTO v0 VALUES('ghi', 3, 'vi');;
;SELECT c0 FROM t0 WHERE c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE +c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE (c0 COLLATE nocase, c0) IS NOT (SELECT 'def', 2);;
;SELECT following FROM v0 WHERE (over, over) = (SELECT 2, 'def');;INSERT INTO v0 VALUES(3, 3, 3);SELECT * FROM t0 WHERE (c0, c0) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM v0 WHERE (following, following) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;CREATE TABLE last_field(test002);;INSERT INTO last_field VALUES(3, 3, 3);;INSERT INTO last_field VALUES(4, 4, 4);;INSERT INTO t0 VALUES(5, 5, 5);SELECT following FROM v0 WHERE (over, following) > (2, 2)
;SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'LP' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct sclp scanpt LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA term RP]
parser: Input 'BETWEEN' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Shift 'BETWEEN', pending reduce 197
parser: Return. Stack=[SELECT distinct sclp scanpt expr BETWEEN]
parser: Input 'LP' with pending reduce 197
parser: Reduce 197 [between_op ::= BETWEEN], go to state 16.
parser: ... then shift 'between_op', go to state 109
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct sclp scanpt expr between_op LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt expr between_op LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt expr between_op LP nexprlist COMMA]
parser: Input 'NULL' in state 91
parser: Shift 'NULL', pending reduce 167
parser: Return. Stack=[SELECT distinct sclp scanpt expr between_op LP nexprlist COMMA NULL]
parser: Input 'RP' with pending reduce 167
parser: Reduce 167 [term ::= NULL|FLOAT|BLOB], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct sclp scanpt expr between_op LP nexprlist COMMA term RP]
parser: Input 'AND' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 109.
parser: ... then shift 'expr', go to state 72
parser: Shift 'AND', go to state 108
parser: Return. Stack=[SELECT distinct sclp scanpt expr between_op expr AND]
parser: Input 'LP' in state 108
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct sclp scanpt expr between_op expr AND LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt expr between_op expr AND LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt expr between_op expr AND LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt expr between_op expr AND LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct sclp scanpt expr between_op expr AND LP nexprlist COMMA term RP]
parser: Input 'SEMI' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 108.
parser: ... then shift 'expr', go to state 126
parser: Reduce 199 [expr ::= expr between_op expr AND expr], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Reduce 100 [from ::=].
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT (NULL, 4) IN (SELECT * FROM v0)
;SELECT (NULL, 4) NOT IN (SELECT * FROM v0)
;CREATE TABLE preceding(t1, x, test001);;INSERT INTO preceding VALUES('abc', 1, 'i');;INSERT INTO v0 VALUES('def', 2, 'iii');;INSERT INTO v0 VALUES('ghi', 3, 'vi');;
;SELECT c0 FROM t0 WHERE c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE +c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE (c0 COLLATE nocase, c0) IS NOT (SELECT 'def', 2);;
;SELECT following FROM v0 WHERE (over, over) = (SELECT 2, 'def');;INSERT INTO v0 VALUES(3, 3, 3);SELECT * FROM t0 WHERE (c0, c0) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM v0 WHERE (following, following) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;CREATE TABLE last_field(test002);;INSERT INTO last_field VALUES(3, 3, 3);;INSERT INTO last_field VALUES(4, 4, 4);;INSERT INTO t0 VALUES(5, 5, 5);SELECT following FROM v0 WHERE (over, following) > (2, 2)
;SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'LP' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct sclp scanpt LP]
parser: Input 'NULL' in state 4
parser: Shift 'NULL', pending reduce 167
parser: Return. Stack=[SELECT distinct sclp scanpt LP NULL]
parser: Input 'COMMA' with pending reduce 167
parser: Reduce 167 [term ::= NULL|FLOAT|BLOB], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA term RP]
parser: Input 'IN' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Shift 'IN', pending reduce 200
parser: Return. Stack=[SELECT distinct sclp scanpt expr IN]
parser: Input 'LP' with pending reduce 200
parser: Reduce 200 [in_op ::= IN], go to state 16.
parser: ... then shift 'in_op', go to state 209
parser: Shift 'LP', go to state 3
parser: Return. Stack=[SELECT distinct sclp scanpt expr in_op LP]
parser: Input 'SELECT' in state 3
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT distinct sclp scanpt expr in_op LP SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 96
parser: Return. Stack=[SELECT distinct sclp scanpt expr in_op LP SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct sclp scanpt expr in_op LP SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct sclp scanpt expr in_op LP SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'RP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 3.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 3.
parser: ... then shift 'select', go to state 518
parser: Shift 'RP', pending reduce 204
parser: Return. Stack=[SELECT distinct sclp scanpt expr in_op LP select RP]
parser: Input 'SEMI' with pending reduce 204
parser: Reduce 204 [expr ::= expr in_op LP select RP], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Reduce 100 [from ::=].
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT (NULL, 4) NOT IN (SELECT * FROM v0)
;CREATE TABLE preceding(t1, x, test001);;INSERT INTO preceding VALUES('abc', 1, 'i');;INSERT INTO v0 VALUES('def', 2, 'iii');;INSERT INTO v0 VALUES('ghi', 3, 'vi');;
;SELECT c0 FROM t0 WHERE c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE +c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE (c0 COLLATE nocase, c0) IS NOT (SELECT 'def', 2);;
;SELECT following FROM v0 WHERE (over, over) = (SELECT 2, 'def');;INSERT INTO v0 VALUES(3, 3, 3);SELECT * FROM t0 WHERE (c0, c0) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM v0 WHERE (following, following) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;CREATE TABLE last_field(test002);;INSERT INTO last_field VALUES(3, 3, 3);;INSERT INTO last_field VALUES(4, 4, 4);;INSERT INTO t0 VALUES(5, 5, 5);SELECT following FROM v0 WHERE (over, following) > (2, 2)
;SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'LP' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct sclp scanpt LP]
parser: Input 'NULL' in state 4
parser: Shift 'NULL', pending reduce 167
parser: Return. Stack=[SELECT distinct sclp scanpt LP NULL]
parser: Input 'COMMA' with pending reduce 167
parser: Reduce 167 [term ::= NULL|FLOAT|BLOB], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct sclp scanpt LP nexprlist COMMA term RP]
parser: Input 'NOT' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Shift 'NOT', go to state 384
parser: Return. Stack=[SELECT distinct sclp scanpt expr NOT]
parser: Input 'IN' in state 384
parser: Shift 'IN', pending reduce 201
parser: Return. Stack=[SELECT distinct sclp scanpt expr NOT IN]
parser: Input 'LP' with pending reduce 201
parser: Reduce 201 [in_op ::= NOT IN], go to state 16.
parser: ... then shift 'in_op', go to state 209
parser: Shift 'LP', go to state 3
parser: Return. Stack=[SELECT distinct sclp scanpt expr in_op LP]
parser: Input 'SELECT' in state 3
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT distinct sclp scanpt expr in_op LP SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 96
parser: Return. Stack=[SELECT distinct sclp scanpt expr in_op LP SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct sclp scanpt expr in_op LP SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct sclp scanpt expr in_op LP SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'RP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 3.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 3.
parser: ... then shift 'select', go to state 518
parser: Shift 'RP', pending reduce 204
parser: Return. Stack=[SELECT distinct sclp scanpt expr in_op LP select RP]
parser: Input 'SEMI' with pending reduce 204
parser: Reduce 204 [expr ::= expr in_op LP select RP], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Reduce 100 [from ::=].
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[CREATE TABLE preceding(t1, x, test001);;INSERT INTO preceding VALUES('abc', 1, 'i');;INSERT INTO v0 VALUES('def', 2, 'iii');;INSERT INTO v0 VALUES('ghi', 3, 'vi');;
;SELECT c0 FROM t0 WHERE c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE +c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE (c0 COLLATE nocase, c0) IS NOT (SELECT 'def', 2);;
;SELECT following FROM v0 WHERE (over, over) = (SELECT 2, 'def');;INSERT INTO v0 VALUES(3, 3, 3);SELECT * FROM t0 WHERE (c0, c0) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM v0 WHERE (following, following) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;CREATE TABLE last_field(test002);;INSERT INTO last_field VALUES(3, 3, 3);;INSERT INTO last_field VALUES(4, 4, 4);;INSERT INTO t0 VALUES(5, 5, 5);SELECT following FROM v0 WHERE (over, following) > (2, 2)
;SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 388
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'PRECEDING' in state 324
parser: FALLBACK PRECEDING => ID
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', pending reduce 331
parser: Return. Stack=[createkw temp TABLE ifnotexists PRECEDING]
parser: Input 'LP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP ID]
parser: Input 'COMMA' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 190
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 376
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 150
parser: Reduce 330 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'COMMA' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 190
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 383
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 151
parser: Reduce 329 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'RP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 190
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 383
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 151
parser: Reduce 329 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Reduce 60 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 538
parser: Shift 'RP', go to state 361
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 361
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: [[[UPDATE 'main'.sqlite_master SET type='table', name='preceding', tbl_name='preceding', rootpage=#2, sql='CREATE TABLE preceding(t1, x, test001)' WHERE rowid=#1]]]
parser: Input 'UPDATE' in state 0
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'UPDATE', go to state 299
parser: Return. Stack=[with UPDATE]
parser: Input 'STRING' in state 299
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', go to state 165
parser: Shift 'STRING', pending reduce 332
parser: Return. Stack=[with UPDATE orconf STRING]
parser: Input 'DOT' with pending reduce 332
parser: Reduce 332 [nm ::= STRING], go to state 165.
parser: ... then shift 'nm', go to state 393
parser: Shift 'DOT', go to state 218
parser: Return. Stack=[with UPDATE orconf nm DOT]
parser: Input 'ID' in state 218
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf nm DOT ID]
parser: Input 'SET' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 218.
parser: ... then shift 'nm', go to state 429
parser: Reduce 113 [xfullname ::= nm DOT nm], go to state 165.
parser: ... then shift 'xfullname', go to state 271
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 428
parser: Shift 'SET', go to state 153
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET]
parser: Input 'ID' in state 153
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 153.
parser: ... then shift 'nm', go to state 442
parser: Shift 'EQ', go to state 84
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ]
parser: Input 'STRING' in state 84
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 84.
parser: ... then shift 'term', go to state 58
parser: Reduce 148 [setlist ::= nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'VARIABLE' in state 86
parser: Shift 'VARIABLE', pending reduce 170
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ VARIABLE]
parser: Input 'COMMA' with pending reduce 170
parser: Reduce 170 [expr ::= VARIABLE], go to state 86.
parser: ... then shift 'expr', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'WHERE' in state 537
parser: Reduce 168 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 416
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr EQ]
parser: Input 'VARIABLE' in state 117
parser: Shift 'VARIABLE', pending reduce 170
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr EQ VARIABLE]
parser: Input 'SEMI' with pending reduce 170
parser: Reduce 170 [expr ::= VARIABLE], go to state 117.
parser: ... then shift 'expr', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 270.
parser: ... then shift 'where_opt', pending reduce 145
parser: Reduce 145 [cmd ::= with UPDATE orconf xfullname indexed_opt SET setlist where_opt], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Input '$' with pending reduce 321
parser: Reduce 321 [ecmd ::= cmdx SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 317 [input ::= cmdlist], go to state 0.
parser: ... then shift 'input', pending reduce -2
parser: Accept!
parser: ... then shift 'create_table_args', pending reduce 328
parser: Reduce 328 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='preceding' AND type!='trigger' ORDER BY rowid]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'FROM' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'STRING' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'STRING', pending reduce 332
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix STRING]
parser: Input 'DOT' with pending reduce 332
parser: Reduce 332 [nm ::= STRING], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Shift 'DOT', go to state 245
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID' in state 245
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 245.
parser: ... then shift 'nm', pending reduce 109
parser: Reduce 109 [dbnm ::= DOT nm], go to state 349.
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[SELECT distinct selcollist from WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND' in state 537
parser: Reduce 168 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'AND', go to state 120
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID' in state 120
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'NE' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Shift 'NE', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr NE]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr NE STRING]
parser: Input 'ORDER' in state 537
parser: Reduce 168 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Reduce 179 [expr ::= expr AND expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[CREATE TABLE preceding(t1, x, test001)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 388
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'PRECEDING' in state 324
parser: FALLBACK PRECEDING => ID
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', pending reduce 331
parser: Return. Stack=[createkw temp TABLE ifnotexists PRECEDING]
parser: Input 'LP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP ID]
parser: Input 'COMMA' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 190
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 376
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 150
parser: Reduce 330 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'COMMA' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 190
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 383
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 151
parser: Reduce 329 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'RP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 190
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 383
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 151
parser: Reduce 329 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Reduce 60 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 538
parser: Shift 'RP', go to state 361
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 361
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 328
parser: Reduce 328 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[;INSERT INTO preceding VALUES('abc', 1, 'i');;INSERT INTO v0 VALUES('def', 2, 'iii');;INSERT INTO v0 VALUES('ghi', 3, 'vi');;
;SELECT c0 FROM t0 WHERE c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE +c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE (c0 COLLATE nocase, c0) IS NOT (SELECT 'def', 2);;
;SELECT following FROM v0 WHERE (over, over) = (SELECT 2, 'def');;INSERT INTO v0 VALUES(3, 3, 3);SELECT * FROM t0 WHERE (c0, c0) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM v0 WHERE (following, following) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;CREATE TABLE last_field(test002);;INSERT INTO last_field VALUES(3, 3, 3);;INSERT INTO last_field VALUES(4, 4, 4);;INSERT INTO t0 VALUES(5, 5, 5);SELECT following FROM v0 WHERE (over, following) > (2, 2)
;SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'INSERT' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'INSERT', go to state 311
parser: Return. Stack=[ecmd with INSERT]
parser: Input 'INTO' in state 311
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', pending reduce 156
parser: Reduce 156 [insert_cmd ::= INSERT orconf], go to state 219.
parser: ... then shift 'insert_cmd', go to state 427
parser: Shift 'INTO', go to state 164
parser: Return. Stack=[ecmd with insert_cmd INTO]
parser: Input 'PRECEDING' in state 164
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', pending reduce 331
parser: Return. Stack=[ecmd with insert_cmd INTO PRECEDING]
parser: Input 'VALUES' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 164.
parser: ... then shift 'nm', go to state 393
parser: Reduce 112 [xfullname ::= nm], go to state 164.
parser: ... then shift 'xfullname', go to state 298
parser: Reduce 158 [idlist_opt ::=].
parser: ... then shift 'idlist_opt', go to state 35
parser: Shift 'VALUES', go to state 526
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES]
parser: Input 'LP' in state 526
parser: Shift 'LP', go to state 28
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP]
parser: Input 'STRING' in state 28
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 28.
parser: ... then shift 'term', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'INTEGER' in state 107
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'STRING' in state 107
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA STRING]
parser: Input 'RP' in state 537
parser: Reduce 168 [term ::= STRING], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'RP', pending reduce 89
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist RP]
parser: Input 'SEMI' with pending reduce 89
parser: Reduce 89 [values ::= VALUES LP nexprlist RP], go to state 35.
parser: ... then shift 'values', go to state 532
parser: Reduce 348 [oneselect ::= values], go to state 35.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 35.
parser: ... then shift 'select', go to state 297
parser: Reduce 152 [upsert ::=].
parser: ... then shift 'upsert', pending reduce 150
parser: Reduce 150 [cmd ::= with insert_cmd INTO xfullname idlist_opt select upsert], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
parser: [[[;INSERT INTO v0 VALUES('def', 2, 'iii');;INSERT INTO v0 VALUES('ghi', 3, 'vi');;
;SELECT c0 FROM t0 WHERE c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE +c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE (c0 COLLATE nocase, c0) IS NOT (SELECT 'def', 2);;
;SELECT following FROM v0 WHERE (over, over) = (SELECT 2, 'def');;INSERT INTO v0 VALUES(3, 3, 3);SELECT * FROM t0 WHERE (c0, c0) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM v0 WHERE (following, following) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;CREATE TABLE last_field(test002);;INSERT INTO last_field VALUES(3, 3, 3);;INSERT INTO last_field VALUES(4, 4, 4);;INSERT INTO t0 VALUES(5, 5, 5);SELECT following FROM v0 WHERE (over, following) > (2, 2)
;SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'INSERT' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'INSERT', go to state 311
parser: Return. Stack=[ecmd with INSERT]
parser: Input 'INTO' in state 311
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', pending reduce 156
parser: Reduce 156 [insert_cmd ::= INSERT orconf], go to state 219.
parser: ... then shift 'insert_cmd', go to state 427
parser: Shift 'INTO', go to state 164
parser: Return. Stack=[ecmd with insert_cmd INTO]
parser: Input 'ID' in state 164
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd with insert_cmd INTO ID]
parser: Input 'VALUES' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 164.
parser: ... then shift 'nm', go to state 393
parser: Reduce 112 [xfullname ::= nm], go to state 164.
parser: ... then shift 'xfullname', go to state 298
parser: Reduce 158 [idlist_opt ::=].
parser: ... then shift 'idlist_opt', go to state 35
parser: Shift 'VALUES', go to state 526
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES]
parser: Input 'LP' in state 526
parser: Shift 'LP', go to state 28
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP]
parser: Input 'STRING' in state 28
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 28.
parser: ... then shift 'term', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'INTEGER' in state 107
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'STRING' in state 107
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA STRING]
parser: Input 'RP' in state 537
parser: Reduce 168 [term ::= STRING], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'RP', pending reduce 89
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist RP]
parser: Input 'SEMI' with pending reduce 89
parser: Reduce 89 [values ::= VALUES LP nexprlist RP], go to state 35.
parser: ... then shift 'values', go to state 532
parser: Reduce 348 [oneselect ::= values], go to state 35.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 35.
parser: ... then shift 'select', go to state 297
parser: Reduce 152 [upsert ::=].
parser: ... then shift 'upsert', pending reduce 150
parser: Reduce 150 [cmd ::= with insert_cmd INTO xfullname idlist_opt select upsert], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
parser: [[[;INSERT INTO v0 VALUES('ghi', 3, 'vi');;
;SELECT c0 FROM t0 WHERE c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE +c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE (c0 COLLATE nocase, c0) IS NOT (SELECT 'def', 2);;
;SELECT following FROM v0 WHERE (over, over) = (SELECT 2, 'def');;INSERT INTO v0 VALUES(3, 3, 3);SELECT * FROM t0 WHERE (c0, c0) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM v0 WHERE (following, following) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;CREATE TABLE last_field(test002);;INSERT INTO last_field VALUES(3, 3, 3);;INSERT INTO last_field VALUES(4, 4, 4);;INSERT INTO t0 VALUES(5, 5, 5);SELECT following FROM v0 WHERE (over, following) > (2, 2)
;SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'INSERT' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'INSERT', go to state 311
parser: Return. Stack=[ecmd with INSERT]
parser: Input 'INTO' in state 311
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', pending reduce 156
parser: Reduce 156 [insert_cmd ::= INSERT orconf], go to state 219.
parser: ... then shift 'insert_cmd', go to state 427
parser: Shift 'INTO', go to state 164
parser: Return. Stack=[ecmd with insert_cmd INTO]
parser: Input 'ID' in state 164
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd with insert_cmd INTO ID]
parser: Input 'VALUES' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 164.
parser: ... then shift 'nm', go to state 393
parser: Reduce 112 [xfullname ::= nm], go to state 164.
parser: ... then shift 'xfullname', go to state 298
parser: Reduce 158 [idlist_opt ::=].
parser: ... then shift 'idlist_opt', go to state 35
parser: Shift 'VALUES', go to state 526
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES]
parser: Input 'LP' in state 526
parser: Shift 'LP', go to state 28
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP]
parser: Input 'STRING' in state 28
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 28.
parser: ... then shift 'term', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'INTEGER' in state 107
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'STRING' in state 107
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA STRING]
parser: Input 'RP' in state 537
parser: Reduce 168 [term ::= STRING], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'RP', pending reduce 89
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist RP]
parser: Input 'SEMI' with pending reduce 89
parser: Reduce 89 [values ::= VALUES LP nexprlist RP], go to state 35.
parser: ... then shift 'values', go to state 532
parser: Reduce 348 [oneselect ::= values], go to state 35.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 35.
parser: ... then shift 'select', go to state 297
parser: Reduce 152 [upsert ::=].
parser: ... then shift 'upsert', pending reduce 150
parser: Reduce 150 [cmd ::= with insert_cmd INTO xfullname idlist_opt select upsert], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
parser: [[[;
;SELECT c0 FROM t0 WHERE c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE +c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE (c0 COLLATE nocase, c0) IS NOT (SELECT 'def', 2);;
;SELECT following FROM v0 WHERE (over, over) = (SELECT 2, 'def');;INSERT INTO v0 VALUES(3, 3, 3);SELECT * FROM t0 WHERE (c0, c0) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM v0 WHERE (following, following) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;CREATE TABLE last_field(test002);;INSERT INTO last_field VALUES(3, 3, 3);;INSERT INTO last_field VALUES(4, 4, 4);;INSERT INTO t0 VALUES(5, 5, 5);SELECT following FROM v0 WHERE (over, following) > (2, 2)
;SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'SEMI' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[ecmd SEMI]
parser: Input 'SELECT' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 1.
parser: ... then shift 'ecmd', pending reduce 318
parser: Reduce 318 [cmdlist ::= cmdlist ecmd], go to state 0.
parser: ... then shift 'cmdlist', go to state 1
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[cmdlist SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID]
parser: Input 'FROM' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[cmdlist SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[cmdlist SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 416
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'LP' in state 117
parser: Shift 'LP', go to state 4
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr EQ LP]
parser: Input 'SELECT' in state 4
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr EQ LP SELECT]
parser: Input 'STRING' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr EQ LP SELECT distinct sclp scanpt STRING]
parser: Input 'COLLATE' in state 537
parser: Reduce 168 [term ::= STRING], go to state 77.
parser: ... then shift 'term', go to state 16
parser: Shift 'COLLATE', go to state 415
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr EQ LP SELECT distinct sclp scanpt term COLLATE]
parser: Input 'ID' in state 415
parser: Shift 'ID', pending reduce 171
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr EQ LP SELECT distinct sclp scanpt term COLLATE ID]
parser: Input 'RP' with pending reduce 171
parser: Reduce 171 [expr ::= expr COLLATE ID|STRING], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Reduce 100 [from ::=].
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 4.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 4.
parser: ... then shift 'select', go to state 483
parser: Shift 'RP', pending reduce 203
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr EQ LP select RP]
parser: Input 'AND' with pending reduce 203
parser: Reduce 203 [expr ::= LP select RP], go to state 117.
parser: ... then shift 'expr', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'AND', go to state 120
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID' in state 120
parser: Shift 'ID', go to state 416
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr AND expr EQ]
parser: Input 'LP' in state 117
parser: Shift 'LP', go to state 4
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr AND expr EQ LP]
parser: Input 'SELECT' in state 4
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr AND expr EQ LP SELECT]
parser: Input 'INTEGER' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr AND expr EQ LP SELECT distinct sclp scanpt INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 77.
parser: ... then shift 'term', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Reduce 100 [from ::=].
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 4.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 4.
parser: ... then shift 'select', go to state 483
parser: Shift 'RP', pending reduce 203
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr AND expr EQ LP select RP]
parser: Input 'SEMI' with pending reduce 203
parser: Reduce 203 [expr ::= LP select RP], go to state 117.
parser: ... then shift 'expr', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Reduce 179 [expr ::= expr AND expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 1.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 1.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdlist cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping cmdlist
parser: [[[;
;SELECT c0 FROM t0 WHERE +c0 = (SELECT 'abc' COLLATE nocase) AND c0 = (SELECT 1);;
;SELECT c0 FROM t0 WHERE (c0 COLLATE nocase, c0) IS NOT (SELECT 'def', 2);;
;SELECT following FROM v0 WHERE (over, over) = (SELECT 2, 'def');;INSERT INTO v0 VALUES(3, 3, 3);SELECT * FROM t0 WHERE (c0, c0) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM v0 WHERE (following, following) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;CREATE TABLE last_field(test002);;INSERT INTO last_field VALUES(3, 3, 3);;INSERT INTO last_field VALUES(4, 4, 4);;INSERT INTO t0 VALUES(5, 5, 5);SELECT following FROM v0 WHERE (over, following) > (2, 2)
;SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'SEMI' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[ecmd SEMI]
parser: Input 'SELECT' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 1.
parser: ... then shift 'ecmd', pending reduce 318
parser: Reduce 318 [cmdlist ::= cmdlist ecmd], go to state 0.
parser: ... then shift 'cmdlist', go to state 1
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[cmdlist SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID]
parser: Input 'FROM' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[cmdlist SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[cmdlist SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE]
parser: Input 'PLUS' in state 93
parser: Shift 'PLUS', go to state 103
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE PLUS]
parser: Input 'ID' in state 103
parser: Shift 'ID', go to state 416
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE PLUS ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 103.
parser: ... then shift 'expr', go to state 147
parser: Reduce 196 [expr ::= PLUS|MINUS expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'LP' in state 117
parser: Shift 'LP', go to state 4
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr EQ LP]
parser: Input 'SELECT' in state 4
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr EQ LP SELECT]
parser: Input 'STRING' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr EQ LP SELECT distinct sclp scanpt STRING]
parser: Input 'COLLATE' in state 537
parser: Reduce 168 [term ::= STRING], go to state 77.
parser: ... then shift 'term', go to state 16
parser: Shift 'COLLATE', go to state 415
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr EQ LP SELECT distinct sclp scanpt term COLLATE]
parser: Input 'ID' in state 415
parser: Shift 'ID', pending reduce 171
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr EQ LP SELECT distinct sclp scanpt term COLLATE ID]
parser: Input 'RP' with pending reduce 171
parser: Reduce 171 [expr ::= expr COLLATE ID|STRING], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Reduce 100 [from ::=].
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 4.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 4.
parser: ... then shift 'select', go to state 483
parser: Shift 'RP', pending reduce 203
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr EQ LP select RP]
parser: Input 'AND' with pending reduce 203
parser: Reduce 203 [expr ::= LP select RP], go to state 117.
parser: ... then shift 'expr', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'AND', go to state 120
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID' in state 120
parser: Shift 'ID', go to state 416
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr AND expr EQ]
parser: Input 'LP' in state 117
parser: Shift 'LP', go to state 4
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr AND expr EQ LP]
parser: Input 'SELECT' in state 4
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr AND expr EQ LP SELECT]
parser: Input 'INTEGER' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr AND expr EQ LP SELECT distinct sclp scanpt INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 77.
parser: ... then shift 'term', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Reduce 100 [from ::=].
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 4.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 4.
parser: ... then shift 'select', go to state 483
parser: Shift 'RP', pending reduce 203
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr AND expr EQ LP select RP]
parser: Input 'SEMI' with pending reduce 203
parser: Reduce 203 [expr ::= LP select RP], go to state 117.
parser: ... then shift 'expr', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Reduce 179 [expr ::= expr AND expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 1.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 1.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdlist cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping cmdlist
parser: [[[;
;SELECT c0 FROM t0 WHERE (c0 COLLATE nocase, c0) IS NOT (SELECT 'def', 2);;
;SELECT following FROM v0 WHERE (over, over) = (SELECT 2, 'def');;INSERT INTO v0 VALUES(3, 3, 3);SELECT * FROM t0 WHERE (c0, c0) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM v0 WHERE (following, following) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;CREATE TABLE last_field(test002);;INSERT INTO last_field VALUES(3, 3, 3);;INSERT INTO last_field VALUES(4, 4, 4);;INSERT INTO t0 VALUES(5, 5, 5);SELECT following FROM v0 WHERE (over, following) > (2, 2)
;SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'SEMI' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[ecmd SEMI]
parser: Input 'SELECT' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 1.
parser: ... then shift 'ecmd', pending reduce 318
parser: Reduce 318 [cmdlist ::= cmdlist ecmd], go to state 0.
parser: ... then shift 'cmdlist', go to state 1
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[cmdlist SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID]
parser: Input 'FROM' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[cmdlist SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[cmdlist SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE]
parser: Input 'LP' in state 93
parser: Shift 'LP', go to state 4
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE LP]
parser: Input 'ID' in state 4
parser: Shift 'ID', go to state 416
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE LP ID]
parser: Input 'COLLATE' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 4.
parser: ... then shift 'expr', go to state 50
parser: Shift 'COLLATE', go to state 415
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE LP expr COLLATE]
parser: Input 'ID' in state 415
parser: Shift 'ID', pending reduce 171
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE LP expr COLLATE ID]
parser: Input 'COMMA' with pending reduce 171
parser: Reduce 171 [expr ::= expr COLLATE ID|STRING], go to state 4.
parser: ... then shift 'expr', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE LP nexprlist COMMA]
parser: Input 'ID' in state 91
parser: Shift 'ID', go to state 416
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE LP nexprlist COMMA ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 91.
parser: ... then shift 'expr', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE LP nexprlist COMMA expr RP]
parser: Input 'IS' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'IS', go to state 110
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr IS]
parser: Input 'NOT' in state 110
parser: Shift 'NOT', go to state 97
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr IS NOT]
parser: Input 'LP' in state 97
parser: Shift 'LP', go to state 4
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr IS NOT LP]
parser: Input 'SELECT' in state 4
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr IS NOT LP SELECT]
parser: Input 'STRING' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr IS NOT LP SELECT distinct sclp scanpt STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 77.
parser: ... then shift 'term', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr IS NOT LP SELECT distinct selcollist COMMA]
parser: Input 'INTEGER' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr IS NOT LP SELECT distinct sclp scanpt INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 77.
parser: ... then shift 'term', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Reduce 100 [from ::=].
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 4.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 4.
parser: ... then shift 'select', go to state 483
parser: Shift 'RP', pending reduce 203
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr IS NOT LP select RP]
parser: Input 'SEMI' with pending reduce 203
parser: Reduce 203 [expr ::= LP select RP], go to state 97.
parser: ... then shift 'expr', go to state 125
parser: Reduce 193 [expr ::= expr IS NOT expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 1.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 1.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdlist cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping cmdlist
parser: [[[;
;SELECT following FROM v0 WHERE (over, over) = (SELECT 2, 'def');;INSERT INTO v0 VALUES(3, 3, 3);SELECT * FROM t0 WHERE (c0, c0) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM v0 WHERE (following, following) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;CREATE TABLE last_field(test002);;INSERT INTO last_field VALUES(3, 3, 3);;INSERT INTO last_field VALUES(4, 4, 4);;INSERT INTO t0 VALUES(5, 5, 5);SELECT following FROM v0 WHERE (over, following) > (2, 2)
;SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'SEMI' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[ecmd SEMI]
parser: Input 'SELECT' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 1.
parser: ... then shift 'ecmd', pending reduce 318
parser: Reduce 318 [cmdlist ::= cmdlist ecmd], go to state 0.
parser: ... then shift 'cmdlist', go to state 1
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[cmdlist SELECT]
parser: Input 'FOLLOWING' in state 288
parser: FALLBACK FOLLOWING => ID
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: FALLBACK FOLLOWING => ID
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: FALLBACK FOLLOWING => ID
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt FOLLOWING]
parser: Input 'FROM' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[cmdlist SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[cmdlist SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE]
parser: Input 'LP' in state 93
parser: Shift 'LP', go to state 4
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE LP]
parser: Input 'ID' in state 4
parser: Shift 'ID', go to state 416
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE LP ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 4.
parser: ... then shift 'expr', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE LP nexprlist COMMA]
parser: Input 'ID' in state 91
parser: Shift 'ID', go to state 416
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE LP nexprlist COMMA ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 91.
parser: ... then shift 'expr', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE LP nexprlist COMMA expr RP]
parser: Input 'EQ' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'LP' in state 117
parser: Shift 'LP', go to state 4
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr EQ LP]
parser: Input 'SELECT' in state 4
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr EQ LP SELECT]
parser: Input 'INTEGER' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr EQ LP SELECT distinct sclp scanpt INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 77.
parser: ... then shift 'term', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr EQ LP SELECT distinct selcollist COMMA]
parser: Input 'STRING' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr EQ LP SELECT distinct sclp scanpt STRING]
parser: Input 'RP' in state 537
parser: Reduce 168 [term ::= STRING], go to state 77.
parser: ... then shift 'term', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Reduce 100 [from ::=].
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 4.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 4.
parser: ... then shift 'select', go to state 483
parser: Shift 'RP', pending reduce 203
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr EQ LP select RP]
parser: Input 'SEMI' with pending reduce 203
parser: Reduce 203 [expr ::= LP select RP], go to state 117.
parser: ... then shift 'expr', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 1.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 1.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdlist cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping cmdlist
parser: [[[;INSERT INTO v0 VALUES(3, 3, 3);SELECT * FROM t0 WHERE (c0, c0) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM v0 WHERE (following, following) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;CREATE TABLE last_field(test002);;INSERT INTO last_field VALUES(3, 3, 3);;INSERT INTO last_field VALUES(4, 4, 4);;INSERT INTO t0 VALUES(5, 5, 5);SELECT following FROM v0 WHERE (over, following) > (2, 2)
;SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'INSERT' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'INSERT', go to state 311
parser: Return. Stack=[ecmd with INSERT]
parser: Input 'INTO' in state 311
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', pending reduce 156
parser: Reduce 156 [insert_cmd ::= INSERT orconf], go to state 219.
parser: ... then shift 'insert_cmd', go to state 427
parser: Shift 'INTO', go to state 164
parser: Return. Stack=[ecmd with insert_cmd INTO]
parser: Input 'ID' in state 164
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd with insert_cmd INTO ID]
parser: Input 'VALUES' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 164.
parser: ... then shift 'nm', go to state 393
parser: Reduce 112 [xfullname ::= nm], go to state 164.
parser: ... then shift 'xfullname', go to state 298
parser: Reduce 158 [idlist_opt ::=].
parser: ... then shift 'idlist_opt', go to state 35
parser: Shift 'VALUES', go to state 526
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES]
parser: Input 'LP' in state 526
parser: Shift 'LP', go to state 28
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP]
parser: Input 'INTEGER' in state 28
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 28.
parser: ... then shift 'term', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'INTEGER' in state 107
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'INTEGER' in state 107
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'RP', pending reduce 89
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist RP]
parser: Input 'SEMI' with pending reduce 89
parser: Reduce 89 [values ::= VALUES LP nexprlist RP], go to state 35.
parser: ... then shift 'values', go to state 532
parser: Reduce 348 [oneselect ::= values], go to state 35.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 35.
parser: ... then shift 'select', go to state 297
parser: Reduce 152 [upsert ::=].
parser: ... then shift 'upsert', pending reduce 150
parser: Reduce 150 [cmd ::= with insert_cmd INTO xfullname idlist_opt select upsert], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
parser: [[[SELECT * FROM t0 WHERE (c0, c0) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM v0 WHERE (following, following) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;CREATE TABLE last_field(test002);;INSERT INTO last_field VALUES(3, 3, 3);;INSERT INTO last_field VALUES(4, 4, 4);;INSERT INTO t0 VALUES(5, 5, 5);SELECT following FROM v0 WHERE (over, following) > (2, 2)
;SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 96
parser: Return. Stack=[SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[SELECT distinct selcollist from WHERE]
parser: Input 'LP' in state 93
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP]
parser: Input 'ID' in state 4
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 4.
parser: ... then shift 'expr', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP nexprlist COMMA]
parser: Input 'ID' in state 91
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP nexprlist COMMA ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 91.
parser: ... then shift 'expr', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP nexprlist COMMA expr RP]
parser: Input 'LT' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'LT', go to state 118
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LT]
parser: Input 'LP' in state 118
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LT LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LT LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LT LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LT LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LT LP nexprlist COMMA term RP]
parser: Input 'SEMI' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 118.
parser: ... then shift 'expr', go to state 130
parser: Reduce 181 [expr ::= expr LT|GT|GE|LE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[EXPLAIN QUERY PLAN SELECT * FROM v0 WHERE (following, following) < (2, 3)
;EXPLAIN QUERY PLAN SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;CREATE TABLE last_field(test002);;INSERT INTO last_field VALUES(3, 3, 3);;INSERT INTO last_field VALUES(4, 4, 4);;INSERT INTO t0 VALUES(5, 5, 5);SELECT following FROM v0 WHERE (over, following) > (2, 2)
;SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'EXPLAIN' in state 0
parser: Shift 'EXPLAIN', go to state 418
parser: Return. Stack=[EXPLAIN]
parser: Input 'QUERY' in state 418
parser: Shift 'QUERY', go to state 417
parser: Return. Stack=[EXPLAIN QUERY]
parser: Input 'PLAN' in state 417
parser: Shift 'PLAN', pending reduce 1
parser: Return. Stack=[EXPLAIN QUERY PLAN]
parser: Input 'SELECT' with pending reduce 1
parser: Reduce 1 [explain ::= EXPLAIN QUERY PLAN], go to state 0.
parser: ... then shift 'explain', go to state 2
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[explain SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 96
parser: Return. Stack=[explain SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[explain SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[explain SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[explain SELECT distinct selcollist from WHERE]
parser: Input 'LP' in state 93
parser: Shift 'LP', go to state 4
parser: Return. Stack=[explain SELECT distinct selcollist from WHERE LP]
parser: Input 'FOLLOWING' in state 4
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[explain SELECT distinct selcollist from WHERE LP FOLLOWING]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 4.
parser: ... then shift 'expr', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[explain SELECT distinct selcollist from WHERE LP nexprlist COMMA]
parser: Input 'FOLLOWING' in state 91
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[explain SELECT distinct selcollist from WHERE LP nexprlist COMMA FOLLOWING]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 91.
parser: ... then shift 'expr', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[explain SELECT distinct selcollist from WHERE LP nexprlist COMMA expr RP]
parser: Input 'LT' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'LT', go to state 118
parser: Return. Stack=[explain SELECT distinct selcollist from WHERE expr LT]
parser: Input 'LP' in state 118
parser: Shift 'LP', go to state 4
parser: Return. Stack=[explain SELECT distinct selcollist from WHERE expr LT LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[explain SELECT distinct selcollist from WHERE expr LT LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[explain SELECT distinct selcollist from WHERE expr LT LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[explain SELECT distinct selcollist from WHERE expr LT LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[explain SELECT distinct selcollist from WHERE expr LT LP nexprlist COMMA term RP]
parser: Input 'SEMI' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 118.
parser: ... then shift 'expr', go to state 130
parser: Reduce 181 [expr ::= expr LT|GT|GE|LE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 2.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 2.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 2.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 2.
parser: ... then shift 'cmdx', pending reduce 322
parser: Reduce 322 [ecmd ::= explain cmdx], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[ecmd SEMI]
parser: Popping SEMI
parser: Popping ecmd
parser: [[[EXPLAIN QUERY PLAN SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;CREATE TABLE last_field(test002);;INSERT INTO last_field VALUES(3, 3, 3);;INSERT INTO last_field VALUES(4, 4, 4);;INSERT INTO t0 VALUES(5, 5, 5);SELECT following FROM v0 WHERE (over, following) > (2, 2)
;SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'EXPLAIN' in state 0
parser: Shift 'EXPLAIN', go to state 418
parser: Return. Stack=[EXPLAIN]
parser: Input 'QUERY' in state 418
parser: Shift 'QUERY', go to state 417
parser: Return. Stack=[EXPLAIN QUERY]
parser: Input 'PLAN' in state 417
parser: Shift 'PLAN', pending reduce 1
parser: Return. Stack=[EXPLAIN QUERY PLAN]
parser: Input 'SELECT' with pending reduce 1
parser: Reduce 1 [explain ::= EXPLAIN QUERY PLAN], go to state 0.
parser: ... then shift 'explain', go to state 2
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[explain SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 96
parser: Return. Stack=[explain SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[explain SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[explain SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[explain SELECT distinct selcollist from WHERE]
parser: Input 'LP' in state 93
parser: Shift 'LP', go to state 4
parser: Return. Stack=[explain SELECT distinct selcollist from WHERE LP]
parser: Input 'ID' in state 4
parser: Shift 'ID', go to state 416
parser: Return. Stack=[explain SELECT distinct selcollist from WHERE LP ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 4.
parser: ... then shift 'expr', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[explain SELECT distinct selcollist from WHERE LP nexprlist COMMA]
parser: Input 'ID' in state 91
parser: Shift 'ID', go to state 416
parser: Return. Stack=[explain SELECT distinct selcollist from WHERE LP nexprlist COMMA ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 91.
parser: ... then shift 'expr', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[explain SELECT distinct selcollist from WHERE LP nexprlist COMMA expr RP]
parser: Input 'GT' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'GT', go to state 118
parser: Return. Stack=[explain SELECT distinct selcollist from WHERE expr GT]
parser: Input 'LP' in state 118
parser: Shift 'LP', go to state 4
parser: Return. Stack=[explain SELECT distinct selcollist from WHERE expr GT LP]
parser: Input 'STRING' in state 4
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[explain SELECT distinct selcollist from WHERE expr GT LP STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[explain SELECT distinct selcollist from WHERE expr GT LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[explain SELECT distinct selcollist from WHERE expr GT LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[explain SELECT distinct selcollist from WHERE expr GT LP nexprlist COMMA term RP]
parser: Input 'SEMI' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 118.
parser: ... then shift 'expr', go to state 130
parser: Reduce 181 [expr ::= expr LT|GT|GE|LE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 2.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 2.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 2.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 2.
parser: ... then shift 'cmdx', pending reduce 322
parser: Reduce 322 [ecmd ::= explain cmdx], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[ecmd SEMI]
parser: Popping SEMI
parser: Popping ecmd
parser: [[[SELECT * FROM t0 WHERE (c0, c0) > ('2', 1)
;CREATE TABLE last_field(test002);;INSERT INTO last_field VALUES(3, 3, 3);;INSERT INTO last_field VALUES(4, 4, 4);;INSERT INTO t0 VALUES(5, 5, 5);SELECT following FROM v0 WHERE (over, following) > (2, 2)
;SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 96
parser: Return. Stack=[SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[SELECT distinct selcollist from WHERE]
parser: Input 'LP' in state 93
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP]
parser: Input 'ID' in state 4
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 4.
parser: ... then shift 'expr', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP nexprlist COMMA]
parser: Input 'ID' in state 91
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP nexprlist COMMA ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 91.
parser: ... then shift 'expr', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP nexprlist COMMA expr RP]
parser: Input 'GT' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'GT', go to state 118
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr GT]
parser: Input 'LP' in state 118
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr GT LP]
parser: Input 'STRING' in state 4
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr GT LP STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr GT LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr GT LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr GT LP nexprlist COMMA term RP]
parser: Input 'SEMI' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 118.
parser: ... then shift 'expr', go to state 130
parser: Reduce 181 [expr ::= expr LT|GT|GE|LE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[CREATE TABLE last_field(test002);;INSERT INTO last_field VALUES(3, 3, 3);;INSERT INTO last_field VALUES(4, 4, 4);;INSERT INTO t0 VALUES(5, 5, 5);SELECT following FROM v0 WHERE (over, following) > (2, 2)
;SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 388
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP ID]
parser: Input 'RP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 190
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 376
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 150
parser: Reduce 330 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Reduce 60 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 538
parser: Shift 'RP', go to state 361
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 361
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: [[[UPDATE 'main'.sqlite_master SET type='table', name='last_field', tbl_name='last_field', rootpage=#2, sql='CREATE TABLE last_field(test002)' WHERE rowid=#1]]]
parser: Input 'UPDATE' in state 0
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'UPDATE', go to state 299
parser: Return. Stack=[with UPDATE]
parser: Input 'STRING' in state 299
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', go to state 165
parser: Shift 'STRING', pending reduce 332
parser: Return. Stack=[with UPDATE orconf STRING]
parser: Input 'DOT' with pending reduce 332
parser: Reduce 332 [nm ::= STRING], go to state 165.
parser: ... then shift 'nm', go to state 393
parser: Shift 'DOT', go to state 218
parser: Return. Stack=[with UPDATE orconf nm DOT]
parser: Input 'ID' in state 218
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf nm DOT ID]
parser: Input 'SET' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 218.
parser: ... then shift 'nm', go to state 429
parser: Reduce 113 [xfullname ::= nm DOT nm], go to state 165.
parser: ... then shift 'xfullname', go to state 271
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 428
parser: Shift 'SET', go to state 153
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET]
parser: Input 'ID' in state 153
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 153.
parser: ... then shift 'nm', go to state 442
parser: Shift 'EQ', go to state 84
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ]
parser: Input 'STRING' in state 84
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 84.
parser: ... then shift 'term', go to state 58
parser: Reduce 148 [setlist ::= nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'VARIABLE' in state 86
parser: Shift 'VARIABLE', pending reduce 170
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ VARIABLE]
parser: Input 'COMMA' with pending reduce 170
parser: Reduce 170 [expr ::= VARIABLE], go to state 86.
parser: ... then shift 'expr', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'WHERE' in state 537
parser: Reduce 168 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 416
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr EQ]
parser: Input 'VARIABLE' in state 117
parser: Shift 'VARIABLE', pending reduce 170
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr EQ VARIABLE]
parser: Input 'SEMI' with pending reduce 170
parser: Reduce 170 [expr ::= VARIABLE], go to state 117.
parser: ... then shift 'expr', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 270.
parser: ... then shift 'where_opt', pending reduce 145
parser: Reduce 145 [cmd ::= with UPDATE orconf xfullname indexed_opt SET setlist where_opt], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Input '$' with pending reduce 321
parser: Reduce 321 [ecmd ::= cmdx SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 317 [input ::= cmdlist], go to state 0.
parser: ... then shift 'input', pending reduce -2
parser: Accept!
parser: ... then shift 'create_table_args', pending reduce 328
parser: Reduce 328 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='last_field' AND type!='trigger' ORDER BY rowid]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'FROM' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'STRING' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'STRING', pending reduce 332
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix STRING]
parser: Input 'DOT' with pending reduce 332
parser: Reduce 332 [nm ::= STRING], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Shift 'DOT', go to state 245
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID' in state 245
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 245.
parser: ... then shift 'nm', pending reduce 109
parser: Reduce 109 [dbnm ::= DOT nm], go to state 349.
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[SELECT distinct selcollist from WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND' in state 537
parser: Reduce 168 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'AND', go to state 120
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID' in state 120
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'NE' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Shift 'NE', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr NE]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr NE STRING]
parser: Input 'ORDER' in state 537
parser: Reduce 168 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Reduce 179 [expr ::= expr AND expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[CREATE TABLE last_field(test002)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 388
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP ID]
parser: Input 'RP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 190
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 376
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 150
parser: Reduce 330 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Reduce 60 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 538
parser: Shift 'RP', go to state 361
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 361
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 328
parser: Reduce 328 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[;INSERT INTO last_field VALUES(3, 3, 3);;INSERT INTO last_field VALUES(4, 4, 4);;INSERT INTO t0 VALUES(5, 5, 5);SELECT following FROM v0 WHERE (over, following) > (2, 2)
;SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'INSERT' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'INSERT', go to state 311
parser: Return. Stack=[ecmd with INSERT]
parser: Input 'INTO' in state 311
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', pending reduce 156
parser: Reduce 156 [insert_cmd ::= INSERT orconf], go to state 219.
parser: ... then shift 'insert_cmd', go to state 427
parser: Shift 'INTO', go to state 164
parser: Return. Stack=[ecmd with insert_cmd INTO]
parser: Input 'ID' in state 164
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd with insert_cmd INTO ID]
parser: Input 'VALUES' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 164.
parser: ... then shift 'nm', go to state 393
parser: Reduce 112 [xfullname ::= nm], go to state 164.
parser: ... then shift 'xfullname', go to state 298
parser: Reduce 158 [idlist_opt ::=].
parser: ... then shift 'idlist_opt', go to state 35
parser: Shift 'VALUES', go to state 526
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES]
parser: Input 'LP' in state 526
parser: Shift 'LP', go to state 28
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP]
parser: Input 'INTEGER' in state 28
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 28.
parser: ... then shift 'term', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'INTEGER' in state 107
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'INTEGER' in state 107
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'RP', pending reduce 89
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist RP]
parser: Input 'SEMI' with pending reduce 89
parser: Reduce 89 [values ::= VALUES LP nexprlist RP], go to state 35.
parser: ... then shift 'values', go to state 532
parser: Reduce 348 [oneselect ::= values], go to state 35.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 35.
parser: ... then shift 'select', go to state 297
parser: Reduce 152 [upsert ::=].
parser: ... then shift 'upsert', pending reduce 150
parser: Reduce 150 [cmd ::= with insert_cmd INTO xfullname idlist_opt select upsert], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
parser: [[[;INSERT INTO last_field VALUES(4, 4, 4);;INSERT INTO t0 VALUES(5, 5, 5);SELECT following FROM v0 WHERE (over, following) > (2, 2)
;SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'INSERT' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'INSERT', go to state 311
parser: Return. Stack=[ecmd with INSERT]
parser: Input 'INTO' in state 311
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', pending reduce 156
parser: Reduce 156 [insert_cmd ::= INSERT orconf], go to state 219.
parser: ... then shift 'insert_cmd', go to state 427
parser: Shift 'INTO', go to state 164
parser: Return. Stack=[ecmd with insert_cmd INTO]
parser: Input 'ID' in state 164
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd with insert_cmd INTO ID]
parser: Input 'VALUES' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 164.
parser: ... then shift 'nm', go to state 393
parser: Reduce 112 [xfullname ::= nm], go to state 164.
parser: ... then shift 'xfullname', go to state 298
parser: Reduce 158 [idlist_opt ::=].
parser: ... then shift 'idlist_opt', go to state 35
parser: Shift 'VALUES', go to state 526
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES]
parser: Input 'LP' in state 526
parser: Shift 'LP', go to state 28
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP]
parser: Input 'INTEGER' in state 28
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 28.
parser: ... then shift 'term', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'INTEGER' in state 107
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'INTEGER' in state 107
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'RP', pending reduce 89
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist RP]
parser: Input 'SEMI' with pending reduce 89
parser: Reduce 89 [values ::= VALUES LP nexprlist RP], go to state 35.
parser: ... then shift 'values', go to state 532
parser: Reduce 348 [oneselect ::= values], go to state 35.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 35.
parser: ... then shift 'select', go to state 297
parser: Reduce 152 [upsert ::=].
parser: ... then shift 'upsert', pending reduce 150
parser: Reduce 150 [cmd ::= with insert_cmd INTO xfullname idlist_opt select upsert], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
parser: [[[;INSERT INTO t0 VALUES(5, 5, 5);SELECT following FROM v0 WHERE (over, following) > (2, 2)
;SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'INSERT' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'INSERT', go to state 311
parser: Return. Stack=[ecmd with INSERT]
parser: Input 'INTO' in state 311
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', pending reduce 156
parser: Reduce 156 [insert_cmd ::= INSERT orconf], go to state 219.
parser: ... then shift 'insert_cmd', go to state 427
parser: Shift 'INTO', go to state 164
parser: Return. Stack=[ecmd with insert_cmd INTO]
parser: Input 'ID' in state 164
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd with insert_cmd INTO ID]
parser: Input 'VALUES' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 164.
parser: ... then shift 'nm', go to state 393
parser: Reduce 112 [xfullname ::= nm], go to state 164.
parser: ... then shift 'xfullname', go to state 298
parser: Reduce 158 [idlist_opt ::=].
parser: ... then shift 'idlist_opt', go to state 35
parser: Shift 'VALUES', go to state 526
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES]
parser: Input 'LP' in state 526
parser: Shift 'LP', go to state 28
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP]
parser: Input 'INTEGER' in state 28
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 28.
parser: ... then shift 'term', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'INTEGER' in state 107
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'INTEGER' in state 107
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'RP', pending reduce 89
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist RP]
parser: Input 'SEMI' with pending reduce 89
parser: Reduce 89 [values ::= VALUES LP nexprlist RP], go to state 35.
parser: ... then shift 'values', go to state 532
parser: Reduce 348 [oneselect ::= values], go to state 35.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 35.
parser: ... then shift 'select', go to state 297
parser: Reduce 152 [upsert ::=].
parser: ... then shift 'upsert', pending reduce 150
parser: Reduce 150 [cmd ::= with insert_cmd INTO xfullname idlist_opt select upsert], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
parser: [[[SELECT following FROM v0 WHERE (over, following) > (2, 2)
;SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'FOLLOWING' in state 288
parser: FALLBACK FOLLOWING => ID
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: FALLBACK FOLLOWING => ID
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: FALLBACK FOLLOWING => ID
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt FOLLOWING]
parser: Input 'FROM' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[SELECT distinct selcollist from WHERE]
parser: Input 'LP' in state 93
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP]
parser: Input 'ID' in state 4
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 4.
parser: ... then shift 'expr', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP nexprlist COMMA]
parser: Input 'FOLLOWING' in state 91
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP nexprlist COMMA FOLLOWING]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 91.
parser: ... then shift 'expr', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP nexprlist COMMA expr RP]
parser: Input 'GT' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'GT', go to state 118
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr GT]
parser: Input 'LP' in state 118
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr GT LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr GT LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr GT LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr GT LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr GT LP nexprlist COMMA term RP]
parser: Input 'SEMI' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 118.
parser: ... then shift 'expr', go to state 130
parser: Reduce 181 [expr ::= expr LT|GT|GE|LE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT following FROM v0 WHERE (over, over) < (4, 5)
;SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'FOLLOWING' in state 288
parser: FALLBACK FOLLOWING => ID
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: FALLBACK FOLLOWING => ID
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: FALLBACK FOLLOWING => ID
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt FOLLOWING]
parser: Input 'FROM' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[SELECT distinct selcollist from WHERE]
parser: Input 'LP' in state 93
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP]
parser: Input 'ID' in state 4
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 4.
parser: ... then shift 'expr', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP nexprlist COMMA]
parser: Input 'ID' in state 91
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP nexprlist COMMA ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 91.
parser: ... then shift 'expr', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP nexprlist COMMA expr RP]
parser: Input 'LT' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'LT', go to state 118
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LT]
parser: Input 'LP' in state 118
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LT LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LT LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LT LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LT LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LT LP nexprlist COMMA term RP]
parser: Input 'SEMI' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 118.
parser: ... then shift 'expr', go to state 130
parser: Reduce 181 [expr ::= expr LT|GT|GE|LE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT test001 FROM preceding WHERE (t1, t1) < (4, 3)
;CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'FROM' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'PRECEDING' in state 197
parser: FALLBACK PRECEDING => ID
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix PRECEDING]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[SELECT distinct selcollist from WHERE]
parser: Input 'LP' in state 93
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP]
parser: Input 'ID' in state 4
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 4.
parser: ... then shift 'expr', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP nexprlist COMMA]
parser: Input 'ID' in state 91
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP nexprlist COMMA ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 91.
parser: ... then shift 'expr', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP nexprlist COMMA expr RP]
parser: Input 'LT' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'LT', go to state 118
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LT]
parser: Input 'LP' in state 118
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LT LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LT LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LT LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LT LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr LT LP nexprlist COMMA term RP]
parser: Input 'SEMI' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 118.
parser: ... then shift 'expr', go to state 130
parser: Reduce 181 [expr ::= expr LT|GT|GE|LE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[CREATE TABLE field1(test003);;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 388
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP ID]
parser: Input 'RP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 190
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 376
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 150
parser: Reduce 330 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Reduce 60 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 538
parser: Shift 'RP', go to state 361
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 361
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: [[[UPDATE 'main'.sqlite_master SET type='table', name='field1', tbl_name='field1', rootpage=#2, sql='CREATE TABLE field1(test003)' WHERE rowid=#1]]]
parser: Input 'UPDATE' in state 0
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'UPDATE', go to state 299
parser: Return. Stack=[with UPDATE]
parser: Input 'STRING' in state 299
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', go to state 165
parser: Shift 'STRING', pending reduce 332
parser: Return. Stack=[with UPDATE orconf STRING]
parser: Input 'DOT' with pending reduce 332
parser: Reduce 332 [nm ::= STRING], go to state 165.
parser: ... then shift 'nm', go to state 393
parser: Shift 'DOT', go to state 218
parser: Return. Stack=[with UPDATE orconf nm DOT]
parser: Input 'ID' in state 218
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf nm DOT ID]
parser: Input 'SET' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 218.
parser: ... then shift 'nm', go to state 429
parser: Reduce 113 [xfullname ::= nm DOT nm], go to state 165.
parser: ... then shift 'xfullname', go to state 271
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 428
parser: Shift 'SET', go to state 153
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET]
parser: Input 'ID' in state 153
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 153.
parser: ... then shift 'nm', go to state 442
parser: Shift 'EQ', go to state 84
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ]
parser: Input 'STRING' in state 84
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 84.
parser: ... then shift 'term', go to state 58
parser: Reduce 148 [setlist ::= nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'VARIABLE' in state 86
parser: Shift 'VARIABLE', pending reduce 170
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ VARIABLE]
parser: Input 'COMMA' with pending reduce 170
parser: Reduce 170 [expr ::= VARIABLE], go to state 86.
parser: ... then shift 'expr', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'WHERE' in state 537
parser: Reduce 168 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 416
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr EQ]
parser: Input 'VARIABLE' in state 117
parser: Shift 'VARIABLE', pending reduce 170
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr EQ VARIABLE]
parser: Input 'SEMI' with pending reduce 170
parser: Reduce 170 [expr ::= VARIABLE], go to state 117.
parser: ... then shift 'expr', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 270.
parser: ... then shift 'where_opt', pending reduce 145
parser: Reduce 145 [cmd ::= with UPDATE orconf xfullname indexed_opt SET setlist where_opt], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Input '$' with pending reduce 321
parser: Reduce 321 [ecmd ::= cmdx SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 317 [input ::= cmdlist], go to state 0.
parser: ... then shift 'input', pending reduce -2
parser: Accept!
parser: ... then shift 'create_table_args', pending reduce 328
parser: Reduce 328 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='field1' AND type!='trigger' ORDER BY rowid]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'FROM' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'STRING' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'STRING', pending reduce 332
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix STRING]
parser: Input 'DOT' with pending reduce 332
parser: Reduce 332 [nm ::= STRING], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Shift 'DOT', go to state 245
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID' in state 245
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 245.
parser: ... then shift 'nm', pending reduce 109
parser: Reduce 109 [dbnm ::= DOT nm], go to state 349.
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[SELECT distinct selcollist from WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND' in state 537
parser: Reduce 168 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'AND', go to state 120
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID' in state 120
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'NE' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Shift 'NE', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr NE]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr NE STRING]
parser: Input 'ORDER' in state 537
parser: Reduce 168 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Reduce 179 [expr ::= expr AND expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[CREATE TABLE field1(test003)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 388
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP ID]
parser: Input 'RP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 190
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 376
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 150
parser: Reduce 330 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Reduce 60 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 538
parser: Shift 'RP', go to state 361
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 361
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 328
parser: Reduce 328 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[;SELECT t1 FROM preceding
    WHERE (t1,t1) IN (SELECT 't1','t1' FROM last_field)
    AND (t1,t1,test001) IN (SELECT 't1','t1','t1' FROM last_field);;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'SELECT' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[ecmd SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt ID]
parser: Input 'FROM' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[ecmd SELECT distinct selcollist FROM]
parser: Input 'PRECEDING' in state 197
parser: FALLBACK PRECEDING => ID
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', pending reduce 331
parser: Return. Stack=[ecmd SELECT distinct selcollist FROM stl_prefix PRECEDING]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE]
parser: Input 'LP' in state 93
parser: Shift 'LP', go to state 4
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE LP]
parser: Input 'ID' in state 4
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE LP ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 4.
parser: ... then shift 'expr', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE LP nexprlist COMMA]
parser: Input 'ID' in state 91
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE LP nexprlist COMMA ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 91.
parser: ... then shift 'expr', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE LP nexprlist COMMA expr RP]
parser: Input 'IN' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'IN', pending reduce 200
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr IN]
parser: Input 'LP' with pending reduce 200
parser: Reduce 200 [in_op ::= IN], go to state 63.
parser: ... then shift 'in_op', go to state 209
parser: Shift 'LP', go to state 3
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr in_op LP]
parser: Input 'SELECT' in state 3
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr in_op LP SELECT]
parser: Input 'STRING' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr in_op LP SELECT distinct sclp scanpt STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 77.
parser: ... then shift 'term', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr in_op LP SELECT distinct selcollist COMMA]
parser: Input 'STRING' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr in_op LP SELECT distinct sclp scanpt STRING]
parser: Input 'FROM' in state 537
parser: Reduce 168 [term ::= STRING], go to state 77.
parser: ... then shift 'term', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr in_op LP SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr in_op LP SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'RP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 3.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 3.
parser: ... then shift 'select', go to state 518
parser: Shift 'RP', pending reduce 204
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr in_op LP select RP]
parser: Input 'AND' with pending reduce 204
parser: Reduce 204 [expr ::= expr in_op LP select RP], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'AND', go to state 120
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr AND]
parser: Input 'LP' in state 120
parser: Shift 'LP', go to state 4
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr AND LP]
parser: Input 'ID' in state 4
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr AND LP ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 4.
parser: ... then shift 'expr', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr AND LP nexprlist COMMA]
parser: Input 'ID' in state 91
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr AND LP nexprlist COMMA ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 91.
parser: ... then shift 'expr', go to state 49
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr AND LP nexprlist COMMA]
parser: Input 'ID' in state 91
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr AND LP nexprlist COMMA ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 91.
parser: ... then shift 'expr', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr AND LP nexprlist COMMA expr RP]
parser: Input 'IN' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Shift 'IN', pending reduce 200
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr AND expr IN]
parser: Input 'LP' with pending reduce 200
parser: Reduce 200 [in_op ::= IN], go to state 76.
parser: ... then shift 'in_op', go to state 209
parser: Shift 'LP', go to state 3
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr AND expr in_op LP]
parser: Input 'SELECT' in state 3
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr AND expr in_op LP SELECT]
parser: Input 'STRING' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr AND expr in_op LP SELECT distinct sclp scanpt STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 77.
parser: ... then shift 'term', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr AND expr in_op LP SELECT distinct selcollist COMMA]
parser: Input 'STRING' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr AND expr in_op LP SELECT distinct sclp scanpt STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 77.
parser: ... then shift 'term', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr AND expr in_op LP SELECT distinct selcollist COMMA]
parser: Input 'STRING' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr AND expr in_op LP SELECT distinct sclp scanpt STRING]
parser: Input 'FROM' in state 537
parser: Reduce 168 [term ::= STRING], go to state 77.
parser: ... then shift 'term', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr AND expr in_op LP SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr AND expr in_op LP SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'RP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 3.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 3.
parser: ... then shift 'select', go to state 518
parser: Shift 'RP', pending reduce 204
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr AND expr in_op LP select RP]
parser: Input 'SEMI' with pending reduce 204
parser: Reduce 204 [expr ::= expr in_op LP select RP], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Reduce 179 [expr ::= expr AND expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 1.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 1.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
parser: [[[;
;CREATE TABLE field2(test004);
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'SEMI' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[ecmd SEMI]
parser: Input 'CREATE' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 1.
parser: ... then shift 'ecmd', pending reduce 318
parser: Reduce 318 [cmdlist ::= cmdlist ecmd], go to state 0.
parser: ... then shift 'cmdlist', go to state 1
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[cmdlist CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 1.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 388
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[cmdlist createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[cmdlist createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 1.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[cmdlist create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[cmdlist create_table LP ID]
parser: Input 'RP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 190
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 376
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 150
parser: Reduce 330 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Reduce 60 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 538
parser: Shift 'RP', go to state 361
parser: Return. Stack=[cmdlist create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 361
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: [[[UPDATE 'main'.sqlite_master SET type='table', name='field2', tbl_name='field2', rootpage=#2, sql='CREATE TABLE field2(test004)' WHERE rowid=#1]]]
parser: Input 'UPDATE' in state 0
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'UPDATE', go to state 299
parser: Return. Stack=[with UPDATE]
parser: Input 'STRING' in state 299
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', go to state 165
parser: Shift 'STRING', pending reduce 332
parser: Return. Stack=[with UPDATE orconf STRING]
parser: Input 'DOT' with pending reduce 332
parser: Reduce 332 [nm ::= STRING], go to state 165.
parser: ... then shift 'nm', go to state 393
parser: Shift 'DOT', go to state 218
parser: Return. Stack=[with UPDATE orconf nm DOT]
parser: Input 'ID' in state 218
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf nm DOT ID]
parser: Input 'SET' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 218.
parser: ... then shift 'nm', go to state 429
parser: Reduce 113 [xfullname ::= nm DOT nm], go to state 165.
parser: ... then shift 'xfullname', go to state 271
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 428
parser: Shift 'SET', go to state 153
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET]
parser: Input 'ID' in state 153
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 153.
parser: ... then shift 'nm', go to state 442
parser: Shift 'EQ', go to state 84
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ]
parser: Input 'STRING' in state 84
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 84.
parser: ... then shift 'term', go to state 58
parser: Reduce 148 [setlist ::= nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'VARIABLE' in state 86
parser: Shift 'VARIABLE', pending reduce 170
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ VARIABLE]
parser: Input 'COMMA' with pending reduce 170
parser: Reduce 170 [expr ::= VARIABLE], go to state 86.
parser: ... then shift 'expr', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'WHERE' in state 537
parser: Reduce 168 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 416
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr EQ]
parser: Input 'VARIABLE' in state 117
parser: Shift 'VARIABLE', pending reduce 170
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr EQ VARIABLE]
parser: Input 'SEMI' with pending reduce 170
parser: Reduce 170 [expr ::= VARIABLE], go to state 117.
parser: ... then shift 'expr', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 270.
parser: ... then shift 'where_opt', pending reduce 145
parser: Reduce 145 [cmd ::= with UPDATE orconf xfullname indexed_opt SET setlist where_opt], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Input '$' with pending reduce 321
parser: Reduce 321 [ecmd ::= cmdx SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 317 [input ::= cmdlist], go to state 0.
parser: ... then shift 'input', pending reduce -2
parser: Accept!
parser: ... then shift 'create_table_args', pending reduce 328
parser: Reduce 328 [cmd ::= create_table create_table_args], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdlist cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping cmdlist
parser: [[[SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='field2' AND type!='trigger' ORDER BY rowid]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'FROM' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'STRING' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'STRING', pending reduce 332
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix STRING]
parser: Input 'DOT' with pending reduce 332
parser: Reduce 332 [nm ::= STRING], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Shift 'DOT', go to state 245
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID' in state 245
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 245.
parser: ... then shift 'nm', pending reduce 109
parser: Reduce 109 [dbnm ::= DOT nm], go to state 349.
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[SELECT distinct selcollist from WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND' in state 537
parser: Reduce 168 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'AND', go to state 120
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID' in state 120
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'NE' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Shift 'NE', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr NE]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr NE STRING]
parser: Input 'ORDER' in state 537
parser: Reduce 168 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Reduce 179 [expr ::= expr AND expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[CREATE TABLE field2(test004)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 388
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP ID]
parser: Input 'RP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 190
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 376
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 150
parser: Reduce 330 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Reduce 60 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 538
parser: Shift 'RP', go to state 361
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 361
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 328
parser: Reduce 328 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[
;DROP TABLE IF EXISTS v0;;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'DROP' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'DROP', go to state 385
parser: Return. Stack=[ecmd DROP]
parser: Input 'TABLE' in state 385
parser: Shift 'TABLE', go to state 304
parser: Return. Stack=[ecmd DROP TABLE]
parser: Input 'IF' in state 304
parser: Shift 'IF', go to state 431
parser: Return. Stack=[ecmd DROP TABLE IF]
parser: Input 'EXISTS' in state 431
parser: Shift 'EXISTS', pending reduce 75
parser: Return. Stack=[ecmd DROP TABLE IF EXISTS]
parser: Input 'ID' with pending reduce 75
parser: Reduce 75 [ifexists ::= IF EXISTS], go to state 304.
parser: ... then shift 'ifexists', go to state 171
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd DROP TABLE ifexists ID]
parser: Input 'SEMI' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 171.
parser: ... then shift 'nm', go to state 459
parser: Reduce 110 [fullname ::= nm], go to state 171.
parser: ... then shift 'fullname', pending reduce 74
parser: Reduce 74 [cmd ::= DROP TABLE ifexists fullname], go to state 1.
parser: [[[DELETE FROM 'main'.sqlite_master WHERE tbl_name='v0' and type!='trigger']]]
parser: Input 'DELETE' in state 0
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'DELETE', go to state 430
parser: Return. Stack=[with DELETE]
parser: Input 'FROM' in state 430
parser: Shift 'FROM', go to state 166
parser: Return. Stack=[with DELETE FROM]
parser: Input 'STRING' in state 166
parser: Shift 'STRING', pending reduce 332
parser: Return. Stack=[with DELETE FROM STRING]
parser: Input 'DOT' with pending reduce 332
parser: Reduce 332 [nm ::= STRING], go to state 166.
parser: ... then shift 'nm', go to state 393
parser: Shift 'DOT', go to state 218
parser: Return. Stack=[with DELETE FROM nm DOT]
parser: Input 'ID' in state 218
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with DELETE FROM nm DOT ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 218.
parser: ... then shift 'nm', go to state 429
parser: Reduce 113 [xfullname ::= nm DOT nm], go to state 166.
parser: ... then shift 'xfullname', go to state 272
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 300
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[with DELETE FROM xfullname indexed_opt WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 416
parser: Return. Stack=[with DELETE FROM xfullname indexed_opt WHERE ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[with DELETE FROM xfullname indexed_opt WHERE expr EQ]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with DELETE FROM xfullname indexed_opt WHERE expr EQ STRING]
parser: Input 'AND' in state 537
parser: Reduce 168 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'AND', go to state 120
parser: Return. Stack=[with DELETE FROM xfullname indexed_opt WHERE expr AND]
parser: Input 'ID' in state 120
parser: Shift 'ID', go to state 416
parser: Return. Stack=[with DELETE FROM xfullname indexed_opt WHERE expr AND ID]
parser: Input 'NE' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Shift 'NE', go to state 117
parser: Return. Stack=[with DELETE FROM xfullname indexed_opt WHERE expr AND expr NE]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with DELETE FROM xfullname indexed_opt WHERE expr AND expr NE STRING]
parser: Input 'SEMI' in state 537
parser: Reduce 168 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Reduce 179 [expr ::= expr AND expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 300.
parser: ... then shift 'where_opt', pending reduce 142
parser: Reduce 142 [cmd ::= with DELETE FROM xfullname indexed_opt where_opt], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Input '$' with pending reduce 321
parser: Reduce 321 [ecmd ::= cmdx SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 317 [input ::= cmdlist], go to state 0.
parser: ... then shift 'input', pending reduce -2
parser: Accept!
parser: [[[UPDATE 'main'.sqlite_master SET rootpage=3 WHERE #2 AND rootpage=#2]]]
parser: Input 'UPDATE' in state 0
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'UPDATE', go to state 299
parser: Return. Stack=[with UPDATE]
parser: Input 'STRING' in state 299
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', go to state 165
parser: Shift 'STRING', pending reduce 332
parser: Return. Stack=[with UPDATE orconf STRING]
parser: Input 'DOT' with pending reduce 332
parser: Reduce 332 [nm ::= STRING], go to state 165.
parser: ... then shift 'nm', go to state 393
parser: Shift 'DOT', go to state 218
parser: Return. Stack=[with UPDATE orconf nm DOT]
parser: Input 'ID' in state 218
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf nm DOT ID]
parser: Input 'SET' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 218.
parser: ... then shift 'nm', go to state 429
parser: Reduce 113 [xfullname ::= nm DOT nm], go to state 165.
parser: ... then shift 'xfullname', go to state 271
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 428
parser: Shift 'SET', go to state 153
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET]
parser: Input 'ID' in state 153
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 153.
parser: ... then shift 'nm', go to state 442
parser: Shift 'EQ', go to state 84
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ]
parser: Input 'INTEGER' in state 84
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ INTEGER]
parser: Input 'WHERE' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 84.
parser: ... then shift 'term', go to state 58
parser: Reduce 148 [setlist ::= nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE]
parser: Input 'VARIABLE' in state 93
parser: Shift 'VARIABLE', pending reduce 170
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE VARIABLE]
parser: Input 'AND' with pending reduce 170
parser: Reduce 170 [expr ::= VARIABLE], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'AND', go to state 120
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr AND]
parser: Input 'ID' in state 120
parser: Shift 'ID', go to state 416
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr AND ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr AND expr EQ]
parser: Input 'VARIABLE' in state 117
parser: Shift 'VARIABLE', pending reduce 170
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr AND expr EQ VARIABLE]
parser: Input 'SEMI' with pending reduce 170
parser: Reduce 170 [expr ::= VARIABLE], go to state 117.
parser: ... then shift 'expr', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Reduce 179 [expr ::= expr AND expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 270.
parser: ... then shift 'where_opt', pending reduce 145
parser: Reduce 145 [cmd ::= with UPDATE orconf xfullname indexed_opt SET setlist where_opt], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Input '$' with pending reduce 321
parser: Reduce 321 [ecmd ::= cmdx SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 317 [input ::= cmdlist], go to state 0.
parser: ... then shift 'input', pending reduce -2
parser: Accept!
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
parser: [[[;INSERT INTO last_field VALUES(1,2);;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'INSERT' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'INSERT', go to state 311
parser: Return. Stack=[ecmd with INSERT]
parser: Input 'INTO' in state 311
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', pending reduce 156
parser: Reduce 156 [insert_cmd ::= INSERT orconf], go to state 219.
parser: ... then shift 'insert_cmd', go to state 427
parser: Shift 'INTO', go to state 164
parser: Return. Stack=[ecmd with insert_cmd INTO]
parser: Input 'ID' in state 164
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd with insert_cmd INTO ID]
parser: Input 'VALUES' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 164.
parser: ... then shift 'nm', go to state 393
parser: Reduce 112 [xfullname ::= nm], go to state 164.
parser: ... then shift 'xfullname', go to state 298
parser: Reduce 158 [idlist_opt ::=].
parser: ... then shift 'idlist_opt', go to state 35
parser: Shift 'VALUES', go to state 526
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES]
parser: Input 'LP' in state 526
parser: Shift 'LP', go to state 28
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP]
parser: Input 'INTEGER' in state 28
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 28.
parser: ... then shift 'term', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'INTEGER' in state 107
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'RP', pending reduce 89
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist RP]
parser: Input 'SEMI' with pending reduce 89
parser: Reduce 89 [values ::= VALUES LP nexprlist RP], go to state 35.
parser: ... then shift 'values', go to state 532
parser: Reduce 348 [oneselect ::= values], go to state 35.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 35.
parser: ... then shift 'select', go to state 297
parser: Reduce 152 [upsert ::=].
parser: ... then shift 'upsert', pending reduce 150
parser: Reduce 150 [cmd ::= with insert_cmd INTO xfullname idlist_opt select upsert], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
parser: [[[;INSERT INTO field1 VALUES(3,4);;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'INSERT' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'INSERT', go to state 311
parser: Return. Stack=[ecmd with INSERT]
parser: Input 'INTO' in state 311
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', pending reduce 156
parser: Reduce 156 [insert_cmd ::= INSERT orconf], go to state 219.
parser: ... then shift 'insert_cmd', go to state 427
parser: Shift 'INTO', go to state 164
parser: Return. Stack=[ecmd with insert_cmd INTO]
parser: Input 'ID' in state 164
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd with insert_cmd INTO ID]
parser: Input 'VALUES' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 164.
parser: ... then shift 'nm', go to state 393
parser: Reduce 112 [xfullname ::= nm], go to state 164.
parser: ... then shift 'xfullname', go to state 298
parser: Reduce 158 [idlist_opt ::=].
parser: ... then shift 'idlist_opt', go to state 35
parser: Shift 'VALUES', go to state 526
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES]
parser: Input 'LP' in state 526
parser: Shift 'LP', go to state 28
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP]
parser: Input 'INTEGER' in state 28
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 28.
parser: ... then shift 'term', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'INTEGER' in state 107
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'RP', pending reduce 89
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist RP]
parser: Input 'SEMI' with pending reduce 89
parser: Reduce 89 [values ::= VALUES LP nexprlist RP], go to state 35.
parser: ... then shift 'values', go to state 532
parser: Reduce 348 [oneselect ::= values], go to state 35.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 35.
parser: ... then shift 'select', go to state 297
parser: Reduce 152 [upsert ::=].
parser: ... then shift 'upsert', pending reduce 150
parser: Reduce 150 [cmd ::= with insert_cmd INTO xfullname idlist_opt select upsert], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
parser: [[[;INSERT INTO last_field VALUES(2), (4);SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'INSERT' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'INSERT', go to state 311
parser: Return. Stack=[ecmd with INSERT]
parser: Input 'INTO' in state 311
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', pending reduce 156
parser: Reduce 156 [insert_cmd ::= INSERT orconf], go to state 219.
parser: ... then shift 'insert_cmd', go to state 427
parser: Shift 'INTO', go to state 164
parser: Return. Stack=[ecmd with insert_cmd INTO]
parser: Input 'ID' in state 164
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd with insert_cmd INTO ID]
parser: Input 'VALUES' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 164.
parser: ... then shift 'nm', go to state 393
parser: Reduce 112 [xfullname ::= nm], go to state 164.
parser: ... then shift 'xfullname', go to state 298
parser: Reduce 158 [idlist_opt ::=].
parser: ... then shift 'idlist_opt', go to state 35
parser: Shift 'VALUES', go to state 526
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES]
parser: Input 'LP' in state 526
parser: Shift 'LP', go to state 28
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP]
parser: Input 'INTEGER' in state 28
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 28.
parser: ... then shift 'term', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'RP', pending reduce 89
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist RP]
parser: Input 'COMMA' with pending reduce 89
parser: Reduce 89 [values ::= VALUES LP nexprlist RP], go to state 35.
parser: ... then shift 'values', go to state 532
parser: Shift 'COMMA', go to state 531
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt values COMMA]
parser: Input 'LP' in state 531
parser: Shift 'LP', go to state 29
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt values COMMA LP]
parser: Input 'INTEGER' in state 29
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt values COMMA LP INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 29.
parser: ... then shift 'term', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 29.
parser: ... then shift 'nexprlist', go to state 414
parser: Shift 'RP', pending reduce 90
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt values COMMA LP nexprlist RP]
parser: Input 'SEMI' with pending reduce 90
parser: Reduce 90 [values ::= values COMMA LP nexprlist RP], go to state 35.
parser: ... then shift 'values', go to state 532
parser: Reduce 348 [oneselect ::= values], go to state 35.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 35.
parser: ... then shift 'select', go to state 297
parser: Reduce 152 [upsert ::=].
parser: ... then shift 'upsert', pending reduce 150
parser: Reduce 150 [cmd ::= with insert_cmd INTO xfullname idlist_opt select upsert], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
parser: [[[SELECT CASE (2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'CASE' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'CASE', go to state 27
parser: Return. Stack=[SELECT distinct sclp scanpt CASE]
parser: Input 'LP' in state 27
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct sclp scanpt CASE LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt CASE LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt CASE LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt CASE LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct sclp scanpt CASE LP nexprlist COMMA term RP]
parser: Input 'WHEN' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 27.
parser: ... then shift 'expr', go to state 69
parser: Reduce 212 [case_operand ::= expr], go to state 27.
parser: ... then shift 'case_operand', go to state 356
parser: Shift 'WHEN', go to state 99
parser: Return. Stack=[SELECT distinct sclp scanpt CASE case_operand WHEN]
parser: Input 'LP' in state 99
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct sclp scanpt CASE case_operand WHEN LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt CASE case_operand WHEN LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt CASE case_operand WHEN LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt CASE case_operand WHEN LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct sclp scanpt CASE case_operand WHEN LP nexprlist COMMA term RP]
parser: Input 'THEN' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 99.
parser: ... then shift 'expr', go to state 51
parser: Shift 'THEN', go to state 98
parser: Return. Stack=[SELECT distinct sclp scanpt CASE case_operand WHEN expr THEN]
parser: Input 'INTEGER' in state 98
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt CASE case_operand WHEN expr THEN INTEGER]
parser: Input 'ELSE' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 98.
parser: ... then shift 'term', go to state 66
parser: Reduce 209 [case_exprlist ::= WHEN expr THEN expr], go to state 356.
parser: ... then shift 'case_exprlist', go to state 286
parser: Shift 'ELSE', go to state 100
parser: Return. Stack=[SELECT distinct sclp scanpt CASE case_operand case_exprlist ELSE]
parser: Input 'INTEGER' in state 100
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt CASE case_operand case_exprlist ELSE INTEGER]
parser: Input 'END' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 100.
parser: ... then shift 'term', go to state 67
parser: FALLBACK END => ID
parser: Reduce 210 [case_else ::= ELSE expr], go to state 286.
parser: ... then shift 'case_else', go to state 525
parser: Shift 'END', pending reduce 207
parser: Return. Stack=[SELECT distinct sclp scanpt CASE case_operand case_exprlist case_else END]
parser: Input 'SEMI' with pending reduce 207
parser: Reduce 207 [expr ::= CASE case_operand case_exprlist case_else END], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Reduce 100 [from ::=].
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'CASE' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'CASE', go to state 27
parser: Return. Stack=[SELECT distinct sclp scanpt CASE]
parser: Input 'LP' in state 27
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct sclp scanpt CASE LP]
parser: Input 'SELECT' in state 4
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT distinct sclp scanpt CASE LP SELECT]
parser: Input 'INTEGER' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt CASE LP SELECT distinct sclp scanpt INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 77.
parser: ... then shift 'term', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct sclp scanpt CASE LP SELECT distinct selcollist COMMA]
parser: Input 'INTEGER' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt CASE LP SELECT distinct sclp scanpt INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 77.
parser: ... then shift 'term', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Reduce 100 [from ::=].
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 4.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 4.
parser: ... then shift 'select', go to state 483
parser: Shift 'RP', pending reduce 203
parser: Return. Stack=[SELECT distinct sclp scanpt CASE LP select RP]
parser: Input 'WHEN' with pending reduce 203
parser: Reduce 203 [expr ::= LP select RP], go to state 27.
parser: ... then shift 'expr', go to state 69
parser: Reduce 212 [case_operand ::= expr], go to state 27.
parser: ... then shift 'case_operand', go to state 356
parser: Shift 'WHEN', go to state 99
parser: Return. Stack=[SELECT distinct sclp scanpt CASE case_operand WHEN]
parser: Input 'LP' in state 99
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct sclp scanpt CASE case_operand WHEN LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt CASE case_operand WHEN LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct sclp scanpt CASE case_operand WHEN LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt CASE case_operand WHEN LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct sclp scanpt CASE case_operand WHEN LP nexprlist COMMA term RP]
parser: Input 'THEN' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 99.
parser: ... then shift 'expr', go to state 51
parser: Shift 'THEN', go to state 98
parser: Return. Stack=[SELECT distinct sclp scanpt CASE case_operand WHEN expr THEN]
parser: Input 'INTEGER' in state 98
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt CASE case_operand WHEN expr THEN INTEGER]
parser: Input 'ELSE' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 98.
parser: ... then shift 'term', go to state 66
parser: Reduce 209 [case_exprlist ::= WHEN expr THEN expr], go to state 356.
parser: ... then shift 'case_exprlist', go to state 286
parser: Shift 'ELSE', go to state 100
parser: Return. Stack=[SELECT distinct sclp scanpt CASE case_operand case_exprlist ELSE]
parser: Input 'INTEGER' in state 100
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt CASE case_operand case_exprlist ELSE INTEGER]
parser: Input 'END' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 100.
parser: ... then shift 'term', go to state 67
parser: FALLBACK END => ID
parser: Reduce 210 [case_else ::= ELSE expr], go to state 286.
parser: ... then shift 'case_else', go to state 525
parser: Shift 'END', pending reduce 207
parser: Return. Stack=[SELECT distinct sclp scanpt CASE case_operand case_exprlist case_else END]
parser: Input 'SEMI' with pending reduce 207
parser: Reduce 207 [expr ::= CASE case_operand case_exprlist case_else END], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Reduce 100 [from ::=].
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT 1 FROM last_field WHERE (1,test002) BETWEEN (1,1) AND (3,3)

;CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'INTEGER' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt INTEGER]
parser: Input 'FROM' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 77.
parser: ... then shift 'term', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[SELECT distinct selcollist from WHERE]
parser: Input 'LP' in state 93
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP nexprlist COMMA]
parser: Input 'ID' in state 91
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP nexprlist COMMA ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 91.
parser: ... then shift 'expr', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct selcollist from WHERE LP nexprlist COMMA expr RP]
parser: Input 'BETWEEN' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'BETWEEN', pending reduce 197
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr BETWEEN]
parser: Input 'LP' with pending reduce 197
parser: Reduce 197 [between_op ::= BETWEEN], go to state 63.
parser: ... then shift 'between_op', go to state 109
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr between_op LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr between_op LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr between_op LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr between_op LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr between_op LP nexprlist COMMA term RP]
parser: Input 'AND' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 109.
parser: ... then shift 'expr', go to state 72
parser: Shift 'AND', go to state 108
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr between_op expr AND]
parser: Input 'LP' in state 108
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr between_op expr AND LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr between_op expr AND LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr between_op expr AND LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr between_op expr AND LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr between_op expr AND LP nexprlist COMMA term RP]
parser: Input 'SEMI' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 108.
parser: ... then shift 'expr', go to state 126
parser: Reduce 199 [expr ::= expr between_op expr AND expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[CREATE TABLE field3(test005 PRIMARY KEY, field4);;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 388
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP ID]
parser: Input 'PRIMARY' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 190
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 376
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 150
parser: Shift 'PRIMARY', go to state 475
parser: Return. Stack=[create_table LP columnname carglist PRIMARY]
parser: Input 'KEY' in state 475
parser: Shift 'KEY', go to state 280
parser: Return. Stack=[create_table LP columnname carglist PRIMARY KEY]
parser: Input 'COMMA' in state 280
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 333
parser: Reduce 68 [onconf ::=].
parser: ... then shift 'onconf', go to state 332
parser: Reduce 42 [autoinc ::=].
parser: ... then shift 'autoinc', pending reduce 36
parser: Reduce 36 [ccons ::= PRIMARY KEY sortorder onconf autoinc], go to state 150.
parser: [[[INSERT INTO 'main'.sqlite_master VALUES('index','sqlite_autoindex_field3_1','field3',#4,NULL);]]]
parser: Input 'INSERT' in state 0
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'INSERT', go to state 311
parser: Return. Stack=[with INSERT]
parser: Input 'INTO' in state 311
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', pending reduce 156
parser: Reduce 156 [insert_cmd ::= INSERT orconf], go to state 219.
parser: ... then shift 'insert_cmd', go to state 427
parser: Shift 'INTO', go to state 164
parser: Return. Stack=[with insert_cmd INTO]
parser: Input 'STRING' in state 164
parser: Shift 'STRING', pending reduce 332
parser: Return. Stack=[with insert_cmd INTO STRING]
parser: Input 'DOT' with pending reduce 332
parser: Reduce 332 [nm ::= STRING], go to state 164.
parser: ... then shift 'nm', go to state 393
parser: Shift 'DOT', go to state 218
parser: Return. Stack=[with insert_cmd INTO nm DOT]
parser: Input 'ID' in state 218
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with insert_cmd INTO nm DOT ID]
parser: Input 'VALUES' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 218.
parser: ... then shift 'nm', go to state 429
parser: Reduce 113 [xfullname ::= nm DOT nm], go to state 164.
parser: ... then shift 'xfullname', go to state 298
parser: Reduce 158 [idlist_opt ::=].
parser: ... then shift 'idlist_opt', go to state 35
parser: Shift 'VALUES', go to state 526
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES]
parser: Input 'LP' in state 526
parser: Shift 'LP', go to state 28
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP]
parser: Input 'STRING' in state 28
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 28.
parser: ... then shift 'term', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'STRING' in state 107
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'STRING' in state 107
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'VARIABLE' in state 107
parser: Shift 'VARIABLE', pending reduce 170
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA VARIABLE]
parser: Input 'COMMA' with pending reduce 170
parser: Reduce 170 [expr ::= VARIABLE], go to state 107.
parser: ... then shift 'expr', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'NULL' in state 107
parser: Shift 'NULL', pending reduce 167
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA NULL]
parser: Input 'RP' with pending reduce 167
parser: Reduce 167 [term ::= NULL|FLOAT|BLOB], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'RP', pending reduce 89
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist RP]
parser: Input 'SEMI' with pending reduce 89
parser: Reduce 89 [values ::= VALUES LP nexprlist RP], go to state 35.
parser: ... then shift 'values', go to state 532
parser: Reduce 348 [oneselect ::= values], go to state 35.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 35.
parser: ... then shift 'select', go to state 297
parser: Reduce 152 [upsert ::=].
parser: ... then shift 'upsert', pending reduce 150
parser: Reduce 150 [cmd ::= with insert_cmd INTO xfullname idlist_opt select upsert], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Input '$' with pending reduce 321
parser: Reduce 321 [ecmd ::= cmdx SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 317 [input ::= cmdlist], go to state 0.
parser: ... then shift 'input', pending reduce -2
parser: Accept!
parser: ... then shift 'ccons', pending reduce 338
parser: Reduce 338 [carglist ::= carglist ccons], go to state 376.
parser: ... then shift 'carglist', go to state 150
parser: Reduce 330 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'RP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 190
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 383
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 151
parser: Reduce 329 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Reduce 60 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 538
parser: Shift 'RP', go to state 361
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 361
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: [[[UPDATE 'main'.sqlite_master SET type='table', name='field3', tbl_name='field3', rootpage=#2, sql='CREATE TABLE field3(test005 PRIMARY KEY, field4)' WHERE rowid=#1]]]
parser: Input 'UPDATE' in state 0
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'UPDATE', go to state 299
parser: Return. Stack=[with UPDATE]
parser: Input 'STRING' in state 299
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', go to state 165
parser: Shift 'STRING', pending reduce 332
parser: Return. Stack=[with UPDATE orconf STRING]
parser: Input 'DOT' with pending reduce 332
parser: Reduce 332 [nm ::= STRING], go to state 165.
parser: ... then shift 'nm', go to state 393
parser: Shift 'DOT', go to state 218
parser: Return. Stack=[with UPDATE orconf nm DOT]
parser: Input 'ID' in state 218
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf nm DOT ID]
parser: Input 'SET' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 218.
parser: ... then shift 'nm', go to state 429
parser: Reduce 113 [xfullname ::= nm DOT nm], go to state 165.
parser: ... then shift 'xfullname', go to state 271
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 428
parser: Shift 'SET', go to state 153
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET]
parser: Input 'ID' in state 153
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 153.
parser: ... then shift 'nm', go to state 442
parser: Shift 'EQ', go to state 84
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ]
parser: Input 'STRING' in state 84
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 84.
parser: ... then shift 'term', go to state 58
parser: Reduce 148 [setlist ::= nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'VARIABLE' in state 86
parser: Shift 'VARIABLE', pending reduce 170
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ VARIABLE]
parser: Input 'COMMA' with pending reduce 170
parser: Reduce 170 [expr ::= VARIABLE], go to state 86.
parser: ... then shift 'expr', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'WHERE' in state 537
parser: Reduce 168 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 416
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr EQ]
parser: Input 'VARIABLE' in state 117
parser: Shift 'VARIABLE', pending reduce 170
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr EQ VARIABLE]
parser: Input 'SEMI' with pending reduce 170
parser: Reduce 170 [expr ::= VARIABLE], go to state 117.
parser: ... then shift 'expr', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 270.
parser: ... then shift 'where_opt', pending reduce 145
parser: Reduce 145 [cmd ::= with UPDATE orconf xfullname indexed_opt SET setlist where_opt], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Input '$' with pending reduce 321
parser: Reduce 321 [ecmd ::= cmdx SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 317 [input ::= cmdlist], go to state 0.
parser: ... then shift 'input', pending reduce -2
parser: Accept!
parser: ... then shift 'create_table_args', pending reduce 328
parser: Reduce 328 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='field3' AND type!='trigger' ORDER BY rowid]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'FROM' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'STRING' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'STRING', pending reduce 332
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix STRING]
parser: Input 'DOT' with pending reduce 332
parser: Reduce 332 [nm ::= STRING], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Shift 'DOT', go to state 245
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID' in state 245
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 245.
parser: ... then shift 'nm', pending reduce 109
parser: Reduce 109 [dbnm ::= DOT nm], go to state 349.
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[SELECT distinct selcollist from WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND' in state 537
parser: Reduce 168 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'AND', go to state 120
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID' in state 120
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'NE' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Shift 'NE', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr NE]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr NE STRING]
parser: Input 'ORDER' in state 537
parser: Reduce 168 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Reduce 179 [expr ::= expr AND expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[CREATE TABLE field3(test005 PRIMARY KEY, field4)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 388
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP ID]
parser: Input 'PRIMARY' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 190
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 376
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 150
parser: Shift 'PRIMARY', go to state 475
parser: Return. Stack=[create_table LP columnname carglist PRIMARY]
parser: Input 'KEY' in state 475
parser: Shift 'KEY', go to state 280
parser: Return. Stack=[create_table LP columnname carglist PRIMARY KEY]
parser: Input 'COMMA' in state 280
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 333
parser: Reduce 68 [onconf ::=].
parser: ... then shift 'onconf', go to state 332
parser: Reduce 42 [autoinc ::=].
parser: ... then shift 'autoinc', pending reduce 36
parser: Reduce 36 [ccons ::= PRIMARY KEY sortorder onconf autoinc], go to state 150.
parser: ... then shift 'ccons', pending reduce 338
parser: Reduce 338 [carglist ::= carglist ccons], go to state 376.
parser: ... then shift 'carglist', go to state 150
parser: Reduce 330 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'RP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 190
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 383
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 151
parser: Reduce 329 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Reduce 60 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 538
parser: Shift 'RP', go to state 361
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 361
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 328
parser: Reduce 328 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[;CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007);;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'CREATE' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[ecmd CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 1.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 388
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[ecmd createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 1.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[ecmd create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd create_table LP ID]
parser: Input 'ID' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 190
parser: Shift 'ID', pending reduce 335
parser: Return. Stack=[ecmd create_table LP nm ID]
parser: Input 'PRIMARY' with pending reduce 335
parser: Reduce 335 [typename ::= ID|STRING], go to state 190.
parser: ... then shift 'typename', go to state 390
parser: Reduce 334 [typetoken ::= typename], go to state 190.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 376
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 150
parser: Shift 'PRIMARY', go to state 475
parser: Return. Stack=[ecmd create_table LP columnname carglist PRIMARY]
parser: Input 'KEY' in state 475
parser: Shift 'KEY', go to state 280
parser: Return. Stack=[ecmd create_table LP columnname carglist PRIMARY KEY]
parser: Input 'COMMA' in state 280
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 333
parser: Reduce 68 [onconf ::=].
parser: ... then shift 'onconf', go to state 332
parser: Reduce 42 [autoinc ::=].
parser: ... then shift 'autoinc', pending reduce 36
parser: Reduce 36 [ccons ::= PRIMARY KEY sortorder onconf autoinc], go to state 150.
parser: ... then shift 'ccons', pending reduce 338
parser: Reduce 338 [carglist ::= carglist ccons], go to state 376.
parser: ... then shift 'carglist', go to state 150
parser: Reduce 330 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[ecmd create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd create_table LP columnlist COMMA ID]
parser: Input 'RP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 190
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 383
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 151
parser: Reduce 329 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Reduce 60 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 538
parser: Shift 'RP', go to state 361
parser: Return. Stack=[ecmd create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 361
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: [[[UPDATE 'main'.sqlite_master SET type='table', name='test006', tbl_name='test006', rootpage=#2, sql='CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007)' WHERE rowid=#1]]]
parser: Input 'UPDATE' in state 0
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'UPDATE', go to state 299
parser: Return. Stack=[with UPDATE]
parser: Input 'STRING' in state 299
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', go to state 165
parser: Shift 'STRING', pending reduce 332
parser: Return. Stack=[with UPDATE orconf STRING]
parser: Input 'DOT' with pending reduce 332
parser: Reduce 332 [nm ::= STRING], go to state 165.
parser: ... then shift 'nm', go to state 393
parser: Shift 'DOT', go to state 218
parser: Return. Stack=[with UPDATE orconf nm DOT]
parser: Input 'ID' in state 218
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf nm DOT ID]
parser: Input 'SET' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 218.
parser: ... then shift 'nm', go to state 429
parser: Reduce 113 [xfullname ::= nm DOT nm], go to state 165.
parser: ... then shift 'xfullname', go to state 271
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 428
parser: Shift 'SET', go to state 153
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET]
parser: Input 'ID' in state 153
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 153.
parser: ... then shift 'nm', go to state 442
parser: Shift 'EQ', go to state 84
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ]
parser: Input 'STRING' in state 84
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 84.
parser: ... then shift 'term', go to state 58
parser: Reduce 148 [setlist ::= nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'VARIABLE' in state 86
parser: Shift 'VARIABLE', pending reduce 170
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ VARIABLE]
parser: Input 'COMMA' with pending reduce 170
parser: Reduce 170 [expr ::= VARIABLE], go to state 86.
parser: ... then shift 'expr', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'WHERE' in state 537
parser: Reduce 168 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 416
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr EQ]
parser: Input 'VARIABLE' in state 117
parser: Shift 'VARIABLE', pending reduce 170
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr EQ VARIABLE]
parser: Input 'SEMI' with pending reduce 170
parser: Reduce 170 [expr ::= VARIABLE], go to state 117.
parser: ... then shift 'expr', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 270.
parser: ... then shift 'where_opt', pending reduce 145
parser: Reduce 145 [cmd ::= with UPDATE orconf xfullname indexed_opt SET setlist where_opt], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Input '$' with pending reduce 321
parser: Reduce 321 [ecmd ::= cmdx SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 317 [input ::= cmdlist], go to state 0.
parser: ... then shift 'input', pending reduce -2
parser: Accept!
parser: ... then shift 'create_table_args', pending reduce 328
parser: Reduce 328 [cmd ::= create_table create_table_args], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
parser: [[[SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='test006' AND type!='trigger' ORDER BY rowid]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'FROM' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'STRING' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'STRING', pending reduce 332
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix STRING]
parser: Input 'DOT' with pending reduce 332
parser: Reduce 332 [nm ::= STRING], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Shift 'DOT', go to state 245
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID' in state 245
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 245.
parser: ... then shift 'nm', pending reduce 109
parser: Reduce 109 [dbnm ::= DOT nm], go to state 349.
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[SELECT distinct selcollist from WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND' in state 537
parser: Reduce 168 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'AND', go to state 120
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID' in state 120
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'NE' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Shift 'NE', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr NE]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr NE STRING]
parser: Input 'ORDER' in state 537
parser: Reduce 168 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Reduce 179 [expr ::= expr AND expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[CREATE TABLE test006(field5 INTEGER PRIMARY KEY, test007)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 388
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP ID]
parser: Input 'ID' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 190
parser: Shift 'ID', pending reduce 335
parser: Return. Stack=[create_table LP nm ID]
parser: Input 'PRIMARY' with pending reduce 335
parser: Reduce 335 [typename ::= ID|STRING], go to state 190.
parser: ... then shift 'typename', go to state 390
parser: Reduce 334 [typetoken ::= typename], go to state 190.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 376
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 150
parser: Shift 'PRIMARY', go to state 475
parser: Return. Stack=[create_table LP columnname carglist PRIMARY]
parser: Input 'KEY' in state 475
parser: Shift 'KEY', go to state 280
parser: Return. Stack=[create_table LP columnname carglist PRIMARY KEY]
parser: Input 'COMMA' in state 280
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 333
parser: Reduce 68 [onconf ::=].
parser: ... then shift 'onconf', go to state 332
parser: Reduce 42 [autoinc ::=].
parser: ... then shift 'autoinc', pending reduce 36
parser: Reduce 36 [ccons ::= PRIMARY KEY sortorder onconf autoinc], go to state 150.
parser: ... then shift 'ccons', pending reduce 338
parser: Reduce 338 [carglist ::= carglist ccons], go to state 376.
parser: ... then shift 'carglist', go to state 150
parser: Reduce 330 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'RP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 190
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 383
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 151
parser: Reduce 329 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Reduce 60 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 538
parser: Shift 'RP', go to state 361
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 361
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 328
parser: Reduce 328 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[;CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END;;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'CREATE' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[ecmd CREATE]
parser: Input 'TRIGGER' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 1.
parser: ... then shift 'createkw', go to state 134
parser: FALLBACK TRIGGER => ID
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 388
parser: Shift 'TRIGGER', go to state 319
parser: Return. Stack=[ecmd createkw temp TRIGGER]
parser: Input 'ID' in state 319
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 227
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd createkw temp TRIGGER ifnotexists ID]
parser: Input 'AFTER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 227.
parser: ... then shift 'nm', go to state 318
parser: FALLBACK AFTER => ID
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 257
parser: Shift 'AFTER', pending reduce 242
parser: Return. Stack=[ecmd createkw temp TRIGGER ifnotexists nm dbnm AFTER]
parser: Input 'UPDATE' with pending reduce 242
parser: Reduce 242 [trigger_time ::= BEFORE|AFTER], go to state 257.
parser: ... then shift 'trigger_time', go to state 256
parser: Shift 'UPDATE', go to state 456
parser: Return. Stack=[ecmd createkw temp TRIGGER ifnotexists nm dbnm trigger_time UPDATE]
parser: Input 'ON' in state 456
parser: Reduce 246 [trigger_event ::= UPDATE], go to state 256.
parser: ... then shift 'trigger_event', go to state 460
parser: Shift 'ON', go to state 179
parser: Return. Stack=[ecmd createkw temp TRIGGER ifnotexists nm dbnm trigger_time trigger_event ON]
parser: Input 'ID' in state 179
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd createkw temp TRIGGER ifnotexists nm dbnm trigger_time trigger_event ON ID]
parser: Input 'BEGIN' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 179.
parser: ... then shift 'nm', go to state 459
parser: FALLBACK BEGIN => ID
parser: Reduce 110 [fullname ::= nm], go to state 179.
parser: ... then shift 'fullname', go to state 317
parser: FALLBACK BEGIN => ID
parser: Reduce 360 [foreach_clause ::=].
parser: ... then shift 'foreach_clause', go to state 316
parser: FALLBACK BEGIN => ID
parser: Reduce 248 [when_clause ::=].
parser: ... then shift 'when_clause', pending reduce 241
parser: Reduce 241 [trigger_decl ::= temp TRIGGER ifnotexists nm dbnm trigger_time trigger_event ON fullname foreach_clause when_clause], go to state 134.
parser: ... then shift 'trigger_decl', go to state 450
parser: Shift 'BEGIN', go to state 144
parser: Return. Stack=[ecmd createkw trigger_decl BEGIN]
parser: Input 'UPDATE' in state 144
parser: Shift 'UPDATE', go to state 312
parser: Return. Stack=[ecmd createkw trigger_decl BEGIN UPDATE]
parser: Input 'PRECEDING' in state 312
parser: FALLBACK PRECEDING => ID
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', go to state 177
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', pending reduce 331
parser: Return. Stack=[ecmd createkw trigger_decl BEGIN UPDATE orconf PRECEDING]
parser: Input 'SET' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 177.
parser: ... then shift 'nm', go to state 448
parser: Reduce 362 [trnm ::= nm], go to state 177.
parser: ... then shift 'trnm', go to state 276
parser: Reduce 363 [tridxby ::=].
parser: ... then shift 'tridxby', go to state 445
parser: Shift 'SET', go to state 156
parser: Return. Stack=[ecmd createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET]
parser: Input 'LP' in state 156
parser: Shift 'LP', go to state 175
parser: Return. Stack=[ecmd createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET LP]
parser: Input 'ID' in state 175
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET LP ID]
parser: Input 'COMMA' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 175.
parser: ... then shift 'nm', pending reduce 161
parser: Reduce 161 [idlist ::= nm], go to state 175.
parser: ... then shift 'idlist', go to state 398
parser: Shift 'COMMA', go to state 241
parser: Return. Stack=[ecmd createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET LP idlist COMMA]
parser: Input 'ID' in state 241
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET LP idlist COMMA ID]
parser: Input 'COMMA' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 241.
parser: ... then shift 'nm', pending reduce 160
parser: Reduce 160 [idlist ::= idlist COMMA nm], go to state 175.
parser: ... then shift 'idlist', go to state 398
parser: Shift 'COMMA', go to state 241
parser: Return. Stack=[ecmd createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET LP idlist COMMA]
parser: Input 'ID' in state 241
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET LP idlist COMMA ID]
parser: Input 'RP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 241.
parser: ... then shift 'nm', pending reduce 160
parser: Reduce 160 [idlist ::= idlist COMMA nm], go to state 175.
parser: ... then shift 'idlist', go to state 398
parser: Shift 'RP', go to state 441
parser: Return. Stack=[ecmd createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET LP idlist RP]
parser: Input 'EQ' in state 441
parser: Shift 'EQ', go to state 83
parser: Return. Stack=[ecmd createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET LP idlist RP EQ]
parser: Input 'LP' in state 83
parser: Shift 'LP', go to state 4
parser: Return. Stack=[ecmd createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET LP idlist RP EQ LP]
parser: Input 'SELECT' in state 4
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[ecmd createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET LP idlist RP EQ LP SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET LP idlist RP EQ LP SELECT distinct sclp scanpt ID]
parser: Input 'DOT' in state 416
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 77.
parser: ... then shift 'nm', go to state 491
parser: Shift 'DOT', go to state 205
parser: Return. Stack=[ecmd createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET LP idlist RP EQ LP SELECT distinct sclp scanpt nm DOT]
parser: Input 'ID' in state 205
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET LP idlist RP EQ LP SELECT distinct sclp scanpt nm DOT ID]
parser: Input 'COMMA' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 205.
parser: ... then shift 'nm', go to state 534
parser: Reduce 165 [expr ::= nm DOT nm], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[ecmd createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET LP idlist RP EQ LP SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET LP idlist RP EQ LP SELECT distinct sclp scanpt ID]
parser: Input 'DOT' in state 416
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 77.
parser: ... then shift 'nm', go to state 491
parser: Shift 'DOT', go to state 205
parser: Return. Stack=[ecmd createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET LP idlist RP EQ LP SELECT distinct sclp scanpt nm DOT]
parser: Input 'ID' in state 205
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET LP idlist RP EQ LP SELECT distinct sclp scanpt nm DOT ID]
parser: Input 'PLUS' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 205.
parser: ... then shift 'nm', go to state 534
parser: Reduce 165 [expr ::= nm DOT nm], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Shift 'PLUS', go to state 115
parser: Return. Stack=[ecmd createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET LP idlist RP EQ LP SELECT distinct sclp scanpt expr PLUS]
parser: Input 'INTEGER' in state 115
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET LP idlist RP EQ LP SELECT distinct sclp scanpt expr PLUS INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 115.
parser: ... then shift 'term', go to state 132
parser: Reduce 184 [expr ::= expr PLUS|MINUS expr], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[ecmd createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET LP idlist RP EQ LP SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET LP idlist RP EQ LP SELECT distinct sclp scanpt ID]
parser: Input 'DOT' in state 416
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 77.
parser: ... then shift 'nm', go to state 491
parser: Shift 'DOT', go to state 205
parser: Return. Stack=[ecmd createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET LP idlist RP EQ LP SELECT distinct sclp scanpt nm DOT]
parser: Input 'ID' in state 205
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET LP idlist RP EQ LP SELECT distinct sclp scanpt nm DOT ID]
parser: Input 'PLUS' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 205.
parser: ... then shift 'nm', go to state 534
parser: Reduce 165 [expr ::= nm DOT nm], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Shift 'PLUS', go to state 115
parser: Return. Stack=[ecmd createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET LP idlist RP EQ LP SELECT distinct sclp scanpt expr PLUS]
parser: Input 'INTEGER' in state 115
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET LP idlist RP EQ LP SELECT distinct sclp scanpt expr PLUS INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 115.
parser: ... then shift 'term', go to state 132
parser: Reduce 184 [expr ::= expr PLUS|MINUS expr], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Reduce 100 [from ::=].
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 4.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 4.
parser: ... then shift 'select', go to state 483
parser: Shift 'RP', pending reduce 203
parser: Return. Stack=[ecmd createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET LP idlist RP EQ LP select RP]
parser: Input 'SEMI' with pending reduce 203
parser: Reduce 203 [expr ::= LP select RP], go to state 83.
parser: ... then shift 'expr', go to state 57
parser: Reduce 149 [setlist ::= LP idlist RP EQ expr], go to state 156.
parser: ... then shift 'setlist', go to state 275
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 375
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', pending reduce 255
parser: Reduce 255 [trigger_cmd ::= UPDATE orconf trnm tridxby SET setlist where_opt scanpt], go to state 144.
parser: ... then shift 'trigger_cmd', go to state 434
parser: Shift 'SEMI', pending reduce 251
parser: Return. Stack=[ecmd createkw trigger_decl BEGIN trigger_cmd SEMI]
parser: Input 'END' with pending reduce 251
parser: Reduce 251 [trigger_cmd_list ::= trigger_cmd SEMI], go to state 144.
parser: ... then shift 'trigger_cmd_list', go to state 187
parser: Shift 'END', pending reduce 240
parser: Return. Stack=[ecmd createkw trigger_decl BEGIN trigger_cmd_list END]
parser: Input 'SEMI' with pending reduce 240
parser: Reduce 240 [cmd ::= createkw trigger_decl BEGIN trigger_cmd_list END], go to state 1.
parser: [[[INSERT INTO 'main'.sqlite_master VALUES('trigger','field6','field1',0,'CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END')]]]
parser: Input 'INSERT' in state 0
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'INSERT', go to state 311
parser: Return. Stack=[with INSERT]
parser: Input 'INTO' in state 311
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', pending reduce 156
parser: Reduce 156 [insert_cmd ::= INSERT orconf], go to state 219.
parser: ... then shift 'insert_cmd', go to state 427
parser: Shift 'INTO', go to state 164
parser: Return. Stack=[with insert_cmd INTO]
parser: Input 'STRING' in state 164
parser: Shift 'STRING', pending reduce 332
parser: Return. Stack=[with insert_cmd INTO STRING]
parser: Input 'DOT' with pending reduce 332
parser: Reduce 332 [nm ::= STRING], go to state 164.
parser: ... then shift 'nm', go to state 393
parser: Shift 'DOT', go to state 218
parser: Return. Stack=[with insert_cmd INTO nm DOT]
parser: Input 'ID' in state 218
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with insert_cmd INTO nm DOT ID]
parser: Input 'VALUES' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 218.
parser: ... then shift 'nm', go to state 429
parser: Reduce 113 [xfullname ::= nm DOT nm], go to state 164.
parser: ... then shift 'xfullname', go to state 298
parser: Reduce 158 [idlist_opt ::=].
parser: ... then shift 'idlist_opt', go to state 35
parser: Shift 'VALUES', go to state 526
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES]
parser: Input 'LP' in state 526
parser: Shift 'LP', go to state 28
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP]
parser: Input 'STRING' in state 28
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 28.
parser: ... then shift 'term', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'STRING' in state 107
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'STRING' in state 107
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'INTEGER' in state 107
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'STRING' in state 107
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA STRING]
parser: Input 'RP' in state 537
parser: Reduce 168 [term ::= STRING], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'RP', pending reduce 89
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist RP]
parser: Input 'SEMI' with pending reduce 89
parser: Reduce 89 [values ::= VALUES LP nexprlist RP], go to state 35.
parser: ... then shift 'values', go to state 532
parser: Reduce 348 [oneselect ::= values], go to state 35.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 35.
parser: ... then shift 'select', go to state 297
parser: Reduce 152 [upsert ::=].
parser: ... then shift 'upsert', pending reduce 150
parser: Reduce 150 [cmd ::= with insert_cmd INTO xfullname idlist_opt select upsert], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Input '$' with pending reduce 321
parser: Reduce 321 [ecmd ::= cmdx SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 317 [input ::= cmdlist], go to state 0.
parser: ... then shift 'input', pending reduce -2
parser: Accept!
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
parser: [[[SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE type='trigger' AND name='field6' ORDER BY rowid]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'FROM' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'STRING' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'STRING', pending reduce 332
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix STRING]
parser: Input 'DOT' with pending reduce 332
parser: Reduce 332 [nm ::= STRING], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Shift 'DOT', go to state 245
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID' in state 245
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 245.
parser: ... then shift 'nm', pending reduce 109
parser: Reduce 109 [dbnm ::= DOT nm], go to state 349.
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[SELECT distinct selcollist from WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND' in state 537
parser: Reduce 168 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'AND', go to state 120
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID' in state 120
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr EQ]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr EQ STRING]
parser: Input 'ORDER' in state 537
parser: Reduce 168 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Reduce 179 [expr ::= expr AND expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[CREATE TRIGGER field6 AFTER UPDATE ON field1 BEGIN
     UPDATE preceding SET (x,test001,x)=(SELECT new.test003,new.test003+1,new.test003+2);
  END]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TRIGGER' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: FALLBACK TRIGGER => ID
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 388
parser: Shift 'TRIGGER', go to state 319
parser: Return. Stack=[createkw temp TRIGGER]
parser: Input 'ID' in state 319
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 227
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp TRIGGER ifnotexists ID]
parser: Input 'AFTER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 227.
parser: ... then shift 'nm', go to state 318
parser: FALLBACK AFTER => ID
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 257
parser: Shift 'AFTER', pending reduce 242
parser: Return. Stack=[createkw temp TRIGGER ifnotexists nm dbnm AFTER]
parser: Input 'UPDATE' with pending reduce 242
parser: Reduce 242 [trigger_time ::= BEFORE|AFTER], go to state 257.
parser: ... then shift 'trigger_time', go to state 256
parser: Shift 'UPDATE', go to state 456
parser: Return. Stack=[createkw temp TRIGGER ifnotexists nm dbnm trigger_time UPDATE]
parser: Input 'ON' in state 456
parser: Reduce 246 [trigger_event ::= UPDATE], go to state 256.
parser: ... then shift 'trigger_event', go to state 460
parser: Shift 'ON', go to state 179
parser: Return. Stack=[createkw temp TRIGGER ifnotexists nm dbnm trigger_time trigger_event ON]
parser: Input 'ID' in state 179
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp TRIGGER ifnotexists nm dbnm trigger_time trigger_event ON ID]
parser: Input 'BEGIN' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 179.
parser: ... then shift 'nm', go to state 459
parser: FALLBACK BEGIN => ID
parser: Reduce 110 [fullname ::= nm], go to state 179.
parser: ... then shift 'fullname', go to state 317
parser: FALLBACK BEGIN => ID
parser: Reduce 360 [foreach_clause ::=].
parser: ... then shift 'foreach_clause', go to state 316
parser: FALLBACK BEGIN => ID
parser: Reduce 248 [when_clause ::=].
parser: ... then shift 'when_clause', pending reduce 241
parser: Reduce 241 [trigger_decl ::= temp TRIGGER ifnotexists nm dbnm trigger_time trigger_event ON fullname foreach_clause when_clause], go to state 134.
parser: ... then shift 'trigger_decl', go to state 450
parser: Shift 'BEGIN', go to state 144
parser: Return. Stack=[createkw trigger_decl BEGIN]
parser: Input 'UPDATE' in state 144
parser: Shift 'UPDATE', go to state 312
parser: Return. Stack=[createkw trigger_decl BEGIN UPDATE]
parser: Input 'PRECEDING' in state 312
parser: FALLBACK PRECEDING => ID
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', go to state 177
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', pending reduce 331
parser: Return. Stack=[createkw trigger_decl BEGIN UPDATE orconf PRECEDING]
parser: Input 'SET' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 177.
parser: ... then shift 'nm', go to state 448
parser: Reduce 362 [trnm ::= nm], go to state 177.
parser: ... then shift 'trnm', go to state 276
parser: Reduce 363 [tridxby ::=].
parser: ... then shift 'tridxby', go to state 445
parser: Shift 'SET', go to state 156
parser: Return. Stack=[createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET]
parser: Input 'LP' in state 156
parser: Shift 'LP', go to state 175
parser: Return. Stack=[createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET LP]
parser: Input 'ID' in state 175
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET LP ID]
parser: Input 'COMMA' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 175.
parser: ... then shift 'nm', pending reduce 161
parser: Reduce 161 [idlist ::= nm], go to state 175.
parser: ... then shift 'idlist', go to state 398
parser: Shift 'COMMA', go to state 241
parser: Return. Stack=[createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET LP idlist COMMA]
parser: Input 'ID' in state 241
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET LP idlist COMMA ID]
parser: Input 'COMMA' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 241.
parser: ... then shift 'nm', pending reduce 160
parser: Reduce 160 [idlist ::= idlist COMMA nm], go to state 175.
parser: ... then shift 'idlist', go to state 398
parser: Shift 'COMMA', go to state 241
parser: Return. Stack=[createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET LP idlist COMMA]
parser: Input 'ID' in state 241
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET LP idlist COMMA ID]
parser: Input 'RP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 241.
parser: ... then shift 'nm', pending reduce 160
parser: Reduce 160 [idlist ::= idlist COMMA nm], go to state 175.
parser: ... then shift 'idlist', go to state 398
parser: Shift 'RP', go to state 441
parser: Return. Stack=[createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET LP idlist RP]
parser: Input 'EQ' in state 441
parser: Shift 'EQ', go to state 83
parser: Return. Stack=[createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET LP idlist RP EQ]
parser: Input 'LP' in state 83
parser: Shift 'LP', go to state 4
parser: Return. Stack=[createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET LP idlist RP EQ LP]
parser: Input 'SELECT' in state 4
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET LP idlist RP EQ LP SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET LP idlist RP EQ LP SELECT distinct sclp scanpt ID]
parser: Input 'DOT' in state 416
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 77.
parser: ... then shift 'nm', go to state 491
parser: Shift 'DOT', go to state 205
parser: Return. Stack=[createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET LP idlist RP EQ LP SELECT distinct sclp scanpt nm DOT]
parser: Input 'ID' in state 205
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET LP idlist RP EQ LP SELECT distinct sclp scanpt nm DOT ID]
parser: Input 'COMMA' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 205.
parser: ... then shift 'nm', go to state 534
parser: Reduce 165 [expr ::= nm DOT nm], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET LP idlist RP EQ LP SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET LP idlist RP EQ LP SELECT distinct sclp scanpt ID]
parser: Input 'DOT' in state 416
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 77.
parser: ... then shift 'nm', go to state 491
parser: Shift 'DOT', go to state 205
parser: Return. Stack=[createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET LP idlist RP EQ LP SELECT distinct sclp scanpt nm DOT]
parser: Input 'ID' in state 205
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET LP idlist RP EQ LP SELECT distinct sclp scanpt nm DOT ID]
parser: Input 'PLUS' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 205.
parser: ... then shift 'nm', go to state 534
parser: Reduce 165 [expr ::= nm DOT nm], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Shift 'PLUS', go to state 115
parser: Return. Stack=[createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET LP idlist RP EQ LP SELECT distinct sclp scanpt expr PLUS]
parser: Input 'INTEGER' in state 115
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET LP idlist RP EQ LP SELECT distinct sclp scanpt expr PLUS INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 115.
parser: ... then shift 'term', go to state 132
parser: Reduce 184 [expr ::= expr PLUS|MINUS expr], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET LP idlist RP EQ LP SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET LP idlist RP EQ LP SELECT distinct sclp scanpt ID]
parser: Input 'DOT' in state 416
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 77.
parser: ... then shift 'nm', go to state 491
parser: Shift 'DOT', go to state 205
parser: Return. Stack=[createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET LP idlist RP EQ LP SELECT distinct sclp scanpt nm DOT]
parser: Input 'ID' in state 205
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET LP idlist RP EQ LP SELECT distinct sclp scanpt nm DOT ID]
parser: Input 'PLUS' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 205.
parser: ... then shift 'nm', go to state 534
parser: Reduce 165 [expr ::= nm DOT nm], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Shift 'PLUS', go to state 115
parser: Return. Stack=[createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET LP idlist RP EQ LP SELECT distinct sclp scanpt expr PLUS]
parser: Input 'INTEGER' in state 115
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET LP idlist RP EQ LP SELECT distinct sclp scanpt expr PLUS INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 115.
parser: ... then shift 'term', go to state 132
parser: Reduce 184 [expr ::= expr PLUS|MINUS expr], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Reduce 100 [from ::=].
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 4.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 4.
parser: ... then shift 'select', go to state 483
parser: Shift 'RP', pending reduce 203
parser: Return. Stack=[createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET LP idlist RP EQ LP select RP]
parser: Input 'SEMI' with pending reduce 203
parser: Reduce 203 [expr ::= LP select RP], go to state 83.
parser: ... then shift 'expr', go to state 57
parser: Reduce 149 [setlist ::= LP idlist RP EQ expr], go to state 156.
parser: ... then shift 'setlist', go to state 275
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 375
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', pending reduce 255
parser: Reduce 255 [trigger_cmd ::= UPDATE orconf trnm tridxby SET setlist where_opt scanpt], go to state 144.
parser: ... then shift 'trigger_cmd', go to state 434
parser: Shift 'SEMI', pending reduce 251
parser: Return. Stack=[createkw trigger_decl BEGIN trigger_cmd SEMI]
parser: Input 'END' with pending reduce 251
parser: Reduce 251 [trigger_cmd_list ::= trigger_cmd SEMI], go to state 144.
parser: ... then shift 'trigger_cmd_list', go to state 187
parser: Shift 'END', pending reduce 240
parser: Return. Stack=[createkw trigger_decl BEGIN trigger_cmd_list END]
parser: Input 'SEMI' with pending reduce 240
parser: Reduce 240 [cmd ::= createkw trigger_decl BEGIN trigger_cmd_list END], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[;SELECT * FROM field2;;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'SELECT' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[ecmd SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 96
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[ecmd SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'SEMI' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 1.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 1.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
parser: [[[;
;UPDATE last_field SET test002=97;;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'SEMI' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[ecmd SEMI]
parser: Input 'UPDATE' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 1.
parser: ... then shift 'ecmd', pending reduce 318
parser: Reduce 318 [cmdlist ::= cmdlist ecmd], go to state 0.
parser: ... then shift 'cmdlist', go to state 1
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'UPDATE', go to state 299
parser: Return. Stack=[cmdlist with UPDATE]
parser: Input 'ID' in state 299
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', go to state 165
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[cmdlist with UPDATE orconf ID]
parser: Input 'SET' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 165.
parser: ... then shift 'nm', go to state 393
parser: Reduce 112 [xfullname ::= nm], go to state 165.
parser: ... then shift 'xfullname', go to state 271
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 428
parser: Shift 'SET', go to state 153
parser: Return. Stack=[cmdlist with UPDATE orconf xfullname indexed_opt SET]
parser: Input 'ID' in state 153
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[cmdlist with UPDATE orconf xfullname indexed_opt SET ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 153.
parser: ... then shift 'nm', go to state 442
parser: Shift 'EQ', go to state 84
parser: Return. Stack=[cmdlist with UPDATE orconf xfullname indexed_opt SET nm EQ]
parser: Input 'INTEGER' in state 84
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[cmdlist with UPDATE orconf xfullname indexed_opt SET nm EQ INTEGER]
parser: Input 'SEMI' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 84.
parser: ... then shift 'term', go to state 58
parser: Reduce 148 [setlist ::= nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', pending reduce 145
parser: Reduce 145 [cmd ::= with UPDATE orconf xfullname indexed_opt SET setlist where_opt], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdlist cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping cmdlist
parser: [[[;
;CREATE TABLE test008(field7, test009, field8, test010, field9);;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'SEMI' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[ecmd SEMI]
parser: Input 'CREATE' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 1.
parser: ... then shift 'ecmd', pending reduce 318
parser: Reduce 318 [cmdlist ::= cmdlist ecmd], go to state 0.
parser: ... then shift 'cmdlist', go to state 1
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[cmdlist CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 1.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 388
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[cmdlist createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[cmdlist createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 1.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[cmdlist create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[cmdlist create_table LP ID]
parser: Input 'COMMA' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 190
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 376
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 150
parser: Reduce 330 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[cmdlist create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[cmdlist create_table LP columnlist COMMA ID]
parser: Input 'COMMA' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 190
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 383
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 151
parser: Reduce 329 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[cmdlist create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[cmdlist create_table LP columnlist COMMA ID]
parser: Input 'COMMA' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 190
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 383
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 151
parser: Reduce 329 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[cmdlist create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[cmdlist create_table LP columnlist COMMA ID]
parser: Input 'COMMA' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 190
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 383
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 151
parser: Reduce 329 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[cmdlist create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[cmdlist create_table LP columnlist COMMA ID]
parser: Input 'RP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 190
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 383
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 151
parser: Reduce 329 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Reduce 60 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 538
parser: Shift 'RP', go to state 361
parser: Return. Stack=[cmdlist create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 361
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: [[[UPDATE 'main'.sqlite_master SET type='table', name='test008', tbl_name='test008', rootpage=#2, sql='CREATE TABLE test008(field7, test009, field8, test010, field9)' WHERE rowid=#1]]]
parser: Input 'UPDATE' in state 0
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'UPDATE', go to state 299
parser: Return. Stack=[with UPDATE]
parser: Input 'STRING' in state 299
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', go to state 165
parser: Shift 'STRING', pending reduce 332
parser: Return. Stack=[with UPDATE orconf STRING]
parser: Input 'DOT' with pending reduce 332
parser: Reduce 332 [nm ::= STRING], go to state 165.
parser: ... then shift 'nm', go to state 393
parser: Shift 'DOT', go to state 218
parser: Return. Stack=[with UPDATE orconf nm DOT]
parser: Input 'ID' in state 218
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf nm DOT ID]
parser: Input 'SET' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 218.
parser: ... then shift 'nm', go to state 429
parser: Reduce 113 [xfullname ::= nm DOT nm], go to state 165.
parser: ... then shift 'xfullname', go to state 271
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 428
parser: Shift 'SET', go to state 153
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET]
parser: Input 'ID' in state 153
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 153.
parser: ... then shift 'nm', go to state 442
parser: Shift 'EQ', go to state 84
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ]
parser: Input 'STRING' in state 84
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 84.
parser: ... then shift 'term', go to state 58
parser: Reduce 148 [setlist ::= nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'VARIABLE' in state 86
parser: Shift 'VARIABLE', pending reduce 170
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ VARIABLE]
parser: Input 'COMMA' with pending reduce 170
parser: Reduce 170 [expr ::= VARIABLE], go to state 86.
parser: ... then shift 'expr', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'WHERE' in state 537
parser: Reduce 168 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 416
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr EQ]
parser: Input 'VARIABLE' in state 117
parser: Shift 'VARIABLE', pending reduce 170
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr EQ VARIABLE]
parser: Input 'SEMI' with pending reduce 170
parser: Reduce 170 [expr ::= VARIABLE], go to state 117.
parser: ... then shift 'expr', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 270.
parser: ... then shift 'where_opt', pending reduce 145
parser: Reduce 145 [cmd ::= with UPDATE orconf xfullname indexed_opt SET setlist where_opt], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Input '$' with pending reduce 321
parser: Reduce 321 [ecmd ::= cmdx SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 317 [input ::= cmdlist], go to state 0.
parser: ... then shift 'input', pending reduce -2
parser: Accept!
parser: ... then shift 'create_table_args', pending reduce 328
parser: Reduce 328 [cmd ::= create_table create_table_args], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdlist cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping cmdlist
parser: [[[SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='test008' AND type!='trigger' ORDER BY rowid]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'FROM' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'STRING' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'STRING', pending reduce 332
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix STRING]
parser: Input 'DOT' with pending reduce 332
parser: Reduce 332 [nm ::= STRING], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Shift 'DOT', go to state 245
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID' in state 245
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 245.
parser: ... then shift 'nm', pending reduce 109
parser: Reduce 109 [dbnm ::= DOT nm], go to state 349.
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[SELECT distinct selcollist from WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND' in state 537
parser: Reduce 168 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'AND', go to state 120
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID' in state 120
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'NE' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Shift 'NE', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr NE]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr NE STRING]
parser: Input 'ORDER' in state 537
parser: Reduce 168 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Reduce 179 [expr ::= expr AND expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[CREATE TABLE test008(field7, test009, field8, test010, field9)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 388
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP ID]
parser: Input 'COMMA' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 190
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 376
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 150
parser: Reduce 330 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'COMMA' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 190
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 383
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 151
parser: Reduce 329 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'COMMA' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 190
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 383
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 151
parser: Reduce 329 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'COMMA' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 190
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 383
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 151
parser: Reduce 329 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'RP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 190
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 383
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 151
parser: Reduce 329 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Reduce 60 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 538
parser: Shift 'RP', go to state 361
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 361
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 328
parser: Reduce 328 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[;CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END;;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'CREATE' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[ecmd CREATE]
parser: Input 'TRIGGER' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 1.
parser: ... then shift 'createkw', go to state 134
parser: FALLBACK TRIGGER => ID
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 388
parser: Shift 'TRIGGER', go to state 319
parser: Return. Stack=[ecmd createkw temp TRIGGER]
parser: Input 'ID' in state 319
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 227
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd createkw temp TRIGGER ifnotexists ID]
parser: Input 'AFTER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 227.
parser: ... then shift 'nm', go to state 318
parser: FALLBACK AFTER => ID
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 257
parser: Shift 'AFTER', pending reduce 242
parser: Return. Stack=[ecmd createkw temp TRIGGER ifnotexists nm dbnm AFTER]
parser: Input 'INSERT' with pending reduce 242
parser: Reduce 242 [trigger_time ::= BEFORE|AFTER], go to state 257.
parser: ... then shift 'trigger_time', go to state 256
parser: Shift 'INSERT', pending reduce 245
parser: Return. Stack=[ecmd createkw temp TRIGGER ifnotexists nm dbnm trigger_time INSERT]
parser: Input 'ON' with pending reduce 245
parser: Reduce 245 [trigger_event ::= DELETE|INSERT], go to state 256.
parser: ... then shift 'trigger_event', go to state 460
parser: Shift 'ON', go to state 179
parser: Return. Stack=[ecmd createkw temp TRIGGER ifnotexists nm dbnm trigger_time trigger_event ON]
parser: Input 'ID' in state 179
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd createkw temp TRIGGER ifnotexists nm dbnm trigger_time trigger_event ON ID]
parser: Input 'BEGIN' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 179.
parser: ... then shift 'nm', go to state 459
parser: FALLBACK BEGIN => ID
parser: Reduce 110 [fullname ::= nm], go to state 179.
parser: ... then shift 'fullname', go to state 317
parser: FALLBACK BEGIN => ID
parser: Reduce 360 [foreach_clause ::=].
parser: ... then shift 'foreach_clause', go to state 316
parser: FALLBACK BEGIN => ID
parser: Reduce 248 [when_clause ::=].
parser: ... then shift 'when_clause', pending reduce 241
parser: Reduce 241 [trigger_decl ::= temp TRIGGER ifnotexists nm dbnm trigger_time trigger_event ON fullname foreach_clause when_clause], go to state 134.
parser: ... then shift 'trigger_decl', go to state 450
parser: Shift 'BEGIN', go to state 144
parser: Return. Stack=[ecmd createkw trigger_decl BEGIN]
parser: Input 'UPDATE' in state 144
parser: Shift 'UPDATE', go to state 312
parser: Return. Stack=[ecmd createkw trigger_decl BEGIN UPDATE]
parser: Input 'ID' in state 312
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', go to state 177
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd createkw trigger_decl BEGIN UPDATE orconf ID]
parser: Input 'SET' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 177.
parser: ... then shift 'nm', go to state 448
parser: Reduce 362 [trnm ::= nm], go to state 177.
parser: ... then shift 'trnm', go to state 276
parser: Reduce 363 [tridxby ::=].
parser: ... then shift 'tridxby', go to state 445
parser: Shift 'SET', go to state 156
parser: Return. Stack=[ecmd createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET]
parser: Input 'LP' in state 156
parser: Shift 'LP', go to state 175
parser: Return. Stack=[ecmd createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET LP]
parser: Input 'ID' in state 175
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET LP ID]
parser: Input 'COMMA' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 175.
parser: ... then shift 'nm', pending reduce 161
parser: Reduce 161 [idlist ::= nm], go to state 175.
parser: ... then shift 'idlist', go to state 398
parser: Shift 'COMMA', go to state 241
parser: Return. Stack=[ecmd createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET LP idlist COMMA]
parser: Input 'ID' in state 241
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET LP idlist COMMA ID]
parser: Input 'RP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 241.
parser: ... then shift 'nm', pending reduce 160
parser: Reduce 160 [idlist ::= idlist COMMA nm], go to state 175.
parser: ... then shift 'idlist', go to state 398
parser: Shift 'RP', go to state 441
parser: Return. Stack=[ecmd createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET LP idlist RP]
parser: Input 'EQ' in state 441
parser: Shift 'EQ', go to state 83
parser: Return. Stack=[ecmd createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET LP idlist RP EQ]
parser: Input 'LP' in state 83
parser: Shift 'LP', go to state 4
parser: Return. Stack=[ecmd createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET LP idlist RP EQ LP]
parser: Input 'SELECT' in state 4
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[ecmd createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET LP idlist RP EQ LP SELECT]
parser: Input 'STRING' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[ecmd createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET LP idlist RP EQ LP SELECT distinct sclp scanpt STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 77.
parser: ... then shift 'term', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[ecmd createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET LP idlist RP EQ LP SELECT distinct selcollist COMMA]
parser: Input 'STRING' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[ecmd createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET LP idlist RP EQ LP SELECT distinct sclp scanpt STRING]
parser: Input 'RP' in state 537
parser: Reduce 168 [term ::= STRING], go to state 77.
parser: ... then shift 'term', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Reduce 100 [from ::=].
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 4.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 4.
parser: ... then shift 'select', go to state 483
parser: Shift 'RP', pending reduce 203
parser: Return. Stack=[ecmd createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET LP idlist RP EQ LP select RP]
parser: Input 'COMMA' with pending reduce 203
parser: Reduce 203 [expr ::= LP select RP], go to state 83.
parser: ... then shift 'expr', go to state 57
parser: Reduce 149 [setlist ::= LP idlist RP EQ expr], go to state 156.
parser: ... then shift 'setlist', go to state 275
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[ecmd createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET setlist COMMA]
parser: Input 'LP' in state 202
parser: Shift 'LP', go to state 176
parser: Return. Stack=[ecmd createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET setlist COMMA LP]
parser: Input 'ID' in state 176
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET setlist COMMA LP ID]
parser: Input 'COMMA' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 176.
parser: ... then shift 'nm', pending reduce 161
parser: Reduce 161 [idlist ::= nm], go to state 176.
parser: ... then shift 'idlist', go to state 399
parser: Shift 'COMMA', go to state 241
parser: Return. Stack=[ecmd createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET setlist COMMA LP idlist COMMA]
parser: Input 'ID' in state 241
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET setlist COMMA LP idlist COMMA ID]
parser: Input 'RP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 241.
parser: ... then shift 'nm', pending reduce 160
parser: Reduce 160 [idlist ::= idlist COMMA nm], go to state 176.
parser: ... then shift 'idlist', go to state 399
parser: Shift 'RP', go to state 443
parser: Return. Stack=[ecmd createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET setlist COMMA LP idlist RP]
parser: Input 'EQ' in state 443
parser: Shift 'EQ', go to state 85
parser: Return. Stack=[ecmd createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET setlist COMMA LP idlist RP EQ]
parser: Input 'LP' in state 85
parser: Shift 'LP', go to state 4
parser: Return. Stack=[ecmd createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET setlist COMMA LP idlist RP EQ LP]
parser: Input 'SELECT' in state 4
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[ecmd createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET setlist COMMA LP idlist RP EQ LP SELECT]
parser: Input 'STRING' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[ecmd createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET setlist COMMA LP idlist RP EQ LP SELECT distinct sclp scanpt STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 77.
parser: ... then shift 'term', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[ecmd createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET setlist COMMA LP idlist RP EQ LP SELECT distinct selcollist COMMA]
parser: Input 'STRING' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[ecmd createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET setlist COMMA LP idlist RP EQ LP SELECT distinct sclp scanpt STRING]
parser: Input 'RP' in state 537
parser: Reduce 168 [term ::= STRING], go to state 77.
parser: ... then shift 'term', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Reduce 100 [from ::=].
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 4.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 4.
parser: ... then shift 'select', go to state 483
parser: Shift 'RP', pending reduce 203
parser: Return. Stack=[ecmd createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET setlist COMMA LP idlist RP EQ LP select RP]
parser: Input 'WHERE' with pending reduce 203
parser: Reduce 203 [expr ::= LP select RP], go to state 85.
parser: ... then shift 'expr', go to state 59
parser: Reduce 147 [setlist ::= setlist COMMA LP idlist RP EQ expr], go to state 156.
parser: ... then shift 'setlist', go to state 275
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[ecmd createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET setlist WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET setlist WHERE ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[ecmd createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET setlist WHERE expr EQ]
parser: Input 'ID' in state 117
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET setlist WHERE expr EQ ID]
parser: Input 'DOT' in state 416
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 117.
parser: ... then shift 'nm', go to state 535
parser: Shift 'DOT', go to state 249
parser: Return. Stack=[ecmd createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET setlist WHERE expr EQ nm DOT]
parser: Input 'ID' in state 249
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET setlist WHERE expr EQ nm DOT ID]
parser: Input 'MINUS' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 249.
parser: ... then shift 'nm', go to state 534
parser: Reduce 165 [expr ::= nm DOT nm], go to state 117.
parser: ... then shift 'expr', go to state 129
parser: Shift 'MINUS', go to state 115
parser: Return. Stack=[ecmd createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET setlist WHERE expr EQ expr MINUS]
parser: Input 'INTEGER' in state 115
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET setlist WHERE expr EQ expr MINUS INTEGER]
parser: Input 'SEMI' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 115.
parser: ... then shift 'term', go to state 132
parser: Reduce 184 [expr ::= expr PLUS|MINUS expr], go to state 117.
parser: ... then shift 'expr', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 275.
parser: ... then shift 'where_opt', go to state 375
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', pending reduce 255
parser: Reduce 255 [trigger_cmd ::= UPDATE orconf trnm tridxby SET setlist where_opt scanpt], go to state 144.
parser: ... then shift 'trigger_cmd', go to state 434
parser: Shift 'SEMI', pending reduce 251
parser: Return. Stack=[ecmd createkw trigger_decl BEGIN trigger_cmd SEMI]
parser: Input 'END' with pending reduce 251
parser: Reduce 251 [trigger_cmd_list ::= trigger_cmd SEMI], go to state 144.
parser: ... then shift 'trigger_cmd_list', go to state 187
parser: Shift 'END', pending reduce 240
parser: Return. Stack=[ecmd createkw trigger_decl BEGIN trigger_cmd_list END]
parser: Input 'SEMI' with pending reduce 240
parser: Reduce 240 [cmd ::= createkw trigger_decl BEGIN trigger_cmd_list END], go to state 1.
parser: [[[INSERT INTO 'main'.sqlite_master VALUES('trigger','test011','t0',0,'CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT ''c0'', ''c0''), (c0, c0) = (SELECT ''c0'', ''c0'')
      WHERE c0 = new.c0-1;
  END')]]]
parser: Input 'INSERT' in state 0
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'INSERT', go to state 311
parser: Return. Stack=[with INSERT]
parser: Input 'INTO' in state 311
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', pending reduce 156
parser: Reduce 156 [insert_cmd ::= INSERT orconf], go to state 219.
parser: ... then shift 'insert_cmd', go to state 427
parser: Shift 'INTO', go to state 164
parser: Return. Stack=[with insert_cmd INTO]
parser: Input 'STRING' in state 164
parser: Shift 'STRING', pending reduce 332
parser: Return. Stack=[with insert_cmd INTO STRING]
parser: Input 'DOT' with pending reduce 332
parser: Reduce 332 [nm ::= STRING], go to state 164.
parser: ... then shift 'nm', go to state 393
parser: Shift 'DOT', go to state 218
parser: Return. Stack=[with insert_cmd INTO nm DOT]
parser: Input 'ID' in state 218
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with insert_cmd INTO nm DOT ID]
parser: Input 'VALUES' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 218.
parser: ... then shift 'nm', go to state 429
parser: Reduce 113 [xfullname ::= nm DOT nm], go to state 164.
parser: ... then shift 'xfullname', go to state 298
parser: Reduce 158 [idlist_opt ::=].
parser: ... then shift 'idlist_opt', go to state 35
parser: Shift 'VALUES', go to state 526
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES]
parser: Input 'LP' in state 526
parser: Shift 'LP', go to state 28
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP]
parser: Input 'STRING' in state 28
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 28.
parser: ... then shift 'term', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'STRING' in state 107
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'STRING' in state 107
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'INTEGER' in state 107
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'STRING' in state 107
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA STRING]
parser: Input 'RP' in state 537
parser: Reduce 168 [term ::= STRING], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'RP', pending reduce 89
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist RP]
parser: Input 'SEMI' with pending reduce 89
parser: Reduce 89 [values ::= VALUES LP nexprlist RP], go to state 35.
parser: ... then shift 'values', go to state 532
parser: Reduce 348 [oneselect ::= values], go to state 35.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 35.
parser: ... then shift 'select', go to state 297
parser: Reduce 152 [upsert ::=].
parser: ... then shift 'upsert', pending reduce 150
parser: Reduce 150 [cmd ::= with insert_cmd INTO xfullname idlist_opt select upsert], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Input '$' with pending reduce 321
parser: Reduce 321 [ecmd ::= cmdx SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 317 [input ::= cmdlist], go to state 0.
parser: ... then shift 'input', pending reduce -2
parser: Accept!
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
parser: [[[SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE type='trigger' AND name='test011' ORDER BY rowid]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'FROM' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'STRING' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'STRING', pending reduce 332
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix STRING]
parser: Input 'DOT' with pending reduce 332
parser: Reduce 332 [nm ::= STRING], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Shift 'DOT', go to state 245
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID' in state 245
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 245.
parser: ... then shift 'nm', pending reduce 109
parser: Reduce 109 [dbnm ::= DOT nm], go to state 349.
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[SELECT distinct selcollist from WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND' in state 537
parser: Reduce 168 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'AND', go to state 120
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID' in state 120
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr EQ]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr EQ STRING]
parser: Input 'ORDER' in state 537
parser: Reduce 168 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Reduce 179 [expr ::= expr AND expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[CREATE TRIGGER test011 AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c0) = (SELECT 'c0', 'c0'), (c0, c0) = (SELECT 'c0', 'c0')
      WHERE c0 = new.c0-1;
  END]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TRIGGER' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: FALLBACK TRIGGER => ID
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 388
parser: Shift 'TRIGGER', go to state 319
parser: Return. Stack=[createkw temp TRIGGER]
parser: Input 'ID' in state 319
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 227
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp TRIGGER ifnotexists ID]
parser: Input 'AFTER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 227.
parser: ... then shift 'nm', go to state 318
parser: FALLBACK AFTER => ID
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 257
parser: Shift 'AFTER', pending reduce 242
parser: Return. Stack=[createkw temp TRIGGER ifnotexists nm dbnm AFTER]
parser: Input 'INSERT' with pending reduce 242
parser: Reduce 242 [trigger_time ::= BEFORE|AFTER], go to state 257.
parser: ... then shift 'trigger_time', go to state 256
parser: Shift 'INSERT', pending reduce 245
parser: Return. Stack=[createkw temp TRIGGER ifnotexists nm dbnm trigger_time INSERT]
parser: Input 'ON' with pending reduce 245
parser: Reduce 245 [trigger_event ::= DELETE|INSERT], go to state 256.
parser: ... then shift 'trigger_event', go to state 460
parser: Shift 'ON', go to state 179
parser: Return. Stack=[createkw temp TRIGGER ifnotexists nm dbnm trigger_time trigger_event ON]
parser: Input 'ID' in state 179
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp TRIGGER ifnotexists nm dbnm trigger_time trigger_event ON ID]
parser: Input 'BEGIN' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 179.
parser: ... then shift 'nm', go to state 459
parser: FALLBACK BEGIN => ID
parser: Reduce 110 [fullname ::= nm], go to state 179.
parser: ... then shift 'fullname', go to state 317
parser: FALLBACK BEGIN => ID
parser: Reduce 360 [foreach_clause ::=].
parser: ... then shift 'foreach_clause', go to state 316
parser: FALLBACK BEGIN => ID
parser: Reduce 248 [when_clause ::=].
parser: ... then shift 'when_clause', pending reduce 241
parser: Reduce 241 [trigger_decl ::= temp TRIGGER ifnotexists nm dbnm trigger_time trigger_event ON fullname foreach_clause when_clause], go to state 134.
parser: ... then shift 'trigger_decl', go to state 450
parser: Shift 'BEGIN', go to state 144
parser: Return. Stack=[createkw trigger_decl BEGIN]
parser: Input 'UPDATE' in state 144
parser: Shift 'UPDATE', go to state 312
parser: Return. Stack=[createkw trigger_decl BEGIN UPDATE]
parser: Input 'ID' in state 312
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', go to state 177
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw trigger_decl BEGIN UPDATE orconf ID]
parser: Input 'SET' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 177.
parser: ... then shift 'nm', go to state 448
parser: Reduce 362 [trnm ::= nm], go to state 177.
parser: ... then shift 'trnm', go to state 276
parser: Reduce 363 [tridxby ::=].
parser: ... then shift 'tridxby', go to state 445
parser: Shift 'SET', go to state 156
parser: Return. Stack=[createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET]
parser: Input 'LP' in state 156
parser: Shift 'LP', go to state 175
parser: Return. Stack=[createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET LP]
parser: Input 'ID' in state 175
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET LP ID]
parser: Input 'COMMA' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 175.
parser: ... then shift 'nm', pending reduce 161
parser: Reduce 161 [idlist ::= nm], go to state 175.
parser: ... then shift 'idlist', go to state 398
parser: Shift 'COMMA', go to state 241
parser: Return. Stack=[createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET LP idlist COMMA]
parser: Input 'ID' in state 241
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET LP idlist COMMA ID]
parser: Input 'RP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 241.
parser: ... then shift 'nm', pending reduce 160
parser: Reduce 160 [idlist ::= idlist COMMA nm], go to state 175.
parser: ... then shift 'idlist', go to state 398
parser: Shift 'RP', go to state 441
parser: Return. Stack=[createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET LP idlist RP]
parser: Input 'EQ' in state 441
parser: Shift 'EQ', go to state 83
parser: Return. Stack=[createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET LP idlist RP EQ]
parser: Input 'LP' in state 83
parser: Shift 'LP', go to state 4
parser: Return. Stack=[createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET LP idlist RP EQ LP]
parser: Input 'SELECT' in state 4
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET LP idlist RP EQ LP SELECT]
parser: Input 'STRING' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET LP idlist RP EQ LP SELECT distinct sclp scanpt STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 77.
parser: ... then shift 'term', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET LP idlist RP EQ LP SELECT distinct selcollist COMMA]
parser: Input 'STRING' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET LP idlist RP EQ LP SELECT distinct sclp scanpt STRING]
parser: Input 'RP' in state 537
parser: Reduce 168 [term ::= STRING], go to state 77.
parser: ... then shift 'term', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Reduce 100 [from ::=].
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 4.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 4.
parser: ... then shift 'select', go to state 483
parser: Shift 'RP', pending reduce 203
parser: Return. Stack=[createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET LP idlist RP EQ LP select RP]
parser: Input 'COMMA' with pending reduce 203
parser: Reduce 203 [expr ::= LP select RP], go to state 83.
parser: ... then shift 'expr', go to state 57
parser: Reduce 149 [setlist ::= LP idlist RP EQ expr], go to state 156.
parser: ... then shift 'setlist', go to state 275
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET setlist COMMA]
parser: Input 'LP' in state 202
parser: Shift 'LP', go to state 176
parser: Return. Stack=[createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET setlist COMMA LP]
parser: Input 'ID' in state 176
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET setlist COMMA LP ID]
parser: Input 'COMMA' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 176.
parser: ... then shift 'nm', pending reduce 161
parser: Reduce 161 [idlist ::= nm], go to state 176.
parser: ... then shift 'idlist', go to state 399
parser: Shift 'COMMA', go to state 241
parser: Return. Stack=[createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET setlist COMMA LP idlist COMMA]
parser: Input 'ID' in state 241
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET setlist COMMA LP idlist COMMA ID]
parser: Input 'RP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 241.
parser: ... then shift 'nm', pending reduce 160
parser: Reduce 160 [idlist ::= idlist COMMA nm], go to state 176.
parser: ... then shift 'idlist', go to state 399
parser: Shift 'RP', go to state 443
parser: Return. Stack=[createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET setlist COMMA LP idlist RP]
parser: Input 'EQ' in state 443
parser: Shift 'EQ', go to state 85
parser: Return. Stack=[createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET setlist COMMA LP idlist RP EQ]
parser: Input 'LP' in state 85
parser: Shift 'LP', go to state 4
parser: Return. Stack=[createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET setlist COMMA LP idlist RP EQ LP]
parser: Input 'SELECT' in state 4
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET setlist COMMA LP idlist RP EQ LP SELECT]
parser: Input 'STRING' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET setlist COMMA LP idlist RP EQ LP SELECT distinct sclp scanpt STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 77.
parser: ... then shift 'term', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET setlist COMMA LP idlist RP EQ LP SELECT distinct selcollist COMMA]
parser: Input 'STRING' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET setlist COMMA LP idlist RP EQ LP SELECT distinct sclp scanpt STRING]
parser: Input 'RP' in state 537
parser: Reduce 168 [term ::= STRING], go to state 77.
parser: ... then shift 'term', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Reduce 100 [from ::=].
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 4.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 4.
parser: ... then shift 'select', go to state 483
parser: Shift 'RP', pending reduce 203
parser: Return. Stack=[createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET setlist COMMA LP idlist RP EQ LP select RP]
parser: Input 'WHERE' with pending reduce 203
parser: Reduce 203 [expr ::= LP select RP], go to state 85.
parser: ... then shift 'expr', go to state 59
parser: Reduce 147 [setlist ::= setlist COMMA LP idlist RP EQ expr], go to state 156.
parser: ... then shift 'setlist', go to state 275
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET setlist WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 416
parser: Return. Stack=[createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET setlist WHERE ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET setlist WHERE expr EQ]
parser: Input 'ID' in state 117
parser: Shift 'ID', go to state 416
parser: Return. Stack=[createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET setlist WHERE expr EQ ID]
parser: Input 'DOT' in state 416
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 117.
parser: ... then shift 'nm', go to state 535
parser: Shift 'DOT', go to state 249
parser: Return. Stack=[createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET setlist WHERE expr EQ nm DOT]
parser: Input 'ID' in state 249
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET setlist WHERE expr EQ nm DOT ID]
parser: Input 'MINUS' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 249.
parser: ... then shift 'nm', go to state 534
parser: Reduce 165 [expr ::= nm DOT nm], go to state 117.
parser: ... then shift 'expr', go to state 129
parser: Shift 'MINUS', go to state 115
parser: Return. Stack=[createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET setlist WHERE expr EQ expr MINUS]
parser: Input 'INTEGER' in state 115
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[createkw trigger_decl BEGIN UPDATE orconf trnm tridxby SET setlist WHERE expr EQ expr MINUS INTEGER]
parser: Input 'SEMI' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 115.
parser: ... then shift 'term', go to state 132
parser: Reduce 184 [expr ::= expr PLUS|MINUS expr], go to state 117.
parser: ... then shift 'expr', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 275.
parser: ... then shift 'where_opt', go to state 375
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', pending reduce 255
parser: Reduce 255 [trigger_cmd ::= UPDATE orconf trnm tridxby SET setlist where_opt scanpt], go to state 144.
parser: ... then shift 'trigger_cmd', go to state 434
parser: Shift 'SEMI', pending reduce 251
parser: Return. Stack=[createkw trigger_decl BEGIN trigger_cmd SEMI]
parser: Input 'END' with pending reduce 251
parser: Reduce 251 [trigger_cmd_list ::= trigger_cmd SEMI], go to state 144.
parser: ... then shift 'trigger_cmd_list', go to state 187
parser: Shift 'END', pending reduce 240
parser: Return. Stack=[createkw trigger_decl BEGIN trigger_cmd_list END]
parser: Input 'SEMI' with pending reduce 240
parser: Reduce 240 [cmd ::= createkw trigger_decl BEGIN trigger_cmd_list END], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[;
;INSERT INTO last_field VALUES(2, 'w', 'x', 'y', 'z');;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'SEMI' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[ecmd SEMI]
parser: Input 'INSERT' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 1.
parser: ... then shift 'ecmd', pending reduce 318
parser: Reduce 318 [cmdlist ::= cmdlist ecmd], go to state 0.
parser: ... then shift 'cmdlist', go to state 1
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'INSERT', go to state 311
parser: Return. Stack=[cmdlist with INSERT]
parser: Input 'INTO' in state 311
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', pending reduce 156
parser: Reduce 156 [insert_cmd ::= INSERT orconf], go to state 219.
parser: ... then shift 'insert_cmd', go to state 427
parser: Shift 'INTO', go to state 164
parser: Return. Stack=[cmdlist with insert_cmd INTO]
parser: Input 'ID' in state 164
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[cmdlist with insert_cmd INTO ID]
parser: Input 'VALUES' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 164.
parser: ... then shift 'nm', go to state 393
parser: Reduce 112 [xfullname ::= nm], go to state 164.
parser: ... then shift 'xfullname', go to state 298
parser: Reduce 158 [idlist_opt ::=].
parser: ... then shift 'idlist_opt', go to state 35
parser: Shift 'VALUES', go to state 526
parser: Return. Stack=[cmdlist with insert_cmd INTO xfullname idlist_opt VALUES]
parser: Input 'LP' in state 526
parser: Shift 'LP', go to state 28
parser: Return. Stack=[cmdlist with insert_cmd INTO xfullname idlist_opt VALUES LP]
parser: Input 'INTEGER' in state 28
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[cmdlist with insert_cmd INTO xfullname idlist_opt VALUES LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 28.
parser: ... then shift 'term', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[cmdlist with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'STRING' in state 107
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[cmdlist with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[cmdlist with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'STRING' in state 107
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[cmdlist with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[cmdlist with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'STRING' in state 107
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[cmdlist with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[cmdlist with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'STRING' in state 107
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[cmdlist with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA STRING]
parser: Input 'RP' in state 537
parser: Reduce 168 [term ::= STRING], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'RP', pending reduce 89
parser: Return. Stack=[cmdlist with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist RP]
parser: Input 'SEMI' with pending reduce 89
parser: Reduce 89 [values ::= VALUES LP nexprlist RP], go to state 35.
parser: ... then shift 'values', go to state 532
parser: Reduce 348 [oneselect ::= values], go to state 35.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 35.
parser: ... then shift 'select', go to state 297
parser: Reduce 152 [upsert ::=].
parser: ... then shift 'upsert', pending reduce 150
parser: Reduce 150 [cmd ::= with insert_cmd INTO xfullname idlist_opt select upsert], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdlist cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping cmdlist
parser: [[[;INSERT INTO field2 VALUES(3, 'i', 'ii', 'iii', 'iv');;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'INSERT' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'INSERT', go to state 311
parser: Return. Stack=[ecmd with INSERT]
parser: Input 'INTO' in state 311
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', pending reduce 156
parser: Reduce 156 [insert_cmd ::= INSERT orconf], go to state 219.
parser: ... then shift 'insert_cmd', go to state 427
parser: Shift 'INTO', go to state 164
parser: Return. Stack=[ecmd with insert_cmd INTO]
parser: Input 'ID' in state 164
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd with insert_cmd INTO ID]
parser: Input 'VALUES' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 164.
parser: ... then shift 'nm', go to state 393
parser: Reduce 112 [xfullname ::= nm], go to state 164.
parser: ... then shift 'xfullname', go to state 298
parser: Reduce 158 [idlist_opt ::=].
parser: ... then shift 'idlist_opt', go to state 35
parser: Shift 'VALUES', go to state 526
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES]
parser: Input 'LP' in state 526
parser: Shift 'LP', go to state 28
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP]
parser: Input 'INTEGER' in state 28
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 28.
parser: ... then shift 'term', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'STRING' in state 107
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'STRING' in state 107
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'STRING' in state 107
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'STRING' in state 107
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA STRING]
parser: Input 'RP' in state 537
parser: Reduce 168 [term ::= STRING], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'RP', pending reduce 89
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist RP]
parser: Input 'SEMI' with pending reduce 89
parser: Reduce 89 [values ::= VALUES LP nexprlist RP], go to state 35.
parser: ... then shift 'values', go to state 532
parser: Reduce 348 [oneselect ::= values], go to state 35.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 35.
parser: ... then shift 'select', go to state 297
parser: Reduce 152 [upsert ::=].
parser: ... then shift 'upsert', pending reduce 150
parser: Reduce 150 [cmd ::= with insert_cmd INTO xfullname idlist_opt select upsert], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
parser: [[[;UPDATE t0 SET c0=c0 WHERE c0=3;;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'UPDATE' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'UPDATE', go to state 299
parser: Return. Stack=[ecmd with UPDATE]
parser: Input 'ID' in state 299
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', go to state 165
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd with UPDATE orconf ID]
parser: Input 'SET' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 165.
parser: ... then shift 'nm', go to state 393
parser: Reduce 112 [xfullname ::= nm], go to state 165.
parser: ... then shift 'xfullname', go to state 271
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 428
parser: Shift 'SET', go to state 153
parser: Return. Stack=[ecmd with UPDATE orconf xfullname indexed_opt SET]
parser: Input 'ID' in state 153
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd with UPDATE orconf xfullname indexed_opt SET ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 153.
parser: ... then shift 'nm', go to state 442
parser: Shift 'EQ', go to state 84
parser: Return. Stack=[ecmd with UPDATE orconf xfullname indexed_opt SET nm EQ]
parser: Input 'ID' in state 84
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd with UPDATE orconf xfullname indexed_opt SET nm EQ ID]
parser: Input 'WHERE' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 84.
parser: ... then shift 'expr', go to state 58
parser: Reduce 148 [setlist ::= nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[ecmd with UPDATE orconf xfullname indexed_opt SET setlist WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd with UPDATE orconf xfullname indexed_opt SET setlist WHERE ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[ecmd with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr EQ]
parser: Input 'INTEGER' in state 117
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr EQ INTEGER]
parser: Input 'SEMI' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 270.
parser: ... then shift 'where_opt', pending reduce 145
parser: Reduce 145 [cmd ::= with UPDATE orconf xfullname indexed_opt SET setlist where_opt], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
parser: [[[;SELECT * FROM field1;;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'SELECT' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[ecmd SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 96
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[ecmd SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'SEMI' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 1.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 1.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
parser: [[[;
;CREATE TABLE field10(test012, field11);;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'SEMI' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[ecmd SEMI]
parser: Input 'CREATE' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 1.
parser: ... then shift 'ecmd', pending reduce 318
parser: Reduce 318 [cmdlist ::= cmdlist ecmd], go to state 0.
parser: ... then shift 'cmdlist', go to state 1
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[cmdlist CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 1.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 388
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[cmdlist createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[cmdlist createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 1.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[cmdlist create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[cmdlist create_table LP ID]
parser: Input 'COMMA' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 190
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 376
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 150
parser: Reduce 330 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[cmdlist create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[cmdlist create_table LP columnlist COMMA ID]
parser: Input 'RP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 190
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 383
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 151
parser: Reduce 329 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Reduce 60 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 538
parser: Shift 'RP', go to state 361
parser: Return. Stack=[cmdlist create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 361
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: [[[UPDATE 'main'.sqlite_master SET type='table', name='field10', tbl_name='field10', rootpage=#2, sql='CREATE TABLE field10(test012, field11)' WHERE rowid=#1]]]
parser: Input 'UPDATE' in state 0
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'UPDATE', go to state 299
parser: Return. Stack=[with UPDATE]
parser: Input 'STRING' in state 299
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', go to state 165
parser: Shift 'STRING', pending reduce 332
parser: Return. Stack=[with UPDATE orconf STRING]
parser: Input 'DOT' with pending reduce 332
parser: Reduce 332 [nm ::= STRING], go to state 165.
parser: ... then shift 'nm', go to state 393
parser: Shift 'DOT', go to state 218
parser: Return. Stack=[with UPDATE orconf nm DOT]
parser: Input 'ID' in state 218
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf nm DOT ID]
parser: Input 'SET' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 218.
parser: ... then shift 'nm', go to state 429
parser: Reduce 113 [xfullname ::= nm DOT nm], go to state 165.
parser: ... then shift 'xfullname', go to state 271
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 428
parser: Shift 'SET', go to state 153
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET]
parser: Input 'ID' in state 153
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 153.
parser: ... then shift 'nm', go to state 442
parser: Shift 'EQ', go to state 84
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ]
parser: Input 'STRING' in state 84
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 84.
parser: ... then shift 'term', go to state 58
parser: Reduce 148 [setlist ::= nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'VARIABLE' in state 86
parser: Shift 'VARIABLE', pending reduce 170
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ VARIABLE]
parser: Input 'COMMA' with pending reduce 170
parser: Reduce 170 [expr ::= VARIABLE], go to state 86.
parser: ... then shift 'expr', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'WHERE' in state 537
parser: Reduce 168 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 416
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr EQ]
parser: Input 'VARIABLE' in state 117
parser: Shift 'VARIABLE', pending reduce 170
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr EQ VARIABLE]
parser: Input 'SEMI' with pending reduce 170
parser: Reduce 170 [expr ::= VARIABLE], go to state 117.
parser: ... then shift 'expr', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 270.
parser: ... then shift 'where_opt', pending reduce 145
parser: Reduce 145 [cmd ::= with UPDATE orconf xfullname indexed_opt SET setlist where_opt], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Input '$' with pending reduce 321
parser: Reduce 321 [ecmd ::= cmdx SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 317 [input ::= cmdlist], go to state 0.
parser: ... then shift 'input', pending reduce -2
parser: Accept!
parser: ... then shift 'create_table_args', pending reduce 328
parser: Reduce 328 [cmd ::= create_table create_table_args], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdlist cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping cmdlist
parser: [[[SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='field10' AND type!='trigger' ORDER BY rowid]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'FROM' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'STRING' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'STRING', pending reduce 332
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix STRING]
parser: Input 'DOT' with pending reduce 332
parser: Reduce 332 [nm ::= STRING], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Shift 'DOT', go to state 245
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID' in state 245
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 245.
parser: ... then shift 'nm', pending reduce 109
parser: Reduce 109 [dbnm ::= DOT nm], go to state 349.
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[SELECT distinct selcollist from WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND' in state 537
parser: Reduce 168 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'AND', go to state 120
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID' in state 120
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'NE' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Shift 'NE', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr NE]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr NE STRING]
parser: Input 'ORDER' in state 537
parser: Reduce 168 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Reduce 179 [expr ::= expr AND expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[CREATE TABLE field10(test012, field11)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 388
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP ID]
parser: Input 'COMMA' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 190
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 376
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 150
parser: Reduce 330 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'RP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 190
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 383
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 151
parser: Reduce 329 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Reduce 60 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 538
parser: Shift 'RP', go to state 361
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 361
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 328
parser: Reduce 328 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[;CREATE TABLE test013(field12);;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'CREATE' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[ecmd CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 1.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 388
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[ecmd createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 1.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[ecmd create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd create_table LP ID]
parser: Input 'RP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 190
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 376
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 150
parser: Reduce 330 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Reduce 60 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 538
parser: Shift 'RP', go to state 361
parser: Return. Stack=[ecmd create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 361
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: [[[UPDATE 'main'.sqlite_master SET type='table', name='test013', tbl_name='test013', rootpage=#2, sql='CREATE TABLE test013(field12)' WHERE rowid=#1]]]
parser: Input 'UPDATE' in state 0
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'UPDATE', go to state 299
parser: Return. Stack=[with UPDATE]
parser: Input 'STRING' in state 299
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', go to state 165
parser: Shift 'STRING', pending reduce 332
parser: Return. Stack=[with UPDATE orconf STRING]
parser: Input 'DOT' with pending reduce 332
parser: Reduce 332 [nm ::= STRING], go to state 165.
parser: ... then shift 'nm', go to state 393
parser: Shift 'DOT', go to state 218
parser: Return. Stack=[with UPDATE orconf nm DOT]
parser: Input 'ID' in state 218
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf nm DOT ID]
parser: Input 'SET' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 218.
parser: ... then shift 'nm', go to state 429
parser: Reduce 113 [xfullname ::= nm DOT nm], go to state 165.
parser: ... then shift 'xfullname', go to state 271
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 428
parser: Shift 'SET', go to state 153
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET]
parser: Input 'ID' in state 153
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 153.
parser: ... then shift 'nm', go to state 442
parser: Shift 'EQ', go to state 84
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ]
parser: Input 'STRING' in state 84
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 84.
parser: ... then shift 'term', go to state 58
parser: Reduce 148 [setlist ::= nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'VARIABLE' in state 86
parser: Shift 'VARIABLE', pending reduce 170
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ VARIABLE]
parser: Input 'COMMA' with pending reduce 170
parser: Reduce 170 [expr ::= VARIABLE], go to state 86.
parser: ... then shift 'expr', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'WHERE' in state 537
parser: Reduce 168 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 416
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr EQ]
parser: Input 'VARIABLE' in state 117
parser: Shift 'VARIABLE', pending reduce 170
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr EQ VARIABLE]
parser: Input 'SEMI' with pending reduce 170
parser: Reduce 170 [expr ::= VARIABLE], go to state 117.
parser: ... then shift 'expr', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 270.
parser: ... then shift 'where_opt', pending reduce 145
parser: Reduce 145 [cmd ::= with UPDATE orconf xfullname indexed_opt SET setlist where_opt], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Input '$' with pending reduce 321
parser: Reduce 321 [ecmd ::= cmdx SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 317 [input ::= cmdlist], go to state 0.
parser: ... then shift 'input', pending reduce -2
parser: Accept!
parser: ... then shift 'create_table_args', pending reduce 328
parser: Reduce 328 [cmd ::= create_table create_table_args], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
parser: [[[SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='test013' AND type!='trigger' ORDER BY rowid]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'FROM' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'STRING' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'STRING', pending reduce 332
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix STRING]
parser: Input 'DOT' with pending reduce 332
parser: Reduce 332 [nm ::= STRING], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Shift 'DOT', go to state 245
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID' in state 245
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 245.
parser: ... then shift 'nm', pending reduce 109
parser: Reduce 109 [dbnm ::= DOT nm], go to state 349.
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[SELECT distinct selcollist from WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND' in state 537
parser: Reduce 168 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'AND', go to state 120
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID' in state 120
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'NE' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Shift 'NE', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr NE]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr NE STRING]
parser: Input 'ORDER' in state 537
parser: Reduce 168 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Reduce 179 [expr ::= expr AND expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[CREATE TABLE test013(field12)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 388
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP ID]
parser: Input 'RP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 190
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 376
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 150
parser: Reduce 330 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Reduce 60 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 538
parser: Shift 'RP', go to state 361
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 361
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 328
parser: Reduce 328 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[;CREATE TABLE test014 ( field13 );;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'CREATE' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[ecmd CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 1.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 388
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[ecmd createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 1.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[ecmd create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd create_table LP ID]
parser: Input 'RP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 190
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 376
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 150
parser: Reduce 330 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Reduce 60 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 538
parser: Shift 'RP', go to state 361
parser: Return. Stack=[ecmd create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 361
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: [[[UPDATE 'main'.sqlite_master SET type='table', name='test014', tbl_name='test014', rootpage=#2, sql='CREATE TABLE test014 ( field13 )' WHERE rowid=#1]]]
parser: Input 'UPDATE' in state 0
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'UPDATE', go to state 299
parser: Return. Stack=[with UPDATE]
parser: Input 'STRING' in state 299
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', go to state 165
parser: Shift 'STRING', pending reduce 332
parser: Return. Stack=[with UPDATE orconf STRING]
parser: Input 'DOT' with pending reduce 332
parser: Reduce 332 [nm ::= STRING], go to state 165.
parser: ... then shift 'nm', go to state 393
parser: Shift 'DOT', go to state 218
parser: Return. Stack=[with UPDATE orconf nm DOT]
parser: Input 'ID' in state 218
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf nm DOT ID]
parser: Input 'SET' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 218.
parser: ... then shift 'nm', go to state 429
parser: Reduce 113 [xfullname ::= nm DOT nm], go to state 165.
parser: ... then shift 'xfullname', go to state 271
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 428
parser: Shift 'SET', go to state 153
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET]
parser: Input 'ID' in state 153
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 153.
parser: ... then shift 'nm', go to state 442
parser: Shift 'EQ', go to state 84
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ]
parser: Input 'STRING' in state 84
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 84.
parser: ... then shift 'term', go to state 58
parser: Reduce 148 [setlist ::= nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'VARIABLE' in state 86
parser: Shift 'VARIABLE', pending reduce 170
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ VARIABLE]
parser: Input 'COMMA' with pending reduce 170
parser: Reduce 170 [expr ::= VARIABLE], go to state 86.
parser: ... then shift 'expr', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'WHERE' in state 537
parser: Reduce 168 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 416
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr EQ]
parser: Input 'VARIABLE' in state 117
parser: Shift 'VARIABLE', pending reduce 170
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr EQ VARIABLE]
parser: Input 'SEMI' with pending reduce 170
parser: Reduce 170 [expr ::= VARIABLE], go to state 117.
parser: ... then shift 'expr', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 270.
parser: ... then shift 'where_opt', pending reduce 145
parser: Reduce 145 [cmd ::= with UPDATE orconf xfullname indexed_opt SET setlist where_opt], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Input '$' with pending reduce 321
parser: Reduce 321 [ecmd ::= cmdx SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 317 [input ::= cmdlist], go to state 0.
parser: ... then shift 'input', pending reduce -2
parser: Accept!
parser: ... then shift 'create_table_args', pending reduce 328
parser: Reduce 328 [cmd ::= create_table create_table_args], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
parser: [[[SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='test014' AND type!='trigger' ORDER BY rowid]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'FROM' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'STRING' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'STRING', pending reduce 332
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix STRING]
parser: Input 'DOT' with pending reduce 332
parser: Reduce 332 [nm ::= STRING], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Shift 'DOT', go to state 245
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID' in state 245
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 245.
parser: ... then shift 'nm', pending reduce 109
parser: Reduce 109 [dbnm ::= DOT nm], go to state 349.
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[SELECT distinct selcollist from WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND' in state 537
parser: Reduce 168 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'AND', go to state 120
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID' in state 120
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'NE' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Shift 'NE', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr NE]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr NE STRING]
parser: Input 'ORDER' in state 537
parser: Reduce 168 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Reduce 179 [expr ::= expr AND expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[CREATE TABLE test014 ( field13 )]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 388
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP ID]
parser: Input 'RP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 190
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 376
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 150
parser: Reduce 330 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Reduce 60 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 538
parser: Shift 'RP', go to state 361
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 361
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 328
parser: Reduce 328 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[;INSERT INTO test008 VALUES (1);;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'INSERT' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'INSERT', go to state 311
parser: Return. Stack=[ecmd with INSERT]
parser: Input 'INTO' in state 311
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', pending reduce 156
parser: Reduce 156 [insert_cmd ::= INSERT orconf], go to state 219.
parser: ... then shift 'insert_cmd', go to state 427
parser: Shift 'INTO', go to state 164
parser: Return. Stack=[ecmd with insert_cmd INTO]
parser: Input 'ID' in state 164
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd with insert_cmd INTO ID]
parser: Input 'VALUES' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 164.
parser: ... then shift 'nm', go to state 393
parser: Reduce 112 [xfullname ::= nm], go to state 164.
parser: ... then shift 'xfullname', go to state 298
parser: Reduce 158 [idlist_opt ::=].
parser: ... then shift 'idlist_opt', go to state 35
parser: Shift 'VALUES', go to state 526
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES]
parser: Input 'LP' in state 526
parser: Shift 'LP', go to state 28
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP]
parser: Input 'INTEGER' in state 28
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 28.
parser: ... then shift 'term', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'RP', pending reduce 89
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist RP]
parser: Input 'SEMI' with pending reduce 89
parser: Reduce 89 [values ::= VALUES LP nexprlist RP], go to state 35.
parser: ... then shift 'values', go to state 532
parser: Reduce 348 [oneselect ::= values], go to state 35.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 35.
parser: ... then shift 'select', go to state 297
parser: Reduce 152 [upsert ::=].
parser: ... then shift 'upsert', pending reduce 150
parser: Reduce 150 [cmd ::= with insert_cmd INTO xfullname idlist_opt select upsert], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
parser: [[[;INSERT INTO test008 VALUES (1, 1), (1, 2);;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'INSERT' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'INSERT', go to state 311
parser: Return. Stack=[ecmd with INSERT]
parser: Input 'INTO' in state 311
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', pending reduce 156
parser: Reduce 156 [insert_cmd ::= INSERT orconf], go to state 219.
parser: ... then shift 'insert_cmd', go to state 427
parser: Shift 'INTO', go to state 164
parser: Return. Stack=[ecmd with insert_cmd INTO]
parser: Input 'ID' in state 164
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd with insert_cmd INTO ID]
parser: Input 'VALUES' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 164.
parser: ... then shift 'nm', go to state 393
parser: Reduce 112 [xfullname ::= nm], go to state 164.
parser: ... then shift 'xfullname', go to state 298
parser: Reduce 158 [idlist_opt ::=].
parser: ... then shift 'idlist_opt', go to state 35
parser: Shift 'VALUES', go to state 526
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES]
parser: Input 'LP' in state 526
parser: Shift 'LP', go to state 28
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP]
parser: Input 'INTEGER' in state 28
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 28.
parser: ... then shift 'term', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'INTEGER' in state 107
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'RP', pending reduce 89
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist RP]
parser: Input 'COMMA' with pending reduce 89
parser: Reduce 89 [values ::= VALUES LP nexprlist RP], go to state 35.
parser: ... then shift 'values', go to state 532
parser: Shift 'COMMA', go to state 531
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt values COMMA]
parser: Input 'LP' in state 531
parser: Shift 'LP', go to state 29
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt values COMMA LP]
parser: Input 'INTEGER' in state 29
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt values COMMA LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 29.
parser: ... then shift 'term', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 29.
parser: ... then shift 'nexprlist', go to state 414
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt values COMMA LP nexprlist COMMA]
parser: Input 'INTEGER' in state 107
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt values COMMA LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 29.
parser: ... then shift 'nexprlist', go to state 414
parser: Shift 'RP', pending reduce 90
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt values COMMA LP nexprlist RP]
parser: Input 'SEMI' with pending reduce 90
parser: Reduce 90 [values ::= values COMMA LP nexprlist RP], go to state 35.
parser: ... then shift 'values', go to state 532
parser: Reduce 348 [oneselect ::= values], go to state 35.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 35.
parser: ... then shift 'select', go to state 297
parser: Reduce 152 [upsert ::=].
parser: ... then shift 'upsert', pending reduce 150
parser: Reduce 150 [cmd ::= with insert_cmd INTO xfullname idlist_opt select upsert], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
parser: [[[;CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016);;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'CREATE' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[ecmd CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 1.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 388
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[ecmd createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 1.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[ecmd create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd create_table LP ID]
parser: Input 'ID' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 190
parser: Shift 'ID', pending reduce 335
parser: Return. Stack=[ecmd create_table LP nm ID]
parser: Input 'PRIMARY' with pending reduce 335
parser: Reduce 335 [typename ::= ID|STRING], go to state 190.
parser: ... then shift 'typename', go to state 390
parser: Reduce 334 [typetoken ::= typename], go to state 190.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 376
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 150
parser: Shift 'PRIMARY', go to state 475
parser: Return. Stack=[ecmd create_table LP columnname carglist PRIMARY]
parser: Input 'KEY' in state 475
parser: Shift 'KEY', go to state 280
parser: Return. Stack=[ecmd create_table LP columnname carglist PRIMARY KEY]
parser: Input 'COMMA' in state 280
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 333
parser: Reduce 68 [onconf ::=].
parser: ... then shift 'onconf', go to state 332
parser: Reduce 42 [autoinc ::=].
parser: ... then shift 'autoinc', pending reduce 36
parser: Reduce 36 [ccons ::= PRIMARY KEY sortorder onconf autoinc], go to state 150.
parser: ... then shift 'ccons', pending reduce 338
parser: Reduce 338 [carglist ::= carglist ccons], go to state 376.
parser: ... then shift 'carglist', go to state 150
parser: Reduce 330 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[ecmd create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd create_table LP columnlist COMMA ID]
parser: Input 'RP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 190
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 383
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 151
parser: Reduce 329 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Reduce 60 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 538
parser: Shift 'RP', go to state 361
parser: Return. Stack=[ecmd create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 361
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: [[[UPDATE 'main'.sqlite_master SET type='table', name='test015', tbl_name='test015', rootpage=#2, sql='CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016)' WHERE rowid=#1]]]
parser: Input 'UPDATE' in state 0
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'UPDATE', go to state 299
parser: Return. Stack=[with UPDATE]
parser: Input 'STRING' in state 299
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', go to state 165
parser: Shift 'STRING', pending reduce 332
parser: Return. Stack=[with UPDATE orconf STRING]
parser: Input 'DOT' with pending reduce 332
parser: Reduce 332 [nm ::= STRING], go to state 165.
parser: ... then shift 'nm', go to state 393
parser: Shift 'DOT', go to state 218
parser: Return. Stack=[with UPDATE orconf nm DOT]
parser: Input 'ID' in state 218
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf nm DOT ID]
parser: Input 'SET' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 218.
parser: ... then shift 'nm', go to state 429
parser: Reduce 113 [xfullname ::= nm DOT nm], go to state 165.
parser: ... then shift 'xfullname', go to state 271
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 428
parser: Shift 'SET', go to state 153
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET]
parser: Input 'ID' in state 153
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 153.
parser: ... then shift 'nm', go to state 442
parser: Shift 'EQ', go to state 84
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ]
parser: Input 'STRING' in state 84
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 84.
parser: ... then shift 'term', go to state 58
parser: Reduce 148 [setlist ::= nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'VARIABLE' in state 86
parser: Shift 'VARIABLE', pending reduce 170
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ VARIABLE]
parser: Input 'COMMA' with pending reduce 170
parser: Reduce 170 [expr ::= VARIABLE], go to state 86.
parser: ... then shift 'expr', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'WHERE' in state 537
parser: Reduce 168 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 416
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr EQ]
parser: Input 'VARIABLE' in state 117
parser: Shift 'VARIABLE', pending reduce 170
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr EQ VARIABLE]
parser: Input 'SEMI' with pending reduce 170
parser: Reduce 170 [expr ::= VARIABLE], go to state 117.
parser: ... then shift 'expr', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 270.
parser: ... then shift 'where_opt', pending reduce 145
parser: Reduce 145 [cmd ::= with UPDATE orconf xfullname indexed_opt SET setlist where_opt], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Input '$' with pending reduce 321
parser: Reduce 321 [ecmd ::= cmdx SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 317 [input ::= cmdlist], go to state 0.
parser: ... then shift 'input', pending reduce -2
parser: Accept!
parser: ... then shift 'create_table_args', pending reduce 328
parser: Reduce 328 [cmd ::= create_table create_table_args], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
parser: [[[SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='test015' AND type!='trigger' ORDER BY rowid]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'FROM' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'STRING' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'STRING', pending reduce 332
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix STRING]
parser: Input 'DOT' with pending reduce 332
parser: Reduce 332 [nm ::= STRING], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Shift 'DOT', go to state 245
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID' in state 245
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 245.
parser: ... then shift 'nm', pending reduce 109
parser: Reduce 109 [dbnm ::= DOT nm], go to state 349.
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[SELECT distinct selcollist from WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND' in state 537
parser: Reduce 168 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'AND', go to state 120
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID' in state 120
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'NE' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Shift 'NE', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr NE]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr NE STRING]
parser: Input 'ORDER' in state 537
parser: Reduce 168 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Reduce 179 [expr ::= expr AND expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[CREATE TABLE test015(field14 INTEGER PRIMARY KEY,test016)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 388
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP ID]
parser: Input 'ID' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 190
parser: Shift 'ID', pending reduce 335
parser: Return. Stack=[create_table LP nm ID]
parser: Input 'PRIMARY' with pending reduce 335
parser: Reduce 335 [typename ::= ID|STRING], go to state 190.
parser: ... then shift 'typename', go to state 390
parser: Reduce 334 [typetoken ::= typename], go to state 190.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 376
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 150
parser: Shift 'PRIMARY', go to state 475
parser: Return. Stack=[create_table LP columnname carglist PRIMARY]
parser: Input 'KEY' in state 475
parser: Shift 'KEY', go to state 280
parser: Return. Stack=[create_table LP columnname carglist PRIMARY KEY]
parser: Input 'COMMA' in state 280
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 333
parser: Reduce 68 [onconf ::=].
parser: ... then shift 'onconf', go to state 332
parser: Reduce 42 [autoinc ::=].
parser: ... then shift 'autoinc', pending reduce 36
parser: Reduce 36 [ccons ::= PRIMARY KEY sortorder onconf autoinc], go to state 150.
parser: ... then shift 'ccons', pending reduce 338
parser: Reduce 338 [carglist ::= carglist ccons], go to state 376.
parser: ... then shift 'carglist', go to state 150
parser: Reduce 330 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'RP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 190
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 383
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 151
parser: Reduce 329 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Reduce 60 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 538
parser: Shift 'RP', go to state 361
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 361
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 328
parser: Reduce 328 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[;
;SELECT * FROM test008 WHERE (field8,field7)>=(3,0) ORDER BY field8;;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'SEMI' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[ecmd SEMI]
parser: Input 'SELECT' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 1.
parser: ... then shift 'ecmd', pending reduce 318
parser: Reduce 318 [cmdlist ::= cmdlist ecmd], go to state 0.
parser: ... then shift 'cmdlist', go to state 1
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[cmdlist SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 96
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[cmdlist SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[cmdlist SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE]
parser: Input 'LP' in state 93
parser: Shift 'LP', go to state 4
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE LP]
parser: Input 'ID' in state 4
parser: Shift 'ID', go to state 416
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE LP ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 4.
parser: ... then shift 'expr', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE LP nexprlist COMMA]
parser: Input 'ID' in state 91
parser: Shift 'ID', go to state 416
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE LP nexprlist COMMA ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 91.
parser: ... then shift 'expr', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE LP nexprlist COMMA expr RP]
parser: Input 'GE' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'GE', go to state 118
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr GE]
parser: Input 'LP' in state 118
parser: Shift 'LP', go to state 4
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr GE LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr GE LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr GE LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr GE LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr GE LP nexprlist COMMA term RP]
parser: Input 'ORDER' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 118.
parser: ... then shift 'expr', go to state 130
parser: Reduce 181 [expr ::= expr LT|GT|GE|LE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[cmdlist SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[cmdlist SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[cmdlist SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 1.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 1.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdlist cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping cmdlist
parser: [[[;
;SELECT * FROM test008 WHERE (field7,field7)<(3,0) ORDER BY field7 DESC;;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'SEMI' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[ecmd SEMI]
parser: Input 'SELECT' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 1.
parser: ... then shift 'ecmd', pending reduce 318
parser: Reduce 318 [cmdlist ::= cmdlist ecmd], go to state 0.
parser: ... then shift 'cmdlist', go to state 1
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[cmdlist SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 96
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[cmdlist SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[cmdlist SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE]
parser: Input 'LP' in state 93
parser: Shift 'LP', go to state 4
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE LP]
parser: Input 'ID' in state 4
parser: Shift 'ID', go to state 416
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE LP ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 4.
parser: ... then shift 'expr', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE LP nexprlist COMMA]
parser: Input 'ID' in state 91
parser: Shift 'ID', go to state 416
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE LP nexprlist COMMA ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 91.
parser: ... then shift 'expr', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE LP nexprlist COMMA expr RP]
parser: Input 'LT' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'LT', go to state 118
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr LT]
parser: Input 'LP' in state 118
parser: Shift 'LP', go to state 4
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr LT LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr LT LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr LT LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr LT LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr LT LP nexprlist COMMA term RP]
parser: Input 'ORDER' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 118.
parser: ... then shift 'expr', go to state 130
parser: Reduce 181 [expr ::= expr LT|GT|GE|LE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[cmdlist SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[cmdlist SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[cmdlist SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'DESC' in state 416
parser: FALLBACK DESC => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Shift 'DESC', pending reduce 132
parser: Return. Stack=[cmdlist SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY expr DESC]
parser: Input 'SEMI' with pending reduce 132
parser: Reduce 132 [sortorder ::= DESC], go to state 13.
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 1.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 1.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdlist cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping cmdlist
parser: [[[;
;SELECT * FROM field2 WHERE (test004,test004)>=(3,34) ORDER BY test004;;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'SEMI' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[ecmd SEMI]
parser: Input 'SELECT' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 1.
parser: ... then shift 'ecmd', pending reduce 318
parser: Reduce 318 [cmdlist ::= cmdlist ecmd], go to state 0.
parser: ... then shift 'cmdlist', go to state 1
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[cmdlist SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 96
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[cmdlist SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[cmdlist SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE]
parser: Input 'LP' in state 93
parser: Shift 'LP', go to state 4
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE LP]
parser: Input 'ID' in state 4
parser: Shift 'ID', go to state 416
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE LP ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 4.
parser: ... then shift 'expr', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE LP nexprlist COMMA]
parser: Input 'ID' in state 91
parser: Shift 'ID', go to state 416
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE LP nexprlist COMMA ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 91.
parser: ... then shift 'expr', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE LP nexprlist COMMA expr RP]
parser: Input 'GE' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'GE', go to state 118
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr GE]
parser: Input 'LP' in state 118
parser: Shift 'LP', go to state 4
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr GE LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr GE LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr GE LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr GE LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr GE LP nexprlist COMMA term RP]
parser: Input 'ORDER' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 118.
parser: ... then shift 'expr', go to state 130
parser: Reduce 181 [expr ::= expr LT|GT|GE|LE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[cmdlist SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[cmdlist SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[cmdlist SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 1.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 1.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdlist cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping cmdlist
parser: [[[;
;SELECT * FROM field1 WHERE (test003,test003)<(3,34) ORDER BY test003 DESC;;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'SEMI' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[ecmd SEMI]
parser: Input 'SELECT' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 1.
parser: ... then shift 'ecmd', pending reduce 318
parser: Reduce 318 [cmdlist ::= cmdlist ecmd], go to state 0.
parser: ... then shift 'cmdlist', go to state 1
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[cmdlist SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 96
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[cmdlist SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[cmdlist SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE]
parser: Input 'LP' in state 93
parser: Shift 'LP', go to state 4
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE LP]
parser: Input 'ID' in state 4
parser: Shift 'ID', go to state 416
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE LP ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 4.
parser: ... then shift 'expr', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE LP nexprlist COMMA]
parser: Input 'ID' in state 91
parser: Shift 'ID', go to state 416
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE LP nexprlist COMMA ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 91.
parser: ... then shift 'expr', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE LP nexprlist COMMA expr RP]
parser: Input 'LT' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'LT', go to state 118
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr LT]
parser: Input 'LP' in state 118
parser: Shift 'LP', go to state 4
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr LT LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr LT LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr LT LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr LT LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr LT LP nexprlist COMMA term RP]
parser: Input 'ORDER' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 118.
parser: ... then shift 'expr', go to state 130
parser: Reduce 181 [expr ::= expr LT|GT|GE|LE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[cmdlist SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[cmdlist SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[cmdlist SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'DESC' in state 416
parser: FALLBACK DESC => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Shift 'DESC', pending reduce 132
parser: Return. Stack=[cmdlist SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY expr DESC]
parser: Input 'SEMI' with pending reduce 132
parser: Reduce 132 [sortorder ::= DESC], go to state 13.
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 1.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 1.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdlist cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping cmdlist
parser: [[[;
;SELECT * FROM test006 WHERE (0,0)<(test007,field5) ORDER BY test007;;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'SEMI' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[ecmd SEMI]
parser: Input 'SELECT' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 1.
parser: ... then shift 'ecmd', pending reduce 318
parser: Reduce 318 [cmdlist ::= cmdlist ecmd], go to state 0.
parser: ... then shift 'cmdlist', go to state 1
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[cmdlist SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 96
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[cmdlist SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[cmdlist SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE]
parser: Input 'LP' in state 93
parser: Shift 'LP', go to state 4
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE LP nexprlist COMMA term RP]
parser: Input 'LT' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'LT', go to state 118
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr LT]
parser: Input 'LP' in state 118
parser: Shift 'LP', go to state 4
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr LT LP]
parser: Input 'ID' in state 4
parser: Shift 'ID', go to state 416
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr LT LP ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 4.
parser: ... then shift 'expr', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr LT LP nexprlist COMMA]
parser: Input 'ID' in state 91
parser: Shift 'ID', go to state 416
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr LT LP nexprlist COMMA ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 91.
parser: ... then shift 'expr', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr LT LP nexprlist COMMA expr RP]
parser: Input 'ORDER' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 118.
parser: ... then shift 'expr', go to state 130
parser: Reduce 181 [expr ::= expr LT|GT|GE|LE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[cmdlist SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[cmdlist SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[cmdlist SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 1.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 1.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdlist cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping cmdlist
parser: [[[;
;SELECT * FROM test008 WHERE (5,0)>(test009,test010) ORDER BY test009 DESC;;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'SEMI' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[ecmd SEMI]
parser: Input 'SELECT' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 1.
parser: ... then shift 'ecmd', pending reduce 318
parser: Reduce 318 [cmdlist ::= cmdlist ecmd], go to state 0.
parser: ... then shift 'cmdlist', go to state 1
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[cmdlist SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 96
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[cmdlist SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[cmdlist SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE]
parser: Input 'LP' in state 93
parser: Shift 'LP', go to state 4
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE LP nexprlist COMMA term RP]
parser: Input 'GT' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'GT', go to state 118
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr GT]
parser: Input 'LP' in state 118
parser: Shift 'LP', go to state 4
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr GT LP]
parser: Input 'ID' in state 4
parser: Shift 'ID', go to state 416
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr GT LP ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 4.
parser: ... then shift 'expr', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr GT LP nexprlist COMMA]
parser: Input 'ID' in state 91
parser: Shift 'ID', go to state 416
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr GT LP nexprlist COMMA ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 91.
parser: ... then shift 'expr', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr GT LP nexprlist COMMA expr RP]
parser: Input 'ORDER' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 118.
parser: ... then shift 'expr', go to state 130
parser: Reduce 181 [expr ::= expr LT|GT|GE|LE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[cmdlist SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[cmdlist SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[cmdlist SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'DESC' in state 416
parser: FALLBACK DESC => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Shift 'DESC', pending reduce 132
parser: Return. Stack=[cmdlist SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY expr DESC]
parser: Input 'SEMI' with pending reduce 132
parser: Reduce 132 [sortorder ::= DESC], go to state 13.
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 1.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 1.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdlist cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping cmdlist
parser: [[[;
;SELECT * FROM field2 WHERE (5,0)>=(test004,test004) ORDER BY test004 DESC;;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'SEMI' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[ecmd SEMI]
parser: Input 'SELECT' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 1.
parser: ... then shift 'ecmd', pending reduce 318
parser: Reduce 318 [cmdlist ::= cmdlist ecmd], go to state 0.
parser: ... then shift 'cmdlist', go to state 1
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[cmdlist SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 96
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[cmdlist SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[cmdlist SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE]
parser: Input 'LP' in state 93
parser: Shift 'LP', go to state 4
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE LP nexprlist COMMA term RP]
parser: Input 'GE' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'GE', go to state 118
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr GE]
parser: Input 'LP' in state 118
parser: Shift 'LP', go to state 4
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr GE LP]
parser: Input 'ID' in state 4
parser: Shift 'ID', go to state 416
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr GE LP ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 4.
parser: ... then shift 'expr', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr GE LP nexprlist COMMA]
parser: Input 'ID' in state 91
parser: Shift 'ID', go to state 416
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr GE LP nexprlist COMMA ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 91.
parser: ... then shift 'expr', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr GE LP nexprlist COMMA expr RP]
parser: Input 'ORDER' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 118.
parser: ... then shift 'expr', go to state 130
parser: Reduce 181 [expr ::= expr LT|GT|GE|LE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[cmdlist SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[cmdlist SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[cmdlist SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'DESC' in state 416
parser: FALLBACK DESC => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Shift 'DESC', pending reduce 132
parser: Return. Stack=[cmdlist SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY expr DESC]
parser: Input 'SEMI' with pending reduce 132
parser: Reduce 132 [sortorder ::= DESC], go to state 13.
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 1.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 1.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdlist cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping cmdlist
parser: [[[;
;SELECT * FROM last_field WHERE (3,0)>(test002,test002) ORDER BY test002 DESC;;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'SEMI' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[ecmd SEMI]
parser: Input 'SELECT' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 1.
parser: ... then shift 'ecmd', pending reduce 318
parser: Reduce 318 [cmdlist ::= cmdlist ecmd], go to state 0.
parser: ... then shift 'cmdlist', go to state 1
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[cmdlist SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 96
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[cmdlist SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[cmdlist SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE]
parser: Input 'LP' in state 93
parser: Shift 'LP', go to state 4
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE LP nexprlist COMMA term RP]
parser: Input 'GT' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'GT', go to state 118
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr GT]
parser: Input 'LP' in state 118
parser: Shift 'LP', go to state 4
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr GT LP]
parser: Input 'ID' in state 4
parser: Shift 'ID', go to state 416
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr GT LP ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 4.
parser: ... then shift 'expr', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr GT LP nexprlist COMMA]
parser: Input 'ID' in state 91
parser: Shift 'ID', go to state 416
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr GT LP nexprlist COMMA ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 91.
parser: ... then shift 'expr', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr GT LP nexprlist COMMA expr RP]
parser: Input 'ORDER' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 118.
parser: ... then shift 'expr', go to state 130
parser: Reduce 181 [expr ::= expr LT|GT|GE|LE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[cmdlist SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[cmdlist SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[cmdlist SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'DESC' in state 416
parser: FALLBACK DESC => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Shift 'DESC', pending reduce 132
parser: Return. Stack=[cmdlist SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY expr DESC]
parser: Input 'SEMI' with pending reduce 132
parser: Reduce 132 [sortorder ::= DESC], go to state 13.
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 1.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 1.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdlist cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping cmdlist
parser: [[[;
;SELECT * FROM test008 WHERE (3,34)<=(field7,field7) ORDER BY field7;;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'SEMI' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[ecmd SEMI]
parser: Input 'SELECT' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 1.
parser: ... then shift 'ecmd', pending reduce 318
parser: Reduce 318 [cmdlist ::= cmdlist ecmd], go to state 0.
parser: ... then shift 'cmdlist', go to state 1
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[cmdlist SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 96
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[cmdlist SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[cmdlist SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE]
parser: Input 'LP' in state 93
parser: Shift 'LP', go to state 4
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE LP nexprlist COMMA term RP]
parser: Input 'LE' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'LE', go to state 118
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr LE]
parser: Input 'LP' in state 118
parser: Shift 'LP', go to state 4
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr LE LP]
parser: Input 'ID' in state 4
parser: Shift 'ID', go to state 416
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr LE LP ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 4.
parser: ... then shift 'expr', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr LE LP nexprlist COMMA]
parser: Input 'ID' in state 91
parser: Shift 'ID', go to state 416
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr LE LP nexprlist COMMA ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 91.
parser: ... then shift 'expr', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr LE LP nexprlist COMMA expr RP]
parser: Input 'ORDER' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 118.
parser: ... then shift 'expr', go to state 130
parser: Reduce 181 [expr ::= expr LT|GT|GE|LE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[cmdlist SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[cmdlist SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[cmdlist SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 1.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 1.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdlist cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping cmdlist
parser: [[[;
;SELECT 1 WHERE (2,(2,0)) IS (2,(2,0));;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'SEMI' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[ecmd SEMI]
parser: Input 'SELECT' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 1.
parser: ... then shift 'ecmd', pending reduce 318
parser: Reduce 318 [cmdlist ::= cmdlist ecmd], go to state 0.
parser: ... then shift 'cmdlist', go to state 1
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[cmdlist SELECT]
parser: Input 'INTEGER' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt INTEGER]
parser: Input 'WHERE' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 77.
parser: ... then shift 'term', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Reduce 100 [from ::=].
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE]
parser: Input 'LP' in state 93
parser: Shift 'LP', go to state 4
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE LP nexprlist COMMA]
parser: Input 'LP' in state 91
parser: Shift 'LP', go to state 4
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE LP nexprlist COMMA LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE LP nexprlist COMMA LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE LP nexprlist COMMA LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE LP nexprlist COMMA LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE LP nexprlist COMMA LP nexprlist COMMA term RP]
parser: Input 'RP' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 91.
parser: ... then shift 'expr', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE LP nexprlist COMMA expr RP]
parser: Input 'IS' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'IS', go to state 110
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr IS]
parser: Input 'LP' in state 110
parser: Shift 'LP', go to state 4
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr IS LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr IS LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr IS LP nexprlist COMMA]
parser: Input 'LP' in state 91
parser: Shift 'LP', go to state 4
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr IS LP nexprlist COMMA LP]
parser: Input 'INTEGER' in state 4
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr IS LP nexprlist COMMA LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 4.
parser: ... then shift 'term', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr IS LP nexprlist COMMA LP nexprlist COMMA]
parser: Input 'INTEGER' in state 91
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr IS LP nexprlist COMMA LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 91.
parser: ... then shift 'term', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr IS LP nexprlist COMMA LP nexprlist COMMA term RP]
parser: Input 'RP' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 91.
parser: ... then shift 'expr', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr IS LP nexprlist COMMA expr RP]
parser: Input 'SEMI' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 110.
parser: ... then shift 'expr', go to state 127
parser: Reduce 192 [expr ::= expr IS expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 1.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 1.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdlist cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping cmdlist
parser: [[[;CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16));;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'CREATE' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[ecmd CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 1.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 388
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[ecmd createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 1.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[ecmd create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd create_table LP ID]
parser: Input 'COMMA' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 190
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 376
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 150
parser: Reduce 330 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[ecmd create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd create_table LP columnlist COMMA ID]
parser: Input 'COMMA' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 190
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 383
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 151
parser: Reduce 329 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[ecmd create_table LP columnlist COMMA]
parser: Input 'PRIMARY' in state 34
parser: Shift 'PRIMARY', go to state 472
parser: Return. Stack=[ecmd create_table LP columnlist COMMA PRIMARY]
parser: Input 'KEY' in state 472
parser: Shift 'KEY', go to state 471
parser: Return. Stack=[ecmd create_table LP columnlist COMMA PRIMARY KEY]
parser: Input 'LP' in state 471
parser: Shift 'LP', go to state 20
parser: Return. Stack=[ecmd create_table LP columnlist COMMA PRIMARY KEY LP]
parser: Input 'ID' in state 20
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd create_table LP columnlist COMMA PRIMARY KEY LP ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 20.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 20.
parser: ... then shift 'sortlist', go to state 277
parser: Shift 'COMMA', go to state 95
parser: Return. Stack=[ecmd create_table LP columnlist COMMA PRIMARY KEY LP sortlist COMMA]
parser: Input 'ID' in state 95
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd create_table LP columnlist COMMA PRIMARY KEY LP sortlist COMMA ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 95.
parser: ... then shift 'expr', go to state 14
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 129
parser: Reduce 129 [sortlist ::= sortlist COMMA expr sortorder], go to state 20.
parser: ... then shift 'sortlist', go to state 277
parser: Reduce 42 [autoinc ::=].
parser: ... then shift 'autoinc', go to state 470
parser: Shift 'RP', go to state 328
parser: Return. Stack=[ecmd create_table LP columnlist COMMA PRIMARY KEY LP sortlist autoinc RP]
parser: Input 'RP' in state 328
parser: Reduce 68 [onconf ::=].
parser: ... then shift 'onconf', pending reduce 63
parser: Reduce 63 [tcons ::= PRIMARY KEY LP sortlist autoinc RP onconf], go to state 34.
parser: [[[INSERT INTO 'main'.sqlite_master VALUES('index','sqlite_autoindex_field15_1','field15',#4,NULL);]]]
parser: Input 'INSERT' in state 0
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'INSERT', go to state 311
parser: Return. Stack=[with INSERT]
parser: Input 'INTO' in state 311
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', pending reduce 156
parser: Reduce 156 [insert_cmd ::= INSERT orconf], go to state 219.
parser: ... then shift 'insert_cmd', go to state 427
parser: Shift 'INTO', go to state 164
parser: Return. Stack=[with insert_cmd INTO]
parser: Input 'STRING' in state 164
parser: Shift 'STRING', pending reduce 332
parser: Return. Stack=[with insert_cmd INTO STRING]
parser: Input 'DOT' with pending reduce 332
parser: Reduce 332 [nm ::= STRING], go to state 164.
parser: ... then shift 'nm', go to state 393
parser: Shift 'DOT', go to state 218
parser: Return. Stack=[with insert_cmd INTO nm DOT]
parser: Input 'ID' in state 218
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with insert_cmd INTO nm DOT ID]
parser: Input 'VALUES' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 218.
parser: ... then shift 'nm', go to state 429
parser: Reduce 113 [xfullname ::= nm DOT nm], go to state 164.
parser: ... then shift 'xfullname', go to state 298
parser: Reduce 158 [idlist_opt ::=].
parser: ... then shift 'idlist_opt', go to state 35
parser: Shift 'VALUES', go to state 526
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES]
parser: Input 'LP' in state 526
parser: Shift 'LP', go to state 28
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP]
parser: Input 'STRING' in state 28
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 28.
parser: ... then shift 'term', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'STRING' in state 107
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'STRING' in state 107
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'VARIABLE' in state 107
parser: Shift 'VARIABLE', pending reduce 170
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA VARIABLE]
parser: Input 'COMMA' with pending reduce 170
parser: Reduce 170 [expr ::= VARIABLE], go to state 107.
parser: ... then shift 'expr', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'NULL' in state 107
parser: Shift 'NULL', pending reduce 167
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA NULL]
parser: Input 'RP' with pending reduce 167
parser: Reduce 167 [term ::= NULL|FLOAT|BLOB], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'RP', pending reduce 89
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist RP]
parser: Input 'SEMI' with pending reduce 89
parser: Reduce 89 [values ::= VALUES LP nexprlist RP], go to state 35.
parser: ... then shift 'values', go to state 532
parser: Reduce 348 [oneselect ::= values], go to state 35.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 35.
parser: ... then shift 'select', go to state 297
parser: Reduce 152 [upsert ::=].
parser: ... then shift 'upsert', pending reduce 150
parser: Reduce 150 [cmd ::= with insert_cmd INTO xfullname idlist_opt select upsert], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Input '$' with pending reduce 321
parser: Reduce 321 [ecmd ::= cmdx SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 317 [input ::= cmdlist], go to state 0.
parser: ... then shift 'input', pending reduce -2
parser: Accept!
parser: ... then shift 'tcons', go to state 278
parser: Reduce 341 [conslist_opt ::= COMMA conslist], go to state 362.
parser: ... then shift 'conslist_opt', go to state 538
parser: Shift 'RP', go to state 361
parser: Return. Stack=[ecmd create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 361
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: [[[UPDATE 'main'.sqlite_master SET type='table', name='field15', tbl_name='field15', rootpage=#2, sql='CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16))' WHERE rowid=#1]]]
parser: Input 'UPDATE' in state 0
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'UPDATE', go to state 299
parser: Return. Stack=[with UPDATE]
parser: Input 'STRING' in state 299
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', go to state 165
parser: Shift 'STRING', pending reduce 332
parser: Return. Stack=[with UPDATE orconf STRING]
parser: Input 'DOT' with pending reduce 332
parser: Reduce 332 [nm ::= STRING], go to state 165.
parser: ... then shift 'nm', go to state 393
parser: Shift 'DOT', go to state 218
parser: Return. Stack=[with UPDATE orconf nm DOT]
parser: Input 'ID' in state 218
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf nm DOT ID]
parser: Input 'SET' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 218.
parser: ... then shift 'nm', go to state 429
parser: Reduce 113 [xfullname ::= nm DOT nm], go to state 165.
parser: ... then shift 'xfullname', go to state 271
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 428
parser: Shift 'SET', go to state 153
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET]
parser: Input 'ID' in state 153
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 153.
parser: ... then shift 'nm', go to state 442
parser: Shift 'EQ', go to state 84
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ]
parser: Input 'STRING' in state 84
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 84.
parser: ... then shift 'term', go to state 58
parser: Reduce 148 [setlist ::= nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'VARIABLE' in state 86
parser: Shift 'VARIABLE', pending reduce 170
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ VARIABLE]
parser: Input 'COMMA' with pending reduce 170
parser: Reduce 170 [expr ::= VARIABLE], go to state 86.
parser: ... then shift 'expr', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'WHERE' in state 537
parser: Reduce 168 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 416
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr EQ]
parser: Input 'VARIABLE' in state 117
parser: Shift 'VARIABLE', pending reduce 170
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr EQ VARIABLE]
parser: Input 'SEMI' with pending reduce 170
parser: Reduce 170 [expr ::= VARIABLE], go to state 117.
parser: ... then shift 'expr', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 270.
parser: ... then shift 'where_opt', pending reduce 145
parser: Reduce 145 [cmd ::= with UPDATE orconf xfullname indexed_opt SET setlist where_opt], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Input '$' with pending reduce 321
parser: Reduce 321 [ecmd ::= cmdx SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 317 [input ::= cmdlist], go to state 0.
parser: ... then shift 'input', pending reduce -2
parser: Accept!
parser: ... then shift 'create_table_args', pending reduce 328
parser: Reduce 328 [cmd ::= create_table create_table_args], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
parser: [[[SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='field15' AND type!='trigger' ORDER BY rowid]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'FROM' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'STRING' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'STRING', pending reduce 332
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix STRING]
parser: Input 'DOT' with pending reduce 332
parser: Reduce 332 [nm ::= STRING], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Shift 'DOT', go to state 245
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID' in state 245
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 245.
parser: ... then shift 'nm', pending reduce 109
parser: Reduce 109 [dbnm ::= DOT nm], go to state 349.
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[SELECT distinct selcollist from WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND' in state 537
parser: Reduce 168 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'AND', go to state 120
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID' in state 120
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'NE' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Shift 'NE', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr NE]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr NE STRING]
parser: Input 'ORDER' in state 537
parser: Reduce 168 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Reduce 179 [expr ::= expr AND expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[CREATE TABLE field15(test017,field16,PRIMARY KEY(field16,field16))]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 388
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP ID]
parser: Input 'COMMA' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 190
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 376
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 150
parser: Reduce 330 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'COMMA' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 190
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 383
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 151
parser: Reduce 329 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'PRIMARY' in state 34
parser: Shift 'PRIMARY', go to state 472
parser: Return. Stack=[create_table LP columnlist COMMA PRIMARY]
parser: Input 'KEY' in state 472
parser: Shift 'KEY', go to state 471
parser: Return. Stack=[create_table LP columnlist COMMA PRIMARY KEY]
parser: Input 'LP' in state 471
parser: Shift 'LP', go to state 20
parser: Return. Stack=[create_table LP columnlist COMMA PRIMARY KEY LP]
parser: Input 'ID' in state 20
parser: Shift 'ID', go to state 416
parser: Return. Stack=[create_table LP columnlist COMMA PRIMARY KEY LP ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 20.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 20.
parser: ... then shift 'sortlist', go to state 277
parser: Shift 'COMMA', go to state 95
parser: Return. Stack=[create_table LP columnlist COMMA PRIMARY KEY LP sortlist COMMA]
parser: Input 'ID' in state 95
parser: Shift 'ID', go to state 416
parser: Return. Stack=[create_table LP columnlist COMMA PRIMARY KEY LP sortlist COMMA ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 95.
parser: ... then shift 'expr', go to state 14
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 129
parser: Reduce 129 [sortlist ::= sortlist COMMA expr sortorder], go to state 20.
parser: ... then shift 'sortlist', go to state 277
parser: Reduce 42 [autoinc ::=].
parser: ... then shift 'autoinc', go to state 470
parser: Shift 'RP', go to state 328
parser: Return. Stack=[create_table LP columnlist COMMA PRIMARY KEY LP sortlist autoinc RP]
parser: Input 'RP' in state 328
parser: Reduce 68 [onconf ::=].
parser: ... then shift 'onconf', pending reduce 63
parser: Reduce 63 [tcons ::= PRIMARY KEY LP sortlist autoinc RP onconf], go to state 34.
parser: ... then shift 'tcons', go to state 278
parser: Reduce 341 [conslist_opt ::= COMMA conslist], go to state 362.
parser: ... then shift 'conslist_opt', go to state 538
parser: Shift 'RP', go to state 361
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 361
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 328
parser: Reduce 328 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[;INSERT INTO test014 VALUES(1,2),(3,4),(5,6);;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'INSERT' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'INSERT', go to state 311
parser: Return. Stack=[ecmd with INSERT]
parser: Input 'INTO' in state 311
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', pending reduce 156
parser: Reduce 156 [insert_cmd ::= INSERT orconf], go to state 219.
parser: ... then shift 'insert_cmd', go to state 427
parser: Shift 'INTO', go to state 164
parser: Return. Stack=[ecmd with insert_cmd INTO]
parser: Input 'ID' in state 164
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd with insert_cmd INTO ID]
parser: Input 'VALUES' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 164.
parser: ... then shift 'nm', go to state 393
parser: Reduce 112 [xfullname ::= nm], go to state 164.
parser: ... then shift 'xfullname', go to state 298
parser: Reduce 158 [idlist_opt ::=].
parser: ... then shift 'idlist_opt', go to state 35
parser: Shift 'VALUES', go to state 526
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES]
parser: Input 'LP' in state 526
parser: Shift 'LP', go to state 28
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP]
parser: Input 'INTEGER' in state 28
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 28.
parser: ... then shift 'term', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'INTEGER' in state 107
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'RP', pending reduce 89
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist RP]
parser: Input 'COMMA' with pending reduce 89
parser: Reduce 89 [values ::= VALUES LP nexprlist RP], go to state 35.
parser: ... then shift 'values', go to state 532
parser: Shift 'COMMA', go to state 531
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt values COMMA]
parser: Input 'LP' in state 531
parser: Shift 'LP', go to state 29
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt values COMMA LP]
parser: Input 'INTEGER' in state 29
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt values COMMA LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 29.
parser: ... then shift 'term', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 29.
parser: ... then shift 'nexprlist', go to state 414
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt values COMMA LP nexprlist COMMA]
parser: Input 'INTEGER' in state 107
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt values COMMA LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 29.
parser: ... then shift 'nexprlist', go to state 414
parser: Shift 'RP', pending reduce 90
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt values COMMA LP nexprlist RP]
parser: Input 'COMMA' with pending reduce 90
parser: Reduce 90 [values ::= values COMMA LP nexprlist RP], go to state 35.
parser: ... then shift 'values', go to state 532
parser: Shift 'COMMA', go to state 531
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt values COMMA]
parser: Input 'LP' in state 531
parser: Shift 'LP', go to state 29
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt values COMMA LP]
parser: Input 'INTEGER' in state 29
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt values COMMA LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 29.
parser: ... then shift 'term', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 29.
parser: ... then shift 'nexprlist', go to state 414
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt values COMMA LP nexprlist COMMA]
parser: Input 'INTEGER' in state 107
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt values COMMA LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 29.
parser: ... then shift 'nexprlist', go to state 414
parser: Shift 'RP', pending reduce 90
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt values COMMA LP nexprlist RP]
parser: Input 'SEMI' with pending reduce 90
parser: Reduce 90 [values ::= values COMMA LP nexprlist RP], go to state 35.
parser: ... then shift 'values', go to state 532
parser: Reduce 348 [oneselect ::= values], go to state 35.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 35.
parser: ... then shift 'select', go to state 297
parser: Reduce 152 [upsert ::=].
parser: ... then shift 'upsert', pending reduce 150
parser: Reduce 150 [cmd ::= with insert_cmd INTO xfullname idlist_opt select upsert], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
parser: [[[;SELECT * FROM test008 WHERE (field7,field8) IN (VALUES(1,2));;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'SELECT' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[ecmd SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 96
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[ecmd SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE]
parser: Input 'LP' in state 93
parser: Shift 'LP', go to state 4
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE LP]
parser: Input 'ID' in state 4
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE LP ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 4.
parser: ... then shift 'expr', go to state 50
parser: Reduce 216 [nexprlist ::= expr], go to state 4.
parser: ... then shift 'nexprlist', go to state 484
parser: Shift 'COMMA', go to state 91
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE LP nexprlist COMMA]
parser: Input 'ID' in state 91
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE LP nexprlist COMMA ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 91.
parser: ... then shift 'expr', go to state 49
parser: Shift 'RP', pending reduce 178
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE LP nexprlist COMMA expr RP]
parser: Input 'IN' with pending reduce 178
parser: Reduce 178 [expr ::= LP nexprlist COMMA expr RP], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'IN', pending reduce 200
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr IN]
parser: Input 'LP' with pending reduce 200
parser: Reduce 200 [in_op ::= IN], go to state 63.
parser: ... then shift 'in_op', go to state 209
parser: Shift 'LP', go to state 3
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr in_op LP]
parser: Input 'VALUES' in state 3
parser: Shift 'VALUES', go to state 526
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr in_op LP VALUES]
parser: Input 'LP' in state 526
parser: Shift 'LP', go to state 28
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr in_op LP VALUES LP]
parser: Input 'INTEGER' in state 28
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr in_op LP VALUES LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 28.
parser: ... then shift 'term', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr in_op LP VALUES LP nexprlist COMMA]
parser: Input 'INTEGER' in state 107
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr in_op LP VALUES LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'RP', pending reduce 89
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr in_op LP VALUES LP nexprlist RP]
parser: Input 'RP' with pending reduce 89
parser: Reduce 89 [values ::= VALUES LP nexprlist RP], go to state 3.
parser: ... then shift 'values', go to state 532
parser: Reduce 348 [oneselect ::= values], go to state 3.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 3.
parser: ... then shift 'select', go to state 518
parser: Shift 'RP', pending reduce 204
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr in_op LP select RP]
parser: Input 'SEMI' with pending reduce 204
parser: Reduce 204 [expr ::= expr in_op LP select RP], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 1.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 1.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
parser: [[[;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 5,6);;
;DROP TABLE IF EXISTS t0;;CREATE TABLE test018(field17 COLLATE NOCASE, test019);;INSERT INTO field2 VALUES('a', 'A');;SELECT (+test005,1) >= (field4, 1), (field4,1)<=(+test005,1) FROM field3;;SELECT 3 FROM test008 WHERE (field9,1) <= (+test010,1);;SELECT 3 FROM last_field WHERE (test002,1) <= (SELECT +test002,1);;SELECT 2 FROM test008 WHERE (test008.field9, TRUE) > (CAST('' AS REAL), FALSE);;
;DROP TABLE test006;;CREATE TABLE field18(test020 UNIQUE);;
;SELECT ('B' COLLATE NOCASE, 0)> (field2.test004, 0) FROM field2;;SELECT 2 FROM test008 WHERE ('B' COLLATE NOCASE, 0)> (test008.test010, 0);;SELECT 2 FROM field3 WHERE ('B', 0)> (field3.test005 COLLATE nocase, 0);;SELECT 2 FROM field1 WHERE (field1.test003 COLLATE nocase, 0) < ('B', 0);]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'SELECT' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[ecmd SELECT]
parser: Input 'LP' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'LP', go to state 4
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt LP]
parser: Input 'SELECT' in state 4
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt LP SELECT]
parser: Input 'INTEGER' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt LP SELECT distinct sclp scanpt INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 77.
parser: ... then shift 'term', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt LP SELECT distinct selcollist COMMA]
parser: Input 'INTEGER' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt LP SELECT distinct sclp scanpt INTEGER]
parser: Input 'UNION' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 77.
parser: ... then shift 'term', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Reduce 100 [from ::=].
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 4.
parser: ... then shift 'oneselect', go to state 264
parser: Shift 'UNION', go to state 533
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt LP oneselect UNION]
parser: Input 'SELECT' in state 533
parser: Reduce 84 [multiselect_op ::= UNION], go to state 264.
parser: ... then shift 'multiselect_op', go to state 195
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt LP oneselect multiselect_op SELECT]
parser: Input 'INTEGER' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt LP oneselect multiselect_op SELECT distinct sclp scanpt INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 77.
parser: ... then shift 'term', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt LP oneselect multiselect_op SELECT distinct selcollist COMMA]
parser: Input 'INTEGER' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt LP oneselect multiselect_op SELECT distinct sclp scanpt INTEGER]
parser: Input 'ORDER' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 77.
parser: ... then shift 'term', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Reduce 100 [from ::=].
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt LP oneselect multiselect_op SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt LP oneselect multiselect_op SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'INTEGER' in state 26
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt LP oneselect multiselect_op SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 26.
parser: ... then shift 'term', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 195.
parser: ... then shift 'oneselect', pending reduce 83
parser: Reduce 83 [selectnowith ::= selectnowith multiselect_op oneselect], go to state 4.
parser: ... then shift 'selectnowith', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 4.
parser: ... then shift 'select', go to state 483
parser: Shift 'RP', pending reduce 203
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt LP select RP]
parser: Input 'IN' with pending reduce 203
parser: Reduce 203 [expr ::= LP select RP], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Shift 'IN', pending reduce 200
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt expr IN]
parser: Input 'LP' with pending reduce 200
parser: Reduce 200 [in_op ::= IN], go to state 16.
parser: ... then shift 'in_op', go to state 209
parser: Shift 'LP', go to state 3
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt expr in_op LP]
parser: Input 'SELECT' in state 3
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt expr in_op LP SELECT]
parser: Input 'INTEGER' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt expr in_op LP SELECT distinct sclp scanpt INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 77.
parser: ... then shift 'term', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt expr in_op LP SELECT distinct selcollist COMMA]
parser: Input 'INTEGER' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt expr in_op LP SELECT distinct sclp scanpt INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 77.
parser: ... then shift 'term', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Reduce 100 [from ::=].
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'o
Program received signal SIGABRT, Aborted.
__GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:50
(gdb) #0  __GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:50
#1  0x00007f0fc76d5859 in __GI_abort () at abort.c:79
#2  0x00007f0fc76d5729 in __assert_fail_base (fmt=0x7f0fc786b588 "%s%s%s:%u: %s%sAssertion `%s' failed.\n%n", assertion=0x2122b4 "pIn->nSdst==1 || pParse->nErr>0", file=0x22873d "sqlite3.c", line=127594, 
    function=<optimized out>) at assert.c:92
#3  0x00007f0fc76e6fd6 in __GI___assert_fail (assertion=0x2122b4 "pIn->nSdst==1 || pParse->nErr>0", file=0x22873d "sqlite3.c", line=127594, 
    function=0x213784 "int generateOutputSubroutine(Parse *, Select *, SelectDest *, SelectDest *, int, int, KeyInfo *, int)") at assert.c:101
#4  0x00000000003b5d8b in generateOutputSubroutine (pParse=0x7ffe47a0f550, p=0xe165d0, pIn=0x7ffe47a0dbd0, pDest=0x7ffe47a0e128, regReturn=15, regPrev=9, pKeyInfo=0xe22ab0, iBreak=-7) at sqlite3.c:127594
#5  0x00000000003b4e37 in multiSelectOrderBy (pParse=0x7ffe47a0f550, p=0xe165d0, pDest=0x7ffe47a0e128) at sqlite3.c:127921
#6  0x00000000003a3d1c in multiSelect (pParse=0x7ffe47a0f550, p=0xe165d0, pDest=0x7ffe47a0e128) at sqlite3.c:127207
#7  0x00000000002fccf5 in sqlite3Select (pParse=0x7ffe47a0f550, p=0xe165d0, pDest=0x7ffe47a0e128) at sqlite3.c:130384
#8  0x000000000034f659 in sqlite3CodeSubselect (pParse=0x7ffe47a0f550, pExpr=0xe181f0) at sqlite3.c:99820
#9  0x0000000000350b1c in exprCodeVector (pParse=0x7ffe47a0f550, p=0xe181f0, piFreeable=0x7ffe47a0e1ec) at sqlite3.c:100296
#10 0x000000000034fbdb in sqlite3ExprCodeIN (pParse=0x7ffe47a0f550, pExpr=0xe14500, destIfFalse=-3, destIfNull=-4) at sqlite3.c:99952
#11 0x000000000034be9e in sqlite3ExprCodeTarget (pParse=0x7ffe47a0f550, pExpr=0xe14500, target=1) at sqlite3.c:100792
#12 0x000000000034e9ee in sqlite3ExprCodeExprList (pParse=0x7ffe47a0f550, pList=0xe1a2c0, target=1, srcReg=0, flags=1 '\001') at sqlite3.c:101202
#13 0x00000000003addca in innerLoopLoadRow (pParse=0x7ffe47a0f550, pSelect=0xe14050, pInfo=0x7ffe47a0e590) at sqlite3.c:125172
#14 0x00000000003a92ea in selectInnerLoop (pParse=0x7ffe47a0f550, p=0xe14050, srcTab=-1, pSort=0x0, pDistinct=0x7ffe47a0e830, pDest=0x7ffe47a0e940, iContinue=-2, iBreak=-2) at sqlite3.c:125624
#15 0x00000000002fe191 in sqlite3Select (pParse=0x7ffe47a0f550, p=0xe14050, pDest=0x7ffe47a0e940) at sqlite3.c:130743
#16 0x00000000002ecaa8 in yy_reduce (yypParser=0x7ffe47a0eb70, yyruleno=79, yyLookahead=1, yyLookaheadToken=..., pParse=0x7ffe47a0f550) at sqlite3.c:151581
#17 0x00000000002e92f8 in sqlite3Parser (yyp=0x7ffe47a0eb70, yymajor=1, yyminor=...) at sqlite3.c:152877
#18 0x00000000002a68b3 in sqlite3RunParser (pParse=0x7ffe47a0f550, 
    zSql=0xe17420 ";;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 5,6);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (S"..., pzErrMsg=0x7ffe47a0f730) at sqlite3.c:154013
#19 0x00000000002a1683 in sqlite3Prepare (db=0xdfe2b0, 
    zSql=0xe05ac6 ";SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT "..., nBytes=1090, prepFlags=128, pReprepare=0x0, ppStmt=0x7ffe47a0f868, pzTail=0x7ffe47a0f850) at sqlite3.c:124303
#20 0x00000000002a0d4e in sqlite3LockAndPrepare (db=0xdfe2b0, 
    zSql=0xe05ac6 ";SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT "..., nBytes=1090, prepFlags=128, pOld=0x0, ppStmt=0x7ffe47a0f868, pzTail=0x7ffe47a0f850) at sqlite3.c:124403
#21 0x000000000029247f in sqlite3_prepare_v2 (db=0xdfe2b0, 
    zSql=0xe05ac6 ";SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1) IN (SELECT 5,6);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT 3,4);;SELECT (SELECT 3,4 UNION SELECT 5,6 ORDER BY 1 DESC) IN (SELECT "..., nBytes=1090, ppStmt=0x7ffe47a0f868, pzTail=0x7ffe47a0f850) at sqlite3.c:124487
#22 0x0000000000256bd0 in main (argc=1, argv=0x7ffe47a0fa18) at target.cc:106
(gdb) quit
A debugging session is active.

	Inferior 1 [process 55710] will be killed.

Quit anyway? (y or n) [answered Y; input not from terminal]
