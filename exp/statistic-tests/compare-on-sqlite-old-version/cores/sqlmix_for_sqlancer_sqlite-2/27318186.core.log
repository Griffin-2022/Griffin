GNU gdb (Ubuntu 9.2-0ubuntu1~20.04.1) 9.2
Copyright (C) 2020 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type "show copying" and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
    <http://www.gnu.org/software/gdb/documentation/>.

For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from /root/sqlite_driver_fast...
(gdb) Starting program: /root/sqlite_driver_fast < "/root/out/default/crashes/id:000205,sig:06,src:021810+011022,time:2922124,execs:473915,op:merge.so,pos:0"
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
parser: [[[;CREATE TABLE t0(c0 TEXT PRIMARY KEY);;INSERT INTO t0 VALUES('c0'), ('b'), ('c'), ('d'), ('e');BEGIN
;;
;SELECT c0, ntile(1) OVER (ORDER BY c0) FROM t0

;;CREATE VIEW v0 AS 
    WITH RECURSIVE t3(v0,y,z) AS (
        SELECT c0,c0,NULL FROM t0
        UNION
        SELECT v0,y,NULL FROM t3, t0
    )
  SELECT * FROM t3 AS xyz;SELECT c0, ntile(2) OVER (ORDER BY c0) FROM t0

;ALTER TABLE t0 RENAME c0 TO v0;;
;DROP TABLE t0;;
;
;CREATE TABLE main.over(following, preceding, t1);SELECT preceding, ntile(6) OVER (ORDER BY preceding) FROM over

;SELECT preceding, ntile(7) OVER (ORDER BY preceding) FROM over

;SELECT t1, ntile(8) OVER (ORDER BY t1) FROM over

;SELECT following, ntile(9) OVER (ORDER BY following) FROM over

;SELECT following, ntile(10) OVER (ORDER BY following) FROM over

;SELECT following, ntile(12) OVER (ORDER BY following) FROM over

;SELECT preceding, ntile(14) OVER (ORDER BY preceding) FROM over

;SELECT following, ntile(16) OVER (ORDER BY following) FROM over

;SELECT t1, ntile(17) OVER (ORDER BY t1) FROM over

;SELECT following, ntile(18) OVER (ORDER BY following) FROM over

;SELECT t1, ntile(19) OVER (ORDER BY t1) FROM over

;DROP TABLE IF EXISTS t4;;CREATE TABLE x(test001 INTEGER PRIMARY KEY, last_field TEXT, test002 INTEGER);;INSERT INTO over VALUES(2, 'preceding', 3);;INSERT INTO over VALUES(5, 'E', 5);;INSERT INTO over VALUES(6, 'F', 1);;INSERT INTO x VALUES(7, 'G', 1);;INSERT INTO x VALUES(8, 'H', 2);;INSERT INTO over VALUES(9, 'I', 10);SELECT preceding, lead(preceding, 2) OVER (ORDER BY preceding) FROM over

;SELECT t1, lead(t1, 3, 'abc') OVER (ORDER BY t1) FROM over

;;CREATE TABLE field1(test003 INTEGER PRIMARY KEY, field2 TEXT, test004 TEXT, field3 INTEGER);;INSERT INTO x VALUES(1, 'last_field', 'one',   5);;INSERT INTO x VALUES(2, 'test001', 'two',   4);;INSERT INTO x VALUES(3, 'test001', 'three', 3);;INSERT INTO x VALUES(4, 'test001', 'four',  2);;INSERT INTO x VALUES(5, 'test001', 'five',  1);SELECT t1, max(following) OVER (ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 2 PRECEDING)
  FROM over

;SELECT preceding, max(following) OVER (ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over

;SELECT last_field, max(test002) OVER (ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 0 PRECEDING)
  FROM x

;SELECT test002, max(test001) OVER (ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 1 FOLLOWING)
  FROM x

;DROP TABLE IF EXISTS ttt;;INSERT INTO field1 VALUES(2, 2, 2);;INSERT INTO x VALUES(5, 2, 3);;INSERT INTO x VALUES(7, 1, 3);;INSERT INTO field1 VALUES(8, 2, 4);;INSERT INTO field1 VALUES(9, 3, 5);;
;SELECT abs(max(t1) OVER (ORDER BY t1)) FROM over GROUP BY t1;;
;SELECT sum(preceding) OVER (
    ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING
  ) FROM over;;
;SELECT max(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002, last_field ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER ( ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY preceding, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
         sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY last_field

;SELECT sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'CREATE' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[ecmd CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 1.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 388
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[ecmd createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 1.
parser: [[[CREATE TABLE x(type text,name text,tbl_name text,rootpage int,sql text)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 388
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP ID]
parser: Input 'ID' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 190
parser: Shift 'ID', pending reduce 335
parser: Return. Stack=[create_table LP nm ID]
parser: Input 'COMMA' with pending reduce 335
parser: Reduce 335 [typename ::= ID|STRING], go to state 190.
parser: ... then shift 'typename', go to state 390
parser: Reduce 334 [typetoken ::= typename], go to state 190.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 376
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 150
parser: Reduce 330 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 190
parser: Shift 'ID', pending reduce 335
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'COMMA' with pending reduce 335
parser: Reduce 335 [typename ::= ID|STRING], go to state 190.
parser: ... then shift 'typename', go to state 390
parser: Reduce 334 [typetoken ::= typename], go to state 190.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 383
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 151
parser: Reduce 329 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 190
parser: Shift 'ID', pending reduce 335
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'COMMA' with pending reduce 335
parser: Reduce 335 [typename ::= ID|STRING], go to state 190.
parser: ... then shift 'typename', go to state 390
parser: Reduce 334 [typetoken ::= typename], go to state 190.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 383
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 151
parser: Reduce 329 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 190
parser: Shift 'ID', pending reduce 335
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'COMMA' with pending reduce 335
parser: Reduce 335 [typename ::= ID|STRING], go to state 190.
parser: ... then shift 'typename', go to state 390
parser: Reduce 334 [typetoken ::= typename], go to state 190.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 383
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 151
parser: Reduce 329 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 190
parser: Shift 'ID', pending reduce 335
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'RP' with pending reduce 335
parser: Reduce 335 [typename ::= ID|STRING], go to state 190.
parser: ... then shift 'typename', go to state 390
parser: Reduce 334 [typetoken ::= typename], go to state 190.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 383
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 151
parser: Reduce 329 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Reduce 60 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 538
parser: Shift 'RP', go to state 361
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 361
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 328
parser: Reduce 328 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'FROM' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'DOT' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Shift 'DOT', go to state 245
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID' in state 245
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'ORDER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 245.
parser: ... then shift 'nm', pending reduce 109
parser: Reduce 109 [dbnm ::= DOT nm], go to state 349.
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[CREATE TABLE x(type text,name text,tbl_name text,rootpage int,sql text)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 388
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP ID]
parser: Input 'ID' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 190
parser: Shift 'ID', pending reduce 335
parser: Return. Stack=[create_table LP nm ID]
parser: Input 'COMMA' with pending reduce 335
parser: Reduce 335 [typename ::= ID|STRING], go to state 190.
parser: ... then shift 'typename', go to state 390
parser: Reduce 334 [typetoken ::= typename], go to state 190.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 376
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 150
parser: Reduce 330 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 190
parser: Shift 'ID', pending reduce 335
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'COMMA' with pending reduce 335
parser: Reduce 335 [typename ::= ID|STRING], go to state 190.
parser: ... then shift 'typename', go to state 390
parser: Reduce 334 [typetoken ::= typename], go to state 190.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 383
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 151
parser: Reduce 329 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 190
parser: Shift 'ID', pending reduce 335
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'COMMA' with pending reduce 335
parser: Reduce 335 [typename ::= ID|STRING], go to state 190.
parser: ... then shift 'typename', go to state 390
parser: Reduce 334 [typetoken ::= typename], go to state 190.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 383
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 151
parser: Reduce 329 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 190
parser: Shift 'ID', pending reduce 335
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'COMMA' with pending reduce 335
parser: Reduce 335 [typename ::= ID|STRING], go to state 190.
parser: ... then shift 'typename', go to state 390
parser: Reduce 334 [typetoken ::= typename], go to state 190.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 383
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 151
parser: Reduce 329 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 190
parser: Shift 'ID', pending reduce 335
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'RP' with pending reduce 335
parser: Reduce 335 [typename ::= ID|STRING], go to state 190.
parser: ... then shift 'typename', go to state 390
parser: Reduce 334 [typetoken ::= typename], go to state 190.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 383
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 151
parser: Reduce 329 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Reduce 60 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 538
parser: Shift 'RP', go to state 361
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 361
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 328
parser: Reduce 328 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[ecmd create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd create_table LP ID]
parser: Input 'ID' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 190
parser: Shift 'ID', pending reduce 335
parser: Return. Stack=[ecmd create_table LP nm ID]
parser: Input 'PRIMARY' with pending reduce 335
parser: Reduce 335 [typename ::= ID|STRING], go to state 190.
parser: ... then shift 'typename', go to state 390
parser: Reduce 334 [typetoken ::= typename], go to state 190.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 376
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 150
parser: Shift 'PRIMARY', go to state 475
parser: Return. Stack=[ecmd create_table LP columnname carglist PRIMARY]
parser: Input 'KEY' in state 475
parser: Shift 'KEY', go to state 280
parser: Return. Stack=[ecmd create_table LP columnname carglist PRIMARY KEY]
parser: Input 'RP' in state 280
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 333
parser: Reduce 68 [onconf ::=].
parser: ... then shift 'onconf', go to state 332
parser: Reduce 42 [autoinc ::=].
parser: ... then shift 'autoinc', pending reduce 36
parser: Reduce 36 [ccons ::= PRIMARY KEY sortorder onconf autoinc], go to state 150.
parser: [[[INSERT INTO 'main'.sqlite_master VALUES('index','sqlite_autoindex_t0_1','t0',#4,NULL);]]]
parser: Input 'INSERT' in state 0
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'INSERT', go to state 311
parser: Return. Stack=[with INSERT]
parser: Input 'INTO' in state 311
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', pending reduce 156
parser: Reduce 156 [insert_cmd ::= INSERT orconf], go to state 219.
parser: ... then shift 'insert_cmd', go to state 427
parser: Shift 'INTO', go to state 164
parser: Return. Stack=[with insert_cmd INTO]
parser: Input 'STRING' in state 164
parser: Shift 'STRING', pending reduce 332
parser: Return. Stack=[with insert_cmd INTO STRING]
parser: Input 'DOT' with pending reduce 332
parser: Reduce 332 [nm ::= STRING], go to state 164.
parser: ... then shift 'nm', go to state 393
parser: Shift 'DOT', go to state 218
parser: Return. Stack=[with insert_cmd INTO nm DOT]
parser: Input 'ID' in state 218
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with insert_cmd INTO nm DOT ID]
parser: Input 'VALUES' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 218.
parser: ... then shift 'nm', go to state 429
parser: Reduce 113 [xfullname ::= nm DOT nm], go to state 164.
parser: ... then shift 'xfullname', go to state 298
parser: Reduce 158 [idlist_opt ::=].
parser: ... then shift 'idlist_opt', go to state 35
parser: Shift 'VALUES', go to state 526
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES]
parser: Input 'LP' in state 526
parser: Shift 'LP', go to state 28
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP]
parser: Input 'STRING' in state 28
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 28.
parser: ... then shift 'term', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'STRING' in state 107
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'STRING' in state 107
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'VARIABLE' in state 107
parser: Shift 'VARIABLE', pending reduce 170
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA VARIABLE]
parser: Input 'COMMA' with pending reduce 170
parser: Reduce 170 [expr ::= VARIABLE], go to state 107.
parser: ... then shift 'expr', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'NULL' in state 107
parser: Shift 'NULL', pending reduce 167
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA NULL]
parser: Input 'RP' with pending reduce 167
parser: Reduce 167 [term ::= NULL|FLOAT|BLOB], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'RP', pending reduce 89
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist RP]
parser: Input 'SEMI' with pending reduce 89
parser: Reduce 89 [values ::= VALUES LP nexprlist RP], go to state 35.
parser: ... then shift 'values', go to state 532
parser: Reduce 348 [oneselect ::= values], go to state 35.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 35.
parser: ... then shift 'select', go to state 297
parser: Reduce 152 [upsert ::=].
parser: ... then shift 'upsert', pending reduce 150
parser: Reduce 150 [cmd ::= with insert_cmd INTO xfullname idlist_opt select upsert], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Input '$' with pending reduce 321
parser: Reduce 321 [ecmd ::= cmdx SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 317 [input ::= cmdlist], go to state 0.
parser: ... then shift 'input', pending reduce -2
parser: Accept!
parser: ... then shift 'ccons', pending reduce 338
parser: Reduce 338 [carglist ::= carglist ccons], go to state 376.
parser: ... then shift 'carglist', go to state 150
parser: Reduce 330 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Reduce 60 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 538
parser: Shift 'RP', go to state 361
parser: Return. Stack=[ecmd create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 361
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: [[[UPDATE 'main'.sqlite_master SET type='table', name='t0', tbl_name='t0', rootpage=#2, sql='CREATE TABLE t0(c0 TEXT PRIMARY KEY)' WHERE rowid=#1]]]
parser: Input 'UPDATE' in state 0
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'UPDATE', go to state 299
parser: Return. Stack=[with UPDATE]
parser: Input 'STRING' in state 299
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', go to state 165
parser: Shift 'STRING', pending reduce 332
parser: Return. Stack=[with UPDATE orconf STRING]
parser: Input 'DOT' with pending reduce 332
parser: Reduce 332 [nm ::= STRING], go to state 165.
parser: ... then shift 'nm', go to state 393
parser: Shift 'DOT', go to state 218
parser: Return. Stack=[with UPDATE orconf nm DOT]
parser: Input 'ID' in state 218
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf nm DOT ID]
parser: Input 'SET' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 218.
parser: ... then shift 'nm', go to state 429
parser: Reduce 113 [xfullname ::= nm DOT nm], go to state 165.
parser: ... then shift 'xfullname', go to state 271
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 428
parser: Shift 'SET', go to state 153
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET]
parser: Input 'ID' in state 153
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 153.
parser: ... then shift 'nm', go to state 442
parser: Shift 'EQ', go to state 84
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ]
parser: Input 'STRING' in state 84
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 84.
parser: ... then shift 'term', go to state 58
parser: Reduce 148 [setlist ::= nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'VARIABLE' in state 86
parser: Shift 'VARIABLE', pending reduce 170
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ VARIABLE]
parser: Input 'COMMA' with pending reduce 170
parser: Reduce 170 [expr ::= VARIABLE], go to state 86.
parser: ... then shift 'expr', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'WHERE' in state 537
parser: Reduce 168 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 416
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr EQ]
parser: Input 'VARIABLE' in state 117
parser: Shift 'VARIABLE', pending reduce 170
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr EQ VARIABLE]
parser: Input 'SEMI' with pending reduce 170
parser: Reduce 170 [expr ::= VARIABLE], go to state 117.
parser: ... then shift 'expr', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 270.
parser: ... then shift 'where_opt', pending reduce 145
parser: Reduce 145 [cmd ::= with UPDATE orconf xfullname indexed_opt SET setlist where_opt], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Input '$' with pending reduce 321
parser: Reduce 321 [ecmd ::= cmdx SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 317 [input ::= cmdlist], go to state 0.
parser: ... then shift 'input', pending reduce -2
parser: Accept!
parser: ... then shift 'create_table_args', pending reduce 328
parser: Reduce 328 [cmd ::= create_table create_table_args], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
parser: [[[SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t0' AND type!='trigger' ORDER BY rowid]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'FROM' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'STRING' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'STRING', pending reduce 332
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix STRING]
parser: Input 'DOT' with pending reduce 332
parser: Reduce 332 [nm ::= STRING], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Shift 'DOT', go to state 245
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID' in state 245
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 245.
parser: ... then shift 'nm', pending reduce 109
parser: Reduce 109 [dbnm ::= DOT nm], go to state 349.
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[SELECT distinct selcollist from WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND' in state 537
parser: Reduce 168 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'AND', go to state 120
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID' in state 120
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'NE' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Shift 'NE', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr NE]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr NE STRING]
parser: Input 'ORDER' in state 537
parser: Reduce 168 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Reduce 179 [expr ::= expr AND expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[CREATE TABLE t0(c0 TEXT PRIMARY KEY)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 388
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP ID]
parser: Input 'ID' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 190
parser: Shift 'ID', pending reduce 335
parser: Return. Stack=[create_table LP nm ID]
parser: Input 'PRIMARY' with pending reduce 335
parser: Reduce 335 [typename ::= ID|STRING], go to state 190.
parser: ... then shift 'typename', go to state 390
parser: Reduce 334 [typetoken ::= typename], go to state 190.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 376
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 150
parser: Shift 'PRIMARY', go to state 475
parser: Return. Stack=[create_table LP columnname carglist PRIMARY]
parser: Input 'KEY' in state 475
parser: Shift 'KEY', go to state 280
parser: Return. Stack=[create_table LP columnname carglist PRIMARY KEY]
parser: Input 'RP' in state 280
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 333
parser: Reduce 68 [onconf ::=].
parser: ... then shift 'onconf', go to state 332
parser: Reduce 42 [autoinc ::=].
parser: ... then shift 'autoinc', pending reduce 36
parser: Reduce 36 [ccons ::= PRIMARY KEY sortorder onconf autoinc], go to state 150.
parser: ... then shift 'ccons', pending reduce 338
parser: Reduce 338 [carglist ::= carglist ccons], go to state 376.
parser: ... then shift 'carglist', go to state 150
parser: Reduce 330 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Reduce 60 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 538
parser: Shift 'RP', go to state 361
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 361
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 328
parser: Reduce 328 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[;INSERT INTO t0 VALUES('c0'), ('b'), ('c'), ('d'), ('e');BEGIN
;;
;SELECT c0, ntile(1) OVER (ORDER BY c0) FROM t0

;;CREATE VIEW v0 AS 
    WITH RECURSIVE t3(v0,y,z) AS (
        SELECT c0,c0,NULL FROM t0
        UNION
        SELECT v0,y,NULL FROM t3, t0
    )
  SELECT * FROM t3 AS xyz;SELECT c0, ntile(2) OVER (ORDER BY c0) FROM t0

;ALTER TABLE t0 RENAME c0 TO v0;;
;DROP TABLE t0;;
;
;CREATE TABLE main.over(following, preceding, t1);SELECT preceding, ntile(6) OVER (ORDER BY preceding) FROM over

;SELECT preceding, ntile(7) OVER (ORDER BY preceding) FROM over

;SELECT t1, ntile(8) OVER (ORDER BY t1) FROM over

;SELECT following, ntile(9) OVER (ORDER BY following) FROM over

;SELECT following, ntile(10) OVER (ORDER BY following) FROM over

;SELECT following, ntile(12) OVER (ORDER BY following) FROM over

;SELECT preceding, ntile(14) OVER (ORDER BY preceding) FROM over

;SELECT following, ntile(16) OVER (ORDER BY following) FROM over

;SELECT t1, ntile(17) OVER (ORDER BY t1) FROM over

;SELECT following, ntile(18) OVER (ORDER BY following) FROM over

;SELECT t1, ntile(19) OVER (ORDER BY t1) FROM over

;DROP TABLE IF EXISTS t4;;CREATE TABLE x(test001 INTEGER PRIMARY KEY, last_field TEXT, test002 INTEGER);;INSERT INTO over VALUES(2, 'preceding', 3);;INSERT INTO over VALUES(5, 'E', 5);;INSERT INTO over VALUES(6, 'F', 1);;INSERT INTO x VALUES(7, 'G', 1);;INSERT INTO x VALUES(8, 'H', 2);;INSERT INTO over VALUES(9, 'I', 10);SELECT preceding, lead(preceding, 2) OVER (ORDER BY preceding) FROM over

;SELECT t1, lead(t1, 3, 'abc') OVER (ORDER BY t1) FROM over

;;CREATE TABLE field1(test003 INTEGER PRIMARY KEY, field2 TEXT, test004 TEXT, field3 INTEGER);;INSERT INTO x VALUES(1, 'last_field', 'one',   5);;INSERT INTO x VALUES(2, 'test001', 'two',   4);;INSERT INTO x VALUES(3, 'test001', 'three', 3);;INSERT INTO x VALUES(4, 'test001', 'four',  2);;INSERT INTO x VALUES(5, 'test001', 'five',  1);SELECT t1, max(following) OVER (ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 2 PRECEDING)
  FROM over

;SELECT preceding, max(following) OVER (ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over

;SELECT last_field, max(test002) OVER (ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 0 PRECEDING)
  FROM x

;SELECT test002, max(test001) OVER (ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 1 FOLLOWING)
  FROM x

;DROP TABLE IF EXISTS ttt;;INSERT INTO field1 VALUES(2, 2, 2);;INSERT INTO x VALUES(5, 2, 3);;INSERT INTO x VALUES(7, 1, 3);;INSERT INTO field1 VALUES(8, 2, 4);;INSERT INTO field1 VALUES(9, 3, 5);;
;SELECT abs(max(t1) OVER (ORDER BY t1)) FROM over GROUP BY t1;;
;SELECT sum(preceding) OVER (
    ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING
  ) FROM over;;
;SELECT max(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002, last_field ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER ( ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY preceding, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
         sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY last_field

;SELECT sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'INSERT' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'INSERT', go to state 311
parser: Return. Stack=[ecmd with INSERT]
parser: Input 'INTO' in state 311
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', pending reduce 156
parser: Reduce 156 [insert_cmd ::= INSERT orconf], go to state 219.
parser: ... then shift 'insert_cmd', go to state 427
parser: Shift 'INTO', go to state 164
parser: Return. Stack=[ecmd with insert_cmd INTO]
parser: Input 'ID' in state 164
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd with insert_cmd INTO ID]
parser: Input 'VALUES' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 164.
parser: ... then shift 'nm', go to state 393
parser: Reduce 112 [xfullname ::= nm], go to state 164.
parser: ... then shift 'xfullname', go to state 298
parser: Reduce 158 [idlist_opt ::=].
parser: ... then shift 'idlist_opt', go to state 35
parser: Shift 'VALUES', go to state 526
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES]
parser: Input 'LP' in state 526
parser: Shift 'LP', go to state 28
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP]
parser: Input 'STRING' in state 28
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP STRING]
parser: Input 'RP' in state 537
parser: Reduce 168 [term ::= STRING], go to state 28.
parser: ... then shift 'term', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'RP', pending reduce 89
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist RP]
parser: Input 'COMMA' with pending reduce 89
parser: Reduce 89 [values ::= VALUES LP nexprlist RP], go to state 35.
parser: ... then shift 'values', go to state 532
parser: Shift 'COMMA', go to state 531
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt values COMMA]
parser: Input 'LP' in state 531
parser: Shift 'LP', go to state 29
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt values COMMA LP]
parser: Input 'STRING' in state 29
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt values COMMA LP STRING]
parser: Input 'RP' in state 537
parser: Reduce 168 [term ::= STRING], go to state 29.
parser: ... then shift 'term', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 29.
parser: ... then shift 'nexprlist', go to state 414
parser: Shift 'RP', pending reduce 90
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt values COMMA LP nexprlist RP]
parser: Input 'COMMA' with pending reduce 90
parser: Reduce 90 [values ::= values COMMA LP nexprlist RP], go to state 35.
parser: ... then shift 'values', go to state 532
parser: Shift 'COMMA', go to state 531
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt values COMMA]
parser: Input 'LP' in state 531
parser: Shift 'LP', go to state 29
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt values COMMA LP]
parser: Input 'STRING' in state 29
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt values COMMA LP STRING]
parser: Input 'RP' in state 537
parser: Reduce 168 [term ::= STRING], go to state 29.
parser: ... then shift 'term', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 29.
parser: ... then shift 'nexprlist', go to state 414
parser: Shift 'RP', pending reduce 90
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt values COMMA LP nexprlist RP]
parser: Input 'COMMA' with pending reduce 90
parser: Reduce 90 [values ::= values COMMA LP nexprlist RP], go to state 35.
parser: ... then shift 'values', go to state 532
parser: Shift 'COMMA', go to state 531
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt values COMMA]
parser: Input 'LP' in state 531
parser: Shift 'LP', go to state 29
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt values COMMA LP]
parser: Input 'STRING' in state 29
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt values COMMA LP STRING]
parser: Input 'RP' in state 537
parser: Reduce 168 [term ::= STRING], go to state 29.
parser: ... then shift 'term', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 29.
parser: ... then shift 'nexprlist', go to state 414
parser: Shift 'RP', pending reduce 90
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt values COMMA LP nexprlist RP]
parser: Input 'COMMA' with pending reduce 90
parser: Reduce 90 [values ::= values COMMA LP nexprlist RP], go to state 35.
parser: ... then shift 'values', go to state 532
parser: Shift 'COMMA', go to state 531
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt values COMMA]
parser: Input 'LP' in state 531
parser: Shift 'LP', go to state 29
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt values COMMA LP]
parser: Input 'STRING' in state 29
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt values COMMA LP STRING]
parser: Input 'RP' in state 537
parser: Reduce 168 [term ::= STRING], go to state 29.
parser: ... then shift 'term', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 29.
parser: ... then shift 'nexprlist', go to state 414
parser: Shift 'RP', pending reduce 90
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt values COMMA LP nexprlist RP]
parser: Input 'SEMI' with pending reduce 90
parser: Reduce 90 [values ::= values COMMA LP nexprlist RP], go to state 35.
parser: ... then shift 'values', go to state 532
parser: Reduce 348 [oneselect ::= values], go to state 35.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 35.
parser: ... then shift 'select', go to state 297
parser: Reduce 152 [upsert ::=].
parser: ... then shift 'upsert', pending reduce 150
parser: Reduce 150 [cmd ::= with insert_cmd INTO xfullname idlist_opt select upsert], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
parser: [[[BEGIN
;;
;SELECT c0, ntile(1) OVER (ORDER BY c0) FROM t0

;;CREATE VIEW v0 AS 
    WITH RECURSIVE t3(v0,y,z) AS (
        SELECT c0,c0,NULL FROM t0
        UNION
        SELECT v0,y,NULL FROM t3, t0
    )
  SELECT * FROM t3 AS xyz;SELECT c0, ntile(2) OVER (ORDER BY c0) FROM t0

;ALTER TABLE t0 RENAME c0 TO v0;;
;DROP TABLE t0;;
;
;CREATE TABLE main.over(following, preceding, t1);SELECT preceding, ntile(6) OVER (ORDER BY preceding) FROM over

;SELECT preceding, ntile(7) OVER (ORDER BY preceding) FROM over

;SELECT t1, ntile(8) OVER (ORDER BY t1) FROM over

;SELECT following, ntile(9) OVER (ORDER BY following) FROM over

;SELECT following, ntile(10) OVER (ORDER BY following) FROM over

;SELECT following, ntile(12) OVER (ORDER BY following) FROM over

;SELECT preceding, ntile(14) OVER (ORDER BY preceding) FROM over

;SELECT following, ntile(16) OVER (ORDER BY following) FROM over

;SELECT t1, ntile(17) OVER (ORDER BY t1) FROM over

;SELECT following, ntile(18) OVER (ORDER BY following) FROM over

;SELECT t1, ntile(19) OVER (ORDER BY t1) FROM over

;DROP TABLE IF EXISTS t4;;CREATE TABLE x(test001 INTEGER PRIMARY KEY, last_field TEXT, test002 INTEGER);;INSERT INTO over VALUES(2, 'preceding', 3);;INSERT INTO over VALUES(5, 'E', 5);;INSERT INTO over VALUES(6, 'F', 1);;INSERT INTO x VALUES(7, 'G', 1);;INSERT INTO x VALUES(8, 'H', 2);;INSERT INTO over VALUES(9, 'I', 10);SELECT preceding, lead(preceding, 2) OVER (ORDER BY preceding) FROM over

;SELECT t1, lead(t1, 3, 'abc') OVER (ORDER BY t1) FROM over

;;CREATE TABLE field1(test003 INTEGER PRIMARY KEY, field2 TEXT, test004 TEXT, field3 INTEGER);;INSERT INTO x VALUES(1, 'last_field', 'one',   5);;INSERT INTO x VALUES(2, 'test001', 'two',   4);;INSERT INTO x VALUES(3, 'test001', 'three', 3);;INSERT INTO x VALUES(4, 'test001', 'four',  2);;INSERT INTO x VALUES(5, 'test001', 'five',  1);SELECT t1, max(following) OVER (ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 2 PRECEDING)
  FROM over

;SELECT preceding, max(following) OVER (ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over

;SELECT last_field, max(test002) OVER (ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 0 PRECEDING)
  FROM x

;SELECT test002, max(test001) OVER (ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 1 FOLLOWING)
  FROM x

;DROP TABLE IF EXISTS ttt;;INSERT INTO field1 VALUES(2, 2, 2);;INSERT INTO x VALUES(5, 2, 3);;INSERT INTO x VALUES(7, 1, 3);;INSERT INTO field1 VALUES(8, 2, 4);;INSERT INTO field1 VALUES(9, 3, 5);;
;SELECT abs(max(t1) OVER (ORDER BY t1)) FROM over GROUP BY t1;;
;SELECT sum(preceding) OVER (
    ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING
  ) FROM over;;
;SELECT max(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002, last_field ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER ( ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY preceding, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
         sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY last_field

;SELECT sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'BEGIN' in state 0
parser: Shift 'BEGIN', go to state 268
parser: Return. Stack=[BEGIN]
parser: Input 'SEMI' in state 268
parser: Reduce 4 [transtype ::=].
parser: ... then shift 'transtype', go to state 367
parser: Reduce 323 [trans_opt ::=].
parser: ... then shift 'trans_opt', pending reduce 3
parser: Reduce 3 [cmd ::= BEGIN transtype trans_opt], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[;
;SELECT c0, ntile(1) OVER (ORDER BY c0) FROM t0

;;CREATE VIEW v0 AS 
    WITH RECURSIVE t3(v0,y,z) AS (
        SELECT c0,c0,NULL FROM t0
        UNION
        SELECT v0,y,NULL FROM t3, t0
    )
  SELECT * FROM t3 AS xyz;SELECT c0, ntile(2) OVER (ORDER BY c0) FROM t0

;ALTER TABLE t0 RENAME c0 TO v0;;
;DROP TABLE t0;;
;
;CREATE TABLE main.over(following, preceding, t1);SELECT preceding, ntile(6) OVER (ORDER BY preceding) FROM over

;SELECT preceding, ntile(7) OVER (ORDER BY preceding) FROM over

;SELECT t1, ntile(8) OVER (ORDER BY t1) FROM over

;SELECT following, ntile(9) OVER (ORDER BY following) FROM over

;SELECT following, ntile(10) OVER (ORDER BY following) FROM over

;SELECT following, ntile(12) OVER (ORDER BY following) FROM over

;SELECT preceding, ntile(14) OVER (ORDER BY preceding) FROM over

;SELECT following, ntile(16) OVER (ORDER BY following) FROM over

;SELECT t1, ntile(17) OVER (ORDER BY t1) FROM over

;SELECT following, ntile(18) OVER (ORDER BY following) FROM over

;SELECT t1, ntile(19) OVER (ORDER BY t1) FROM over

;DROP TABLE IF EXISTS t4;;CREATE TABLE x(test001 INTEGER PRIMARY KEY, last_field TEXT, test002 INTEGER);;INSERT INTO over VALUES(2, 'preceding', 3);;INSERT INTO over VALUES(5, 'E', 5);;INSERT INTO over VALUES(6, 'F', 1);;INSERT INTO x VALUES(7, 'G', 1);;INSERT INTO x VALUES(8, 'H', 2);;INSERT INTO over VALUES(9, 'I', 10);SELECT preceding, lead(preceding, 2) OVER (ORDER BY preceding) FROM over

;SELECT t1, lead(t1, 3, 'abc') OVER (ORDER BY t1) FROM over

;;CREATE TABLE field1(test003 INTEGER PRIMARY KEY, field2 TEXT, test004 TEXT, field3 INTEGER);;INSERT INTO x VALUES(1, 'last_field', 'one',   5);;INSERT INTO x VALUES(2, 'test001', 'two',   4);;INSERT INTO x VALUES(3, 'test001', 'three', 3);;INSERT INTO x VALUES(4, 'test001', 'four',  2);;INSERT INTO x VALUES(5, 'test001', 'five',  1);SELECT t1, max(following) OVER (ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 2 PRECEDING)
  FROM over

;SELECT preceding, max(following) OVER (ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over

;SELECT last_field, max(test002) OVER (ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 0 PRECEDING)
  FROM x

;SELECT test002, max(test001) OVER (ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 1 FOLLOWING)
  FROM x

;DROP TABLE IF EXISTS ttt;;INSERT INTO field1 VALUES(2, 2, 2);;INSERT INTO x VALUES(5, 2, 3);;INSERT INTO x VALUES(7, 1, 3);;INSERT INTO field1 VALUES(8, 2, 4);;INSERT INTO field1 VALUES(9, 3, 5);;
;SELECT abs(max(t1) OVER (ORDER BY t1)) FROM over GROUP BY t1;;
;SELECT sum(preceding) OVER (
    ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING
  ) FROM over;;
;SELECT max(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002, last_field ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER ( ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY preceding, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
         sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY last_field

;SELECT sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'SEMI' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[ecmd SEMI]
parser: Input 'SELECT' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 1.
parser: ... then shift 'ecmd', pending reduce 318
parser: Reduce 318 [cmdlist ::= cmdlist ecmd], go to state 0.
parser: ... then shift 'cmdlist', go to state 1
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[cmdlist SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[cmdlist SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP]
parser: Input 'INTEGER' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 11.
parser: ... then shift 'term', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'ORDER' in state 32
parser: Shift 'ORDER', go to state 500
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER]
parser: Input 'BY' in state 500
parser: Shift 'BY', go to state 22
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY]
parser: Input 'ID' in state 22
parser: Shift 'ID', go to state 416
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 22.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 22.
parser: ... then shift 'sortlist', go to state 184
parser: Reduce 297 [frame_opt ::=].
parser: ... then shift 'frame_opt', pending reduce 293
parser: Reduce 293 [window ::= ORDER BY sortlist frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[cmdlist SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[cmdlist SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'SEMI' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 1.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 1.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdlist cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping cmdlist
parser: [[[;CREATE VIEW v0 AS 
    WITH RECURSIVE t3(v0,y,z) AS (
        SELECT c0,c0,NULL FROM t0
        UNION
        SELECT v0,y,NULL FROM t3, t0
    )
  SELECT * FROM t3 AS xyz;SELECT c0, ntile(2) OVER (ORDER BY c0) FROM t0

;ALTER TABLE t0 RENAME c0 TO v0;;
;DROP TABLE t0;;
;
;CREATE TABLE main.over(following, preceding, t1);SELECT preceding, ntile(6) OVER (ORDER BY preceding) FROM over

;SELECT preceding, ntile(7) OVER (ORDER BY preceding) FROM over

;SELECT t1, ntile(8) OVER (ORDER BY t1) FROM over

;SELECT following, ntile(9) OVER (ORDER BY following) FROM over

;SELECT following, ntile(10) OVER (ORDER BY following) FROM over

;SELECT following, ntile(12) OVER (ORDER BY following) FROM over

;SELECT preceding, ntile(14) OVER (ORDER BY preceding) FROM over

;SELECT following, ntile(16) OVER (ORDER BY following) FROM over

;SELECT t1, ntile(17) OVER (ORDER BY t1) FROM over

;SELECT following, ntile(18) OVER (ORDER BY following) FROM over

;SELECT t1, ntile(19) OVER (ORDER BY t1) FROM over

;DROP TABLE IF EXISTS t4;;CREATE TABLE x(test001 INTEGER PRIMARY KEY, last_field TEXT, test002 INTEGER);;INSERT INTO over VALUES(2, 'preceding', 3);;INSERT INTO over VALUES(5, 'E', 5);;INSERT INTO over VALUES(6, 'F', 1);;INSERT INTO x VALUES(7, 'G', 1);;INSERT INTO x VALUES(8, 'H', 2);;INSERT INTO over VALUES(9, 'I', 10);SELECT preceding, lead(preceding, 2) OVER (ORDER BY preceding) FROM over

;SELECT t1, lead(t1, 3, 'abc') OVER (ORDER BY t1) FROM over

;;CREATE TABLE field1(test003 INTEGER PRIMARY KEY, field2 TEXT, test004 TEXT, field3 INTEGER);;INSERT INTO x VALUES(1, 'last_field', 'one',   5);;INSERT INTO x VALUES(2, 'test001', 'two',   4);;INSERT INTO x VALUES(3, 'test001', 'three', 3);;INSERT INTO x VALUES(4, 'test001', 'four',  2);;INSERT INTO x VALUES(5, 'test001', 'five',  1);SELECT t1, max(following) OVER (ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 2 PRECEDING)
  FROM over

;SELECT preceding, max(following) OVER (ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over

;SELECT last_field, max(test002) OVER (ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 0 PRECEDING)
  FROM x

;SELECT test002, max(test001) OVER (ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 1 FOLLOWING)
  FROM x

;DROP TABLE IF EXISTS ttt;;INSERT INTO field1 VALUES(2, 2, 2);;INSERT INTO x VALUES(5, 2, 3);;INSERT INTO x VALUES(7, 1, 3);;INSERT INTO field1 VALUES(8, 2, 4);;INSERT INTO field1 VALUES(9, 3, 5);;
;SELECT abs(max(t1) OVER (ORDER BY t1)) FROM over GROUP BY t1;;
;SELECT sum(preceding) OVER (
    ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING
  ) FROM over;;
;SELECT max(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002, last_field ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER ( ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY preceding, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
         sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY last_field

;SELECT sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'CREATE' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[ecmd CREATE]
parser: Input 'VIEW' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 1.
parser: ... then shift 'createkw', go to state 134
parser: FALLBACK VIEW => ID
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 388
parser: Shift 'VIEW', go to state 322
parser: Return. Stack=[ecmd createkw temp VIEW]
parser: Input 'ID' in state 322
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 228
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd createkw temp VIEW ifnotexists ID]
parser: Input 'AS' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 228.
parser: ... then shift 'nm', go to state 321
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 320
parser: Reduce 222 [eidlist_opt ::=].
parser: ... then shift 'eidlist_opt', go to state 461
parser: Shift 'AS', go to state 37
parser: Return. Stack=[ecmd createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS]
parser: Input 'WITH' in state 37
parser: Shift 'WITH', go to state 160
parser: Return. Stack=[ecmd createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH]
parser: Input 'RECURSIVE' in state 160
parser: Shift 'RECURSIVE', go to state 181
parser: Return. Stack=[ecmd createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE]
parser: Input 'ID' in state 181
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE ID]
parser: Input 'LP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 181.
parser: ... then shift 'nm', go to state 337
parser: Shift 'LP', go to state 182
parser: Return. Stack=[ecmd createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm LP]
parser: Input 'ID' in state 182
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm LP ID]
parser: Input 'COMMA' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 182.
parser: ... then shift 'nm', go to state 338
parser: Reduce 226 [collate ::=].
parser: ... then shift 'collate', go to state 281
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 225
parser: Reduce 225 [eidlist ::= nm collate sortorder], go to state 182.
parser: ... then shift 'eidlist', go to state 408
parser: Shift 'COMMA', go to state 237
parser: Return. Stack=[ecmd createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm LP eidlist COMMA]
parser: Input 'ID' in state 237
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm LP eidlist COMMA ID]
parser: Input 'COMMA' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 237.
parser: ... then shift 'nm', go to state 339
parser: Reduce 226 [collate ::=].
parser: ... then shift 'collate', go to state 282
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 224
parser: Reduce 224 [eidlist ::= eidlist COMMA nm collate sortorder], go to state 182.
parser: ... then shift 'eidlist', go to state 408
parser: Shift 'COMMA', go to state 237
parser: Return. Stack=[ecmd createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm LP eidlist COMMA]
parser: Input 'ID' in state 237
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm LP eidlist COMMA ID]
parser: Input 'RP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 237.
parser: ... then shift 'nm', go to state 339
parser: Reduce 226 [collate ::=].
parser: ... then shift 'collate', go to state 282
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 224
parser: Reduce 224 [eidlist ::= eidlist COMMA nm collate sortorder], go to state 182.
parser: ... then shift 'eidlist', go to state 408
parser: Shift 'RP', pending reduce 223
parser: Return. Stack=[ecmd createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm LP eidlist RP]
parser: Input 'AS' with pending reduce 223
parser: Reduce 223 [eidlist_opt ::= LP eidlist RP], go to state 337.
parser: ... then shift 'eidlist_opt', go to state 487
parser: Shift 'AS', go to state 486
parser: Return. Stack=[ecmd createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS]
parser: Input 'LP' in state 486
parser: Shift 'LP', go to state 39
parser: Return. Stack=[ecmd createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP]
parser: Input 'SELECT' in state 39
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[ecmd createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[ecmd createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[ecmd createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP SELECT distinct selcollist COMMA]
parser: Input 'NULL' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'NULL', pending reduce 167
parser: Return. Stack=[ecmd createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP SELECT distinct sclp scanpt NULL]
parser: Input 'FROM' with pending reduce 167
parser: Reduce 167 [term ::= NULL|FLOAT|BLOB], go to state 77.
parser: ... then shift 'term', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[ecmd createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'UNION' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 39.
parser: ... then shift 'oneselect', go to state 264
parser: Shift 'UNION', go to state 533
parser: Return. Stack=[ecmd createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP oneselect UNION]
parser: Input 'SELECT' in state 533
parser: Reduce 84 [multiselect_op ::= UNION], go to state 264.
parser: ... then shift 'multiselect_op', go to state 195
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[ecmd createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP oneselect multiselect_op SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP oneselect multiselect_op SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[ecmd createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP oneselect multiselect_op SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[ecmd createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP oneselect multiselect_op SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[ecmd createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP oneselect multiselect_op SELECT distinct selcollist COMMA]
parser: Input 'NULL' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'NULL', pending reduce 167
parser: Return. Stack=[ecmd createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP oneselect multiselect_op SELECT distinct sclp scanpt NULL]
parser: Input 'FROM' with pending reduce 167
parser: Reduce 167 [term ::= NULL|FLOAT|BLOB], go to state 77.
parser: ... then shift 'term', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[ecmd createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP oneselect multiselect_op SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP oneselect multiselect_op SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'COMMA' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Shift 'COMMA', pending reduce 116
parser: Return. Stack=[ecmd createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP oneselect multiselect_op SELECT distinct selcollist FROM seltablist COMMA]
parser: Input 'ID' with pending reduce 116
parser: Reduce 116 [joinop ::= COMMA|JOIN], go to state 263.
parser: ... then shift 'joinop', pending reduce 102
parser: Reduce 102 [stl_prefix ::= seltablist joinop], go to state 197.
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP oneselect multiselect_op SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'RP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 195.
parser: ... then shift 'oneselect', pending reduce 83
parser: Reduce 83 [selectnowith ::= selectnowith multiselect_op oneselect], go to state 39.
parser: ... then shift 'selectnowith', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 39.
parser: ... then shift 'select', go to state 485
parser: Shift 'RP', pending reduce 286
parser: Return. Stack=[ecmd createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP select RP]
parser: Input 'SELECT' with pending reduce 286
parser: Reduce 286 [wqlist ::= nm eidlist_opt AS LP select RP], go to state 181.
parser: ... then shift 'wqlist', go to state 142
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[ecmd createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE wqlist SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 96
parser: Return. Stack=[ecmd createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE wqlist SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[ecmd createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE wqlist SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE wqlist SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'AS' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Shift 'AS', go to state 242
parser: Return. Stack=[ecmd createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE wqlist SELECT distinct selcollist FROM stl_prefix nm dbnm AS]
parser: Input 'ID' in state 242
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE wqlist SELECT distinct selcollist FROM stl_prefix nm dbnm AS ID]
parser: Input 'SEMI' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 242.
parser: ... then shift 'nm', pending reduce 98
parser: Reduce 98 [as ::= AS nm], go to state 243.
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 142.
parser: ... then shift 'oneselect', go to state 258
parser: Reduce 81 [select ::= WITH RECURSIVE wqlist selectnowith], go to state 37.
parser: ... then shift 'select', pending reduce 77
parser: Reduce 77 [cmd ::= createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS select], go to state 1.
parser: [[[UPDATE 'main'.sqlite_master SET type='view', name='v0', tbl_name='v0', rootpage=#2, sql='CREATE VIEW v0 AS 
    WITH RECURSIVE t3(v0,y,z) AS (
        SELECT c0,c0,NULL FROM t0
        UNION
        SELECT v0,y,NULL FROM t3, t0
    )
  SELECT * FROM t3 AS xyz' WHERE rowid=#1]]]
parser: Input 'UPDATE' in state 0
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'UPDATE', go to state 299
parser: Return. Stack=[with UPDATE]
parser: Input 'STRING' in state 299
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', go to state 165
parser: Shift 'STRING', pending reduce 332
parser: Return. Stack=[with UPDATE orconf STRING]
parser: Input 'DOT' with pending reduce 332
parser: Reduce 332 [nm ::= STRING], go to state 165.
parser: ... then shift 'nm', go to state 393
parser: Shift 'DOT', go to state 218
parser: Return. Stack=[with UPDATE orconf nm DOT]
parser: Input 'ID' in state 218
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf nm DOT ID]
parser: Input 'SET' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 218.
parser: ... then shift 'nm', go to state 429
parser: Reduce 113 [xfullname ::= nm DOT nm], go to state 165.
parser: ... then shift 'xfullname', go to state 271
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 428
parser: Shift 'SET', go to state 153
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET]
parser: Input 'ID' in state 153
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 153.
parser: ... then shift 'nm', go to state 442
parser: Shift 'EQ', go to state 84
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ]
parser: Input 'STRING' in state 84
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 84.
parser: ... then shift 'term', go to state 58
parser: Reduce 148 [setlist ::= nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'VARIABLE' in state 86
parser: Shift 'VARIABLE', pending reduce 170
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ VARIABLE]
parser: Input 'COMMA' with pending reduce 170
parser: Reduce 170 [expr ::= VARIABLE], go to state 86.
parser: ... then shift 'expr', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'WHERE' in state 537
parser: Reduce 168 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 416
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr EQ]
parser: Input 'VARIABLE' in state 117
parser: Shift 'VARIABLE', pending reduce 170
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr EQ VARIABLE]
parser: Input 'SEMI' with pending reduce 170
parser: Reduce 170 [expr ::= VARIABLE], go to state 117.
parser: ... then shift 'expr', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 270.
parser: ... then shift 'where_opt', pending reduce 145
parser: Reduce 145 [cmd ::= with UPDATE orconf xfullname indexed_opt SET setlist where_opt], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Input '$' with pending reduce 321
parser: Reduce 321 [ecmd ::= cmdx SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 317 [input ::= cmdlist], go to state 0.
parser: ... then shift 'input', pending reduce -2
parser: Accept!
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
parser: [[[SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='v0' AND type!='trigger' ORDER BY rowid]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'FROM' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'STRING' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'STRING', pending reduce 332
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix STRING]
parser: Input 'DOT' with pending reduce 332
parser: Reduce 332 [nm ::= STRING], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Shift 'DOT', go to state 245
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID' in state 245
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 245.
parser: ... then shift 'nm', pending reduce 109
parser: Reduce 109 [dbnm ::= DOT nm], go to state 349.
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[SELECT distinct selcollist from WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND' in state 537
parser: Reduce 168 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'AND', go to state 120
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID' in state 120
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'NE' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Shift 'NE', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr NE]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr NE STRING]
parser: Input 'ORDER' in state 537
parser: Reduce 168 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Reduce 179 [expr ::= expr AND expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[CREATE VIEW v0 AS 
    WITH RECURSIVE t3(v0,y,z) AS (
        SELECT c0,c0,NULL FROM t0
        UNION
        SELECT v0,y,NULL FROM t3, t0
    )
  SELECT * FROM t3 AS xyz]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'VIEW' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: FALLBACK VIEW => ID
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 388
parser: Shift 'VIEW', go to state 322
parser: Return. Stack=[createkw temp VIEW]
parser: Input 'ID' in state 322
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 228
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp VIEW ifnotexists ID]
parser: Input 'AS' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 228.
parser: ... then shift 'nm', go to state 321
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 320
parser: Reduce 222 [eidlist_opt ::=].
parser: ... then shift 'eidlist_opt', go to state 461
parser: Shift 'AS', go to state 37
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS]
parser: Input 'WITH' in state 37
parser: Shift 'WITH', go to state 160
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH]
parser: Input 'RECURSIVE' in state 160
parser: Shift 'RECURSIVE', go to state 181
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE]
parser: Input 'ID' in state 181
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE ID]
parser: Input 'LP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 181.
parser: ... then shift 'nm', go to state 337
parser: Shift 'LP', go to state 182
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm LP]
parser: Input 'ID' in state 182
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm LP ID]
parser: Input 'COMMA' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 182.
parser: ... then shift 'nm', go to state 338
parser: Reduce 226 [collate ::=].
parser: ... then shift 'collate', go to state 281
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 225
parser: Reduce 225 [eidlist ::= nm collate sortorder], go to state 182.
parser: ... then shift 'eidlist', go to state 408
parser: Shift 'COMMA', go to state 237
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm LP eidlist COMMA]
parser: Input 'ID' in state 237
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm LP eidlist COMMA ID]
parser: Input 'COMMA' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 237.
parser: ... then shift 'nm', go to state 339
parser: Reduce 226 [collate ::=].
parser: ... then shift 'collate', go to state 282
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 224
parser: Reduce 224 [eidlist ::= eidlist COMMA nm collate sortorder], go to state 182.
parser: ... then shift 'eidlist', go to state 408
parser: Shift 'COMMA', go to state 237
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm LP eidlist COMMA]
parser: Input 'ID' in state 237
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm LP eidlist COMMA ID]
parser: Input 'RP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 237.
parser: ... then shift 'nm', go to state 339
parser: Reduce 226 [collate ::=].
parser: ... then shift 'collate', go to state 282
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 224
parser: Reduce 224 [eidlist ::= eidlist COMMA nm collate sortorder], go to state 182.
parser: ... then shift 'eidlist', go to state 408
parser: Shift 'RP', pending reduce 223
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm LP eidlist RP]
parser: Input 'AS' with pending reduce 223
parser: Reduce 223 [eidlist_opt ::= LP eidlist RP], go to state 337.
parser: ... then shift 'eidlist_opt', go to state 487
parser: Shift 'AS', go to state 486
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS]
parser: Input 'LP' in state 486
parser: Shift 'LP', go to state 39
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP]
parser: Input 'SELECT' in state 39
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP SELECT distinct selcollist COMMA]
parser: Input 'NULL' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'NULL', pending reduce 167
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP SELECT distinct sclp scanpt NULL]
parser: Input 'FROM' with pending reduce 167
parser: Reduce 167 [term ::= NULL|FLOAT|BLOB], go to state 77.
parser: ... then shift 'term', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'UNION' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 39.
parser: ... then shift 'oneselect', go to state 264
parser: Shift 'UNION', go to state 533
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP oneselect UNION]
parser: Input 'SELECT' in state 533
parser: Reduce 84 [multiselect_op ::= UNION], go to state 264.
parser: ... then shift 'multiselect_op', go to state 195
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP oneselect multiselect_op SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP oneselect multiselect_op SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP oneselect multiselect_op SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP oneselect multiselect_op SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP oneselect multiselect_op SELECT distinct selcollist COMMA]
parser: Input 'NULL' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'NULL', pending reduce 167
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP oneselect multiselect_op SELECT distinct sclp scanpt NULL]
parser: Input 'FROM' with pending reduce 167
parser: Reduce 167 [term ::= NULL|FLOAT|BLOB], go to state 77.
parser: ... then shift 'term', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP oneselect multiselect_op SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP oneselect multiselect_op SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'COMMA' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Shift 'COMMA', pending reduce 116
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP oneselect multiselect_op SELECT distinct selcollist FROM seltablist COMMA]
parser: Input 'ID' with pending reduce 116
parser: Reduce 116 [joinop ::= COMMA|JOIN], go to state 263.
parser: ... then shift 'joinop', pending reduce 102
parser: Reduce 102 [stl_prefix ::= seltablist joinop], go to state 197.
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP oneselect multiselect_op SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'RP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 195.
parser: ... then shift 'oneselect', pending reduce 83
parser: Reduce 83 [selectnowith ::= selectnowith multiselect_op oneselect], go to state 39.
parser: ... then shift 'selectnowith', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 39.
parser: ... then shift 'select', go to state 485
parser: Shift 'RP', pending reduce 286
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP select RP]
parser: Input 'SELECT' with pending reduce 286
parser: Reduce 286 [wqlist ::= nm eidlist_opt AS LP select RP], go to state 181.
parser: ... then shift 'wqlist', go to state 142
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE wqlist SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 96
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE wqlist SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE wqlist SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE wqlist SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'AS' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Shift 'AS', go to state 242
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE wqlist SELECT distinct selcollist FROM stl_prefix nm dbnm AS]
parser: Input 'ID' in state 242
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE wqlist SELECT distinct selcollist FROM stl_prefix nm dbnm AS ID]
parser: Input 'SEMI' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 242.
parser: ... then shift 'nm', pending reduce 98
parser: Reduce 98 [as ::= AS nm], go to state 243.
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 142.
parser: ... then shift 'oneselect', go to state 258
parser: Reduce 81 [select ::= WITH RECURSIVE wqlist selectnowith], go to state 37.
parser: ... then shift 'select', pending reduce 77
parser: Reduce 77 [cmd ::= createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT c0, ntile(2) OVER (ORDER BY c0) FROM t0

;ALTER TABLE t0 RENAME c0 TO v0;;
;DROP TABLE t0;;
;
;CREATE TABLE main.over(following, preceding, t1);SELECT preceding, ntile(6) OVER (ORDER BY preceding) FROM over

;SELECT preceding, ntile(7) OVER (ORDER BY preceding) FROM over

;SELECT t1, ntile(8) OVER (ORDER BY t1) FROM over

;SELECT following, ntile(9) OVER (ORDER BY following) FROM over

;SELECT following, ntile(10) OVER (ORDER BY following) FROM over

;SELECT following, ntile(12) OVER (ORDER BY following) FROM over

;SELECT preceding, ntile(14) OVER (ORDER BY preceding) FROM over

;SELECT following, ntile(16) OVER (ORDER BY following) FROM over

;SELECT t1, ntile(17) OVER (ORDER BY t1) FROM over

;SELECT following, ntile(18) OVER (ORDER BY following) FROM over

;SELECT t1, ntile(19) OVER (ORDER BY t1) FROM over

;DROP TABLE IF EXISTS t4;;CREATE TABLE x(test001 INTEGER PRIMARY KEY, last_field TEXT, test002 INTEGER);;INSERT INTO over VALUES(2, 'preceding', 3);;INSERT INTO over VALUES(5, 'E', 5);;INSERT INTO over VALUES(6, 'F', 1);;INSERT INTO x VALUES(7, 'G', 1);;INSERT INTO x VALUES(8, 'H', 2);;INSERT INTO over VALUES(9, 'I', 10);SELECT preceding, lead(preceding, 2) OVER (ORDER BY preceding) FROM over

;SELECT t1, lead(t1, 3, 'abc') OVER (ORDER BY t1) FROM over

;;CREATE TABLE field1(test003 INTEGER PRIMARY KEY, field2 TEXT, test004 TEXT, field3 INTEGER);;INSERT INTO x VALUES(1, 'last_field', 'one',   5);;INSERT INTO x VALUES(2, 'test001', 'two',   4);;INSERT INTO x VALUES(3, 'test001', 'three', 3);;INSERT INTO x VALUES(4, 'test001', 'four',  2);;INSERT INTO x VALUES(5, 'test001', 'five',  1);SELECT t1, max(following) OVER (ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 2 PRECEDING)
  FROM over

;SELECT preceding, max(following) OVER (ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over

;SELECT last_field, max(test002) OVER (ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 0 PRECEDING)
  FROM x

;SELECT test002, max(test001) OVER (ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 1 FOLLOWING)
  FROM x

;DROP TABLE IF EXISTS ttt;;INSERT INTO field1 VALUES(2, 2, 2);;INSERT INTO x VALUES(5, 2, 3);;INSERT INTO x VALUES(7, 1, 3);;INSERT INTO field1 VALUES(8, 2, 4);;INSERT INTO field1 VALUES(9, 3, 5);;
;SELECT abs(max(t1) OVER (ORDER BY t1)) FROM over GROUP BY t1;;
;SELECT sum(preceding) OVER (
    ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING
  ) FROM over;;
;SELECT max(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002, last_field ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER ( ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY preceding, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
         sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY last_field

;SELECT sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'INTEGER' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 11.
parser: ... then shift 'term', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'ORDER' in state 32
parser: Shift 'ORDER', go to state 500
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER]
parser: Input 'BY' in state 500
parser: Shift 'BY', go to state 22
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY]
parser: Input 'ID' in state 22
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 22.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 22.
parser: ... then shift 'sortlist', go to state 184
parser: Reduce 297 [frame_opt ::=].
parser: ... then shift 'frame_opt', pending reduce 293
parser: Reduce 293 [window ::= ORDER BY sortlist frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'SEMI' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[ALTER TABLE t0 RENAME c0 TO v0;;
;DROP TABLE t0;;
;
;CREATE TABLE main.over(following, preceding, t1);SELECT preceding, ntile(6) OVER (ORDER BY preceding) FROM over

;SELECT preceding, ntile(7) OVER (ORDER BY preceding) FROM over

;SELECT t1, ntile(8) OVER (ORDER BY t1) FROM over

;SELECT following, ntile(9) OVER (ORDER BY following) FROM over

;SELECT following, ntile(10) OVER (ORDER BY following) FROM over

;SELECT following, ntile(12) OVER (ORDER BY following) FROM over

;SELECT preceding, ntile(14) OVER (ORDER BY preceding) FROM over

;SELECT following, ntile(16) OVER (ORDER BY following) FROM over

;SELECT t1, ntile(17) OVER (ORDER BY t1) FROM over

;SELECT following, ntile(18) OVER (ORDER BY following) FROM over

;SELECT t1, ntile(19) OVER (ORDER BY t1) FROM over

;DROP TABLE IF EXISTS t4;;CREATE TABLE x(test001 INTEGER PRIMARY KEY, last_field TEXT, test002 INTEGER);;INSERT INTO over VALUES(2, 'preceding', 3);;INSERT INTO over VALUES(5, 'E', 5);;INSERT INTO over VALUES(6, 'F', 1);;INSERT INTO x VALUES(7, 'G', 1);;INSERT INTO x VALUES(8, 'H', 2);;INSERT INTO over VALUES(9, 'I', 10);SELECT preceding, lead(preceding, 2) OVER (ORDER BY preceding) FROM over

;SELECT t1, lead(t1, 3, 'abc') OVER (ORDER BY t1) FROM over

;;CREATE TABLE field1(test003 INTEGER PRIMARY KEY, field2 TEXT, test004 TEXT, field3 INTEGER);;INSERT INTO x VALUES(1, 'last_field', 'one',   5);;INSERT INTO x VALUES(2, 'test001', 'two',   4);;INSERT INTO x VALUES(3, 'test001', 'three', 3);;INSERT INTO x VALUES(4, 'test001', 'four',  2);;INSERT INTO x VALUES(5, 'test001', 'five',  1);SELECT t1, max(following) OVER (ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 2 PRECEDING)
  FROM over

;SELECT preceding, max(following) OVER (ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over

;SELECT last_field, max(test002) OVER (ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 0 PRECEDING)
  FROM x

;SELECT test002, max(test001) OVER (ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 1 FOLLOWING)
  FROM x

;DROP TABLE IF EXISTS ttt;;INSERT INTO field1 VALUES(2, 2, 2);;INSERT INTO x VALUES(5, 2, 3);;INSERT INTO x VALUES(7, 1, 3);;INSERT INTO field1 VALUES(8, 2, 4);;INSERT INTO field1 VALUES(9, 3, 5);;
;SELECT abs(max(t1) OVER (ORDER BY t1)) FROM over GROUP BY t1;;
;SELECT sum(preceding) OVER (
    ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING
  ) FROM over;;
;SELECT max(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002, last_field ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER ( ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY preceding, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
         sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY last_field

;SELECT sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'ALTER' in state 0
parser: Shift 'ALTER', go to state 423
parser: Return. Stack=[ALTER]
parser: Input 'TABLE' in state 423
parser: Shift 'TABLE', go to state 133
parser: Return. Stack=[ALTER TABLE]
parser: Input 'ID' in state 133
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ALTER TABLE ID]
parser: Input 'RENAME' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 133.
parser: ... then shift 'nm', go to state 459
parser: FALLBACK RENAME => ID
parser: Reduce 110 [fullname ::= nm], go to state 133.
parser: ... then shift 'fullname', go to state 422
parser: Shift 'RENAME', go to state 269
parser: Return. Stack=[ALTER TABLE fullname RENAME]
parser: Input 'ID' in state 269
parser: Reduce 366 [kwcolumn_opt ::=].
parser: ... then shift 'kwcolumn_opt', go to state 211
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ALTER TABLE fullname RENAME kwcolumn_opt ID]
parser: Input 'TO' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 211.
parser: ... then shift 'nm', go to state 421
parser: Shift 'TO', go to state 210
parser: Return. Stack=[ALTER TABLE fullname RENAME kwcolumn_opt nm TO]
parser: Input 'ID' in state 210
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ALTER TABLE fullname RENAME kwcolumn_opt nm TO ID]
parser: Input 'SEMI' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 210.
parser: ... then shift 'nm', pending reduce 276
parser: Reduce 276 [cmd ::= ALTER TABLE fullname RENAME kwcolumn_opt nm TO nm], go to state 0.
parser: [[[UPDATE "main".sqlite_master SET sql = sqlite_rename_column(sql, type, name, 'main', 't0', 0, 'v0', 0, 0) WHERE name NOT LIKE 'sqlite_%' AND (type != 'index' OR tbl_name = 't0') AND sql NOT LIKE 'create virtual%']]]
parser: Input 'UPDATE' in state 0
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'UPDATE', go to state 299
parser: Return. Stack=[with UPDATE]
parser: Input 'ID' in state 299
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', go to state 165
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf ID]
parser: Input 'DOT' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 165.
parser: ... then shift 'nm', go to state 393
parser: Shift 'DOT', go to state 218
parser: Return. Stack=[with UPDATE orconf nm DOT]
parser: Input 'ID' in state 218
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf nm DOT ID]
parser: Input 'SET' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 218.
parser: ... then shift 'nm', go to state 429
parser: Reduce 113 [xfullname ::= nm DOT nm], go to state 165.
parser: ... then shift 'xfullname', go to state 271
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 428
parser: Shift 'SET', go to state 153
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET]
parser: Input 'ID' in state 153
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 153.
parser: ... then shift 'nm', go to state 442
parser: Shift 'EQ', go to state 84
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ]
parser: Input 'ID' in state 84
parser: Shift 'ID', go to state 416
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ ID LP distinct ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ ID LP distinct nexprlist COMMA]
parser: Input 'ID' in state 107
parser: Shift 'ID', go to state 416
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ ID LP distinct nexprlist COMMA ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 107.
parser: ... then shift 'expr', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ ID LP distinct nexprlist COMMA]
parser: Input 'ID' in state 107
parser: Shift 'ID', go to state 416
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ ID LP distinct nexprlist COMMA ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 107.
parser: ... then shift 'expr', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ ID LP distinct nexprlist COMMA]
parser: Input 'STRING' in state 107
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ ID LP distinct nexprlist COMMA STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ ID LP distinct nexprlist COMMA]
parser: Input 'STRING' in state 107
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ ID LP distinct nexprlist COMMA STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ ID LP distinct nexprlist COMMA]
parser: Input 'INTEGER' in state 107
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ ID LP distinct nexprlist COMMA INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ ID LP distinct nexprlist COMMA]
parser: Input 'STRING' in state 107
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ ID LP distinct nexprlist COMMA STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ ID LP distinct nexprlist COMMA]
parser: Input 'INTEGER' in state 107
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ ID LP distinct nexprlist COMMA INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ ID LP distinct nexprlist COMMA]
parser: Input 'INTEGER' in state 107
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ ID LP distinct nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ ID LP distinct exprlist RP]
parser: Input 'WHERE' in state 192
parser: Reduce 173 [expr ::= ID|INDEXED LP distinct exprlist RP], go to state 84.
parser: ... then shift 'expr', go to state 58
parser: Reduce 148 [setlist ::= nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 416
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE ID]
parser: Input 'NOT' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'NOT', go to state 384
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr NOT]
parser: Input 'LIKE_KW' in state 384
parser: Shift 'LIKE_KW', pending reduce 187
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr NOT LIKE_KW]
parser: Input 'STRING' with pending reduce 187
parser: Reduce 187 [likeop ::= NOT LIKE_KW|MATCH], go to state 63.
parser: ... then shift 'likeop', go to state 112
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr likeop STRING]
parser: Input 'AND' in state 537
parser: Reduce 168 [term ::= STRING], go to state 112.
parser: ... then shift 'term', go to state 124
parser: Reduce 188 [expr ::= expr likeop expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'AND', go to state 120
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr AND]
parser: Input 'LP' in state 120
parser: Shift 'LP', go to state 4
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr AND LP]
parser: Input 'ID' in state 4
parser: Shift 'ID', go to state 416
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr AND LP ID]
parser: Input 'NE' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 4.
parser: ... then shift 'expr', go to state 50
parser: Shift 'NE', go to state 117
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr AND LP expr NE]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr AND LP expr NE STRING]
parser: Input 'OR' in state 537
parser: Reduce 168 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 4.
parser: ... then shift 'expr', go to state 50
parser: Shift 'OR', go to state 119
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr AND LP expr OR]
parser: Input 'ID' in state 119
parser: Shift 'ID', go to state 416
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr AND LP expr OR ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 119.
parser: ... then shift 'expr', go to state 74
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr AND LP expr OR expr EQ]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr AND LP expr OR expr EQ STRING]
parser: Input 'RP' in state 537
parser: Reduce 168 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 119.
parser: ... then shift 'expr', go to state 74
parser: Reduce 180 [expr ::= expr OR expr], go to state 4.
parser: ... then shift 'expr', go to state 50
parser: Shift 'RP', pending reduce 162
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr AND LP expr RP]
parser: Input 'AND' with pending reduce 162
parser: Reduce 162 [expr ::= LP expr RP], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Reduce 179 [expr ::= expr AND expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'AND', go to state 120
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr AND]
parser: Input 'ID' in state 120
parser: Shift 'ID', go to state 416
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr AND ID]
parser: Input 'NOT' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Shift 'NOT', go to state 384
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr AND expr NOT]
parser: Input 'LIKE_KW' in state 384
parser: Shift 'LIKE_KW', pending reduce 187
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr AND expr NOT LIKE_KW]
parser: Input 'STRING' with pending reduce 187
parser: Reduce 187 [likeop ::= NOT LIKE_KW|MATCH], go to state 76.
parser: ... then shift 'likeop', go to state 112
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr AND expr likeop STRING]
parser: Input 'SEMI' in state 537
parser: Reduce 168 [term ::= STRING], go to state 112.
parser: ... then shift 'term', go to state 124
parser: Reduce 188 [expr ::= expr likeop expr], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Reduce 179 [expr ::= expr AND expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 270.
parser: ... then shift 'where_opt', pending reduce 145
parser: Reduce 145 [cmd ::= with UPDATE orconf xfullname indexed_opt SET setlist where_opt], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Input '$' with pending reduce 321
parser: Reduce 321 [ecmd ::= cmdx SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 317 [input ::= cmdlist], go to state 0.
parser: ... then shift 'input', pending reduce -2
parser: Accept!
parser: [[[UPDATE temp.sqlite_master SET sql = sqlite_rename_column(sql, type, name, 'main', 't0', 0, 'v0', 0, 1) WHERE type IN ('trigger', 'view')]]]
parser: Input 'UPDATE' in state 0
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'UPDATE', go to state 299
parser: Return. Stack=[with UPDATE]
parser: Input 'TEMP' in state 299
parser: FALLBACK TEMP => ID
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', go to state 165
parser: FALLBACK TEMP => ID
parser: Shift 'TEMP', pending reduce 331
parser: Return. Stack=[with UPDATE orconf TEMP]
parser: Input 'DOT' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 165.
parser: ... then shift 'nm', go to state 393
parser: Shift 'DOT', go to state 218
parser: Return. Stack=[with UPDATE orconf nm DOT]
parser: Input 'ID' in state 218
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf nm DOT ID]
parser: Input 'SET' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 218.
parser: ... then shift 'nm', go to state 429
parser: Reduce 113 [xfullname ::= nm DOT nm], go to state 165.
parser: ... then shift 'xfullname', go to state 271
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 428
parser: Shift 'SET', go to state 153
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET]
parser: Input 'ID' in state 153
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 153.
parser: ... then shift 'nm', go to state 442
parser: Shift 'EQ', go to state 84
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ]
parser: Input 'ID' in state 84
parser: Shift 'ID', go to state 416
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ ID LP distinct ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ ID LP distinct nexprlist COMMA]
parser: Input 'ID' in state 107
parser: Shift 'ID', go to state 416
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ ID LP distinct nexprlist COMMA ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 107.
parser: ... then shift 'expr', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ ID LP distinct nexprlist COMMA]
parser: Input 'ID' in state 107
parser: Shift 'ID', go to state 416
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ ID LP distinct nexprlist COMMA ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 107.
parser: ... then shift 'expr', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ ID LP distinct nexprlist COMMA]
parser: Input 'STRING' in state 107
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ ID LP distinct nexprlist COMMA STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ ID LP distinct nexprlist COMMA]
parser: Input 'STRING' in state 107
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ ID LP distinct nexprlist COMMA STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ ID LP distinct nexprlist COMMA]
parser: Input 'INTEGER' in state 107
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ ID LP distinct nexprlist COMMA INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ ID LP distinct nexprlist COMMA]
parser: Input 'STRING' in state 107
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ ID LP distinct nexprlist COMMA STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ ID LP distinct nexprlist COMMA]
parser: Input 'INTEGER' in state 107
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ ID LP distinct nexprlist COMMA INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ ID LP distinct nexprlist COMMA]
parser: Input 'INTEGER' in state 107
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ ID LP distinct nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ ID LP distinct exprlist RP]
parser: Input 'WHERE' in state 192
parser: Reduce 173 [expr ::= ID|INDEXED LP distinct exprlist RP], go to state 84.
parser: ... then shift 'expr', go to state 58
parser: Reduce 148 [setlist ::= nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 416
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE ID]
parser: Input 'IN' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'IN', pending reduce 200
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr IN]
parser: Input 'LP' with pending reduce 200
parser: Reduce 200 [in_op ::= IN], go to state 63.
parser: ... then shift 'in_op', go to state 209
parser: Shift 'LP', go to state 3
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr in_op LP]
parser: Input 'STRING' in state 3
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr in_op LP STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 3.
parser: ... then shift 'term', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 3.
parser: ... then shift 'nexprlist', go to state 517
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr in_op LP nexprlist COMMA]
parser: Input 'STRING' in state 107
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr in_op LP nexprlist COMMA STRING]
parser: Input 'RP' in state 537
parser: Reduce 168 [term ::= STRING], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 3.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 3.
parser: ... then shift 'exprlist', go to state 519
parser: Shift 'RP', pending reduce 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr in_op LP exprlist RP]
parser: Input 'SEMI' with pending reduce 202
parser: Reduce 202 [expr ::= expr in_op LP exprlist RP], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 270.
parser: ... then shift 'where_opt', pending reduce 145
parser: Reduce 145 [cmd ::= with UPDATE orconf xfullname indexed_opt SET setlist where_opt], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Input '$' with pending reduce 321
parser: Reduce 321 [ecmd ::= cmdx SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 317 [input ::= cmdlist], go to state 0.
parser: ... then shift 'input', pending reduce -2
parser: Accept!
parser: [[[SELECT 1 FROM "main".sqlite_master WHERE name NOT LIKE 'sqlite_%' AND sql NOT LIKE 'create virtual%' AND sqlite_rename_test('main', sql, type, name, 0)=NULL ]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'INTEGER' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt INTEGER]
parser: Input 'FROM' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 77.
parser: ... then shift 'term', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'DOT' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Shift 'DOT', go to state 245
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID' in state 245
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 245.
parser: ... then shift 'nm', pending reduce 109
parser: Reduce 109 [dbnm ::= DOT nm], go to state 349.
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[SELECT distinct selcollist from WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE ID]
parser: Input 'NOT' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'NOT', go to state 384
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr NOT]
parser: Input 'LIKE_KW' in state 384
parser: Shift 'LIKE_KW', pending reduce 187
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr NOT LIKE_KW]
parser: Input 'STRING' with pending reduce 187
parser: Reduce 187 [likeop ::= NOT LIKE_KW|MATCH], go to state 63.
parser: ... then shift 'likeop', go to state 112
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr likeop STRING]
parser: Input 'AND' in state 537
parser: Reduce 168 [term ::= STRING], go to state 112.
parser: ... then shift 'term', go to state 124
parser: Reduce 188 [expr ::= expr likeop expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'AND', go to state 120
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID' in state 120
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'NOT' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Shift 'NOT', go to state 384
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr NOT]
parser: Input 'LIKE_KW' in state 384
parser: Shift 'LIKE_KW', pending reduce 187
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr NOT LIKE_KW]
parser: Input 'STRING' with pending reduce 187
parser: Reduce 187 [likeop ::= NOT LIKE_KW|MATCH], go to state 76.
parser: ... then shift 'likeop', go to state 112
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr likeop STRING]
parser: Input 'AND' in state 537
parser: Reduce 168 [term ::= STRING], go to state 112.
parser: ... then shift 'term', go to state 124
parser: Reduce 188 [expr ::= expr likeop expr], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Reduce 179 [expr ::= expr AND expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'AND', go to state 120
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID' in state 120
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND ID LP]
parser: Input 'STRING' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND ID LP distinct STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 11.
parser: ... then shift 'term', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND ID LP distinct nexprlist COMMA]
parser: Input 'ID' in state 107
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND ID LP distinct nexprlist COMMA ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 107.
parser: ... then shift 'expr', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND ID LP distinct nexprlist COMMA]
parser: Input 'ID' in state 107
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND ID LP distinct nexprlist COMMA ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 107.
parser: ... then shift 'expr', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND ID LP distinct nexprlist COMMA]
parser: Input 'ID' in state 107
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND ID LP distinct nexprlist COMMA ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 107.
parser: ... then shift 'expr', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND ID LP distinct nexprlist COMMA]
parser: Input 'INTEGER' in state 107
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND ID LP distinct nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND ID LP distinct exprlist RP]
parser: Input 'EQ' in state 192
parser: Reduce 173 [expr ::= ID|INDEXED LP distinct exprlist RP], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr EQ]
parser: Input 'NULL' in state 117
parser: Shift 'NULL', pending reduce 167
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr EQ NULL]
parser: Input 'SEMI' with pending reduce 167
parser: Reduce 167 [term ::= NULL|FLOAT|BLOB], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Reduce 179 [expr ::= expr AND expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Input '$' with pending reduce 321
parser: Reduce 321 [ecmd ::= cmdx SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 317 [input ::= cmdlist], go to state 0.
parser: ... then shift 'input', pending reduce -2
parser: Accept!
parser: [[[SELECT 1 FROM temp.sqlite_master WHERE name NOT LIKE 'sqlite_%' AND sql NOT LIKE 'create virtual%' AND sqlite_rename_test('main', sql, type, name, 1)=NULL ]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'INTEGER' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt INTEGER]
parser: Input 'FROM' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 77.
parser: ... then shift 'term', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'TEMP' in state 197
parser: FALLBACK TEMP => ID
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: FALLBACK TEMP => ID
parser: Shift 'TEMP', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix TEMP]
parser: Input 'DOT' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Shift 'DOT', go to state 245
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID' in state 245
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 245.
parser: ... then shift 'nm', pending reduce 109
parser: Reduce 109 [dbnm ::= DOT nm], go to state 349.
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[SELECT distinct selcollist from WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE ID]
parser: Input 'NOT' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'NOT', go to state 384
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr NOT]
parser: Input 'LIKE_KW' in state 384
parser: Shift 'LIKE_KW', pending reduce 187
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr NOT LIKE_KW]
parser: Input 'STRING' with pending reduce 187
parser: Reduce 187 [likeop ::= NOT LIKE_KW|MATCH], go to state 63.
parser: ... then shift 'likeop', go to state 112
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr likeop STRING]
parser: Input 'AND' in state 537
parser: Reduce 168 [term ::= STRING], go to state 112.
parser: ... then shift 'term', go to state 124
parser: Reduce 188 [expr ::= expr likeop expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'AND', go to state 120
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID' in state 120
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'NOT' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Shift 'NOT', go to state 384
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr NOT]
parser: Input 'LIKE_KW' in state 384
parser: Shift 'LIKE_KW', pending reduce 187
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr NOT LIKE_KW]
parser: Input 'STRING' with pending reduce 187
parser: Reduce 187 [likeop ::= NOT LIKE_KW|MATCH], go to state 76.
parser: ... then shift 'likeop', go to state 112
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr likeop STRING]
parser: Input 'AND' in state 537
parser: Reduce 168 [term ::= STRING], go to state 112.
parser: ... then shift 'term', go to state 124
parser: Reduce 188 [expr ::= expr likeop expr], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Reduce 179 [expr ::= expr AND expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'AND', go to state 120
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID' in state 120
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND ID LP]
parser: Input 'STRING' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND ID LP distinct STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 11.
parser: ... then shift 'term', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND ID LP distinct nexprlist COMMA]
parser: Input 'ID' in state 107
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND ID LP distinct nexprlist COMMA ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 107.
parser: ... then shift 'expr', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND ID LP distinct nexprlist COMMA]
parser: Input 'ID' in state 107
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND ID LP distinct nexprlist COMMA ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 107.
parser: ... then shift 'expr', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND ID LP distinct nexprlist COMMA]
parser: Input 'ID' in state 107
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND ID LP distinct nexprlist COMMA ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 107.
parser: ... then shift 'expr', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND ID LP distinct nexprlist COMMA]
parser: Input 'INTEGER' in state 107
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND ID LP distinct nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND ID LP distinct exprlist RP]
parser: Input 'EQ' in state 192
parser: Reduce 173 [expr ::= ID|INDEXED LP distinct exprlist RP], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr EQ]
parser: Input 'NULL' in state 117
parser: Shift 'NULL', pending reduce 167
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr EQ NULL]
parser: Input 'SEMI' with pending reduce 167
parser: Reduce 167 [term ::= NULL|FLOAT|BLOB], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Reduce 179 [expr ::= expr AND expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Input '$' with pending reduce 321
parser: Reduce 321 [ecmd ::= cmdx SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 317 [input ::= cmdlist], go to state 0.
parser: ... then shift 'input', pending reduce -2
parser: Accept!
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[CREATE TABLE t0(c0 TEXT PRIMARY KEY)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 388
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP ID]
parser: Input 'ID' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 190
parser: Shift 'ID', pending reduce 335
parser: Return. Stack=[create_table LP nm ID]
parser: Input 'PRIMARY' with pending reduce 335
parser: Reduce 335 [typename ::= ID|STRING], go to state 190.
parser: ... then shift 'typename', go to state 390
parser: Reduce 334 [typetoken ::= typename], go to state 190.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 376
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 150
parser: Shift 'PRIMARY', go to state 475
parser: Return. Stack=[create_table LP columnname carglist PRIMARY]
parser: Input 'KEY' in state 475
parser: Shift 'KEY', go to state 280
parser: Return. Stack=[create_table LP columnname carglist PRIMARY KEY]
parser: Input 'RP' in state 280
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 333
parser: Reduce 68 [onconf ::=].
parser: ... then shift 'onconf', go to state 332
parser: Reduce 42 [autoinc ::=].
parser: ... then shift 'autoinc', pending reduce 36
parser: Reduce 36 [ccons ::= PRIMARY KEY sortorder onconf autoinc], go to state 150.
parser: ... then shift 'ccons', pending reduce 338
parser: Reduce 338 [carglist ::= carglist ccons], go to state 376.
parser: ... then shift 'carglist', go to state 150
parser: Reduce 330 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Reduce 60 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 538
parser: Shift 'RP', go to state 361
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 361
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: [[[UPDATE 'main'.sqlite_master SET type='table', name='t0', tbl_name='t0', rootpage=#2, sql='CREATE TABLE t0(c0 TEXT PRIMARY KEY)' WHERE rowid=#1]]]
parser: Input 'UPDATE' in state 0
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'UPDATE', go to state 299
parser: Return. Stack=[with UPDATE]
parser: Input 'STRING' in state 299
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', go to state 165
parser: Shift 'STRING', pending reduce 332
parser: Return. Stack=[with UPDATE orconf STRING]
parser: Input 'DOT' with pending reduce 332
parser: Reduce 332 [nm ::= STRING], go to state 165.
parser: ... then shift 'nm', go to state 393
parser: Shift 'DOT', go to state 218
parser: Return. Stack=[with UPDATE orconf nm DOT]
parser: Input 'ID' in state 218
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf nm DOT ID]
parser: Input 'SET' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 218.
parser: ... then shift 'nm', go to state 429
parser: Reduce 113 [xfullname ::= nm DOT nm], go to state 165.
parser: ... then shift 'xfullname', go to state 271
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 428
parser: Shift 'SET', go to state 153
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET]
parser: Input 'ID' in state 153
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 153.
parser: ... then shift 'nm', go to state 442
parser: Shift 'EQ', go to state 84
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ]
parser: Input 'STRING' in state 84
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 84.
parser: ... then shift 'term', go to state 58
parser: Reduce 148 [setlist ::= nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'VARIABLE' in state 86
parser: Shift 'VARIABLE', pending reduce 170
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ VARIABLE]
parser: Input 'COMMA' with pending reduce 170
parser: Reduce 170 [expr ::= VARIABLE], go to state 86.
parser: ... then shift 'expr', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'WHERE' in state 537
parser: Reduce 168 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 416
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr EQ]
parser: Input 'VARIABLE' in state 117
parser: Shift 'VARIABLE', pending reduce 170
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr EQ VARIABLE]
parser: Input 'SEMI' with pending reduce 170
parser: Reduce 170 [expr ::= VARIABLE], go to state 117.
parser: ... then shift 'expr', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 270.
parser: ... then shift 'where_opt', pending reduce 145
parser: Reduce 145 [cmd ::= with UPDATE orconf xfullname indexed_opt SET setlist where_opt], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Input '$' with pending reduce 321
parser: Reduce 321 [ecmd ::= cmdx SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 317 [input ::= cmdlist], go to state 0.
parser: ... then shift 'input', pending reduce -2
parser: Accept!
parser: ... then shift 'create_table_args', pending reduce 328
parser: Reduce 328 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[CREATE VIEW v0 AS 
    WITH RECURSIVE t3(v0,y,z) AS (
        SELECT c0,c0,NULL FROM t0
        UNION
        SELECT v0,y,NULL FROM t3, t0
    )
  SELECT * FROM t3 AS xyz]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'VIEW' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: FALLBACK VIEW => ID
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 388
parser: Shift 'VIEW', go to state 322
parser: Return. Stack=[createkw temp VIEW]
parser: Input 'ID' in state 322
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 228
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp VIEW ifnotexists ID]
parser: Input 'AS' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 228.
parser: ... then shift 'nm', go to state 321
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 320
parser: Reduce 222 [eidlist_opt ::=].
parser: ... then shift 'eidlist_opt', go to state 461
parser: Shift 'AS', go to state 37
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS]
parser: Input 'WITH' in state 37
parser: Shift 'WITH', go to state 160
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH]
parser: Input 'RECURSIVE' in state 160
parser: Shift 'RECURSIVE', go to state 181
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE]
parser: Input 'ID' in state 181
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE ID]
parser: Input 'LP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 181.
parser: ... then shift 'nm', go to state 337
parser: Shift 'LP', go to state 182
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm LP]
parser: Input 'ID' in state 182
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm LP ID]
parser: Input 'COMMA' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 182.
parser: ... then shift 'nm', go to state 338
parser: Reduce 226 [collate ::=].
parser: ... then shift 'collate', go to state 281
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 225
parser: Reduce 225 [eidlist ::= nm collate sortorder], go to state 182.
parser: ... then shift 'eidlist', go to state 408
parser: Shift 'COMMA', go to state 237
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm LP eidlist COMMA]
parser: Input 'ID' in state 237
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm LP eidlist COMMA ID]
parser: Input 'COMMA' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 237.
parser: ... then shift 'nm', go to state 339
parser: Reduce 226 [collate ::=].
parser: ... then shift 'collate', go to state 282
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 224
parser: Reduce 224 [eidlist ::= eidlist COMMA nm collate sortorder], go to state 182.
parser: ... then shift 'eidlist', go to state 408
parser: Shift 'COMMA', go to state 237
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm LP eidlist COMMA]
parser: Input 'ID' in state 237
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm LP eidlist COMMA ID]
parser: Input 'RP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 237.
parser: ... then shift 'nm', go to state 339
parser: Reduce 226 [collate ::=].
parser: ... then shift 'collate', go to state 282
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 224
parser: Reduce 224 [eidlist ::= eidlist COMMA nm collate sortorder], go to state 182.
parser: ... then shift 'eidlist', go to state 408
parser: Shift 'RP', pending reduce 223
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm LP eidlist RP]
parser: Input 'AS' with pending reduce 223
parser: Reduce 223 [eidlist_opt ::= LP eidlist RP], go to state 337.
parser: ... then shift 'eidlist_opt', go to state 487
parser: Shift 'AS', go to state 486
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS]
parser: Input 'LP' in state 486
parser: Shift 'LP', go to state 39
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP]
parser: Input 'SELECT' in state 39
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP SELECT distinct selcollist COMMA]
parser: Input 'NULL' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'NULL', pending reduce 167
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP SELECT distinct sclp scanpt NULL]
parser: Input 'FROM' with pending reduce 167
parser: Reduce 167 [term ::= NULL|FLOAT|BLOB], go to state 77.
parser: ... then shift 'term', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'UNION' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 39.
parser: ... then shift 'oneselect', go to state 264
parser: Shift 'UNION', go to state 533
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP oneselect UNION]
parser: Input 'SELECT' in state 533
parser: Reduce 84 [multiselect_op ::= UNION], go to state 264.
parser: ... then shift 'multiselect_op', go to state 195
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP oneselect multiselect_op SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP oneselect multiselect_op SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP oneselect multiselect_op SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP oneselect multiselect_op SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP oneselect multiselect_op SELECT distinct selcollist COMMA]
parser: Input 'NULL' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'NULL', pending reduce 167
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP oneselect multiselect_op SELECT distinct sclp scanpt NULL]
parser: Input 'FROM' with pending reduce 167
parser: Reduce 167 [term ::= NULL|FLOAT|BLOB], go to state 77.
parser: ... then shift 'term', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP oneselect multiselect_op SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP oneselect multiselect_op SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'COMMA' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Shift 'COMMA', pending reduce 116
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP oneselect multiselect_op SELECT distinct selcollist FROM seltablist COMMA]
parser: Input 'ID' with pending reduce 116
parser: Reduce 116 [joinop ::= COMMA|JOIN], go to state 263.
parser: ... then shift 'joinop', pending reduce 102
parser: Reduce 102 [stl_prefix ::= seltablist joinop], go to state 197.
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP oneselect multiselect_op SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'RP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 195.
parser: ... then shift 'oneselect', pending reduce 83
parser: Reduce 83 [selectnowith ::= selectnowith multiselect_op oneselect], go to state 39.
parser: ... then shift 'selectnowith', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 39.
parser: ... then shift 'select', go to state 485
parser: Shift 'RP', pending reduce 286
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP select RP]
parser: Input 'SELECT' with pending reduce 286
parser: Reduce 286 [wqlist ::= nm eidlist_opt AS LP select RP], go to state 181.
parser: ... then shift 'wqlist', go to state 142
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE wqlist SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 96
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE wqlist SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE wqlist SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE wqlist SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'AS' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Shift 'AS', go to state 242
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE wqlist SELECT distinct selcollist FROM stl_prefix nm dbnm AS]
parser: Input 'ID' in state 242
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE wqlist SELECT distinct selcollist FROM stl_prefix nm dbnm AS ID]
parser: Input 'SEMI' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 242.
parser: ... then shift 'nm', pending reduce 98
parser: Reduce 98 [as ::= AS nm], go to state 243.
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 142.
parser: ... then shift 'oneselect', go to state 258
parser: Reduce 81 [select ::= WITH RECURSIVE wqlist selectnowith], go to state 37.
parser: ... then shift 'select', pending reduce 77
parser: Reduce 77 [cmd ::= createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS select], go to state 0.
parser: [[[UPDATE 'main'.sqlite_master SET type='view', name='v0', tbl_name='v0', rootpage=#2, sql='CREATE VIEW v0 AS 
    WITH RECURSIVE t3(v0,y,z) AS (
        SELECT c0,c0,NULL FROM t0
        UNION
        SELECT v0,y,NULL FROM t3, t0
    )
  SELECT * FROM t3 AS xyz' WHERE rowid=#1]]]
parser: Input 'UPDATE' in state 0
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'UPDATE', go to state 299
parser: Return. Stack=[with UPDATE]
parser: Input 'STRING' in state 299
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', go to state 165
parser: Shift 'STRING', pending reduce 332
parser: Return. Stack=[with UPDATE orconf STRING]
parser: Input 'DOT' with pending reduce 332
parser: Reduce 332 [nm ::= STRING], go to state 165.
parser: ... then shift 'nm', go to state 393
parser: Shift 'DOT', go to state 218
parser: Return. Stack=[with UPDATE orconf nm DOT]
parser: Input 'ID' in state 218
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf nm DOT ID]
parser: Input 'SET' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 218.
parser: ... then shift 'nm', go to state 429
parser: Reduce 113 [xfullname ::= nm DOT nm], go to state 165.
parser: ... then shift 'xfullname', go to state 271
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 428
parser: Shift 'SET', go to state 153
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET]
parser: Input 'ID' in state 153
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 153.
parser: ... then shift 'nm', go to state 442
parser: Shift 'EQ', go to state 84
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ]
parser: Input 'STRING' in state 84
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 84.
parser: ... then shift 'term', go to state 58
parser: Reduce 148 [setlist ::= nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'VARIABLE' in state 86
parser: Shift 'VARIABLE', pending reduce 170
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ VARIABLE]
parser: Input 'COMMA' with pending reduce 170
parser: Reduce 170 [expr ::= VARIABLE], go to state 86.
parser: ... then shift 'expr', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'WHERE' in state 537
parser: Reduce 168 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 416
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr EQ]
parser: Input 'VARIABLE' in state 117
parser: Shift 'VARIABLE', pending reduce 170
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr EQ VARIABLE]
parser: Input 'SEMI' with pending reduce 170
parser: Reduce 170 [expr ::= VARIABLE], go to state 117.
parser: ... then shift 'expr', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 270.
parser: ... then shift 'where_opt', pending reduce 145
parser: Reduce 145 [cmd ::= with UPDATE orconf xfullname indexed_opt SET setlist where_opt], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Input '$' with pending reduce 321
parser: Reduce 321 [ecmd ::= cmdx SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 317 [input ::= cmdlist], go to state 0.
parser: ... then shift 'input', pending reduce -2
parser: Accept!
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[CREATE TABLE x(type text,name text,tbl_name text,rootpage int,sql text)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 388
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP ID]
parser: Input 'ID' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 190
parser: Shift 'ID', pending reduce 335
parser: Return. Stack=[create_table LP nm ID]
parser: Input 'COMMA' with pending reduce 335
parser: Reduce 335 [typename ::= ID|STRING], go to state 190.
parser: ... then shift 'typename', go to state 390
parser: Reduce 334 [typetoken ::= typename], go to state 190.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 376
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 150
parser: Reduce 330 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 190
parser: Shift 'ID', pending reduce 335
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'COMMA' with pending reduce 335
parser: Reduce 335 [typename ::= ID|STRING], go to state 190.
parser: ... then shift 'typename', go to state 390
parser: Reduce 334 [typetoken ::= typename], go to state 190.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 383
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 151
parser: Reduce 329 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 190
parser: Shift 'ID', pending reduce 335
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'COMMA' with pending reduce 335
parser: Reduce 335 [typename ::= ID|STRING], go to state 190.
parser: ... then shift 'typename', go to state 390
parser: Reduce 334 [typetoken ::= typename], go to state 190.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 383
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 151
parser: Reduce 329 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 190
parser: Shift 'ID', pending reduce 335
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'COMMA' with pending reduce 335
parser: Reduce 335 [typename ::= ID|STRING], go to state 190.
parser: ... then shift 'typename', go to state 390
parser: Reduce 334 [typetoken ::= typename], go to state 190.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 383
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 151
parser: Reduce 329 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 190
parser: Shift 'ID', pending reduce 335
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'RP' with pending reduce 335
parser: Reduce 335 [typename ::= ID|STRING], go to state 190.
parser: ... then shift 'typename', go to state 390
parser: Reduce 334 [typetoken ::= typename], go to state 190.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 383
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 151
parser: Reduce 329 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Reduce 60 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 538
parser: Shift 'RP', go to state 361
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 361
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 328
parser: Reduce 328 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'FROM' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'DOT' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Shift 'DOT', go to state 245
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID' in state 245
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'ORDER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 245.
parser: ... then shift 'nm', pending reduce 109
parser: Reduce 109 [dbnm ::= DOT nm], go to state 349.
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[CREATE TABLE t0(v0 TEXT PRIMARY KEY)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 388
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP ID]
parser: Input 'ID' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 190
parser: Shift 'ID', pending reduce 335
parser: Return. Stack=[create_table LP nm ID]
parser: Input 'PRIMARY' with pending reduce 335
parser: Reduce 335 [typename ::= ID|STRING], go to state 190.
parser: ... then shift 'typename', go to state 390
parser: Reduce 334 [typetoken ::= typename], go to state 190.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 376
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 150
parser: Shift 'PRIMARY', go to state 475
parser: Return. Stack=[create_table LP columnname carglist PRIMARY]
parser: Input 'KEY' in state 475
parser: Shift 'KEY', go to state 280
parser: Return. Stack=[create_table LP columnname carglist PRIMARY KEY]
parser: Input 'RP' in state 280
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 333
parser: Reduce 68 [onconf ::=].
parser: ... then shift 'onconf', go to state 332
parser: Reduce 42 [autoinc ::=].
parser: ... then shift 'autoinc', pending reduce 36
parser: Reduce 36 [ccons ::= PRIMARY KEY sortorder onconf autoinc], go to state 150.
parser: ... then shift 'ccons', pending reduce 338
parser: Reduce 338 [carglist ::= carglist ccons], go to state 376.
parser: ... then shift 'carglist', go to state 150
parser: Reduce 330 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Reduce 60 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 538
parser: Shift 'RP', go to state 361
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 361
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 328
parser: Reduce 328 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[CREATE VIEW v0 AS 
    WITH RECURSIVE t3(v0,y,z) AS (
        SELECT c0,c0,NULL FROM t0
        UNION
        SELECT v0,y,NULL FROM t3, t0
    )
  SELECT * FROM t3 AS xyz]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'VIEW' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: FALLBACK VIEW => ID
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 388
parser: Shift 'VIEW', go to state 322
parser: Return. Stack=[createkw temp VIEW]
parser: Input 'ID' in state 322
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 228
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp VIEW ifnotexists ID]
parser: Input 'AS' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 228.
parser: ... then shift 'nm', go to state 321
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 320
parser: Reduce 222 [eidlist_opt ::=].
parser: ... then shift 'eidlist_opt', go to state 461
parser: Shift 'AS', go to state 37
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS]
parser: Input 'WITH' in state 37
parser: Shift 'WITH', go to state 160
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH]
parser: Input 'RECURSIVE' in state 160
parser: Shift 'RECURSIVE', go to state 181
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE]
parser: Input 'ID' in state 181
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE ID]
parser: Input 'LP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 181.
parser: ... then shift 'nm', go to state 337
parser: Shift 'LP', go to state 182
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm LP]
parser: Input 'ID' in state 182
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm LP ID]
parser: Input 'COMMA' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 182.
parser: ... then shift 'nm', go to state 338
parser: Reduce 226 [collate ::=].
parser: ... then shift 'collate', go to state 281
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 225
parser: Reduce 225 [eidlist ::= nm collate sortorder], go to state 182.
parser: ... then shift 'eidlist', go to state 408
parser: Shift 'COMMA', go to state 237
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm LP eidlist COMMA]
parser: Input 'ID' in state 237
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm LP eidlist COMMA ID]
parser: Input 'COMMA' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 237.
parser: ... then shift 'nm', go to state 339
parser: Reduce 226 [collate ::=].
parser: ... then shift 'collate', go to state 282
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 224
parser: Reduce 224 [eidlist ::= eidlist COMMA nm collate sortorder], go to state 182.
parser: ... then shift 'eidlist', go to state 408
parser: Shift 'COMMA', go to state 237
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm LP eidlist COMMA]
parser: Input 'ID' in state 237
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm LP eidlist COMMA ID]
parser: Input 'RP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 237.
parser: ... then shift 'nm', go to state 339
parser: Reduce 226 [collate ::=].
parser: ... then shift 'collate', go to state 282
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 224
parser: Reduce 224 [eidlist ::= eidlist COMMA nm collate sortorder], go to state 182.
parser: ... then shift 'eidlist', go to state 408
parser: Shift 'RP', pending reduce 223
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm LP eidlist RP]
parser: Input 'AS' with pending reduce 223
parser: Reduce 223 [eidlist_opt ::= LP eidlist RP], go to state 337.
parser: ... then shift 'eidlist_opt', go to state 487
parser: Shift 'AS', go to state 486
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS]
parser: Input 'LP' in state 486
parser: Shift 'LP', go to state 39
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP]
parser: Input 'SELECT' in state 39
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP SELECT distinct selcollist COMMA]
parser: Input 'NULL' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'NULL', pending reduce 167
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP SELECT distinct sclp scanpt NULL]
parser: Input 'FROM' with pending reduce 167
parser: Reduce 167 [term ::= NULL|FLOAT|BLOB], go to state 77.
parser: ... then shift 'term', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'UNION' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 39.
parser: ... then shift 'oneselect', go to state 264
parser: Shift 'UNION', go to state 533
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP oneselect UNION]
parser: Input 'SELECT' in state 533
parser: Reduce 84 [multiselect_op ::= UNION], go to state 264.
parser: ... then shift 'multiselect_op', go to state 195
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP oneselect multiselect_op SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP oneselect multiselect_op SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP oneselect multiselect_op SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP oneselect multiselect_op SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP oneselect multiselect_op SELECT distinct selcollist COMMA]
parser: Input 'NULL' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'NULL', pending reduce 167
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP oneselect multiselect_op SELECT distinct sclp scanpt NULL]
parser: Input 'FROM' with pending reduce 167
parser: Reduce 167 [term ::= NULL|FLOAT|BLOB], go to state 77.
parser: ... then shift 'term', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP oneselect multiselect_op SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP oneselect multiselect_op SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'COMMA' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Shift 'COMMA', pending reduce 116
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP oneselect multiselect_op SELECT distinct selcollist FROM seltablist COMMA]
parser: Input 'ID' with pending reduce 116
parser: Reduce 116 [joinop ::= COMMA|JOIN], go to state 263.
parser: ... then shift 'joinop', pending reduce 102
parser: Reduce 102 [stl_prefix ::= seltablist joinop], go to state 197.
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP oneselect multiselect_op SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'RP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 195.
parser: ... then shift 'oneselect', pending reduce 83
parser: Reduce 83 [selectnowith ::= selectnowith multiselect_op oneselect], go to state 39.
parser: ... then shift 'selectnowith', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 39.
parser: ... then shift 'select', go to state 485
parser: Shift 'RP', pending reduce 286
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP select RP]
parser: Input 'SELECT' with pending reduce 286
parser: Reduce 286 [wqlist ::= nm eidlist_opt AS LP select RP], go to state 181.
parser: ... then shift 'wqlist', go to state 142
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE wqlist SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 96
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE wqlist SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE wqlist SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE wqlist SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'AS' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Shift 'AS', go to state 242
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE wqlist SELECT distinct selcollist FROM stl_prefix nm dbnm AS]
parser: Input 'ID' in state 242
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE wqlist SELECT distinct selcollist FROM stl_prefix nm dbnm AS ID]
parser: Input 'SEMI' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 242.
parser: ... then shift 'nm', pending reduce 98
parser: Reduce 98 [as ::= AS nm], go to state 243.
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 142.
parser: ... then shift 'oneselect', go to state 258
parser: Reduce 81 [select ::= WITH RECURSIVE wqlist selectnowith], go to state 37.
parser: ... then shift 'select', pending reduce 77
parser: Reduce 77 [cmd ::= createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[CREATE TABLE x(type text,name text,tbl_name text,rootpage int,sql text)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 388
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP ID]
parser: Input 'ID' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 190
parser: Shift 'ID', pending reduce 335
parser: Return. Stack=[create_table LP nm ID]
parser: Input 'COMMA' with pending reduce 335
parser: Reduce 335 [typename ::= ID|STRING], go to state 190.
parser: ... then shift 'typename', go to state 390
parser: Reduce 334 [typetoken ::= typename], go to state 190.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 376
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 150
parser: Reduce 330 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 190
parser: Shift 'ID', pending reduce 335
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'COMMA' with pending reduce 335
parser: Reduce 335 [typename ::= ID|STRING], go to state 190.
parser: ... then shift 'typename', go to state 390
parser: Reduce 334 [typetoken ::= typename], go to state 190.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 383
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 151
parser: Reduce 329 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 190
parser: Shift 'ID', pending reduce 335
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'COMMA' with pending reduce 335
parser: Reduce 335 [typename ::= ID|STRING], go to state 190.
parser: ... then shift 'typename', go to state 390
parser: Reduce 334 [typetoken ::= typename], go to state 190.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 383
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 151
parser: Reduce 329 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 190
parser: Shift 'ID', pending reduce 335
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'COMMA' with pending reduce 335
parser: Reduce 335 [typename ::= ID|STRING], go to state 190.
parser: ... then shift 'typename', go to state 390
parser: Reduce 334 [typetoken ::= typename], go to state 190.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 383
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 151
parser: Reduce 329 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 190
parser: Shift 'ID', pending reduce 335
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'RP' with pending reduce 335
parser: Reduce 335 [typename ::= ID|STRING], go to state 190.
parser: ... then shift 'typename', go to state 390
parser: Reduce 334 [typetoken ::= typename], go to state 190.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 383
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 151
parser: Reduce 329 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Reduce 60 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 538
parser: Shift 'RP', go to state 361
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 361
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 328
parser: Reduce 328 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT name, rootpage, sql FROM "temp".sqlite_temp_master ORDER BY rowid]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'FROM' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'DOT' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Shift 'DOT', go to state 245
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID' in state 245
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'ORDER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 245.
parser: ... then shift 'nm', pending reduce 109
parser: Reduce 109 [dbnm ::= DOT nm], go to state 349.
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[CREATE TABLE t0(v0 TEXT PRIMARY KEY)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 388
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP ID]
parser: Input 'ID' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 190
parser: Shift 'ID', pending reduce 335
parser: Return. Stack=[create_table LP nm ID]
parser: Input 'PRIMARY' with pending reduce 335
parser: Reduce 335 [typename ::= ID|STRING], go to state 190.
parser: ... then shift 'typename', go to state 390
parser: Reduce 334 [typetoken ::= typename], go to state 190.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 376
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 150
parser: Shift 'PRIMARY', go to state 475
parser: Return. Stack=[create_table LP columnname carglist PRIMARY]
parser: Input 'KEY' in state 475
parser: Shift 'KEY', go to state 280
parser: Return. Stack=[create_table LP columnname carglist PRIMARY KEY]
parser: Input 'RP' in state 280
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 333
parser: Reduce 68 [onconf ::=].
parser: ... then shift 'onconf', go to state 332
parser: Reduce 42 [autoinc ::=].
parser: ... then shift 'autoinc', pending reduce 36
parser: Reduce 36 [ccons ::= PRIMARY KEY sortorder onconf autoinc], go to state 150.
parser: ... then shift 'ccons', pending reduce 338
parser: Reduce 338 [carglist ::= carglist ccons], go to state 376.
parser: ... then shift 'carglist', go to state 150
parser: Reduce 330 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Reduce 60 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 538
parser: Shift 'RP', go to state 361
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 361
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: [[[UPDATE 'main'.sqlite_master SET type='table', name='t0', tbl_name='t0', rootpage=#2, sql='CREATE TABLE t0(v0 TEXT PRIMARY KEY)' WHERE rowid=#1]]]
parser: Input 'UPDATE' in state 0
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'UPDATE', go to state 299
parser: Return. Stack=[with UPDATE]
parser: Input 'STRING' in state 299
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', go to state 165
parser: Shift 'STRING', pending reduce 332
parser: Return. Stack=[with UPDATE orconf STRING]
parser: Input 'DOT' with pending reduce 332
parser: Reduce 332 [nm ::= STRING], go to state 165.
parser: ... then shift 'nm', go to state 393
parser: Shift 'DOT', go to state 218
parser: Return. Stack=[with UPDATE orconf nm DOT]
parser: Input 'ID' in state 218
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf nm DOT ID]
parser: Input 'SET' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 218.
parser: ... then shift 'nm', go to state 429
parser: Reduce 113 [xfullname ::= nm DOT nm], go to state 165.
parser: ... then shift 'xfullname', go to state 271
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 428
parser: Shift 'SET', go to state 153
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET]
parser: Input 'ID' in state 153
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 153.
parser: ... then shift 'nm', go to state 442
parser: Shift 'EQ', go to state 84
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ]
parser: Input 'STRING' in state 84
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 84.
parser: ... then shift 'term', go to state 58
parser: Reduce 148 [setlist ::= nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'VARIABLE' in state 86
parser: Shift 'VARIABLE', pending reduce 170
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ VARIABLE]
parser: Input 'COMMA' with pending reduce 170
parser: Reduce 170 [expr ::= VARIABLE], go to state 86.
parser: ... then shift 'expr', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'WHERE' in state 537
parser: Reduce 168 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 416
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr EQ]
parser: Input 'VARIABLE' in state 117
parser: Shift 'VARIABLE', pending reduce 170
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr EQ VARIABLE]
parser: Input 'SEMI' with pending reduce 170
parser: Reduce 170 [expr ::= VARIABLE], go to state 117.
parser: ... then shift 'expr', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 270.
parser: ... then shift 'where_opt', pending reduce 145
parser: Reduce 145 [cmd ::= with UPDATE orconf xfullname indexed_opt SET setlist where_opt], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Input '$' with pending reduce 321
parser: Reduce 321 [ecmd ::= cmdx SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 317 [input ::= cmdlist], go to state 0.
parser: ... then shift 'input', pending reduce -2
parser: Accept!
parser: ... then shift 'create_table_args', pending reduce 328
parser: Reduce 328 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[CREATE VIEW v0 AS 
    WITH RECURSIVE t3(v0,y,z) AS (
        SELECT c0,c0,NULL FROM t0
        UNION
        SELECT v0,y,NULL FROM t3, t0
    )
  SELECT * FROM t3 AS xyz]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'VIEW' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: FALLBACK VIEW => ID
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 388
parser: Shift 'VIEW', go to state 322
parser: Return. Stack=[createkw temp VIEW]
parser: Input 'ID' in state 322
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 228
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp VIEW ifnotexists ID]
parser: Input 'AS' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 228.
parser: ... then shift 'nm', go to state 321
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 320
parser: Reduce 222 [eidlist_opt ::=].
parser: ... then shift 'eidlist_opt', go to state 461
parser: Shift 'AS', go to state 37
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS]
parser: Input 'WITH' in state 37
parser: Shift 'WITH', go to state 160
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH]
parser: Input 'RECURSIVE' in state 160
parser: Shift 'RECURSIVE', go to state 181
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE]
parser: Input 'ID' in state 181
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE ID]
parser: Input 'LP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 181.
parser: ... then shift 'nm', go to state 337
parser: Shift 'LP', go to state 182
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm LP]
parser: Input 'ID' in state 182
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm LP ID]
parser: Input 'COMMA' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 182.
parser: ... then shift 'nm', go to state 338
parser: Reduce 226 [collate ::=].
parser: ... then shift 'collate', go to state 281
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 225
parser: Reduce 225 [eidlist ::= nm collate sortorder], go to state 182.
parser: ... then shift 'eidlist', go to state 408
parser: Shift 'COMMA', go to state 237
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm LP eidlist COMMA]
parser: Input 'ID' in state 237
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm LP eidlist COMMA ID]
parser: Input 'COMMA' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 237.
parser: ... then shift 'nm', go to state 339
parser: Reduce 226 [collate ::=].
parser: ... then shift 'collate', go to state 282
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 224
parser: Reduce 224 [eidlist ::= eidlist COMMA nm collate sortorder], go to state 182.
parser: ... then shift 'eidlist', go to state 408
parser: Shift 'COMMA', go to state 237
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm LP eidlist COMMA]
parser: Input 'ID' in state 237
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm LP eidlist COMMA ID]
parser: Input 'RP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 237.
parser: ... then shift 'nm', go to state 339
parser: Reduce 226 [collate ::=].
parser: ... then shift 'collate', go to state 282
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 224
parser: Reduce 224 [eidlist ::= eidlist COMMA nm collate sortorder], go to state 182.
parser: ... then shift 'eidlist', go to state 408
parser: Shift 'RP', pending reduce 223
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm LP eidlist RP]
parser: Input 'AS' with pending reduce 223
parser: Reduce 223 [eidlist_opt ::= LP eidlist RP], go to state 337.
parser: ... then shift 'eidlist_opt', go to state 487
parser: Shift 'AS', go to state 486
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS]
parser: Input 'LP' in state 486
parser: Shift 'LP', go to state 39
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP]
parser: Input 'SELECT' in state 39
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP SELECT distinct selcollist COMMA]
parser: Input 'NULL' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'NULL', pending reduce 167
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP SELECT distinct sclp scanpt NULL]
parser: Input 'FROM' with pending reduce 167
parser: Reduce 167 [term ::= NULL|FLOAT|BLOB], go to state 77.
parser: ... then shift 'term', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'UNION' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 39.
parser: ... then shift 'oneselect', go to state 264
parser: Shift 'UNION', go to state 533
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP oneselect UNION]
parser: Input 'SELECT' in state 533
parser: Reduce 84 [multiselect_op ::= UNION], go to state 264.
parser: ... then shift 'multiselect_op', go to state 195
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP oneselect multiselect_op SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP oneselect multiselect_op SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP oneselect multiselect_op SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP oneselect multiselect_op SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP oneselect multiselect_op SELECT distinct selcollist COMMA]
parser: Input 'NULL' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'NULL', pending reduce 167
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP oneselect multiselect_op SELECT distinct sclp scanpt NULL]
parser: Input 'FROM' with pending reduce 167
parser: Reduce 167 [term ::= NULL|FLOAT|BLOB], go to state 77.
parser: ... then shift 'term', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP oneselect multiselect_op SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP oneselect multiselect_op SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'COMMA' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Shift 'COMMA', pending reduce 116
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP oneselect multiselect_op SELECT distinct selcollist FROM seltablist COMMA]
parser: Input 'ID' with pending reduce 116
parser: Reduce 116 [joinop ::= COMMA|JOIN], go to state 263.
parser: ... then shift 'joinop', pending reduce 102
parser: Reduce 102 [stl_prefix ::= seltablist joinop], go to state 197.
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP oneselect multiselect_op SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'RP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 195.
parser: ... then shift 'oneselect', pending reduce 83
parser: Reduce 83 [selectnowith ::= selectnowith multiselect_op oneselect], go to state 39.
parser: ... then shift 'selectnowith', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 39.
parser: ... then shift 'select', go to state 485
parser: Shift 'RP', pending reduce 286
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP select RP]
parser: Input 'SELECT' with pending reduce 286
parser: Reduce 286 [wqlist ::= nm eidlist_opt AS LP select RP], go to state 181.
parser: ... then shift 'wqlist', go to state 142
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE wqlist SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 96
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE wqlist SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE wqlist SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE wqlist SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'AS' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Shift 'AS', go to state 242
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE wqlist SELECT distinct selcollist FROM stl_prefix nm dbnm AS]
parser: Input 'ID' in state 242
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE wqlist SELECT distinct selcollist FROM stl_prefix nm dbnm AS ID]
parser: Input 'SEMI' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 242.
parser: ... then shift 'nm', pending reduce 98
parser: Reduce 98 [as ::= AS nm], go to state 243.
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 142.
parser: ... then shift 'oneselect', go to state 258
parser: Reduce 81 [select ::= WITH RECURSIVE wqlist selectnowith], go to state 37.
parser: ... then shift 'select', pending reduce 77
parser: Reduce 77 [cmd ::= createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS select], go to state 0.
parser: [[[UPDATE 'main'.sqlite_master SET type='view', name='v0', tbl_name='v0', rootpage=#2, sql='CREATE VIEW v0 AS 
    WITH RECURSIVE t3(v0,y,z) AS (
        SELECT c0,c0,NULL FROM t0
        UNION
        SELECT v0,y,NULL FROM t3, t0
    )
  SELECT * FROM t3 AS xyz' WHERE rowid=#1]]]
parser: Input 'UPDATE' in state 0
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'UPDATE', go to state 299
parser: Return. Stack=[with UPDATE]
parser: Input 'STRING' in state 299
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', go to state 165
parser: Shift 'STRING', pending reduce 332
parser: Return. Stack=[with UPDATE orconf STRING]
parser: Input 'DOT' with pending reduce 332
parser: Reduce 332 [nm ::= STRING], go to state 165.
parser: ... then shift 'nm', go to state 393
parser: Shift 'DOT', go to state 218
parser: Return. Stack=[with UPDATE orconf nm DOT]
parser: Input 'ID' in state 218
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf nm DOT ID]
parser: Input 'SET' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 218.
parser: ... then shift 'nm', go to state 429
parser: Reduce 113 [xfullname ::= nm DOT nm], go to state 165.
parser: ... then shift 'xfullname', go to state 271
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 428
parser: Shift 'SET', go to state 153
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET]
parser: Input 'ID' in state 153
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 153.
parser: ... then shift 'nm', go to state 442
parser: Shift 'EQ', go to state 84
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ]
parser: Input 'STRING' in state 84
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 84.
parser: ... then shift 'term', go to state 58
parser: Reduce 148 [setlist ::= nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'VARIABLE' in state 86
parser: Shift 'VARIABLE', pending reduce 170
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ VARIABLE]
parser: Input 'COMMA' with pending reduce 170
parser: Reduce 170 [expr ::= VARIABLE], go to state 86.
parser: ... then shift 'expr', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'WHERE' in state 537
parser: Reduce 168 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 416
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr EQ]
parser: Input 'VARIABLE' in state 117
parser: Shift 'VARIABLE', pending reduce 170
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr EQ VARIABLE]
parser: Input 'SEMI' with pending reduce 170
parser: Reduce 170 [expr ::= VARIABLE], go to state 117.
parser: ... then shift 'expr', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 270.
parser: ... then shift 'where_opt', pending reduce 145
parser: Reduce 145 [cmd ::= with UPDATE orconf xfullname indexed_opt SET setlist where_opt], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Input '$' with pending reduce 321
parser: Reduce 321 [ecmd ::= cmdx SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 317 [input ::= cmdlist], go to state 0.
parser: ... then shift 'input', pending reduce -2
parser: Accept!
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[;
;DROP TABLE t0;;
;
;CREATE TABLE main.over(following, preceding, t1);SELECT preceding, ntile(6) OVER (ORDER BY preceding) FROM over

;SELECT preceding, ntile(7) OVER (ORDER BY preceding) FROM over

;SELECT t1, ntile(8) OVER (ORDER BY t1) FROM over

;SELECT following, ntile(9) OVER (ORDER BY following) FROM over

;SELECT following, ntile(10) OVER (ORDER BY following) FROM over

;SELECT following, ntile(12) OVER (ORDER BY following) FROM over

;SELECT preceding, ntile(14) OVER (ORDER BY preceding) FROM over

;SELECT following, ntile(16) OVER (ORDER BY following) FROM over

;SELECT t1, ntile(17) OVER (ORDER BY t1) FROM over

;SELECT following, ntile(18) OVER (ORDER BY following) FROM over

;SELECT t1, ntile(19) OVER (ORDER BY t1) FROM over

;DROP TABLE IF EXISTS t4;;CREATE TABLE x(test001 INTEGER PRIMARY KEY, last_field TEXT, test002 INTEGER);;INSERT INTO over VALUES(2, 'preceding', 3);;INSERT INTO over VALUES(5, 'E', 5);;INSERT INTO over VALUES(6, 'F', 1);;INSERT INTO x VALUES(7, 'G', 1);;INSERT INTO x VALUES(8, 'H', 2);;INSERT INTO over VALUES(9, 'I', 10);SELECT preceding, lead(preceding, 2) OVER (ORDER BY preceding) FROM over

;SELECT t1, lead(t1, 3, 'abc') OVER (ORDER BY t1) FROM over

;;CREATE TABLE field1(test003 INTEGER PRIMARY KEY, field2 TEXT, test004 TEXT, field3 INTEGER);;INSERT INTO x VALUES(1, 'last_field', 'one',   5);;INSERT INTO x VALUES(2, 'test001', 'two',   4);;INSERT INTO x VALUES(3, 'test001', 'three', 3);;INSERT INTO x VALUES(4, 'test001', 'four',  2);;INSERT INTO x VALUES(5, 'test001', 'five',  1);SELECT t1, max(following) OVER (ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 2 PRECEDING)
  FROM over

;SELECT preceding, max(following) OVER (ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over

;SELECT last_field, max(test002) OVER (ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 0 PRECEDING)
  FROM x

;SELECT test002, max(test001) OVER (ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 1 FOLLOWING)
  FROM x

;DROP TABLE IF EXISTS ttt;;INSERT INTO field1 VALUES(2, 2, 2);;INSERT INTO x VALUES(5, 2, 3);;INSERT INTO x VALUES(7, 1, 3);;INSERT INTO field1 VALUES(8, 2, 4);;INSERT INTO field1 VALUES(9, 3, 5);;
;SELECT abs(max(t1) OVER (ORDER BY t1)) FROM over GROUP BY t1;;
;SELECT sum(preceding) OVER (
    ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING
  ) FROM over;;
;SELECT max(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002, last_field ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER ( ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY preceding, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
         sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY last_field

;SELECT sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'SEMI' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[ecmd SEMI]
parser: Input 'DROP' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 1.
parser: ... then shift 'ecmd', pending reduce 318
parser: Reduce 318 [cmdlist ::= cmdlist ecmd], go to state 0.
parser: ... then shift 'cmdlist', go to state 1
parser: Shift 'DROP', go to state 385
parser: Return. Stack=[cmdlist DROP]
parser: Input 'TABLE' in state 385
parser: Shift 'TABLE', go to state 304
parser: Return. Stack=[cmdlist DROP TABLE]
parser: Input 'ID' in state 304
parser: Reduce 76 [ifexists ::=].
parser: ... then shift 'ifexists', go to state 171
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[cmdlist DROP TABLE ifexists ID]
parser: Input 'SEMI' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 171.
parser: ... then shift 'nm', go to state 459
parser: Reduce 110 [fullname ::= nm], go to state 171.
parser: ... then shift 'fullname', pending reduce 74
parser: Reduce 74 [cmd ::= DROP TABLE ifexists fullname], go to state 1.
parser: [[[DELETE FROM 'main'.sqlite_master WHERE tbl_name='t0' and type!='trigger']]]
parser: Input 'DELETE' in state 0
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'DELETE', go to state 430
parser: Return. Stack=[with DELETE]
parser: Input 'FROM' in state 430
parser: Shift 'FROM', go to state 166
parser: Return. Stack=[with DELETE FROM]
parser: Input 'STRING' in state 166
parser: Shift 'STRING', pending reduce 332
parser: Return. Stack=[with DELETE FROM STRING]
parser: Input 'DOT' with pending reduce 332
parser: Reduce 332 [nm ::= STRING], go to state 166.
parser: ... then shift 'nm', go to state 393
parser: Shift 'DOT', go to state 218
parser: Return. Stack=[with DELETE FROM nm DOT]
parser: Input 'ID' in state 218
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with DELETE FROM nm DOT ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 218.
parser: ... then shift 'nm', go to state 429
parser: Reduce 113 [xfullname ::= nm DOT nm], go to state 166.
parser: ... then shift 'xfullname', go to state 272
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 300
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[with DELETE FROM xfullname indexed_opt WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 416
parser: Return. Stack=[with DELETE FROM xfullname indexed_opt WHERE ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[with DELETE FROM xfullname indexed_opt WHERE expr EQ]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with DELETE FROM xfullname indexed_opt WHERE expr EQ STRING]
parser: Input 'AND' in state 537
parser: Reduce 168 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'AND', go to state 120
parser: Return. Stack=[with DELETE FROM xfullname indexed_opt WHERE expr AND]
parser: Input 'ID' in state 120
parser: Shift 'ID', go to state 416
parser: Return. Stack=[with DELETE FROM xfullname indexed_opt WHERE expr AND ID]
parser: Input 'NE' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Shift 'NE', go to state 117
parser: Return. Stack=[with DELETE FROM xfullname indexed_opt WHERE expr AND expr NE]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with DELETE FROM xfullname indexed_opt WHERE expr AND expr NE STRING]
parser: Input 'SEMI' in state 537
parser: Reduce 168 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Reduce 179 [expr ::= expr AND expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 300.
parser: ... then shift 'where_opt', pending reduce 142
parser: Reduce 142 [cmd ::= with DELETE FROM xfullname indexed_opt where_opt], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Input '$' with pending reduce 321
parser: Reduce 321 [ecmd ::= cmdx SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 317 [input ::= cmdlist], go to state 0.
parser: ... then shift 'input', pending reduce -2
parser: Accept!
parser: [[[UPDATE 'main'.sqlite_master SET rootpage=3 WHERE #2 AND rootpage=#2]]]
parser: Input 'UPDATE' in state 0
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'UPDATE', go to state 299
parser: Return. Stack=[with UPDATE]
parser: Input 'STRING' in state 299
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', go to state 165
parser: Shift 'STRING', pending reduce 332
parser: Return. Stack=[with UPDATE orconf STRING]
parser: Input 'DOT' with pending reduce 332
parser: Reduce 332 [nm ::= STRING], go to state 165.
parser: ... then shift 'nm', go to state 393
parser: Shift 'DOT', go to state 218
parser: Return. Stack=[with UPDATE orconf nm DOT]
parser: Input 'ID' in state 218
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf nm DOT ID]
parser: Input 'SET' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 218.
parser: ... then shift 'nm', go to state 429
parser: Reduce 113 [xfullname ::= nm DOT nm], go to state 165.
parser: ... then shift 'xfullname', go to state 271
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 428
parser: Shift 'SET', go to state 153
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET]
parser: Input 'ID' in state 153
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 153.
parser: ... then shift 'nm', go to state 442
parser: Shift 'EQ', go to state 84
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ]
parser: Input 'INTEGER' in state 84
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ INTEGER]
parser: Input 'WHERE' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 84.
parser: ... then shift 'term', go to state 58
parser: Reduce 148 [setlist ::= nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE]
parser: Input 'VARIABLE' in state 93
parser: Shift 'VARIABLE', pending reduce 170
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE VARIABLE]
parser: Input 'AND' with pending reduce 170
parser: Reduce 170 [expr ::= VARIABLE], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'AND', go to state 120
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr AND]
parser: Input 'ID' in state 120
parser: Shift 'ID', go to state 416
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr AND ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr AND expr EQ]
parser: Input 'VARIABLE' in state 117
parser: Shift 'VARIABLE', pending reduce 170
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr AND expr EQ VARIABLE]
parser: Input 'SEMI' with pending reduce 170
parser: Reduce 170 [expr ::= VARIABLE], go to state 117.
parser: ... then shift 'expr', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Reduce 179 [expr ::= expr AND expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 270.
parser: ... then shift 'where_opt', pending reduce 145
parser: Reduce 145 [cmd ::= with UPDATE orconf xfullname indexed_opt SET setlist where_opt], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Input '$' with pending reduce 321
parser: Reduce 321 [ecmd ::= cmdx SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 317 [input ::= cmdlist], go to state 0.
parser: ... then shift 'input', pending reduce -2
parser: Accept!
parser: [[[UPDATE 'main'.sqlite_master SET rootpage=2 WHERE #2 AND rootpage=#2]]]
parser: Input 'UPDATE' in state 0
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'UPDATE', go to state 299
parser: Return. Stack=[with UPDATE]
parser: Input 'STRING' in state 299
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', go to state 165
parser: Shift 'STRING', pending reduce 332
parser: Return. Stack=[with UPDATE orconf STRING]
parser: Input 'DOT' with pending reduce 332
parser: Reduce 332 [nm ::= STRING], go to state 165.
parser: ... then shift 'nm', go to state 393
parser: Shift 'DOT', go to state 218
parser: Return. Stack=[with UPDATE orconf nm DOT]
parser: Input 'ID' in state 218
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf nm DOT ID]
parser: Input 'SET' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 218.
parser: ... then shift 'nm', go to state 429
parser: Reduce 113 [xfullname ::= nm DOT nm], go to state 165.
parser: ... then shift 'xfullname', go to state 271
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 428
parser: Shift 'SET', go to state 153
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET]
parser: Input 'ID' in state 153
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 153.
parser: ... then shift 'nm', go to state 442
parser: Shift 'EQ', go to state 84
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ]
parser: Input 'INTEGER' in state 84
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ INTEGER]
parser: Input 'WHERE' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 84.
parser: ... then shift 'term', go to state 58
parser: Reduce 148 [setlist ::= nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE]
parser: Input 'VARIABLE' in state 93
parser: Shift 'VARIABLE', pending reduce 170
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE VARIABLE]
parser: Input 'AND' with pending reduce 170
parser: Reduce 170 [expr ::= VARIABLE], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'AND', go to state 120
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr AND]
parser: Input 'ID' in state 120
parser: Shift 'ID', go to state 416
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr AND ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr AND expr EQ]
parser: Input 'VARIABLE' in state 117
parser: Shift 'VARIABLE', pending reduce 170
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr AND expr EQ VARIABLE]
parser: Input 'SEMI' with pending reduce 170
parser: Reduce 170 [expr ::= VARIABLE], go to state 117.
parser: ... then shift 'expr', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Reduce 179 [expr ::= expr AND expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 270.
parser: ... then shift 'where_opt', pending reduce 145
parser: Reduce 145 [cmd ::= with UPDATE orconf xfullname indexed_opt SET setlist where_opt], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Input '$' with pending reduce 321
parser: Reduce 321 [ecmd ::= cmdx SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 317 [input ::= cmdlist], go to state 0.
parser: ... then shift 'input', pending reduce -2
parser: Accept!
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdlist cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping cmdlist
parser: [[[;
;DROP TABLE t0;]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'SEMI' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[ecmd SEMI]
parser: Input 'DROP' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 1.
parser: ... then shift 'ecmd', pending reduce 318
parser: Reduce 318 [cmdlist ::= cmdlist ecmd], go to state 0.
parser: ... then shift 'cmdlist', go to state 1
parser: Shift 'DROP', go to state 385
parser: Return. Stack=[cmdlist DROP]
parser: Input 'TABLE' in state 385
parser: Shift 'TABLE', go to state 304
parser: Return. Stack=[cmdlist DROP TABLE]
parser: Input 'ID' in state 304
parser: Reduce 76 [ifexists ::=].
parser: ... then shift 'ifexists', go to state 171
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[cmdlist DROP TABLE ifexists ID]
parser: Input 'SEMI' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 171.
parser: ... then shift 'nm', go to state 459
parser: Reduce 110 [fullname ::= nm], go to state 171.
parser: ... then shift 'fullname', pending reduce 74
parser: Reduce 74 [cmd ::= DROP TABLE ifexists fullname], go to state 1.
parser: [[[CREATE TABLE x(type text,name text,tbl_name text,rootpage int,sql text)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 388
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP ID]
parser: Input 'ID' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 190
parser: Shift 'ID', pending reduce 335
parser: Return. Stack=[create_table LP nm ID]
parser: Input 'COMMA' with pending reduce 335
parser: Reduce 335 [typename ::= ID|STRING], go to state 190.
parser: ... then shift 'typename', go to state 390
parser: Reduce 334 [typetoken ::= typename], go to state 190.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 376
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 150
parser: Reduce 330 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 190
parser: Shift 'ID', pending reduce 335
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'COMMA' with pending reduce 335
parser: Reduce 335 [typename ::= ID|STRING], go to state 190.
parser: ... then shift 'typename', go to state 390
parser: Reduce 334 [typetoken ::= typename], go to state 190.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 383
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 151
parser: Reduce 329 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 190
parser: Shift 'ID', pending reduce 335
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'COMMA' with pending reduce 335
parser: Reduce 335 [typename ::= ID|STRING], go to state 190.
parser: ... then shift 'typename', go to state 390
parser: Reduce 334 [typetoken ::= typename], go to state 190.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 383
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 151
parser: Reduce 329 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 190
parser: Shift 'ID', pending reduce 335
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'COMMA' with pending reduce 335
parser: Reduce 335 [typename ::= ID|STRING], go to state 190.
parser: ... then shift 'typename', go to state 390
parser: Reduce 334 [typetoken ::= typename], go to state 190.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 383
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 151
parser: Reduce 329 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 190
parser: Shift 'ID', pending reduce 335
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'RP' with pending reduce 335
parser: Reduce 335 [typename ::= ID|STRING], go to state 190.
parser: ... then shift 'typename', go to state 390
parser: Reduce 334 [typetoken ::= typename], go to state 190.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 383
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 151
parser: Reduce 329 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Reduce 60 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 538
parser: Shift 'RP', go to state 361
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 361
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 328
parser: Reduce 328 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'FROM' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'DOT' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Shift 'DOT', go to state 245
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID' in state 245
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'ORDER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 245.
parser: ... then shift 'nm', pending reduce 109
parser: Reduce 109 [dbnm ::= DOT nm], go to state 349.
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[CREATE TABLE t0(c0 TEXT PRIMARY KEY)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 388
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP ID]
parser: Input 'ID' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 190
parser: Shift 'ID', pending reduce 335
parser: Return. Stack=[create_table LP nm ID]
parser: Input 'PRIMARY' with pending reduce 335
parser: Reduce 335 [typename ::= ID|STRING], go to state 190.
parser: ... then shift 'typename', go to state 390
parser: Reduce 334 [typetoken ::= typename], go to state 190.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 376
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 150
parser: Shift 'PRIMARY', go to state 475
parser: Return. Stack=[create_table LP columnname carglist PRIMARY]
parser: Input 'KEY' in state 475
parser: Shift 'KEY', go to state 280
parser: Return. Stack=[create_table LP columnname carglist PRIMARY KEY]
parser: Input 'RP' in state 280
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 333
parser: Reduce 68 [onconf ::=].
parser: ... then shift 'onconf', go to state 332
parser: Reduce 42 [autoinc ::=].
parser: ... then shift 'autoinc', pending reduce 36
parser: Reduce 36 [ccons ::= PRIMARY KEY sortorder onconf autoinc], go to state 150.
parser: ... then shift 'ccons', pending reduce 338
parser: Reduce 338 [carglist ::= carglist ccons], go to state 376.
parser: ... then shift 'carglist', go to state 150
parser: Reduce 330 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Reduce 60 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 538
parser: Shift 'RP', go to state 361
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 361
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 328
parser: Reduce 328 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[CREATE VIEW v0 AS 
    WITH RECURSIVE t3(v0,y,z) AS (
        SELECT c0,c0,NULL FROM t0
        UNION
        SELECT v0,y,NULL FROM t3, t0
    )
  SELECT * FROM t3 AS xyz]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'VIEW' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: FALLBACK VIEW => ID
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 388
parser: Shift 'VIEW', go to state 322
parser: Return. Stack=[createkw temp VIEW]
parser: Input 'ID' in state 322
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 228
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp VIEW ifnotexists ID]
parser: Input 'AS' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 228.
parser: ... then shift 'nm', go to state 321
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 320
parser: Reduce 222 [eidlist_opt ::=].
parser: ... then shift 'eidlist_opt', go to state 461
parser: Shift 'AS', go to state 37
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS]
parser: Input 'WITH' in state 37
parser: Shift 'WITH', go to state 160
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH]
parser: Input 'RECURSIVE' in state 160
parser: Shift 'RECURSIVE', go to state 181
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE]
parser: Input 'ID' in state 181
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE ID]
parser: Input 'LP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 181.
parser: ... then shift 'nm', go to state 337
parser: Shift 'LP', go to state 182
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm LP]
parser: Input 'ID' in state 182
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm LP ID]
parser: Input 'COMMA' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 182.
parser: ... then shift 'nm', go to state 338
parser: Reduce 226 [collate ::=].
parser: ... then shift 'collate', go to state 281
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 225
parser: Reduce 225 [eidlist ::= nm collate sortorder], go to state 182.
parser: ... then shift 'eidlist', go to state 408
parser: Shift 'COMMA', go to state 237
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm LP eidlist COMMA]
parser: Input 'ID' in state 237
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm LP eidlist COMMA ID]
parser: Input 'COMMA' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 237.
parser: ... then shift 'nm', go to state 339
parser: Reduce 226 [collate ::=].
parser: ... then shift 'collate', go to state 282
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 224
parser: Reduce 224 [eidlist ::= eidlist COMMA nm collate sortorder], go to state 182.
parser: ... then shift 'eidlist', go to state 408
parser: Shift 'COMMA', go to state 237
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm LP eidlist COMMA]
parser: Input 'ID' in state 237
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm LP eidlist COMMA ID]
parser: Input 'RP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 237.
parser: ... then shift 'nm', go to state 339
parser: Reduce 226 [collate ::=].
parser: ... then shift 'collate', go to state 282
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 224
parser: Reduce 224 [eidlist ::= eidlist COMMA nm collate sortorder], go to state 182.
parser: ... then shift 'eidlist', go to state 408
parser: Shift 'RP', pending reduce 223
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm LP eidlist RP]
parser: Input 'AS' with pending reduce 223
parser: Reduce 223 [eidlist_opt ::= LP eidlist RP], go to state 337.
parser: ... then shift 'eidlist_opt', go to state 487
parser: Shift 'AS', go to state 486
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS]
parser: Input 'LP' in state 486
parser: Shift 'LP', go to state 39
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP]
parser: Input 'SELECT' in state 39
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP SELECT distinct selcollist COMMA]
parser: Input 'NULL' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'NULL', pending reduce 167
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP SELECT distinct sclp scanpt NULL]
parser: Input 'FROM' with pending reduce 167
parser: Reduce 167 [term ::= NULL|FLOAT|BLOB], go to state 77.
parser: ... then shift 'term', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'UNION' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 39.
parser: ... then shift 'oneselect', go to state 264
parser: Shift 'UNION', go to state 533
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP oneselect UNION]
parser: Input 'SELECT' in state 533
parser: Reduce 84 [multiselect_op ::= UNION], go to state 264.
parser: ... then shift 'multiselect_op', go to state 195
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP oneselect multiselect_op SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP oneselect multiselect_op SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP oneselect multiselect_op SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP oneselect multiselect_op SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP oneselect multiselect_op SELECT distinct selcollist COMMA]
parser: Input 'NULL' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'NULL', pending reduce 167
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP oneselect multiselect_op SELECT distinct sclp scanpt NULL]
parser: Input 'FROM' with pending reduce 167
parser: Reduce 167 [term ::= NULL|FLOAT|BLOB], go to state 77.
parser: ... then shift 'term', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP oneselect multiselect_op SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP oneselect multiselect_op SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'COMMA' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Shift 'COMMA', pending reduce 116
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP oneselect multiselect_op SELECT distinct selcollist FROM seltablist COMMA]
parser: Input 'ID' with pending reduce 116
parser: Reduce 116 [joinop ::= COMMA|JOIN], go to state 263.
parser: ... then shift 'joinop', pending reduce 102
parser: Reduce 102 [stl_prefix ::= seltablist joinop], go to state 197.
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP oneselect multiselect_op SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'RP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 195.
parser: ... then shift 'oneselect', pending reduce 83
parser: Reduce 83 [selectnowith ::= selectnowith multiselect_op oneselect], go to state 39.
parser: ... then shift 'selectnowith', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 39.
parser: ... then shift 'select', go to state 485
parser: Shift 'RP', pending reduce 286
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE nm eidlist_opt AS LP select RP]
parser: Input 'SELECT' with pending reduce 286
parser: Reduce 286 [wqlist ::= nm eidlist_opt AS LP select RP], go to state 181.
parser: ... then shift 'wqlist', go to state 142
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE wqlist SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 96
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE wqlist SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE wqlist SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE wqlist SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'AS' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Shift 'AS', go to state 242
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE wqlist SELECT distinct selcollist FROM stl_prefix nm dbnm AS]
parser: Input 'ID' in state 242
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS WITH RECURSIVE wqlist SELECT distinct selcollist FROM stl_prefix nm dbnm AS ID]
parser: Input 'SEMI' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 242.
parser: ... then shift 'nm', pending reduce 98
parser: Reduce 98 [as ::= AS nm], go to state 243.
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 142.
parser: ... then shift 'oneselect', go to state 258
parser: Reduce 81 [select ::= WITH RECURSIVE wqlist selectnowith], go to state 37.
parser: ... then shift 'select', pending reduce 77
parser: Reduce 77 [cmd ::= createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[CREATE TABLE x(type text,name text,tbl_name text,rootpage int,sql text)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 388
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP ID]
parser: Input 'ID' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 190
parser: Shift 'ID', pending reduce 335
parser: Return. Stack=[create_table LP nm ID]
parser: Input 'COMMA' with pending reduce 335
parser: Reduce 335 [typename ::= ID|STRING], go to state 190.
parser: ... then shift 'typename', go to state 390
parser: Reduce 334 [typetoken ::= typename], go to state 190.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 376
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 150
parser: Reduce 330 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 190
parser: Shift 'ID', pending reduce 335
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'COMMA' with pending reduce 335
parser: Reduce 335 [typename ::= ID|STRING], go to state 190.
parser: ... then shift 'typename', go to state 390
parser: Reduce 334 [typetoken ::= typename], go to state 190.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 383
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 151
parser: Reduce 329 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 190
parser: Shift 'ID', pending reduce 335
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'COMMA' with pending reduce 335
parser: Reduce 335 [typename ::= ID|STRING], go to state 190.
parser: ... then shift 'typename', go to state 390
parser: Reduce 334 [typetoken ::= typename], go to state 190.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 383
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 151
parser: Reduce 329 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 190
parser: Shift 'ID', pending reduce 335
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'COMMA' with pending reduce 335
parser: Reduce 335 [typename ::= ID|STRING], go to state 190.
parser: ... then shift 'typename', go to state 390
parser: Reduce 334 [typetoken ::= typename], go to state 190.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 383
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 151
parser: Reduce 329 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 190
parser: Shift 'ID', pending reduce 335
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'RP' with pending reduce 335
parser: Reduce 335 [typename ::= ID|STRING], go to state 190.
parser: ... then shift 'typename', go to state 390
parser: Reduce 334 [typetoken ::= typename], go to state 190.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 383
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 151
parser: Reduce 329 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Reduce 60 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 538
parser: Shift 'RP', go to state 361
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 361
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 328
parser: Reduce 328 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT name, rootpage, sql FROM "temp".sqlite_temp_master ORDER BY rowid]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'FROM' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'DOT' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Shift 'DOT', go to state 245
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID' in state 245
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'ORDER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 245.
parser: ... then shift 'nm', pending reduce 109
parser: Reduce 109 [dbnm ::= DOT nm], go to state 349.
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[DELETE FROM 'main'.sqlite_master WHERE tbl_name='t0' and type!='trigger']]]
parser: Input 'DELETE' in state 0
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'DELETE', go to state 430
parser: Return. Stack=[with DELETE]
parser: Input 'FROM' in state 430
parser: Shift 'FROM', go to state 166
parser: Return. Stack=[with DELETE FROM]
parser: Input 'STRING' in state 166
parser: Shift 'STRING', pending reduce 332
parser: Return. Stack=[with DELETE FROM STRING]
parser: Input 'DOT' with pending reduce 332
parser: Reduce 332 [nm ::= STRING], go to state 166.
parser: ... then shift 'nm', go to state 393
parser: Shift 'DOT', go to state 218
parser: Return. Stack=[with DELETE FROM nm DOT]
parser: Input 'ID' in state 218
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with DELETE FROM nm DOT ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 218.
parser: ... then shift 'nm', go to state 429
parser: Reduce 113 [xfullname ::= nm DOT nm], go to state 166.
parser: ... then shift 'xfullname', go to state 272
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 300
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[with DELETE FROM xfullname indexed_opt WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 416
parser: Return. Stack=[with DELETE FROM xfullname indexed_opt WHERE ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[with DELETE FROM xfullname indexed_opt WHERE expr EQ]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with DELETE FROM xfullname indexed_opt WHERE expr EQ STRING]
parser: Input 'AND' in state 537
parser: Reduce 168 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'AND', go to state 120
parser: Return. Stack=[with DELETE FROM xfullname indexed_opt WHERE expr AND]
parser: Input 'ID' in state 120
parser: Shift 'ID', go to state 416
parser: Return. Stack=[with DELETE FROM xfullname indexed_opt WHERE expr AND ID]
parser: Input 'NE' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Shift 'NE', go to state 117
parser: Return. Stack=[with DELETE FROM xfullname indexed_opt WHERE expr AND expr NE]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with DELETE FROM xfullname indexed_opt WHERE expr AND expr NE STRING]
parser: Input 'SEMI' in state 537
parser: Reduce 168 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Reduce 179 [expr ::= expr AND expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 300.
parser: ... then shift 'where_opt', pending reduce 142
parser: Reduce 142 [cmd ::= with DELETE FROM xfullname indexed_opt where_opt], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Input '$' with pending reduce 321
parser: Reduce 321 [ecmd ::= cmdx SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 317 [input ::= cmdlist], go to state 0.
parser: ... then shift 'input', pending reduce -2
parser: Accept!
parser: [[[UPDATE 'main'.sqlite_master SET rootpage=3 WHERE #2 AND rootpage=#2]]]
parser: Input 'UPDATE' in state 0
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'UPDATE', go to state 299
parser: Return. Stack=[with UPDATE]
parser: Input 'STRING' in state 299
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', go to state 165
parser: Shift 'STRING', pending reduce 332
parser: Return. Stack=[with UPDATE orconf STRING]
parser: Input 'DOT' with pending reduce 332
parser: Reduce 332 [nm ::= STRING], go to state 165.
parser: ... then shift 'nm', go to state 393
parser: Shift 'DOT', go to state 218
parser: Return. Stack=[with UPDATE orconf nm DOT]
parser: Input 'ID' in state 218
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf nm DOT ID]
parser: Input 'SET' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 218.
parser: ... then shift 'nm', go to state 429
parser: Reduce 113 [xfullname ::= nm DOT nm], go to state 165.
parser: ... then shift 'xfullname', go to state 271
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 428
parser: Shift 'SET', go to state 153
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET]
parser: Input 'ID' in state 153
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 153.
parser: ... then shift 'nm', go to state 442
parser: Shift 'EQ', go to state 84
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ]
parser: Input 'INTEGER' in state 84
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ INTEGER]
parser: Input 'WHERE' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 84.
parser: ... then shift 'term', go to state 58
parser: Reduce 148 [setlist ::= nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE]
parser: Input 'VARIABLE' in state 93
parser: Shift 'VARIABLE', pending reduce 170
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE VARIABLE]
parser: Input 'AND' with pending reduce 170
parser: Reduce 170 [expr ::= VARIABLE], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'AND', go to state 120
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr AND]
parser: Input 'ID' in state 120
parser: Shift 'ID', go to state 416
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr AND ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr AND expr EQ]
parser: Input 'VARIABLE' in state 117
parser: Shift 'VARIABLE', pending reduce 170
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr AND expr EQ VARIABLE]
parser: Input 'SEMI' with pending reduce 170
parser: Reduce 170 [expr ::= VARIABLE], go to state 117.
parser: ... then shift 'expr', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Reduce 179 [expr ::= expr AND expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 270.
parser: ... then shift 'where_opt', pending reduce 145
parser: Reduce 145 [cmd ::= with UPDATE orconf xfullname indexed_opt SET setlist where_opt], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Input '$' with pending reduce 321
parser: Reduce 321 [ecmd ::= cmdx SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 317 [input ::= cmdlist], go to state 0.
parser: ... then shift 'input', pending reduce -2
parser: Accept!
parser: [[[UPDATE 'main'.sqlite_master SET rootpage=2 WHERE #2 AND rootpage=#2]]]
parser: Input 'UPDATE' in state 0
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'UPDATE', go to state 299
parser: Return. Stack=[with UPDATE]
parser: Input 'STRING' in state 299
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', go to state 165
parser: Shift 'STRING', pending reduce 332
parser: Return. Stack=[with UPDATE orconf STRING]
parser: Input 'DOT' with pending reduce 332
parser: Reduce 332 [nm ::= STRING], go to state 165.
parser: ... then shift 'nm', go to state 393
parser: Shift 'DOT', go to state 218
parser: Return. Stack=[with UPDATE orconf nm DOT]
parser: Input 'ID' in state 218
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf nm DOT ID]
parser: Input 'SET' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 218.
parser: ... then shift 'nm', go to state 429
parser: Reduce 113 [xfullname ::= nm DOT nm], go to state 165.
parser: ... then shift 'xfullname', go to state 271
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 428
parser: Shift 'SET', go to state 153
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET]
parser: Input 'ID' in state 153
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 153.
parser: ... then shift 'nm', go to state 442
parser: Shift 'EQ', go to state 84
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ]
parser: Input 'INTEGER' in state 84
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ INTEGER]
parser: Input 'WHERE' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 84.
parser: ... then shift 'term', go to state 58
parser: Reduce 148 [setlist ::= nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE]
parser: Input 'VARIABLE' in state 93
parser: Shift 'VARIABLE', pending reduce 170
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE VARIABLE]
parser: Input 'AND' with pending reduce 170
parser: Reduce 170 [expr ::= VARIABLE], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'AND', go to state 120
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr AND]
parser: Input 'ID' in state 120
parser: Shift 'ID', go to state 416
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr AND ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr AND expr EQ]
parser: Input 'VARIABLE' in state 117
parser: Shift 'VARIABLE', pending reduce 170
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr AND expr EQ VARIABLE]
parser: Input 'SEMI' with pending reduce 170
parser: Reduce 170 [expr ::= VARIABLE], go to state 117.
parser: ... then shift 'expr', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Reduce 179 [expr ::= expr AND expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 270.
parser: ... then shift 'where_opt', pending reduce 145
parser: Reduce 145 [cmd ::= with UPDATE orconf xfullname indexed_opt SET setlist where_opt], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Input '$' with pending reduce 321
parser: Reduce 321 [ecmd ::= cmdx SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 317 [input ::= cmdlist], go to state 0.
parser: ... then shift 'input', pending reduce -2
parser: Accept!
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdlist cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping cmdlist
parser: [[[;
;
;CREATE TABLE main.over(following, preceding, t1);SELECT preceding, ntile(6) OVER (ORDER BY preceding) FROM over

;SELECT preceding, ntile(7) OVER (ORDER BY preceding) FROM over

;SELECT t1, ntile(8) OVER (ORDER BY t1) FROM over

;SELECT following, ntile(9) OVER (ORDER BY following) FROM over

;SELECT following, ntile(10) OVER (ORDER BY following) FROM over

;SELECT following, ntile(12) OVER (ORDER BY following) FROM over

;SELECT preceding, ntile(14) OVER (ORDER BY preceding) FROM over

;SELECT following, ntile(16) OVER (ORDER BY following) FROM over

;SELECT t1, ntile(17) OVER (ORDER BY t1) FROM over

;SELECT following, ntile(18) OVER (ORDER BY following) FROM over

;SELECT t1, ntile(19) OVER (ORDER BY t1) FROM over

;DROP TABLE IF EXISTS t4;;CREATE TABLE x(test001 INTEGER PRIMARY KEY, last_field TEXT, test002 INTEGER);;INSERT INTO over VALUES(2, 'preceding', 3);;INSERT INTO over VALUES(5, 'E', 5);;INSERT INTO over VALUES(6, 'F', 1);;INSERT INTO x VALUES(7, 'G', 1);;INSERT INTO x VALUES(8, 'H', 2);;INSERT INTO over VALUES(9, 'I', 10);SELECT preceding, lead(preceding, 2) OVER (ORDER BY preceding) FROM over

;SELECT t1, lead(t1, 3, 'abc') OVER (ORDER BY t1) FROM over

;;CREATE TABLE field1(test003 INTEGER PRIMARY KEY, field2 TEXT, test004 TEXT, field3 INTEGER);;INSERT INTO x VALUES(1, 'last_field', 'one',   5);;INSERT INTO x VALUES(2, 'test001', 'two',   4);;INSERT INTO x VALUES(3, 'test001', 'three', 3);;INSERT INTO x VALUES(4, 'test001', 'four',  2);;INSERT INTO x VALUES(5, 'test001', 'five',  1);SELECT t1, max(following) OVER (ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 2 PRECEDING)
  FROM over

;SELECT preceding, max(following) OVER (ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over

;SELECT last_field, max(test002) OVER (ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 0 PRECEDING)
  FROM x

;SELECT test002, max(test001) OVER (ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 1 FOLLOWING)
  FROM x

;DROP TABLE IF EXISTS ttt;;INSERT INTO field1 VALUES(2, 2, 2);;INSERT INTO x VALUES(5, 2, 3);;INSERT INTO x VALUES(7, 1, 3);;INSERT INTO field1 VALUES(8, 2, 4);;INSERT INTO field1 VALUES(9, 3, 5);;
;SELECT abs(max(t1) OVER (ORDER BY t1)) FROM over GROUP BY t1;;
;SELECT sum(preceding) OVER (
    ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING
  ) FROM over;;
;SELECT max(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002, last_field ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER ( ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY preceding, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
         sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY last_field

;SELECT sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'SEMI' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[ecmd SEMI]
parser: Input 'SEMI' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 1.
parser: ... then shift 'ecmd', pending reduce 318
parser: Reduce 318 [cmdlist ::= cmdlist ecmd], go to state 0.
parser: ... then shift 'cmdlist', go to state 1
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[cmdlist SEMI]
parser: Input 'CREATE' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 1.
parser: ... then shift 'ecmd', pending reduce 318
parser: Reduce 318 [cmdlist ::= cmdlist ecmd], go to state 0.
parser: ... then shift 'cmdlist', go to state 1
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[cmdlist CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 1.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 388
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[cmdlist createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[cmdlist createkw temp TABLE ifnotexists ID]
parser: Input 'DOT' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Shift 'DOT', go to state 245
parser: Return. Stack=[cmdlist createkw temp TABLE ifnotexists nm DOT]
parser: Input 'ID' in state 245
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[cmdlist createkw temp TABLE ifnotexists nm DOT ID]
parser: Input 'LP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 245.
parser: ... then shift 'nm', pending reduce 109
parser: Reduce 109 [dbnm ::= DOT nm], go to state 323.
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 1.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[cmdlist create_table LP]
parser: Input 'FOLLOWING' in state 139
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', pending reduce 331
parser: Return. Stack=[cmdlist create_table LP FOLLOWING]
parser: Input 'COMMA' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 190
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 376
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 150
parser: Reduce 330 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[cmdlist create_table LP columnlist COMMA]
parser: Input 'PRECEDING' in state 34
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', pending reduce 331
parser: Return. Stack=[cmdlist create_table LP columnlist COMMA PRECEDING]
parser: Input 'COMMA' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 190
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 383
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 151
parser: Reduce 329 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[cmdlist create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[cmdlist create_table LP columnlist COMMA ID]
parser: Input 'RP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 190
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 383
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 151
parser: Reduce 329 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Reduce 60 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 538
parser: Shift 'RP', go to state 361
parser: Return. Stack=[cmdlist create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 361
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: [[[UPDATE 'main'.sqlite_master SET type='table', name='over', tbl_name='over', rootpage=#2, sql='CREATE TABLE over(following, preceding, t1)' WHERE rowid=#1]]]
parser: Input 'UPDATE' in state 0
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'UPDATE', go to state 299
parser: Return. Stack=[with UPDATE]
parser: Input 'STRING' in state 299
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', go to state 165
parser: Shift 'STRING', pending reduce 332
parser: Return. Stack=[with UPDATE orconf STRING]
parser: Input 'DOT' with pending reduce 332
parser: Reduce 332 [nm ::= STRING], go to state 165.
parser: ... then shift 'nm', go to state 393
parser: Shift 'DOT', go to state 218
parser: Return. Stack=[with UPDATE orconf nm DOT]
parser: Input 'ID' in state 218
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf nm DOT ID]
parser: Input 'SET' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 218.
parser: ... then shift 'nm', go to state 429
parser: Reduce 113 [xfullname ::= nm DOT nm], go to state 165.
parser: ... then shift 'xfullname', go to state 271
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 428
parser: Shift 'SET', go to state 153
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET]
parser: Input 'ID' in state 153
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 153.
parser: ... then shift 'nm', go to state 442
parser: Shift 'EQ', go to state 84
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ]
parser: Input 'STRING' in state 84
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 84.
parser: ... then shift 'term', go to state 58
parser: Reduce 148 [setlist ::= nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'VARIABLE' in state 86
parser: Shift 'VARIABLE', pending reduce 170
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ VARIABLE]
parser: Input 'COMMA' with pending reduce 170
parser: Reduce 170 [expr ::= VARIABLE], go to state 86.
parser: ... then shift 'expr', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'WHERE' in state 537
parser: Reduce 168 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 416
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr EQ]
parser: Input 'VARIABLE' in state 117
parser: Shift 'VARIABLE', pending reduce 170
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr EQ VARIABLE]
parser: Input 'SEMI' with pending reduce 170
parser: Reduce 170 [expr ::= VARIABLE], go to state 117.
parser: ... then shift 'expr', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 270.
parser: ... then shift 'where_opt', pending reduce 145
parser: Reduce 145 [cmd ::= with UPDATE orconf xfullname indexed_opt SET setlist where_opt], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Input '$' with pending reduce 321
parser: Reduce 321 [ecmd ::= cmdx SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 317 [input ::= cmdlist], go to state 0.
parser: ... then shift 'input', pending reduce -2
parser: Accept!
parser: ... then shift 'create_table_args', pending reduce 328
parser: Reduce 328 [cmd ::= create_table create_table_args], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdlist cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping cmdlist
parser: [[[SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='over' AND type!='trigger' ORDER BY rowid]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'FROM' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'STRING' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'STRING', pending reduce 332
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix STRING]
parser: Input 'DOT' with pending reduce 332
parser: Reduce 332 [nm ::= STRING], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Shift 'DOT', go to state 245
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID' in state 245
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 245.
parser: ... then shift 'nm', pending reduce 109
parser: Reduce 109 [dbnm ::= DOT nm], go to state 349.
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[SELECT distinct selcollist from WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND' in state 537
parser: Reduce 168 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'AND', go to state 120
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID' in state 120
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'NE' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Shift 'NE', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr NE]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr NE STRING]
parser: Input 'ORDER' in state 537
parser: Reduce 168 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Reduce 179 [expr ::= expr AND expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[CREATE TABLE over(following, preceding, t1)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 388
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'FOLLOWING' in state 139
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', pending reduce 331
parser: Return. Stack=[create_table LP FOLLOWING]
parser: Input 'COMMA' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 190
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 376
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 150
parser: Reduce 330 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'PRECEDING' in state 34
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', pending reduce 331
parser: Return. Stack=[create_table LP columnlist COMMA PRECEDING]
parser: Input 'COMMA' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 190
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 383
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 151
parser: Reduce 329 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'RP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 190
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 383
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 151
parser: Reduce 329 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Reduce 60 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 538
parser: Shift 'RP', go to state 361
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 361
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 328
parser: Reduce 328 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT preceding, ntile(6) OVER (ORDER BY preceding) FROM over

;SELECT preceding, ntile(7) OVER (ORDER BY preceding) FROM over

;SELECT t1, ntile(8) OVER (ORDER BY t1) FROM over

;SELECT following, ntile(9) OVER (ORDER BY following) FROM over

;SELECT following, ntile(10) OVER (ORDER BY following) FROM over

;SELECT following, ntile(12) OVER (ORDER BY following) FROM over

;SELECT preceding, ntile(14) OVER (ORDER BY preceding) FROM over

;SELECT following, ntile(16) OVER (ORDER BY following) FROM over

;SELECT t1, ntile(17) OVER (ORDER BY t1) FROM over

;SELECT following, ntile(18) OVER (ORDER BY following) FROM over

;SELECT t1, ntile(19) OVER (ORDER BY t1) FROM over

;DROP TABLE IF EXISTS t4;;CREATE TABLE x(test001 INTEGER PRIMARY KEY, last_field TEXT, test002 INTEGER);;INSERT INTO over VALUES(2, 'preceding', 3);;INSERT INTO over VALUES(5, 'E', 5);;INSERT INTO over VALUES(6, 'F', 1);;INSERT INTO x VALUES(7, 'G', 1);;INSERT INTO x VALUES(8, 'H', 2);;INSERT INTO over VALUES(9, 'I', 10);SELECT preceding, lead(preceding, 2) OVER (ORDER BY preceding) FROM over

;SELECT t1, lead(t1, 3, 'abc') OVER (ORDER BY t1) FROM over

;;CREATE TABLE field1(test003 INTEGER PRIMARY KEY, field2 TEXT, test004 TEXT, field3 INTEGER);;INSERT INTO x VALUES(1, 'last_field', 'one',   5);;INSERT INTO x VALUES(2, 'test001', 'two',   4);;INSERT INTO x VALUES(3, 'test001', 'three', 3);;INSERT INTO x VALUES(4, 'test001', 'four',  2);;INSERT INTO x VALUES(5, 'test001', 'five',  1);SELECT t1, max(following) OVER (ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 2 PRECEDING)
  FROM over

;SELECT preceding, max(following) OVER (ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over

;SELECT last_field, max(test002) OVER (ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 0 PRECEDING)
  FROM x

;SELECT test002, max(test001) OVER (ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 1 FOLLOWING)
  FROM x

;DROP TABLE IF EXISTS ttt;;INSERT INTO field1 VALUES(2, 2, 2);;INSERT INTO x VALUES(5, 2, 3);;INSERT INTO x VALUES(7, 1, 3);;INSERT INTO field1 VALUES(8, 2, 4);;INSERT INTO field1 VALUES(9, 3, 5);;
;SELECT abs(max(t1) OVER (ORDER BY t1)) FROM over GROUP BY t1;;
;SELECT sum(preceding) OVER (
    ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING
  ) FROM over;;
;SELECT max(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002, last_field ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER ( ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY preceding, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
         sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY last_field

;SELECT sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'PRECEDING' in state 288
parser: FALLBACK PRECEDING => ID
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: FALLBACK PRECEDING => ID
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: FALLBACK PRECEDING => ID
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt PRECEDING]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'INTEGER' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 11.
parser: ... then shift 'term', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'ORDER' in state 32
parser: Shift 'ORDER', go to state 500
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER]
parser: Input 'BY' in state 500
parser: Shift 'BY', go to state 22
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY]
parser: Input 'PRECEDING' in state 22
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY PRECEDING]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 22.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 22.
parser: ... then shift 'sortlist', go to state 184
parser: Reduce 297 [frame_opt ::=].
parser: ... then shift 'frame_opt', pending reduce 293
parser: Reduce 293 [window ::= ORDER BY sortlist frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'SEMI' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT preceding, ntile(7) OVER (ORDER BY preceding) FROM over

;SELECT t1, ntile(8) OVER (ORDER BY t1) FROM over

;SELECT following, ntile(9) OVER (ORDER BY following) FROM over

;SELECT following, ntile(10) OVER (ORDER BY following) FROM over

;SELECT following, ntile(12) OVER (ORDER BY following) FROM over

;SELECT preceding, ntile(14) OVER (ORDER BY preceding) FROM over

;SELECT following, ntile(16) OVER (ORDER BY following) FROM over

;SELECT t1, ntile(17) OVER (ORDER BY t1) FROM over

;SELECT following, ntile(18) OVER (ORDER BY following) FROM over

;SELECT t1, ntile(19) OVER (ORDER BY t1) FROM over

;DROP TABLE IF EXISTS t4;;CREATE TABLE x(test001 INTEGER PRIMARY KEY, last_field TEXT, test002 INTEGER);;INSERT INTO over VALUES(2, 'preceding', 3);;INSERT INTO over VALUES(5, 'E', 5);;INSERT INTO over VALUES(6, 'F', 1);;INSERT INTO x VALUES(7, 'G', 1);;INSERT INTO x VALUES(8, 'H', 2);;INSERT INTO over VALUES(9, 'I', 10);SELECT preceding, lead(preceding, 2) OVER (ORDER BY preceding) FROM over

;SELECT t1, lead(t1, 3, 'abc') OVER (ORDER BY t1) FROM over

;;CREATE TABLE field1(test003 INTEGER PRIMARY KEY, field2 TEXT, test004 TEXT, field3 INTEGER);;INSERT INTO x VALUES(1, 'last_field', 'one',   5);;INSERT INTO x VALUES(2, 'test001', 'two',   4);;INSERT INTO x VALUES(3, 'test001', 'three', 3);;INSERT INTO x VALUES(4, 'test001', 'four',  2);;INSERT INTO x VALUES(5, 'test001', 'five',  1);SELECT t1, max(following) OVER (ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 2 PRECEDING)
  FROM over

;SELECT preceding, max(following) OVER (ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over

;SELECT last_field, max(test002) OVER (ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 0 PRECEDING)
  FROM x

;SELECT test002, max(test001) OVER (ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 1 FOLLOWING)
  FROM x

;DROP TABLE IF EXISTS ttt;;INSERT INTO field1 VALUES(2, 2, 2);;INSERT INTO x VALUES(5, 2, 3);;INSERT INTO x VALUES(7, 1, 3);;INSERT INTO field1 VALUES(8, 2, 4);;INSERT INTO field1 VALUES(9, 3, 5);;
;SELECT abs(max(t1) OVER (ORDER BY t1)) FROM over GROUP BY t1;;
;SELECT sum(preceding) OVER (
    ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING
  ) FROM over;;
;SELECT max(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002, last_field ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER ( ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY preceding, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
         sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY last_field

;SELECT sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'PRECEDING' in state 288
parser: FALLBACK PRECEDING => ID
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: FALLBACK PRECEDING => ID
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: FALLBACK PRECEDING => ID
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt PRECEDING]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'INTEGER' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 11.
parser: ... then shift 'term', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'ORDER' in state 32
parser: Shift 'ORDER', go to state 500
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER]
parser: Input 'BY' in state 500
parser: Shift 'BY', go to state 22
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY]
parser: Input 'PRECEDING' in state 22
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY PRECEDING]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 22.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 22.
parser: ... then shift 'sortlist', go to state 184
parser: Reduce 297 [frame_opt ::=].
parser: ... then shift 'frame_opt', pending reduce 293
parser: Reduce 293 [window ::= ORDER BY sortlist frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'SEMI' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT t1, ntile(8) OVER (ORDER BY t1) FROM over

;SELECT following, ntile(9) OVER (ORDER BY following) FROM over

;SELECT following, ntile(10) OVER (ORDER BY following) FROM over

;SELECT following, ntile(12) OVER (ORDER BY following) FROM over

;SELECT preceding, ntile(14) OVER (ORDER BY preceding) FROM over

;SELECT following, ntile(16) OVER (ORDER BY following) FROM over

;SELECT t1, ntile(17) OVER (ORDER BY t1) FROM over

;SELECT following, ntile(18) OVER (ORDER BY following) FROM over

;SELECT t1, ntile(19) OVER (ORDER BY t1) FROM over

;DROP TABLE IF EXISTS t4;;CREATE TABLE x(test001 INTEGER PRIMARY KEY, last_field TEXT, test002 INTEGER);;INSERT INTO over VALUES(2, 'preceding', 3);;INSERT INTO over VALUES(5, 'E', 5);;INSERT INTO over VALUES(6, 'F', 1);;INSERT INTO x VALUES(7, 'G', 1);;INSERT INTO x VALUES(8, 'H', 2);;INSERT INTO over VALUES(9, 'I', 10);SELECT preceding, lead(preceding, 2) OVER (ORDER BY preceding) FROM over

;SELECT t1, lead(t1, 3, 'abc') OVER (ORDER BY t1) FROM over

;;CREATE TABLE field1(test003 INTEGER PRIMARY KEY, field2 TEXT, test004 TEXT, field3 INTEGER);;INSERT INTO x VALUES(1, 'last_field', 'one',   5);;INSERT INTO x VALUES(2, 'test001', 'two',   4);;INSERT INTO x VALUES(3, 'test001', 'three', 3);;INSERT INTO x VALUES(4, 'test001', 'four',  2);;INSERT INTO x VALUES(5, 'test001', 'five',  1);SELECT t1, max(following) OVER (ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 2 PRECEDING)
  FROM over

;SELECT preceding, max(following) OVER (ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over

;SELECT last_field, max(test002) OVER (ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 0 PRECEDING)
  FROM x

;SELECT test002, max(test001) OVER (ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 1 FOLLOWING)
  FROM x

;DROP TABLE IF EXISTS ttt;;INSERT INTO field1 VALUES(2, 2, 2);;INSERT INTO x VALUES(5, 2, 3);;INSERT INTO x VALUES(7, 1, 3);;INSERT INTO field1 VALUES(8, 2, 4);;INSERT INTO field1 VALUES(9, 3, 5);;
;SELECT abs(max(t1) OVER (ORDER BY t1)) FROM over GROUP BY t1;;
;SELECT sum(preceding) OVER (
    ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING
  ) FROM over;;
;SELECT max(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002, last_field ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER ( ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY preceding, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
         sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY last_field

;SELECT sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'INTEGER' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 11.
parser: ... then shift 'term', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'ORDER' in state 32
parser: Shift 'ORDER', go to state 500
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER]
parser: Input 'BY' in state 500
parser: Shift 'BY', go to state 22
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY]
parser: Input 'ID' in state 22
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 22.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 22.
parser: ... then shift 'sortlist', go to state 184
parser: Reduce 297 [frame_opt ::=].
parser: ... then shift 'frame_opt', pending reduce 293
parser: Reduce 293 [window ::= ORDER BY sortlist frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'SEMI' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT following, ntile(9) OVER (ORDER BY following) FROM over

;SELECT following, ntile(10) OVER (ORDER BY following) FROM over

;SELECT following, ntile(12) OVER (ORDER BY following) FROM over

;SELECT preceding, ntile(14) OVER (ORDER BY preceding) FROM over

;SELECT following, ntile(16) OVER (ORDER BY following) FROM over

;SELECT t1, ntile(17) OVER (ORDER BY t1) FROM over

;SELECT following, ntile(18) OVER (ORDER BY following) FROM over

;SELECT t1, ntile(19) OVER (ORDER BY t1) FROM over

;DROP TABLE IF EXISTS t4;;CREATE TABLE x(test001 INTEGER PRIMARY KEY, last_field TEXT, test002 INTEGER);;INSERT INTO over VALUES(2, 'preceding', 3);;INSERT INTO over VALUES(5, 'E', 5);;INSERT INTO over VALUES(6, 'F', 1);;INSERT INTO x VALUES(7, 'G', 1);;INSERT INTO x VALUES(8, 'H', 2);;INSERT INTO over VALUES(9, 'I', 10);SELECT preceding, lead(preceding, 2) OVER (ORDER BY preceding) FROM over

;SELECT t1, lead(t1, 3, 'abc') OVER (ORDER BY t1) FROM over

;;CREATE TABLE field1(test003 INTEGER PRIMARY KEY, field2 TEXT, test004 TEXT, field3 INTEGER);;INSERT INTO x VALUES(1, 'last_field', 'one',   5);;INSERT INTO x VALUES(2, 'test001', 'two',   4);;INSERT INTO x VALUES(3, 'test001', 'three', 3);;INSERT INTO x VALUES(4, 'test001', 'four',  2);;INSERT INTO x VALUES(5, 'test001', 'five',  1);SELECT t1, max(following) OVER (ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 2 PRECEDING)
  FROM over

;SELECT preceding, max(following) OVER (ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over

;SELECT last_field, max(test002) OVER (ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 0 PRECEDING)
  FROM x

;SELECT test002, max(test001) OVER (ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 1 FOLLOWING)
  FROM x

;DROP TABLE IF EXISTS ttt;;INSERT INTO field1 VALUES(2, 2, 2);;INSERT INTO x VALUES(5, 2, 3);;INSERT INTO x VALUES(7, 1, 3);;INSERT INTO field1 VALUES(8, 2, 4);;INSERT INTO field1 VALUES(9, 3, 5);;
;SELECT abs(max(t1) OVER (ORDER BY t1)) FROM over GROUP BY t1;;
;SELECT sum(preceding) OVER (
    ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING
  ) FROM over;;
;SELECT max(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002, last_field ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER ( ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY preceding, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
         sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY last_field

;SELECT sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'FOLLOWING' in state 288
parser: FALLBACK FOLLOWING => ID
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: FALLBACK FOLLOWING => ID
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: FALLBACK FOLLOWING => ID
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt FOLLOWING]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'INTEGER' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 11.
parser: ... then shift 'term', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'ORDER' in state 32
parser: Shift 'ORDER', go to state 500
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER]
parser: Input 'BY' in state 500
parser: Shift 'BY', go to state 22
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY]
parser: Input 'FOLLOWING' in state 22
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY FOLLOWING]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 22.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 22.
parser: ... then shift 'sortlist', go to state 184
parser: Reduce 297 [frame_opt ::=].
parser: ... then shift 'frame_opt', pending reduce 293
parser: Reduce 293 [window ::= ORDER BY sortlist frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'SEMI' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT following, ntile(10) OVER (ORDER BY following) FROM over

;SELECT following, ntile(12) OVER (ORDER BY following) FROM over

;SELECT preceding, ntile(14) OVER (ORDER BY preceding) FROM over

;SELECT following, ntile(16) OVER (ORDER BY following) FROM over

;SELECT t1, ntile(17) OVER (ORDER BY t1) FROM over

;SELECT following, ntile(18) OVER (ORDER BY following) FROM over

;SELECT t1, ntile(19) OVER (ORDER BY t1) FROM over

;DROP TABLE IF EXISTS t4;;CREATE TABLE x(test001 INTEGER PRIMARY KEY, last_field TEXT, test002 INTEGER);;INSERT INTO over VALUES(2, 'preceding', 3);;INSERT INTO over VALUES(5, 'E', 5);;INSERT INTO over VALUES(6, 'F', 1);;INSERT INTO x VALUES(7, 'G', 1);;INSERT INTO x VALUES(8, 'H', 2);;INSERT INTO over VALUES(9, 'I', 10);SELECT preceding, lead(preceding, 2) OVER (ORDER BY preceding) FROM over

;SELECT t1, lead(t1, 3, 'abc') OVER (ORDER BY t1) FROM over

;;CREATE TABLE field1(test003 INTEGER PRIMARY KEY, field2 TEXT, test004 TEXT, field3 INTEGER);;INSERT INTO x VALUES(1, 'last_field', 'one',   5);;INSERT INTO x VALUES(2, 'test001', 'two',   4);;INSERT INTO x VALUES(3, 'test001', 'three', 3);;INSERT INTO x VALUES(4, 'test001', 'four',  2);;INSERT INTO x VALUES(5, 'test001', 'five',  1);SELECT t1, max(following) OVER (ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 2 PRECEDING)
  FROM over

;SELECT preceding, max(following) OVER (ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over

;SELECT last_field, max(test002) OVER (ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 0 PRECEDING)
  FROM x

;SELECT test002, max(test001) OVER (ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 1 FOLLOWING)
  FROM x

;DROP TABLE IF EXISTS ttt;;INSERT INTO field1 VALUES(2, 2, 2);;INSERT INTO x VALUES(5, 2, 3);;INSERT INTO x VALUES(7, 1, 3);;INSERT INTO field1 VALUES(8, 2, 4);;INSERT INTO field1 VALUES(9, 3, 5);;
;SELECT abs(max(t1) OVER (ORDER BY t1)) FROM over GROUP BY t1;;
;SELECT sum(preceding) OVER (
    ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING
  ) FROM over;;
;SELECT max(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002, last_field ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER ( ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY preceding, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
         sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY last_field

;SELECT sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'FOLLOWING' in state 288
parser: FALLBACK FOLLOWING => ID
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: FALLBACK FOLLOWING => ID
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: FALLBACK FOLLOWING => ID
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt FOLLOWING]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'INTEGER' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 11.
parser: ... then shift 'term', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'ORDER' in state 32
parser: Shift 'ORDER', go to state 500
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER]
parser: Input 'BY' in state 500
parser: Shift 'BY', go to state 22
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY]
parser: Input 'FOLLOWING' in state 22
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY FOLLOWING]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 22.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 22.
parser: ... then shift 'sortlist', go to state 184
parser: Reduce 297 [frame_opt ::=].
parser: ... then shift 'frame_opt', pending reduce 293
parser: Reduce 293 [window ::= ORDER BY sortlist frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'SEMI' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT following, ntile(12) OVER (ORDER BY following) FROM over

;SELECT preceding, ntile(14) OVER (ORDER BY preceding) FROM over

;SELECT following, ntile(16) OVER (ORDER BY following) FROM over

;SELECT t1, ntile(17) OVER (ORDER BY t1) FROM over

;SELECT following, ntile(18) OVER (ORDER BY following) FROM over

;SELECT t1, ntile(19) OVER (ORDER BY t1) FROM over

;DROP TABLE IF EXISTS t4;;CREATE TABLE x(test001 INTEGER PRIMARY KEY, last_field TEXT, test002 INTEGER);;INSERT INTO over VALUES(2, 'preceding', 3);;INSERT INTO over VALUES(5, 'E', 5);;INSERT INTO over VALUES(6, 'F', 1);;INSERT INTO x VALUES(7, 'G', 1);;INSERT INTO x VALUES(8, 'H', 2);;INSERT INTO over VALUES(9, 'I', 10);SELECT preceding, lead(preceding, 2) OVER (ORDER BY preceding) FROM over

;SELECT t1, lead(t1, 3, 'abc') OVER (ORDER BY t1) FROM over

;;CREATE TABLE field1(test003 INTEGER PRIMARY KEY, field2 TEXT, test004 TEXT, field3 INTEGER);;INSERT INTO x VALUES(1, 'last_field', 'one',   5);;INSERT INTO x VALUES(2, 'test001', 'two',   4);;INSERT INTO x VALUES(3, 'test001', 'three', 3);;INSERT INTO x VALUES(4, 'test001', 'four',  2);;INSERT INTO x VALUES(5, 'test001', 'five',  1);SELECT t1, max(following) OVER (ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 2 PRECEDING)
  FROM over

;SELECT preceding, max(following) OVER (ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over

;SELECT last_field, max(test002) OVER (ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 0 PRECEDING)
  FROM x

;SELECT test002, max(test001) OVER (ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 1 FOLLOWING)
  FROM x

;DROP TABLE IF EXISTS ttt;;INSERT INTO field1 VALUES(2, 2, 2);;INSERT INTO x VALUES(5, 2, 3);;INSERT INTO x VALUES(7, 1, 3);;INSERT INTO field1 VALUES(8, 2, 4);;INSERT INTO field1 VALUES(9, 3, 5);;
;SELECT abs(max(t1) OVER (ORDER BY t1)) FROM over GROUP BY t1;;
;SELECT sum(preceding) OVER (
    ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING
  ) FROM over;;
;SELECT max(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002, last_field ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER ( ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY preceding, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
         sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY last_field

;SELECT sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'FOLLOWING' in state 288
parser: FALLBACK FOLLOWING => ID
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: FALLBACK FOLLOWING => ID
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: FALLBACK FOLLOWING => ID
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt FOLLOWING]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'INTEGER' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 11.
parser: ... then shift 'term', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'ORDER' in state 32
parser: Shift 'ORDER', go to state 500
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER]
parser: Input 'BY' in state 500
parser: Shift 'BY', go to state 22
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY]
parser: Input 'FOLLOWING' in state 22
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY FOLLOWING]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 22.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 22.
parser: ... then shift 'sortlist', go to state 184
parser: Reduce 297 [frame_opt ::=].
parser: ... then shift 'frame_opt', pending reduce 293
parser: Reduce 293 [window ::= ORDER BY sortlist frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'SEMI' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT preceding, ntile(14) OVER (ORDER BY preceding) FROM over

;SELECT following, ntile(16) OVER (ORDER BY following) FROM over

;SELECT t1, ntile(17) OVER (ORDER BY t1) FROM over

;SELECT following, ntile(18) OVER (ORDER BY following) FROM over

;SELECT t1, ntile(19) OVER (ORDER BY t1) FROM over

;DROP TABLE IF EXISTS t4;;CREATE TABLE x(test001 INTEGER PRIMARY KEY, last_field TEXT, test002 INTEGER);;INSERT INTO over VALUES(2, 'preceding', 3);;INSERT INTO over VALUES(5, 'E', 5);;INSERT INTO over VALUES(6, 'F', 1);;INSERT INTO x VALUES(7, 'G', 1);;INSERT INTO x VALUES(8, 'H', 2);;INSERT INTO over VALUES(9, 'I', 10);SELECT preceding, lead(preceding, 2) OVER (ORDER BY preceding) FROM over

;SELECT t1, lead(t1, 3, 'abc') OVER (ORDER BY t1) FROM over

;;CREATE TABLE field1(test003 INTEGER PRIMARY KEY, field2 TEXT, test004 TEXT, field3 INTEGER);;INSERT INTO x VALUES(1, 'last_field', 'one',   5);;INSERT INTO x VALUES(2, 'test001', 'two',   4);;INSERT INTO x VALUES(3, 'test001', 'three', 3);;INSERT INTO x VALUES(4, 'test001', 'four',  2);;INSERT INTO x VALUES(5, 'test001', 'five',  1);SELECT t1, max(following) OVER (ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 2 PRECEDING)
  FROM over

;SELECT preceding, max(following) OVER (ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over

;SELECT last_field, max(test002) OVER (ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 0 PRECEDING)
  FROM x

;SELECT test002, max(test001) OVER (ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 1 FOLLOWING)
  FROM x

;DROP TABLE IF EXISTS ttt;;INSERT INTO field1 VALUES(2, 2, 2);;INSERT INTO x VALUES(5, 2, 3);;INSERT INTO x VALUES(7, 1, 3);;INSERT INTO field1 VALUES(8, 2, 4);;INSERT INTO field1 VALUES(9, 3, 5);;
;SELECT abs(max(t1) OVER (ORDER BY t1)) FROM over GROUP BY t1;;
;SELECT sum(preceding) OVER (
    ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING
  ) FROM over;;
;SELECT max(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002, last_field ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER ( ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY preceding, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
         sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY last_field

;SELECT sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'PRECEDING' in state 288
parser: FALLBACK PRECEDING => ID
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: FALLBACK PRECEDING => ID
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: FALLBACK PRECEDING => ID
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt PRECEDING]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'INTEGER' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 11.
parser: ... then shift 'term', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'ORDER' in state 32
parser: Shift 'ORDER', go to state 500
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER]
parser: Input 'BY' in state 500
parser: Shift 'BY', go to state 22
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY]
parser: Input 'PRECEDING' in state 22
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY PRECEDING]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 22.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 22.
parser: ... then shift 'sortlist', go to state 184
parser: Reduce 297 [frame_opt ::=].
parser: ... then shift 'frame_opt', pending reduce 293
parser: Reduce 293 [window ::= ORDER BY sortlist frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'SEMI' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT following, ntile(16) OVER (ORDER BY following) FROM over

;SELECT t1, ntile(17) OVER (ORDER BY t1) FROM over

;SELECT following, ntile(18) OVER (ORDER BY following) FROM over

;SELECT t1, ntile(19) OVER (ORDER BY t1) FROM over

;DROP TABLE IF EXISTS t4;;CREATE TABLE x(test001 INTEGER PRIMARY KEY, last_field TEXT, test002 INTEGER);;INSERT INTO over VALUES(2, 'preceding', 3);;INSERT INTO over VALUES(5, 'E', 5);;INSERT INTO over VALUES(6, 'F', 1);;INSERT INTO x VALUES(7, 'G', 1);;INSERT INTO x VALUES(8, 'H', 2);;INSERT INTO over VALUES(9, 'I', 10);SELECT preceding, lead(preceding, 2) OVER (ORDER BY preceding) FROM over

;SELECT t1, lead(t1, 3, 'abc') OVER (ORDER BY t1) FROM over

;;CREATE TABLE field1(test003 INTEGER PRIMARY KEY, field2 TEXT, test004 TEXT, field3 INTEGER);;INSERT INTO x VALUES(1, 'last_field', 'one',   5);;INSERT INTO x VALUES(2, 'test001', 'two',   4);;INSERT INTO x VALUES(3, 'test001', 'three', 3);;INSERT INTO x VALUES(4, 'test001', 'four',  2);;INSERT INTO x VALUES(5, 'test001', 'five',  1);SELECT t1, max(following) OVER (ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 2 PRECEDING)
  FROM over

;SELECT preceding, max(following) OVER (ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over

;SELECT last_field, max(test002) OVER (ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 0 PRECEDING)
  FROM x

;SELECT test002, max(test001) OVER (ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 1 FOLLOWING)
  FROM x

;DROP TABLE IF EXISTS ttt;;INSERT INTO field1 VALUES(2, 2, 2);;INSERT INTO x VALUES(5, 2, 3);;INSERT INTO x VALUES(7, 1, 3);;INSERT INTO field1 VALUES(8, 2, 4);;INSERT INTO field1 VALUES(9, 3, 5);;
;SELECT abs(max(t1) OVER (ORDER BY t1)) FROM over GROUP BY t1;;
;SELECT sum(preceding) OVER (
    ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING
  ) FROM over;;
;SELECT max(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002, last_field ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER ( ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY preceding, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
         sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY last_field

;SELECT sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'FOLLOWING' in state 288
parser: FALLBACK FOLLOWING => ID
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: FALLBACK FOLLOWING => ID
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: FALLBACK FOLLOWING => ID
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt FOLLOWING]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'INTEGER' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 11.
parser: ... then shift 'term', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'ORDER' in state 32
parser: Shift 'ORDER', go to state 500
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER]
parser: Input 'BY' in state 500
parser: Shift 'BY', go to state 22
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY]
parser: Input 'FOLLOWING' in state 22
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY FOLLOWING]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 22.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 22.
parser: ... then shift 'sortlist', go to state 184
parser: Reduce 297 [frame_opt ::=].
parser: ... then shift 'frame_opt', pending reduce 293
parser: Reduce 293 [window ::= ORDER BY sortlist frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'SEMI' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT t1, ntile(17) OVER (ORDER BY t1) FROM over

;SELECT following, ntile(18) OVER (ORDER BY following) FROM over

;SELECT t1, ntile(19) OVER (ORDER BY t1) FROM over

;DROP TABLE IF EXISTS t4;;CREATE TABLE x(test001 INTEGER PRIMARY KEY, last_field TEXT, test002 INTEGER);;INSERT INTO over VALUES(2, 'preceding', 3);;INSERT INTO over VALUES(5, 'E', 5);;INSERT INTO over VALUES(6, 'F', 1);;INSERT INTO x VALUES(7, 'G', 1);;INSERT INTO x VALUES(8, 'H', 2);;INSERT INTO over VALUES(9, 'I', 10);SELECT preceding, lead(preceding, 2) OVER (ORDER BY preceding) FROM over

;SELECT t1, lead(t1, 3, 'abc') OVER (ORDER BY t1) FROM over

;;CREATE TABLE field1(test003 INTEGER PRIMARY KEY, field2 TEXT, test004 TEXT, field3 INTEGER);;INSERT INTO x VALUES(1, 'last_field', 'one',   5);;INSERT INTO x VALUES(2, 'test001', 'two',   4);;INSERT INTO x VALUES(3, 'test001', 'three', 3);;INSERT INTO x VALUES(4, 'test001', 'four',  2);;INSERT INTO x VALUES(5, 'test001', 'five',  1);SELECT t1, max(following) OVER (ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 2 PRECEDING)
  FROM over

;SELECT preceding, max(following) OVER (ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over

;SELECT last_field, max(test002) OVER (ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 0 PRECEDING)
  FROM x

;SELECT test002, max(test001) OVER (ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 1 FOLLOWING)
  FROM x

;DROP TABLE IF EXISTS ttt;;INSERT INTO field1 VALUES(2, 2, 2);;INSERT INTO x VALUES(5, 2, 3);;INSERT INTO x VALUES(7, 1, 3);;INSERT INTO field1 VALUES(8, 2, 4);;INSERT INTO field1 VALUES(9, 3, 5);;
;SELECT abs(max(t1) OVER (ORDER BY t1)) FROM over GROUP BY t1;;
;SELECT sum(preceding) OVER (
    ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING
  ) FROM over;;
;SELECT max(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002, last_field ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER ( ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY preceding, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
         sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY last_field

;SELECT sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'INTEGER' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 11.
parser: ... then shift 'term', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'ORDER' in state 32
parser: Shift 'ORDER', go to state 500
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER]
parser: Input 'BY' in state 500
parser: Shift 'BY', go to state 22
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY]
parser: Input 'ID' in state 22
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 22.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 22.
parser: ... then shift 'sortlist', go to state 184
parser: Reduce 297 [frame_opt ::=].
parser: ... then shift 'frame_opt', pending reduce 293
parser: Reduce 293 [window ::= ORDER BY sortlist frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'SEMI' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT following, ntile(18) OVER (ORDER BY following) FROM over

;SELECT t1, ntile(19) OVER (ORDER BY t1) FROM over

;DROP TABLE IF EXISTS t4;;CREATE TABLE x(test001 INTEGER PRIMARY KEY, last_field TEXT, test002 INTEGER);;INSERT INTO over VALUES(2, 'preceding', 3);;INSERT INTO over VALUES(5, 'E', 5);;INSERT INTO over VALUES(6, 'F', 1);;INSERT INTO x VALUES(7, 'G', 1);;INSERT INTO x VALUES(8, 'H', 2);;INSERT INTO over VALUES(9, 'I', 10);SELECT preceding, lead(preceding, 2) OVER (ORDER BY preceding) FROM over

;SELECT t1, lead(t1, 3, 'abc') OVER (ORDER BY t1) FROM over

;;CREATE TABLE field1(test003 INTEGER PRIMARY KEY, field2 TEXT, test004 TEXT, field3 INTEGER);;INSERT INTO x VALUES(1, 'last_field', 'one',   5);;INSERT INTO x VALUES(2, 'test001', 'two',   4);;INSERT INTO x VALUES(3, 'test001', 'three', 3);;INSERT INTO x VALUES(4, 'test001', 'four',  2);;INSERT INTO x VALUES(5, 'test001', 'five',  1);SELECT t1, max(following) OVER (ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 2 PRECEDING)
  FROM over

;SELECT preceding, max(following) OVER (ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over

;SELECT last_field, max(test002) OVER (ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 0 PRECEDING)
  FROM x

;SELECT test002, max(test001) OVER (ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 1 FOLLOWING)
  FROM x

;DROP TABLE IF EXISTS ttt;;INSERT INTO field1 VALUES(2, 2, 2);;INSERT INTO x VALUES(5, 2, 3);;INSERT INTO x VALUES(7, 1, 3);;INSERT INTO field1 VALUES(8, 2, 4);;INSERT INTO field1 VALUES(9, 3, 5);;
;SELECT abs(max(t1) OVER (ORDER BY t1)) FROM over GROUP BY t1;;
;SELECT sum(preceding) OVER (
    ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING
  ) FROM over;;
;SELECT max(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002, last_field ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER ( ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY preceding, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
         sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY last_field

;SELECT sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'FOLLOWING' in state 288
parser: FALLBACK FOLLOWING => ID
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: FALLBACK FOLLOWING => ID
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: FALLBACK FOLLOWING => ID
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt FOLLOWING]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'INTEGER' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 11.
parser: ... then shift 'term', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'ORDER' in state 32
parser: Shift 'ORDER', go to state 500
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER]
parser: Input 'BY' in state 500
parser: Shift 'BY', go to state 22
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY]
parser: Input 'FOLLOWING' in state 22
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY FOLLOWING]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 22.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 22.
parser: ... then shift 'sortlist', go to state 184
parser: Reduce 297 [frame_opt ::=].
parser: ... then shift 'frame_opt', pending reduce 293
parser: Reduce 293 [window ::= ORDER BY sortlist frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'SEMI' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT t1, ntile(19) OVER (ORDER BY t1) FROM over

;DROP TABLE IF EXISTS t4;;CREATE TABLE x(test001 INTEGER PRIMARY KEY, last_field TEXT, test002 INTEGER);;INSERT INTO over VALUES(2, 'preceding', 3);;INSERT INTO over VALUES(5, 'E', 5);;INSERT INTO over VALUES(6, 'F', 1);;INSERT INTO x VALUES(7, 'G', 1);;INSERT INTO x VALUES(8, 'H', 2);;INSERT INTO over VALUES(9, 'I', 10);SELECT preceding, lead(preceding, 2) OVER (ORDER BY preceding) FROM over

;SELECT t1, lead(t1, 3, 'abc') OVER (ORDER BY t1) FROM over

;;CREATE TABLE field1(test003 INTEGER PRIMARY KEY, field2 TEXT, test004 TEXT, field3 INTEGER);;INSERT INTO x VALUES(1, 'last_field', 'one',   5);;INSERT INTO x VALUES(2, 'test001', 'two',   4);;INSERT INTO x VALUES(3, 'test001', 'three', 3);;INSERT INTO x VALUES(4, 'test001', 'four',  2);;INSERT INTO x VALUES(5, 'test001', 'five',  1);SELECT t1, max(following) OVER (ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 2 PRECEDING)
  FROM over

;SELECT preceding, max(following) OVER (ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over

;SELECT last_field, max(test002) OVER (ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 0 PRECEDING)
  FROM x

;SELECT test002, max(test001) OVER (ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 1 FOLLOWING)
  FROM x

;DROP TABLE IF EXISTS ttt;;INSERT INTO field1 VALUES(2, 2, 2);;INSERT INTO x VALUES(5, 2, 3);;INSERT INTO x VALUES(7, 1, 3);;INSERT INTO field1 VALUES(8, 2, 4);;INSERT INTO field1 VALUES(9, 3, 5);;
;SELECT abs(max(t1) OVER (ORDER BY t1)) FROM over GROUP BY t1;;
;SELECT sum(preceding) OVER (
    ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING
  ) FROM over;;
;SELECT max(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002, last_field ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER ( ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY preceding, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
         sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY last_field

;SELECT sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'INTEGER' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 11.
parser: ... then shift 'term', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'ORDER' in state 32
parser: Shift 'ORDER', go to state 500
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER]
parser: Input 'BY' in state 500
parser: Shift 'BY', go to state 22
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY]
parser: Input 'ID' in state 22
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 22.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 22.
parser: ... then shift 'sortlist', go to state 184
parser: Reduce 297 [frame_opt ::=].
parser: ... then shift 'frame_opt', pending reduce 293
parser: Reduce 293 [window ::= ORDER BY sortlist frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'SEMI' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[DROP TABLE IF EXISTS t4;;CREATE TABLE x(test001 INTEGER PRIMARY KEY, last_field TEXT, test002 INTEGER);;INSERT INTO over VALUES(2, 'preceding', 3);;INSERT INTO over VALUES(5, 'E', 5);;INSERT INTO over VALUES(6, 'F', 1);;INSERT INTO x VALUES(7, 'G', 1);;INSERT INTO x VALUES(8, 'H', 2);;INSERT INTO over VALUES(9, 'I', 10);SELECT preceding, lead(preceding, 2) OVER (ORDER BY preceding) FROM over

;SELECT t1, lead(t1, 3, 'abc') OVER (ORDER BY t1) FROM over

;;CREATE TABLE field1(test003 INTEGER PRIMARY KEY, field2 TEXT, test004 TEXT, field3 INTEGER);;INSERT INTO x VALUES(1, 'last_field', 'one',   5);;INSERT INTO x VALUES(2, 'test001', 'two',   4);;INSERT INTO x VALUES(3, 'test001', 'three', 3);;INSERT INTO x VALUES(4, 'test001', 'four',  2);;INSERT INTO x VALUES(5, 'test001', 'five',  1);SELECT t1, max(following) OVER (ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 2 PRECEDING)
  FROM over

;SELECT preceding, max(following) OVER (ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over

;SELECT last_field, max(test002) OVER (ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 0 PRECEDING)
  FROM x

;SELECT test002, max(test001) OVER (ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 1 FOLLOWING)
  FROM x

;DROP TABLE IF EXISTS ttt;;INSERT INTO field1 VALUES(2, 2, 2);;INSERT INTO x VALUES(5, 2, 3);;INSERT INTO x VALUES(7, 1, 3);;INSERT INTO field1 VALUES(8, 2, 4);;INSERT INTO field1 VALUES(9, 3, 5);;
;SELECT abs(max(t1) OVER (ORDER BY t1)) FROM over GROUP BY t1;;
;SELECT sum(preceding) OVER (
    ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING
  ) FROM over;;
;SELECT max(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002, last_field ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER ( ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY preceding, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
         sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY last_field

;SELECT sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'DROP' in state 0
parser: Shift 'DROP', go to state 385
parser: Return. Stack=[DROP]
parser: Input 'TABLE' in state 385
parser: Shift 'TABLE', go to state 304
parser: Return. Stack=[DROP TABLE]
parser: Input 'IF' in state 304
parser: Shift 'IF', go to state 431
parser: Return. Stack=[DROP TABLE IF]
parser: Input 'EXISTS' in state 431
parser: Shift 'EXISTS', pending reduce 75
parser: Return. Stack=[DROP TABLE IF EXISTS]
parser: Input 'ID' with pending reduce 75
parser: Reduce 75 [ifexists ::= IF EXISTS], go to state 304.
parser: ... then shift 'ifexists', go to state 171
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[DROP TABLE ifexists ID]
parser: Input 'SEMI' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 171.
parser: ... then shift 'nm', go to state 459
parser: Reduce 110 [fullname ::= nm], go to state 171.
parser: ... then shift 'fullname', pending reduce 74
parser: Reduce 74 [cmd ::= DROP TABLE ifexists fullname], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[;CREATE TABLE x(test001 INTEGER PRIMARY KEY, last_field TEXT, test002 INTEGER);;INSERT INTO over VALUES(2, 'preceding', 3);;INSERT INTO over VALUES(5, 'E', 5);;INSERT INTO over VALUES(6, 'F', 1);;INSERT INTO x VALUES(7, 'G', 1);;INSERT INTO x VALUES(8, 'H', 2);;INSERT INTO over VALUES(9, 'I', 10);SELECT preceding, lead(preceding, 2) OVER (ORDER BY preceding) FROM over

;SELECT t1, lead(t1, 3, 'abc') OVER (ORDER BY t1) FROM over

;;CREATE TABLE field1(test003 INTEGER PRIMARY KEY, field2 TEXT, test004 TEXT, field3 INTEGER);;INSERT INTO x VALUES(1, 'last_field', 'one',   5);;INSERT INTO x VALUES(2, 'test001', 'two',   4);;INSERT INTO x VALUES(3, 'test001', 'three', 3);;INSERT INTO x VALUES(4, 'test001', 'four',  2);;INSERT INTO x VALUES(5, 'test001', 'five',  1);SELECT t1, max(following) OVER (ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 2 PRECEDING)
  FROM over

;SELECT preceding, max(following) OVER (ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over

;SELECT last_field, max(test002) OVER (ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 0 PRECEDING)
  FROM x

;SELECT test002, max(test001) OVER (ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 1 FOLLOWING)
  FROM x

;DROP TABLE IF EXISTS ttt;;INSERT INTO field1 VALUES(2, 2, 2);;INSERT INTO x VALUES(5, 2, 3);;INSERT INTO x VALUES(7, 1, 3);;INSERT INTO field1 VALUES(8, 2, 4);;INSERT INTO field1 VALUES(9, 3, 5);;
;SELECT abs(max(t1) OVER (ORDER BY t1)) FROM over GROUP BY t1;;
;SELECT sum(preceding) OVER (
    ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING
  ) FROM over;;
;SELECT max(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002, last_field ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER ( ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY preceding, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
         sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY last_field

;SELECT sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'CREATE' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[ecmd CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 1.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 388
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[ecmd createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 1.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[ecmd create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd create_table LP ID]
parser: Input 'ID' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 190
parser: Shift 'ID', pending reduce 335
parser: Return. Stack=[ecmd create_table LP nm ID]
parser: Input 'PRIMARY' with pending reduce 335
parser: Reduce 335 [typename ::= ID|STRING], go to state 190.
parser: ... then shift 'typename', go to state 390
parser: Reduce 334 [typetoken ::= typename], go to state 190.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 376
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 150
parser: Shift 'PRIMARY', go to state 475
parser: Return. Stack=[ecmd create_table LP columnname carglist PRIMARY]
parser: Input 'KEY' in state 475
parser: Shift 'KEY', go to state 280
parser: Return. Stack=[ecmd create_table LP columnname carglist PRIMARY KEY]
parser: Input 'COMMA' in state 280
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 333
parser: Reduce 68 [onconf ::=].
parser: ... then shift 'onconf', go to state 332
parser: Reduce 42 [autoinc ::=].
parser: ... then shift 'autoinc', pending reduce 36
parser: Reduce 36 [ccons ::= PRIMARY KEY sortorder onconf autoinc], go to state 150.
parser: ... then shift 'ccons', pending reduce 338
parser: Reduce 338 [carglist ::= carglist ccons], go to state 376.
parser: ... then shift 'carglist', go to state 150
parser: Reduce 330 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[ecmd create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 190
parser: Shift 'ID', pending reduce 335
parser: Return. Stack=[ecmd create_table LP columnlist COMMA nm ID]
parser: Input 'COMMA' with pending reduce 335
parser: Reduce 335 [typename ::= ID|STRING], go to state 190.
parser: ... then shift 'typename', go to state 390
parser: Reduce 334 [typetoken ::= typename], go to state 190.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 383
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 151
parser: Reduce 329 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[ecmd create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 190
parser: Shift 'ID', pending reduce 335
parser: Return. Stack=[ecmd create_table LP columnlist COMMA nm ID]
parser: Input 'RP' with pending reduce 335
parser: Reduce 335 [typename ::= ID|STRING], go to state 190.
parser: ... then shift 'typename', go to state 390
parser: Reduce 334 [typetoken ::= typename], go to state 190.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 383
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 151
parser: Reduce 329 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Reduce 60 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 538
parser: Shift 'RP', go to state 361
parser: Return. Stack=[ecmd create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 361
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: [[[UPDATE 'main'.sqlite_master SET type='table', name='x', tbl_name='x', rootpage=#2, sql='CREATE TABLE x(test001 INTEGER PRIMARY KEY, last_field TEXT, test002 INTEGER)' WHERE rowid=#1]]]
parser: Input 'UPDATE' in state 0
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'UPDATE', go to state 299
parser: Return. Stack=[with UPDATE]
parser: Input 'STRING' in state 299
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', go to state 165
parser: Shift 'STRING', pending reduce 332
parser: Return. Stack=[with UPDATE orconf STRING]
parser: Input 'DOT' with pending reduce 332
parser: Reduce 332 [nm ::= STRING], go to state 165.
parser: ... then shift 'nm', go to state 393
parser: Shift 'DOT', go to state 218
parser: Return. Stack=[with UPDATE orconf nm DOT]
parser: Input 'ID' in state 218
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf nm DOT ID]
parser: Input 'SET' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 218.
parser: ... then shift 'nm', go to state 429
parser: Reduce 113 [xfullname ::= nm DOT nm], go to state 165.
parser: ... then shift 'xfullname', go to state 271
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 428
parser: Shift 'SET', go to state 153
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET]
parser: Input 'ID' in state 153
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 153.
parser: ... then shift 'nm', go to state 442
parser: Shift 'EQ', go to state 84
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ]
parser: Input 'STRING' in state 84
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 84.
parser: ... then shift 'term', go to state 58
parser: Reduce 148 [setlist ::= nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'VARIABLE' in state 86
parser: Shift 'VARIABLE', pending reduce 170
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ VARIABLE]
parser: Input 'COMMA' with pending reduce 170
parser: Reduce 170 [expr ::= VARIABLE], go to state 86.
parser: ... then shift 'expr', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'WHERE' in state 537
parser: Reduce 168 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 416
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr EQ]
parser: Input 'VARIABLE' in state 117
parser: Shift 'VARIABLE', pending reduce 170
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr EQ VARIABLE]
parser: Input 'SEMI' with pending reduce 170
parser: Reduce 170 [expr ::= VARIABLE], go to state 117.
parser: ... then shift 'expr', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 270.
parser: ... then shift 'where_opt', pending reduce 145
parser: Reduce 145 [cmd ::= with UPDATE orconf xfullname indexed_opt SET setlist where_opt], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Input '$' with pending reduce 321
parser: Reduce 321 [ecmd ::= cmdx SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 317 [input ::= cmdlist], go to state 0.
parser: ... then shift 'input', pending reduce -2
parser: Accept!
parser: ... then shift 'create_table_args', pending reduce 328
parser: Reduce 328 [cmd ::= create_table create_table_args], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
parser: [[[SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='x' AND type!='trigger' ORDER BY rowid]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'FROM' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'STRING' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'STRING', pending reduce 332
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix STRING]
parser: Input 'DOT' with pending reduce 332
parser: Reduce 332 [nm ::= STRING], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Shift 'DOT', go to state 245
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID' in state 245
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 245.
parser: ... then shift 'nm', pending reduce 109
parser: Reduce 109 [dbnm ::= DOT nm], go to state 349.
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[SELECT distinct selcollist from WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND' in state 537
parser: Reduce 168 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'AND', go to state 120
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID' in state 120
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'NE' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Shift 'NE', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr NE]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr NE STRING]
parser: Input 'ORDER' in state 537
parser: Reduce 168 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Reduce 179 [expr ::= expr AND expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[CREATE TABLE x(test001 INTEGER PRIMARY KEY, last_field TEXT, test002 INTEGER)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 388
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP ID]
parser: Input 'ID' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 190
parser: Shift 'ID', pending reduce 335
parser: Return. Stack=[create_table LP nm ID]
parser: Input 'PRIMARY' with pending reduce 335
parser: Reduce 335 [typename ::= ID|STRING], go to state 190.
parser: ... then shift 'typename', go to state 390
parser: Reduce 334 [typetoken ::= typename], go to state 190.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 376
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 150
parser: Shift 'PRIMARY', go to state 475
parser: Return. Stack=[create_table LP columnname carglist PRIMARY]
parser: Input 'KEY' in state 475
parser: Shift 'KEY', go to state 280
parser: Return. Stack=[create_table LP columnname carglist PRIMARY KEY]
parser: Input 'COMMA' in state 280
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 333
parser: Reduce 68 [onconf ::=].
parser: ... then shift 'onconf', go to state 332
parser: Reduce 42 [autoinc ::=].
parser: ... then shift 'autoinc', pending reduce 36
parser: Reduce 36 [ccons ::= PRIMARY KEY sortorder onconf autoinc], go to state 150.
parser: ... then shift 'ccons', pending reduce 338
parser: Reduce 338 [carglist ::= carglist ccons], go to state 376.
parser: ... then shift 'carglist', go to state 150
parser: Reduce 330 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 190
parser: Shift 'ID', pending reduce 335
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'COMMA' with pending reduce 335
parser: Reduce 335 [typename ::= ID|STRING], go to state 190.
parser: ... then shift 'typename', go to state 390
parser: Reduce 334 [typetoken ::= typename], go to state 190.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 383
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 151
parser: Reduce 329 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 190
parser: Shift 'ID', pending reduce 335
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'RP' with pending reduce 335
parser: Reduce 335 [typename ::= ID|STRING], go to state 190.
parser: ... then shift 'typename', go to state 390
parser: Reduce 334 [typetoken ::= typename], go to state 190.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 383
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 151
parser: Reduce 329 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Reduce 60 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 538
parser: Shift 'RP', go to state 361
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 361
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 328
parser: Reduce 328 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[;INSERT INTO over VALUES(2, 'preceding', 3);;INSERT INTO over VALUES(5, 'E', 5);;INSERT INTO over VALUES(6, 'F', 1);;INSERT INTO x VALUES(7, 'G', 1);;INSERT INTO x VALUES(8, 'H', 2);;INSERT INTO over VALUES(9, 'I', 10);SELECT preceding, lead(preceding, 2) OVER (ORDER BY preceding) FROM over

;SELECT t1, lead(t1, 3, 'abc') OVER (ORDER BY t1) FROM over

;;CREATE TABLE field1(test003 INTEGER PRIMARY KEY, field2 TEXT, test004 TEXT, field3 INTEGER);;INSERT INTO x VALUES(1, 'last_field', 'one',   5);;INSERT INTO x VALUES(2, 'test001', 'two',   4);;INSERT INTO x VALUES(3, 'test001', 'three', 3);;INSERT INTO x VALUES(4, 'test001', 'four',  2);;INSERT INTO x VALUES(5, 'test001', 'five',  1);SELECT t1, max(following) OVER (ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 2 PRECEDING)
  FROM over

;SELECT preceding, max(following) OVER (ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over

;SELECT last_field, max(test002) OVER (ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 0 PRECEDING)
  FROM x

;SELECT test002, max(test001) OVER (ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 1 FOLLOWING)
  FROM x

;DROP TABLE IF EXISTS ttt;;INSERT INTO field1 VALUES(2, 2, 2);;INSERT INTO x VALUES(5, 2, 3);;INSERT INTO x VALUES(7, 1, 3);;INSERT INTO field1 VALUES(8, 2, 4);;INSERT INTO field1 VALUES(9, 3, 5);;
;SELECT abs(max(t1) OVER (ORDER BY t1)) FROM over GROUP BY t1;;
;SELECT sum(preceding) OVER (
    ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING
  ) FROM over;;
;SELECT max(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002, last_field ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER ( ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY preceding, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
         sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY last_field

;SELECT sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'INSERT' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'INSERT', go to state 311
parser: Return. Stack=[ecmd with INSERT]
parser: Input 'INTO' in state 311
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', pending reduce 156
parser: Reduce 156 [insert_cmd ::= INSERT orconf], go to state 219.
parser: ... then shift 'insert_cmd', go to state 427
parser: Shift 'INTO', go to state 164
parser: Return. Stack=[ecmd with insert_cmd INTO]
parser: Input 'ID' in state 164
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd with insert_cmd INTO ID]
parser: Input 'VALUES' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 164.
parser: ... then shift 'nm', go to state 393
parser: Reduce 112 [xfullname ::= nm], go to state 164.
parser: ... then shift 'xfullname', go to state 298
parser: Reduce 158 [idlist_opt ::=].
parser: ... then shift 'idlist_opt', go to state 35
parser: Shift 'VALUES', go to state 526
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES]
parser: Input 'LP' in state 526
parser: Shift 'LP', go to state 28
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP]
parser: Input 'INTEGER' in state 28
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 28.
parser: ... then shift 'term', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'STRING' in state 107
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'INTEGER' in state 107
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'RP', pending reduce 89
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist RP]
parser: Input 'SEMI' with pending reduce 89
parser: Reduce 89 [values ::= VALUES LP nexprlist RP], go to state 35.
parser: ... then shift 'values', go to state 532
parser: Reduce 348 [oneselect ::= values], go to state 35.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 35.
parser: ... then shift 'select', go to state 297
parser: Reduce 152 [upsert ::=].
parser: ... then shift 'upsert', pending reduce 150
parser: Reduce 150 [cmd ::= with insert_cmd INTO xfullname idlist_opt select upsert], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
parser: [[[;INSERT INTO over VALUES(5, 'E', 5);;INSERT INTO over VALUES(6, 'F', 1);;INSERT INTO x VALUES(7, 'G', 1);;INSERT INTO x VALUES(8, 'H', 2);;INSERT INTO over VALUES(9, 'I', 10);SELECT preceding, lead(preceding, 2) OVER (ORDER BY preceding) FROM over

;SELECT t1, lead(t1, 3, 'abc') OVER (ORDER BY t1) FROM over

;;CREATE TABLE field1(test003 INTEGER PRIMARY KEY, field2 TEXT, test004 TEXT, field3 INTEGER);;INSERT INTO x VALUES(1, 'last_field', 'one',   5);;INSERT INTO x VALUES(2, 'test001', 'two',   4);;INSERT INTO x VALUES(3, 'test001', 'three', 3);;INSERT INTO x VALUES(4, 'test001', 'four',  2);;INSERT INTO x VALUES(5, 'test001', 'five',  1);SELECT t1, max(following) OVER (ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 2 PRECEDING)
  FROM over

;SELECT preceding, max(following) OVER (ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over

;SELECT last_field, max(test002) OVER (ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 0 PRECEDING)
  FROM x

;SELECT test002, max(test001) OVER (ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 1 FOLLOWING)
  FROM x

;DROP TABLE IF EXISTS ttt;;INSERT INTO field1 VALUES(2, 2, 2);;INSERT INTO x VALUES(5, 2, 3);;INSERT INTO x VALUES(7, 1, 3);;INSERT INTO field1 VALUES(8, 2, 4);;INSERT INTO field1 VALUES(9, 3, 5);;
;SELECT abs(max(t1) OVER (ORDER BY t1)) FROM over GROUP BY t1;;
;SELECT sum(preceding) OVER (
    ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING
  ) FROM over;;
;SELECT max(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002, last_field ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER ( ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY preceding, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
         sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY last_field

;SELECT sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'INSERT' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'INSERT', go to state 311
parser: Return. Stack=[ecmd with INSERT]
parser: Input 'INTO' in state 311
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', pending reduce 156
parser: Reduce 156 [insert_cmd ::= INSERT orconf], go to state 219.
parser: ... then shift 'insert_cmd', go to state 427
parser: Shift 'INTO', go to state 164
parser: Return. Stack=[ecmd with insert_cmd INTO]
parser: Input 'ID' in state 164
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd with insert_cmd INTO ID]
parser: Input 'VALUES' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 164.
parser: ... then shift 'nm', go to state 393
parser: Reduce 112 [xfullname ::= nm], go to state 164.
parser: ... then shift 'xfullname', go to state 298
parser: Reduce 158 [idlist_opt ::=].
parser: ... then shift 'idlist_opt', go to state 35
parser: Shift 'VALUES', go to state 526
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES]
parser: Input 'LP' in state 526
parser: Shift 'LP', go to state 28
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP]
parser: Input 'INTEGER' in state 28
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 28.
parser: ... then shift 'term', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'STRING' in state 107
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'INTEGER' in state 107
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'RP', pending reduce 89
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist RP]
parser: Input 'SEMI' with pending reduce 89
parser: Reduce 89 [values ::= VALUES LP nexprlist RP], go to state 35.
parser: ... then shift 'values', go to state 532
parser: Reduce 348 [oneselect ::= values], go to state 35.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 35.
parser: ... then shift 'select', go to state 297
parser: Reduce 152 [upsert ::=].
parser: ... then shift 'upsert', pending reduce 150
parser: Reduce 150 [cmd ::= with insert_cmd INTO xfullname idlist_opt select upsert], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
parser: [[[;INSERT INTO over VALUES(6, 'F', 1);;INSERT INTO x VALUES(7, 'G', 1);;INSERT INTO x VALUES(8, 'H', 2);;INSERT INTO over VALUES(9, 'I', 10);SELECT preceding, lead(preceding, 2) OVER (ORDER BY preceding) FROM over

;SELECT t1, lead(t1, 3, 'abc') OVER (ORDER BY t1) FROM over

;;CREATE TABLE field1(test003 INTEGER PRIMARY KEY, field2 TEXT, test004 TEXT, field3 INTEGER);;INSERT INTO x VALUES(1, 'last_field', 'one',   5);;INSERT INTO x VALUES(2, 'test001', 'two',   4);;INSERT INTO x VALUES(3, 'test001', 'three', 3);;INSERT INTO x VALUES(4, 'test001', 'four',  2);;INSERT INTO x VALUES(5, 'test001', 'five',  1);SELECT t1, max(following) OVER (ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 2 PRECEDING)
  FROM over

;SELECT preceding, max(following) OVER (ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over

;SELECT last_field, max(test002) OVER (ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 0 PRECEDING)
  FROM x

;SELECT test002, max(test001) OVER (ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 1 FOLLOWING)
  FROM x

;DROP TABLE IF EXISTS ttt;;INSERT INTO field1 VALUES(2, 2, 2);;INSERT INTO x VALUES(5, 2, 3);;INSERT INTO x VALUES(7, 1, 3);;INSERT INTO field1 VALUES(8, 2, 4);;INSERT INTO field1 VALUES(9, 3, 5);;
;SELECT abs(max(t1) OVER (ORDER BY t1)) FROM over GROUP BY t1;;
;SELECT sum(preceding) OVER (
    ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING
  ) FROM over;;
;SELECT max(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002, last_field ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER ( ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY preceding, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
         sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY last_field

;SELECT sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'INSERT' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'INSERT', go to state 311
parser: Return. Stack=[ecmd with INSERT]
parser: Input 'INTO' in state 311
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', pending reduce 156
parser: Reduce 156 [insert_cmd ::= INSERT orconf], go to state 219.
parser: ... then shift 'insert_cmd', go to state 427
parser: Shift 'INTO', go to state 164
parser: Return. Stack=[ecmd with insert_cmd INTO]
parser: Input 'ID' in state 164
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd with insert_cmd INTO ID]
parser: Input 'VALUES' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 164.
parser: ... then shift 'nm', go to state 393
parser: Reduce 112 [xfullname ::= nm], go to state 164.
parser: ... then shift 'xfullname', go to state 298
parser: Reduce 158 [idlist_opt ::=].
parser: ... then shift 'idlist_opt', go to state 35
parser: Shift 'VALUES', go to state 526
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES]
parser: Input 'LP' in state 526
parser: Shift 'LP', go to state 28
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP]
parser: Input 'INTEGER' in state 28
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 28.
parser: ... then shift 'term', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'STRING' in state 107
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'INTEGER' in state 107
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'RP', pending reduce 89
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist RP]
parser: Input 'SEMI' with pending reduce 89
parser: Reduce 89 [values ::= VALUES LP nexprlist RP], go to state 35.
parser: ... then shift 'values', go to state 532
parser: Reduce 348 [oneselect ::= values], go to state 35.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 35.
parser: ... then shift 'select', go to state 297
parser: Reduce 152 [upsert ::=].
parser: ... then shift 'upsert', pending reduce 150
parser: Reduce 150 [cmd ::= with insert_cmd INTO xfullname idlist_opt select upsert], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
parser: [[[;INSERT INTO x VALUES(7, 'G', 1);;INSERT INTO x VALUES(8, 'H', 2);;INSERT INTO over VALUES(9, 'I', 10);SELECT preceding, lead(preceding, 2) OVER (ORDER BY preceding) FROM over

;SELECT t1, lead(t1, 3, 'abc') OVER (ORDER BY t1) FROM over

;;CREATE TABLE field1(test003 INTEGER PRIMARY KEY, field2 TEXT, test004 TEXT, field3 INTEGER);;INSERT INTO x VALUES(1, 'last_field', 'one',   5);;INSERT INTO x VALUES(2, 'test001', 'two',   4);;INSERT INTO x VALUES(3, 'test001', 'three', 3);;INSERT INTO x VALUES(4, 'test001', 'four',  2);;INSERT INTO x VALUES(5, 'test001', 'five',  1);SELECT t1, max(following) OVER (ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 2 PRECEDING)
  FROM over

;SELECT preceding, max(following) OVER (ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over

;SELECT last_field, max(test002) OVER (ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 0 PRECEDING)
  FROM x

;SELECT test002, max(test001) OVER (ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 1 FOLLOWING)
  FROM x

;DROP TABLE IF EXISTS ttt;;INSERT INTO field1 VALUES(2, 2, 2);;INSERT INTO x VALUES(5, 2, 3);;INSERT INTO x VALUES(7, 1, 3);;INSERT INTO field1 VALUES(8, 2, 4);;INSERT INTO field1 VALUES(9, 3, 5);;
;SELECT abs(max(t1) OVER (ORDER BY t1)) FROM over GROUP BY t1;;
;SELECT sum(preceding) OVER (
    ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING
  ) FROM over;;
;SELECT max(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002, last_field ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER ( ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY preceding, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
         sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY last_field

;SELECT sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'INSERT' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'INSERT', go to state 311
parser: Return. Stack=[ecmd with INSERT]
parser: Input 'INTO' in state 311
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', pending reduce 156
parser: Reduce 156 [insert_cmd ::= INSERT orconf], go to state 219.
parser: ... then shift 'insert_cmd', go to state 427
parser: Shift 'INTO', go to state 164
parser: Return. Stack=[ecmd with insert_cmd INTO]
parser: Input 'ID' in state 164
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd with insert_cmd INTO ID]
parser: Input 'VALUES' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 164.
parser: ... then shift 'nm', go to state 393
parser: Reduce 112 [xfullname ::= nm], go to state 164.
parser: ... then shift 'xfullname', go to state 298
parser: Reduce 158 [idlist_opt ::=].
parser: ... then shift 'idlist_opt', go to state 35
parser: Shift 'VALUES', go to state 526
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES]
parser: Input 'LP' in state 526
parser: Shift 'LP', go to state 28
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP]
parser: Input 'INTEGER' in state 28
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 28.
parser: ... then shift 'term', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'STRING' in state 107
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'INTEGER' in state 107
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'RP', pending reduce 89
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist RP]
parser: Input 'SEMI' with pending reduce 89
parser: Reduce 89 [values ::= VALUES LP nexprlist RP], go to state 35.
parser: ... then shift 'values', go to state 532
parser: Reduce 348 [oneselect ::= values], go to state 35.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 35.
parser: ... then shift 'select', go to state 297
parser: Reduce 152 [upsert ::=].
parser: ... then shift 'upsert', pending reduce 150
parser: Reduce 150 [cmd ::= with insert_cmd INTO xfullname idlist_opt select upsert], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
parser: [[[;INSERT INTO x VALUES(8, 'H', 2);;INSERT INTO over VALUES(9, 'I', 10);SELECT preceding, lead(preceding, 2) OVER (ORDER BY preceding) FROM over

;SELECT t1, lead(t1, 3, 'abc') OVER (ORDER BY t1) FROM over

;;CREATE TABLE field1(test003 INTEGER PRIMARY KEY, field2 TEXT, test004 TEXT, field3 INTEGER);;INSERT INTO x VALUES(1, 'last_field', 'one',   5);;INSERT INTO x VALUES(2, 'test001', 'two',   4);;INSERT INTO x VALUES(3, 'test001', 'three', 3);;INSERT INTO x VALUES(4, 'test001', 'four',  2);;INSERT INTO x VALUES(5, 'test001', 'five',  1);SELECT t1, max(following) OVER (ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 2 PRECEDING)
  FROM over

;SELECT preceding, max(following) OVER (ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over

;SELECT last_field, max(test002) OVER (ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 0 PRECEDING)
  FROM x

;SELECT test002, max(test001) OVER (ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 1 FOLLOWING)
  FROM x

;DROP TABLE IF EXISTS ttt;;INSERT INTO field1 VALUES(2, 2, 2);;INSERT INTO x VALUES(5, 2, 3);;INSERT INTO x VALUES(7, 1, 3);;INSERT INTO field1 VALUES(8, 2, 4);;INSERT INTO field1 VALUES(9, 3, 5);;
;SELECT abs(max(t1) OVER (ORDER BY t1)) FROM over GROUP BY t1;;
;SELECT sum(preceding) OVER (
    ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING
  ) FROM over;;
;SELECT max(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002, last_field ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER ( ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY preceding, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
         sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY last_field

;SELECT sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'INSERT' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'INSERT', go to state 311
parser: Return. Stack=[ecmd with INSERT]
parser: Input 'INTO' in state 311
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', pending reduce 156
parser: Reduce 156 [insert_cmd ::= INSERT orconf], go to state 219.
parser: ... then shift 'insert_cmd', go to state 427
parser: Shift 'INTO', go to state 164
parser: Return. Stack=[ecmd with insert_cmd INTO]
parser: Input 'ID' in state 164
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd with insert_cmd INTO ID]
parser: Input 'VALUES' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 164.
parser: ... then shift 'nm', go to state 393
parser: Reduce 112 [xfullname ::= nm], go to state 164.
parser: ... then shift 'xfullname', go to state 298
parser: Reduce 158 [idlist_opt ::=].
parser: ... then shift 'idlist_opt', go to state 35
parser: Shift 'VALUES', go to state 526
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES]
parser: Input 'LP' in state 526
parser: Shift 'LP', go to state 28
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP]
parser: Input 'INTEGER' in state 28
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 28.
parser: ... then shift 'term', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'STRING' in state 107
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'INTEGER' in state 107
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'RP', pending reduce 89
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist RP]
parser: Input 'SEMI' with pending reduce 89
parser: Reduce 89 [values ::= VALUES LP nexprlist RP], go to state 35.
parser: ... then shift 'values', go to state 532
parser: Reduce 348 [oneselect ::= values], go to state 35.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 35.
parser: ... then shift 'select', go to state 297
parser: Reduce 152 [upsert ::=].
parser: ... then shift 'upsert', pending reduce 150
parser: Reduce 150 [cmd ::= with insert_cmd INTO xfullname idlist_opt select upsert], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
parser: [[[;INSERT INTO over VALUES(9, 'I', 10);SELECT preceding, lead(preceding, 2) OVER (ORDER BY preceding) FROM over

;SELECT t1, lead(t1, 3, 'abc') OVER (ORDER BY t1) FROM over

;;CREATE TABLE field1(test003 INTEGER PRIMARY KEY, field2 TEXT, test004 TEXT, field3 INTEGER);;INSERT INTO x VALUES(1, 'last_field', 'one',   5);;INSERT INTO x VALUES(2, 'test001', 'two',   4);;INSERT INTO x VALUES(3, 'test001', 'three', 3);;INSERT INTO x VALUES(4, 'test001', 'four',  2);;INSERT INTO x VALUES(5, 'test001', 'five',  1);SELECT t1, max(following) OVER (ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 2 PRECEDING)
  FROM over

;SELECT preceding, max(following) OVER (ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over

;SELECT last_field, max(test002) OVER (ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 0 PRECEDING)
  FROM x

;SELECT test002, max(test001) OVER (ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 1 FOLLOWING)
  FROM x

;DROP TABLE IF EXISTS ttt;;INSERT INTO field1 VALUES(2, 2, 2);;INSERT INTO x VALUES(5, 2, 3);;INSERT INTO x VALUES(7, 1, 3);;INSERT INTO field1 VALUES(8, 2, 4);;INSERT INTO field1 VALUES(9, 3, 5);;
;SELECT abs(max(t1) OVER (ORDER BY t1)) FROM over GROUP BY t1;;
;SELECT sum(preceding) OVER (
    ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING
  ) FROM over;;
;SELECT max(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002, last_field ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER ( ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY preceding, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
         sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY last_field

;SELECT sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'INSERT' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'INSERT', go to state 311
parser: Return. Stack=[ecmd with INSERT]
parser: Input 'INTO' in state 311
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', pending reduce 156
parser: Reduce 156 [insert_cmd ::= INSERT orconf], go to state 219.
parser: ... then shift 'insert_cmd', go to state 427
parser: Shift 'INTO', go to state 164
parser: Return. Stack=[ecmd with insert_cmd INTO]
parser: Input 'ID' in state 164
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd with insert_cmd INTO ID]
parser: Input 'VALUES' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 164.
parser: ... then shift 'nm', go to state 393
parser: Reduce 112 [xfullname ::= nm], go to state 164.
parser: ... then shift 'xfullname', go to state 298
parser: Reduce 158 [idlist_opt ::=].
parser: ... then shift 'idlist_opt', go to state 35
parser: Shift 'VALUES', go to state 526
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES]
parser: Input 'LP' in state 526
parser: Shift 'LP', go to state 28
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP]
parser: Input 'INTEGER' in state 28
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 28.
parser: ... then shift 'term', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'STRING' in state 107
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'INTEGER' in state 107
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'RP', pending reduce 89
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist RP]
parser: Input 'SEMI' with pending reduce 89
parser: Reduce 89 [values ::= VALUES LP nexprlist RP], go to state 35.
parser: ... then shift 'values', go to state 532
parser: Reduce 348 [oneselect ::= values], go to state 35.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 35.
parser: ... then shift 'select', go to state 297
parser: Reduce 152 [upsert ::=].
parser: ... then shift 'upsert', pending reduce 150
parser: Reduce 150 [cmd ::= with insert_cmd INTO xfullname idlist_opt select upsert], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
parser: [[[SELECT preceding, lead(preceding, 2) OVER (ORDER BY preceding) FROM over

;SELECT t1, lead(t1, 3, 'abc') OVER (ORDER BY t1) FROM over

;;CREATE TABLE field1(test003 INTEGER PRIMARY KEY, field2 TEXT, test004 TEXT, field3 INTEGER);;INSERT INTO x VALUES(1, 'last_field', 'one',   5);;INSERT INTO x VALUES(2, 'test001', 'two',   4);;INSERT INTO x VALUES(3, 'test001', 'three', 3);;INSERT INTO x VALUES(4, 'test001', 'four',  2);;INSERT INTO x VALUES(5, 'test001', 'five',  1);SELECT t1, max(following) OVER (ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 2 PRECEDING)
  FROM over

;SELECT preceding, max(following) OVER (ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over

;SELECT last_field, max(test002) OVER (ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 0 PRECEDING)
  FROM x

;SELECT test002, max(test001) OVER (ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 1 FOLLOWING)
  FROM x

;DROP TABLE IF EXISTS ttt;;INSERT INTO field1 VALUES(2, 2, 2);;INSERT INTO x VALUES(5, 2, 3);;INSERT INTO x VALUES(7, 1, 3);;INSERT INTO field1 VALUES(8, 2, 4);;INSERT INTO field1 VALUES(9, 3, 5);;
;SELECT abs(max(t1) OVER (ORDER BY t1)) FROM over GROUP BY t1;;
;SELECT sum(preceding) OVER (
    ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING
  ) FROM over;;
;SELECT max(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002, last_field ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER ( ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY preceding, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
         sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY last_field

;SELECT sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'PRECEDING' in state 288
parser: FALLBACK PRECEDING => ID
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: FALLBACK PRECEDING => ID
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: FALLBACK PRECEDING => ID
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt PRECEDING]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'PRECEDING' in state 266
parser: FALLBACK PRECEDING => ID
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct PRECEDING]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct nexprlist COMMA]
parser: Input 'INTEGER' in state 107
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'ORDER' in state 32
parser: Shift 'ORDER', go to state 500
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER]
parser: Input 'BY' in state 500
parser: Shift 'BY', go to state 22
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY]
parser: Input 'PRECEDING' in state 22
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY PRECEDING]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 22.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 22.
parser: ... then shift 'sortlist', go to state 184
parser: Reduce 297 [frame_opt ::=].
parser: ... then shift 'frame_opt', pending reduce 293
parser: Reduce 293 [window ::= ORDER BY sortlist frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'SEMI' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT t1, lead(t1, 3, 'abc') OVER (ORDER BY t1) FROM over

;;CREATE TABLE field1(test003 INTEGER PRIMARY KEY, field2 TEXT, test004 TEXT, field3 INTEGER);;INSERT INTO x VALUES(1, 'last_field', 'one',   5);;INSERT INTO x VALUES(2, 'test001', 'two',   4);;INSERT INTO x VALUES(3, 'test001', 'three', 3);;INSERT INTO x VALUES(4, 'test001', 'four',  2);;INSERT INTO x VALUES(5, 'test001', 'five',  1);SELECT t1, max(following) OVER (ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 2 PRECEDING)
  FROM over

;SELECT preceding, max(following) OVER (ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over

;SELECT last_field, max(test002) OVER (ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 0 PRECEDING)
  FROM x

;SELECT test002, max(test001) OVER (ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 1 FOLLOWING)
  FROM x

;DROP TABLE IF EXISTS ttt;;INSERT INTO field1 VALUES(2, 2, 2);;INSERT INTO x VALUES(5, 2, 3);;INSERT INTO x VALUES(7, 1, 3);;INSERT INTO field1 VALUES(8, 2, 4);;INSERT INTO field1 VALUES(9, 3, 5);;
;SELECT abs(max(t1) OVER (ORDER BY t1)) FROM over GROUP BY t1;;
;SELECT sum(preceding) OVER (
    ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING
  ) FROM over;;
;SELECT max(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002, last_field ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER ( ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY preceding, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
         sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY last_field

;SELECT sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct nexprlist COMMA]
parser: Input 'INTEGER' in state 107
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct nexprlist COMMA INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct nexprlist COMMA]
parser: Input 'STRING' in state 107
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct nexprlist COMMA STRING]
parser: Input 'RP' in state 537
parser: Reduce 168 [term ::= STRING], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'ORDER' in state 32
parser: Shift 'ORDER', go to state 500
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER]
parser: Input 'BY' in state 500
parser: Shift 'BY', go to state 22
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY]
parser: Input 'ID' in state 22
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 22.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 22.
parser: ... then shift 'sortlist', go to state 184
parser: Reduce 297 [frame_opt ::=].
parser: ... then shift 'frame_opt', pending reduce 293
parser: Reduce 293 [window ::= ORDER BY sortlist frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'SEMI' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[;CREATE TABLE field1(test003 INTEGER PRIMARY KEY, field2 TEXT, test004 TEXT, field3 INTEGER);;INSERT INTO x VALUES(1, 'last_field', 'one',   5);;INSERT INTO x VALUES(2, 'test001', 'two',   4);;INSERT INTO x VALUES(3, 'test001', 'three', 3);;INSERT INTO x VALUES(4, 'test001', 'four',  2);;INSERT INTO x VALUES(5, 'test001', 'five',  1);SELECT t1, max(following) OVER (ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 2 PRECEDING)
  FROM over

;SELECT preceding, max(following) OVER (ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over

;SELECT last_field, max(test002) OVER (ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 0 PRECEDING)
  FROM x

;SELECT test002, max(test001) OVER (ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 1 FOLLOWING)
  FROM x

;DROP TABLE IF EXISTS ttt;;INSERT INTO field1 VALUES(2, 2, 2);;INSERT INTO x VALUES(5, 2, 3);;INSERT INTO x VALUES(7, 1, 3);;INSERT INTO field1 VALUES(8, 2, 4);;INSERT INTO field1 VALUES(9, 3, 5);;
;SELECT abs(max(t1) OVER (ORDER BY t1)) FROM over GROUP BY t1;;
;SELECT sum(preceding) OVER (
    ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING
  ) FROM over;;
;SELECT max(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002, last_field ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER ( ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY preceding, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
         sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY last_field

;SELECT sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'CREATE' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[ecmd CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 1.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 388
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[ecmd createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 1.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[ecmd create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd create_table LP ID]
parser: Input 'ID' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 190
parser: Shift 'ID', pending reduce 335
parser: Return. Stack=[ecmd create_table LP nm ID]
parser: Input 'PRIMARY' with pending reduce 335
parser: Reduce 335 [typename ::= ID|STRING], go to state 190.
parser: ... then shift 'typename', go to state 390
parser: Reduce 334 [typetoken ::= typename], go to state 190.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 376
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 150
parser: Shift 'PRIMARY', go to state 475
parser: Return. Stack=[ecmd create_table LP columnname carglist PRIMARY]
parser: Input 'KEY' in state 475
parser: Shift 'KEY', go to state 280
parser: Return. Stack=[ecmd create_table LP columnname carglist PRIMARY KEY]
parser: Input 'COMMA' in state 280
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 333
parser: Reduce 68 [onconf ::=].
parser: ... then shift 'onconf', go to state 332
parser: Reduce 42 [autoinc ::=].
parser: ... then shift 'autoinc', pending reduce 36
parser: Reduce 36 [ccons ::= PRIMARY KEY sortorder onconf autoinc], go to state 150.
parser: ... then shift 'ccons', pending reduce 338
parser: Reduce 338 [carglist ::= carglist ccons], go to state 376.
parser: ... then shift 'carglist', go to state 150
parser: Reduce 330 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[ecmd create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 190
parser: Shift 'ID', pending reduce 335
parser: Return. Stack=[ecmd create_table LP columnlist COMMA nm ID]
parser: Input 'COMMA' with pending reduce 335
parser: Reduce 335 [typename ::= ID|STRING], go to state 190.
parser: ... then shift 'typename', go to state 390
parser: Reduce 334 [typetoken ::= typename], go to state 190.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 383
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 151
parser: Reduce 329 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[ecmd create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 190
parser: Shift 'ID', pending reduce 335
parser: Return. Stack=[ecmd create_table LP columnlist COMMA nm ID]
parser: Input 'COMMA' with pending reduce 335
parser: Reduce 335 [typename ::= ID|STRING], go to state 190.
parser: ... then shift 'typename', go to state 390
parser: Reduce 334 [typetoken ::= typename], go to state 190.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 383
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 151
parser: Reduce 329 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[ecmd create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 190
parser: Shift 'ID', pending reduce 335
parser: Return. Stack=[ecmd create_table LP columnlist COMMA nm ID]
parser: Input 'RP' with pending reduce 335
parser: Reduce 335 [typename ::= ID|STRING], go to state 190.
parser: ... then shift 'typename', go to state 390
parser: Reduce 334 [typetoken ::= typename], go to state 190.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 383
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 151
parser: Reduce 329 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Reduce 60 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 538
parser: Shift 'RP', go to state 361
parser: Return. Stack=[ecmd create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 361
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: [[[UPDATE 'main'.sqlite_master SET type='table', name='field1', tbl_name='field1', rootpage=#2, sql='CREATE TABLE field1(test003 INTEGER PRIMARY KEY, field2 TEXT, test004 TEXT, field3 INTEGER)' WHERE rowid=#1]]]
parser: Input 'UPDATE' in state 0
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'UPDATE', go to state 299
parser: Return. Stack=[with UPDATE]
parser: Input 'STRING' in state 299
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', go to state 165
parser: Shift 'STRING', pending reduce 332
parser: Return. Stack=[with UPDATE orconf STRING]
parser: Input 'DOT' with pending reduce 332
parser: Reduce 332 [nm ::= STRING], go to state 165.
parser: ... then shift 'nm', go to state 393
parser: Shift 'DOT', go to state 218
parser: Return. Stack=[with UPDATE orconf nm DOT]
parser: Input 'ID' in state 218
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf nm DOT ID]
parser: Input 'SET' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 218.
parser: ... then shift 'nm', go to state 429
parser: Reduce 113 [xfullname ::= nm DOT nm], go to state 165.
parser: ... then shift 'xfullname', go to state 271
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 428
parser: Shift 'SET', go to state 153
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET]
parser: Input 'ID' in state 153
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 153.
parser: ... then shift 'nm', go to state 442
parser: Shift 'EQ', go to state 84
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ]
parser: Input 'STRING' in state 84
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 84.
parser: ... then shift 'term', go to state 58
parser: Reduce 148 [setlist ::= nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'VARIABLE' in state 86
parser: Shift 'VARIABLE', pending reduce 170
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ VARIABLE]
parser: Input 'COMMA' with pending reduce 170
parser: Reduce 170 [expr ::= VARIABLE], go to state 86.
parser: ... then shift 'expr', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'WHERE' in state 537
parser: Reduce 168 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 416
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr EQ]
parser: Input 'VARIABLE' in state 117
parser: Shift 'VARIABLE', pending reduce 170
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr EQ VARIABLE]
parser: Input 'SEMI' with pending reduce 170
parser: Reduce 170 [expr ::= VARIABLE], go to state 117.
parser: ... then shift 'expr', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 270.
parser: ... then shift 'where_opt', pending reduce 145
parser: Reduce 145 [cmd ::= with UPDATE orconf xfullname indexed_opt SET setlist where_opt], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Input '$' with pending reduce 321
parser: Reduce 321 [ecmd ::= cmdx SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 317 [input ::= cmdlist], go to state 0.
parser: ... then shift 'input', pending reduce -2
parser: Accept!
parser: ... then shift 'create_table_args', pending reduce 328
parser: Reduce 328 [cmd ::= create_table create_table_args], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
parser: [[[SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='field1' AND type!='trigger' ORDER BY rowid]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'FROM' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'STRING' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'STRING', pending reduce 332
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix STRING]
parser: Input 'DOT' with pending reduce 332
parser: Reduce 332 [nm ::= STRING], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Shift 'DOT', go to state 245
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID' in state 245
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 245.
parser: ... then shift 'nm', pending reduce 109
parser: Reduce 109 [dbnm ::= DOT nm], go to state 349.
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[SELECT distinct selcollist from WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND' in state 537
parser: Reduce 168 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'AND', go to state 120
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID' in state 120
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'NE' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Shift 'NE', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr NE]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr NE STRING]
parser: Input 'ORDER' in state 537
parser: Reduce 168 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Reduce 179 [expr ::= expr AND expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[CREATE TABLE field1(test003 INTEGER PRIMARY KEY, field2 TEXT, test004 TEXT, field3 INTEGER)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 388
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP ID]
parser: Input 'ID' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 190
parser: Shift 'ID', pending reduce 335
parser: Return. Stack=[create_table LP nm ID]
parser: Input 'PRIMARY' with pending reduce 335
parser: Reduce 335 [typename ::= ID|STRING], go to state 190.
parser: ... then shift 'typename', go to state 390
parser: Reduce 334 [typetoken ::= typename], go to state 190.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 376
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 150
parser: Shift 'PRIMARY', go to state 475
parser: Return. Stack=[create_table LP columnname carglist PRIMARY]
parser: Input 'KEY' in state 475
parser: Shift 'KEY', go to state 280
parser: Return. Stack=[create_table LP columnname carglist PRIMARY KEY]
parser: Input 'COMMA' in state 280
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 333
parser: Reduce 68 [onconf ::=].
parser: ... then shift 'onconf', go to state 332
parser: Reduce 42 [autoinc ::=].
parser: ... then shift 'autoinc', pending reduce 36
parser: Reduce 36 [ccons ::= PRIMARY KEY sortorder onconf autoinc], go to state 150.
parser: ... then shift 'ccons', pending reduce 338
parser: Reduce 338 [carglist ::= carglist ccons], go to state 376.
parser: ... then shift 'carglist', go to state 150
parser: Reduce 330 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 190
parser: Shift 'ID', pending reduce 335
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'COMMA' with pending reduce 335
parser: Reduce 335 [typename ::= ID|STRING], go to state 190.
parser: ... then shift 'typename', go to state 390
parser: Reduce 334 [typetoken ::= typename], go to state 190.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 383
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 151
parser: Reduce 329 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 190
parser: Shift 'ID', pending reduce 335
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'COMMA' with pending reduce 335
parser: Reduce 335 [typename ::= ID|STRING], go to state 190.
parser: ... then shift 'typename', go to state 390
parser: Reduce 334 [typetoken ::= typename], go to state 190.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 383
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 151
parser: Reduce 329 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 190
parser: Shift 'ID', pending reduce 335
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'RP' with pending reduce 335
parser: Reduce 335 [typename ::= ID|STRING], go to state 190.
parser: ... then shift 'typename', go to state 390
parser: Reduce 334 [typetoken ::= typename], go to state 190.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 383
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 151
parser: Reduce 329 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Reduce 60 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 538
parser: Shift 'RP', go to state 361
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 361
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 328
parser: Reduce 328 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[;INSERT INTO x VALUES(1, 'last_field', 'one',   5);;INSERT INTO x VALUES(2, 'test001', 'two',   4);;INSERT INTO x VALUES(3, 'test001', 'three', 3);;INSERT INTO x VALUES(4, 'test001', 'four',  2);;INSERT INTO x VALUES(5, 'test001', 'five',  1);SELECT t1, max(following) OVER (ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 2 PRECEDING)
  FROM over

;SELECT preceding, max(following) OVER (ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over

;SELECT last_field, max(test002) OVER (ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 0 PRECEDING)
  FROM x

;SELECT test002, max(test001) OVER (ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 1 FOLLOWING)
  FROM x

;DROP TABLE IF EXISTS ttt;;INSERT INTO field1 VALUES(2, 2, 2);;INSERT INTO x VALUES(5, 2, 3);;INSERT INTO x VALUES(7, 1, 3);;INSERT INTO field1 VALUES(8, 2, 4);;INSERT INTO field1 VALUES(9, 3, 5);;
;SELECT abs(max(t1) OVER (ORDER BY t1)) FROM over GROUP BY t1;;
;SELECT sum(preceding) OVER (
    ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING
  ) FROM over;;
;SELECT max(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002, last_field ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER ( ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY preceding, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
         sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY last_field

;SELECT sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'INSERT' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'INSERT', go to state 311
parser: Return. Stack=[ecmd with INSERT]
parser: Input 'INTO' in state 311
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', pending reduce 156
parser: Reduce 156 [insert_cmd ::= INSERT orconf], go to state 219.
parser: ... then shift 'insert_cmd', go to state 427
parser: Shift 'INTO', go to state 164
parser: Return. Stack=[ecmd with insert_cmd INTO]
parser: Input 'ID' in state 164
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd with insert_cmd INTO ID]
parser: Input 'VALUES' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 164.
parser: ... then shift 'nm', go to state 393
parser: Reduce 112 [xfullname ::= nm], go to state 164.
parser: ... then shift 'xfullname', go to state 298
parser: Reduce 158 [idlist_opt ::=].
parser: ... then shift 'idlist_opt', go to state 35
parser: Shift 'VALUES', go to state 526
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES]
parser: Input 'LP' in state 526
parser: Shift 'LP', go to state 28
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP]
parser: Input 'INTEGER' in state 28
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 28.
parser: ... then shift 'term', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'STRING' in state 107
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'STRING' in state 107
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'INTEGER' in state 107
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'RP', pending reduce 89
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist RP]
parser: Input 'SEMI' with pending reduce 89
parser: Reduce 89 [values ::= VALUES LP nexprlist RP], go to state 35.
parser: ... then shift 'values', go to state 532
parser: Reduce 348 [oneselect ::= values], go to state 35.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 35.
parser: ... then shift 'select', go to state 297
parser: Reduce 152 [upsert ::=].
parser: ... then shift 'upsert', pending reduce 150
parser: Reduce 150 [cmd ::= with insert_cmd INTO xfullname idlist_opt select upsert], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
parser: [[[;INSERT INTO x VALUES(2, 'test001', 'two',   4);;INSERT INTO x VALUES(3, 'test001', 'three', 3);;INSERT INTO x VALUES(4, 'test001', 'four',  2);;INSERT INTO x VALUES(5, 'test001', 'five',  1);SELECT t1, max(following) OVER (ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 2 PRECEDING)
  FROM over

;SELECT preceding, max(following) OVER (ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over

;SELECT last_field, max(test002) OVER (ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 0 PRECEDING)
  FROM x

;SELECT test002, max(test001) OVER (ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 1 FOLLOWING)
  FROM x

;DROP TABLE IF EXISTS ttt;;INSERT INTO field1 VALUES(2, 2, 2);;INSERT INTO x VALUES(5, 2, 3);;INSERT INTO x VALUES(7, 1, 3);;INSERT INTO field1 VALUES(8, 2, 4);;INSERT INTO field1 VALUES(9, 3, 5);;
;SELECT abs(max(t1) OVER (ORDER BY t1)) FROM over GROUP BY t1;;
;SELECT sum(preceding) OVER (
    ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING
  ) FROM over;;
;SELECT max(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002, last_field ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER ( ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY preceding, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
         sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY last_field

;SELECT sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'INSERT' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'INSERT', go to state 311
parser: Return. Stack=[ecmd with INSERT]
parser: Input 'INTO' in state 311
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', pending reduce 156
parser: Reduce 156 [insert_cmd ::= INSERT orconf], go to state 219.
parser: ... then shift 'insert_cmd', go to state 427
parser: Shift 'INTO', go to state 164
parser: Return. Stack=[ecmd with insert_cmd INTO]
parser: Input 'ID' in state 164
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd with insert_cmd INTO ID]
parser: Input 'VALUES' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 164.
parser: ... then shift 'nm', go to state 393
parser: Reduce 112 [xfullname ::= nm], go to state 164.
parser: ... then shift 'xfullname', go to state 298
parser: Reduce 158 [idlist_opt ::=].
parser: ... then shift 'idlist_opt', go to state 35
parser: Shift 'VALUES', go to state 526
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES]
parser: Input 'LP' in state 526
parser: Shift 'LP', go to state 28
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP]
parser: Input 'INTEGER' in state 28
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 28.
parser: ... then shift 'term', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'STRING' in state 107
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'STRING' in state 107
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'INTEGER' in state 107
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'RP', pending reduce 89
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist RP]
parser: Input 'SEMI' with pending reduce 89
parser: Reduce 89 [values ::= VALUES LP nexprlist RP], go to state 35.
parser: ... then shift 'values', go to state 532
parser: Reduce 348 [oneselect ::= values], go to state 35.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 35.
parser: ... then shift 'select', go to state 297
parser: Reduce 152 [upsert ::=].
parser: ... then shift 'upsert', pending reduce 150
parser: Reduce 150 [cmd ::= with insert_cmd INTO xfullname idlist_opt select upsert], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
parser: [[[;INSERT INTO x VALUES(3, 'test001', 'three', 3);;INSERT INTO x VALUES(4, 'test001', 'four',  2);;INSERT INTO x VALUES(5, 'test001', 'five',  1);SELECT t1, max(following) OVER (ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 2 PRECEDING)
  FROM over

;SELECT preceding, max(following) OVER (ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over

;SELECT last_field, max(test002) OVER (ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 0 PRECEDING)
  FROM x

;SELECT test002, max(test001) OVER (ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 1 FOLLOWING)
  FROM x

;DROP TABLE IF EXISTS ttt;;INSERT INTO field1 VALUES(2, 2, 2);;INSERT INTO x VALUES(5, 2, 3);;INSERT INTO x VALUES(7, 1, 3);;INSERT INTO field1 VALUES(8, 2, 4);;INSERT INTO field1 VALUES(9, 3, 5);;
;SELECT abs(max(t1) OVER (ORDER BY t1)) FROM over GROUP BY t1;;
;SELECT sum(preceding) OVER (
    ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING
  ) FROM over;;
;SELECT max(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002, last_field ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER ( ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY preceding, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
         sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY last_field

;SELECT sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'INSERT' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'INSERT', go to state 311
parser: Return. Stack=[ecmd with INSERT]
parser: Input 'INTO' in state 311
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', pending reduce 156
parser: Reduce 156 [insert_cmd ::= INSERT orconf], go to state 219.
parser: ... then shift 'insert_cmd', go to state 427
parser: Shift 'INTO', go to state 164
parser: Return. Stack=[ecmd with insert_cmd INTO]
parser: Input 'ID' in state 164
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd with insert_cmd INTO ID]
parser: Input 'VALUES' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 164.
parser: ... then shift 'nm', go to state 393
parser: Reduce 112 [xfullname ::= nm], go to state 164.
parser: ... then shift 'xfullname', go to state 298
parser: Reduce 158 [idlist_opt ::=].
parser: ... then shift 'idlist_opt', go to state 35
parser: Shift 'VALUES', go to state 526
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES]
parser: Input 'LP' in state 526
parser: Shift 'LP', go to state 28
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP]
parser: Input 'INTEGER' in state 28
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 28.
parser: ... then shift 'term', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'STRING' in state 107
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'STRING' in state 107
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'INTEGER' in state 107
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'RP', pending reduce 89
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist RP]
parser: Input 'SEMI' with pending reduce 89
parser: Reduce 89 [values ::= VALUES LP nexprlist RP], go to state 35.
parser: ... then shift 'values', go to state 532
parser: Reduce 348 [oneselect ::= values], go to state 35.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 35.
parser: ... then shift 'select', go to state 297
parser: Reduce 152 [upsert ::=].
parser: ... then shift 'upsert', pending reduce 150
parser: Reduce 150 [cmd ::= with insert_cmd INTO xfullname idlist_opt select upsert], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
parser: [[[;INSERT INTO x VALUES(4, 'test001', 'four',  2);;INSERT INTO x VALUES(5, 'test001', 'five',  1);SELECT t1, max(following) OVER (ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 2 PRECEDING)
  FROM over

;SELECT preceding, max(following) OVER (ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over

;SELECT last_field, max(test002) OVER (ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 0 PRECEDING)
  FROM x

;SELECT test002, max(test001) OVER (ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 1 FOLLOWING)
  FROM x

;DROP TABLE IF EXISTS ttt;;INSERT INTO field1 VALUES(2, 2, 2);;INSERT INTO x VALUES(5, 2, 3);;INSERT INTO x VALUES(7, 1, 3);;INSERT INTO field1 VALUES(8, 2, 4);;INSERT INTO field1 VALUES(9, 3, 5);;
;SELECT abs(max(t1) OVER (ORDER BY t1)) FROM over GROUP BY t1;;
;SELECT sum(preceding) OVER (
    ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING
  ) FROM over;;
;SELECT max(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002, last_field ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER ( ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY preceding, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
         sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY last_field

;SELECT sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'INSERT' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'INSERT', go to state 311
parser: Return. Stack=[ecmd with INSERT]
parser: Input 'INTO' in state 311
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', pending reduce 156
parser: Reduce 156 [insert_cmd ::= INSERT orconf], go to state 219.
parser: ... then shift 'insert_cmd', go to state 427
parser: Shift 'INTO', go to state 164
parser: Return. Stack=[ecmd with insert_cmd INTO]
parser: Input 'ID' in state 164
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd with insert_cmd INTO ID]
parser: Input 'VALUES' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 164.
parser: ... then shift 'nm', go to state 393
parser: Reduce 112 [xfullname ::= nm], go to state 164.
parser: ... then shift 'xfullname', go to state 298
parser: Reduce 158 [idlist_opt ::=].
parser: ... then shift 'idlist_opt', go to state 35
parser: Shift 'VALUES', go to state 526
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES]
parser: Input 'LP' in state 526
parser: Shift 'LP', go to state 28
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP]
parser: Input 'INTEGER' in state 28
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 28.
parser: ... then shift 'term', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'STRING' in state 107
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'STRING' in state 107
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'INTEGER' in state 107
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'RP', pending reduce 89
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist RP]
parser: Input 'SEMI' with pending reduce 89
parser: Reduce 89 [values ::= VALUES LP nexprlist RP], go to state 35.
parser: ... then shift 'values', go to state 532
parser: Reduce 348 [oneselect ::= values], go to state 35.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 35.
parser: ... then shift 'select', go to state 297
parser: Reduce 152 [upsert ::=].
parser: ... then shift 'upsert', pending reduce 150
parser: Reduce 150 [cmd ::= with insert_cmd INTO xfullname idlist_opt select upsert], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
parser: [[[;INSERT INTO x VALUES(5, 'test001', 'five',  1);SELECT t1, max(following) OVER (ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 2 PRECEDING)
  FROM over

;SELECT preceding, max(following) OVER (ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over

;SELECT last_field, max(test002) OVER (ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 0 PRECEDING)
  FROM x

;SELECT test002, max(test001) OVER (ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 1 FOLLOWING)
  FROM x

;DROP TABLE IF EXISTS ttt;;INSERT INTO field1 VALUES(2, 2, 2);;INSERT INTO x VALUES(5, 2, 3);;INSERT INTO x VALUES(7, 1, 3);;INSERT INTO field1 VALUES(8, 2, 4);;INSERT INTO field1 VALUES(9, 3, 5);;
;SELECT abs(max(t1) OVER (ORDER BY t1)) FROM over GROUP BY t1;;
;SELECT sum(preceding) OVER (
    ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING
  ) FROM over;;
;SELECT max(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002, last_field ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER ( ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY preceding, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
         sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY last_field

;SELECT sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'INSERT' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'INSERT', go to state 311
parser: Return. Stack=[ecmd with INSERT]
parser: Input 'INTO' in state 311
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', pending reduce 156
parser: Reduce 156 [insert_cmd ::= INSERT orconf], go to state 219.
parser: ... then shift 'insert_cmd', go to state 427
parser: Shift 'INTO', go to state 164
parser: Return. Stack=[ecmd with insert_cmd INTO]
parser: Input 'ID' in state 164
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd with insert_cmd INTO ID]
parser: Input 'VALUES' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 164.
parser: ... then shift 'nm', go to state 393
parser: Reduce 112 [xfullname ::= nm], go to state 164.
parser: ... then shift 'xfullname', go to state 298
parser: Reduce 158 [idlist_opt ::=].
parser: ... then shift 'idlist_opt', go to state 35
parser: Shift 'VALUES', go to state 526
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES]
parser: Input 'LP' in state 526
parser: Shift 'LP', go to state 28
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP]
parser: Input 'INTEGER' in state 28
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 28.
parser: ... then shift 'term', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'STRING' in state 107
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'STRING' in state 107
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'INTEGER' in state 107
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'RP', pending reduce 89
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist RP]
parser: Input 'SEMI' with pending reduce 89
parser: Reduce 89 [values ::= VALUES LP nexprlist RP], go to state 35.
parser: ... then shift 'values', go to state 532
parser: Reduce 348 [oneselect ::= values], go to state 35.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 35.
parser: ... then shift 'select', go to state 297
parser: Reduce 152 [upsert ::=].
parser: ... then shift 'upsert', pending reduce 150
parser: Reduce 150 [cmd ::= with insert_cmd INTO xfullname idlist_opt select upsert], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
parser: [[[SELECT t1, max(following) OVER (ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 2 PRECEDING)
  FROM over

;SELECT preceding, max(following) OVER (ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over

;SELECT last_field, max(test002) OVER (ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 0 PRECEDING)
  FROM x

;SELECT test002, max(test001) OVER (ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 1 FOLLOWING)
  FROM x

;DROP TABLE IF EXISTS ttt;;INSERT INTO field1 VALUES(2, 2, 2);;INSERT INTO x VALUES(5, 2, 3);;INSERT INTO x VALUES(7, 1, 3);;INSERT INTO field1 VALUES(8, 2, 4);;INSERT INTO field1 VALUES(9, 3, 5);;
;SELECT abs(max(t1) OVER (ORDER BY t1)) FROM over GROUP BY t1;;
;SELECT sum(preceding) OVER (
    ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING
  ) FROM over;;
;SELECT max(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002, last_field ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER ( ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY preceding, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
         sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY last_field

;SELECT sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'FOLLOWING' in state 266
parser: FALLBACK FOLLOWING => ID
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct FOLLOWING]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'ORDER' in state 32
parser: Shift 'ORDER', go to state 500
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER]
parser: Input 'BY' in state 500
parser: Shift 'BY', go to state 22
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY]
parser: Input 'ID' in state 22
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY ID]
parser: Input 'ROWS' in state 416
parser: FALLBACK ROWS => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 22.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK ROWS => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 22.
parser: ... then shift 'sortlist', go to state 184
parser: Shift 'ROWS', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY sortlist ROWS]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 184.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY sortlist range_or_rows BETWEEN]
parser: Input 'INTEGER' in state 8
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY sortlist range_or_rows BETWEEN INTEGER]
parser: Input 'PRECEDING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 8.
parser: ... then shift 'term', go to state 42
parser: Shift 'PRECEDING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY sortlist range_or_rows BETWEEN term PRECEDING]
parser: Input 'AND' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 8.
parser: ... then shift 'frame_bound', pending reduce 301
parser: Reduce 301 [frame_bound_s ::= frame_bound], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY sortlist range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'INTEGER' in state 7
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY sortlist range_or_rows BETWEEN frame_bound_s AND INTEGER]
parser: Input 'PRECEDING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 7.
parser: ... then shift 'term', go to state 42
parser: Shift 'PRECEDING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY sortlist range_or_rows BETWEEN frame_bound_s AND term PRECEDING]
parser: Input 'RP' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 184.
parser: ... then shift 'frame_opt', pending reduce 293
parser: Reduce 293 [window ::= ORDER BY sortlist frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'SEMI' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT preceding, max(following) OVER (ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over

;SELECT last_field, max(test002) OVER (ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 0 PRECEDING)
  FROM x

;SELECT test002, max(test001) OVER (ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 1 FOLLOWING)
  FROM x

;DROP TABLE IF EXISTS ttt;;INSERT INTO field1 VALUES(2, 2, 2);;INSERT INTO x VALUES(5, 2, 3);;INSERT INTO x VALUES(7, 1, 3);;INSERT INTO field1 VALUES(8, 2, 4);;INSERT INTO field1 VALUES(9, 3, 5);;
;SELECT abs(max(t1) OVER (ORDER BY t1)) FROM over GROUP BY t1;;
;SELECT sum(preceding) OVER (
    ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING
  ) FROM over;;
;SELECT max(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002, last_field ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER ( ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY preceding, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
         sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY last_field

;SELECT sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'PRECEDING' in state 288
parser: FALLBACK PRECEDING => ID
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: FALLBACK PRECEDING => ID
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: FALLBACK PRECEDING => ID
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt PRECEDING]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'FOLLOWING' in state 266
parser: FALLBACK FOLLOWING => ID
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct FOLLOWING]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'ORDER' in state 32
parser: Shift 'ORDER', go to state 500
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER]
parser: Input 'BY' in state 500
parser: Shift 'BY', go to state 22
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY]
parser: Input 'PRECEDING' in state 22
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY PRECEDING]
parser: Input 'ROWS' in state 416
parser: FALLBACK ROWS => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 22.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK ROWS => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 22.
parser: ... then shift 'sortlist', go to state 184
parser: Shift 'ROWS', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY sortlist ROWS]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 184.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY sortlist range_or_rows BETWEEN]
parser: Input 'INTEGER' in state 8
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY sortlist range_or_rows BETWEEN INTEGER]
parser: Input 'PRECEDING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 8.
parser: ... then shift 'term', go to state 42
parser: Shift 'PRECEDING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY sortlist range_or_rows BETWEEN term PRECEDING]
parser: Input 'AND' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 8.
parser: ... then shift 'frame_bound', pending reduce 301
parser: Reduce 301 [frame_bound_s ::= frame_bound], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY sortlist range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'INTEGER' in state 7
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY sortlist range_or_rows BETWEEN frame_bound_s AND INTEGER]
parser: Input 'PRECEDING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 7.
parser: ... then shift 'term', go to state 42
parser: Shift 'PRECEDING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY sortlist range_or_rows BETWEEN frame_bound_s AND term PRECEDING]
parser: Input 'RP' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 184.
parser: ... then shift 'frame_opt', pending reduce 293
parser: Reduce 293 [window ::= ORDER BY sortlist frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'SEMI' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT last_field, max(test002) OVER (ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 0 PRECEDING)
  FROM x

;SELECT test002, max(test001) OVER (ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 1 FOLLOWING)
  FROM x

;DROP TABLE IF EXISTS ttt;;INSERT INTO field1 VALUES(2, 2, 2);;INSERT INTO x VALUES(5, 2, 3);;INSERT INTO x VALUES(7, 1, 3);;INSERT INTO field1 VALUES(8, 2, 4);;INSERT INTO field1 VALUES(9, 3, 5);;
;SELECT abs(max(t1) OVER (ORDER BY t1)) FROM over GROUP BY t1;;
;SELECT sum(preceding) OVER (
    ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING
  ) FROM over;;
;SELECT max(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002, last_field ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER ( ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY preceding, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
         sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY last_field

;SELECT sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'ORDER' in state 32
parser: Shift 'ORDER', go to state 500
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER]
parser: Input 'BY' in state 500
parser: Shift 'BY', go to state 22
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY]
parser: Input 'ID' in state 22
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY ID]
parser: Input 'ROWS' in state 416
parser: FALLBACK ROWS => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 22.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK ROWS => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 22.
parser: ... then shift 'sortlist', go to state 184
parser: Shift 'ROWS', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY sortlist ROWS]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 184.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY sortlist range_or_rows BETWEEN]
parser: Input 'INTEGER' in state 8
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY sortlist range_or_rows BETWEEN INTEGER]
parser: Input 'PRECEDING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 8.
parser: ... then shift 'term', go to state 42
parser: Shift 'PRECEDING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY sortlist range_or_rows BETWEEN term PRECEDING]
parser: Input 'AND' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 8.
parser: ... then shift 'frame_bound', pending reduce 301
parser: Reduce 301 [frame_bound_s ::= frame_bound], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY sortlist range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'INTEGER' in state 7
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY sortlist range_or_rows BETWEEN frame_bound_s AND INTEGER]
parser: Input 'PRECEDING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 7.
parser: ... then shift 'term', go to state 42
parser: Shift 'PRECEDING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY sortlist range_or_rows BETWEEN frame_bound_s AND term PRECEDING]
parser: Input 'RP' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 184.
parser: ... then shift 'frame_opt', pending reduce 293
parser: Reduce 293 [window ::= ORDER BY sortlist frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'SEMI' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT test002, max(test001) OVER (ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 1 FOLLOWING)
  FROM x

;DROP TABLE IF EXISTS ttt;;INSERT INTO field1 VALUES(2, 2, 2);;INSERT INTO x VALUES(5, 2, 3);;INSERT INTO x VALUES(7, 1, 3);;INSERT INTO field1 VALUES(8, 2, 4);;INSERT INTO field1 VALUES(9, 3, 5);;
;SELECT abs(max(t1) OVER (ORDER BY t1)) FROM over GROUP BY t1;;
;SELECT sum(preceding) OVER (
    ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING
  ) FROM over;;
;SELECT max(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002, last_field ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER ( ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY preceding, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
         sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY last_field

;SELECT sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'ORDER' in state 32
parser: Shift 'ORDER', go to state 500
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER]
parser: Input 'BY' in state 500
parser: Shift 'BY', go to state 22
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY]
parser: Input 'ID' in state 22
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY ID]
parser: Input 'ROWS' in state 416
parser: FALLBACK ROWS => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 22.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK ROWS => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 22.
parser: ... then shift 'sortlist', go to state 184
parser: Shift 'ROWS', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY sortlist ROWS]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 184.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY sortlist range_or_rows BETWEEN]
parser: Input 'INTEGER' in state 8
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY sortlist range_or_rows BETWEEN INTEGER]
parser: Input 'FOLLOWING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 8.
parser: ... then shift 'term', go to state 42
parser: Shift 'FOLLOWING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY sortlist range_or_rows BETWEEN term FOLLOWING]
parser: Input 'AND' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 8.
parser: ... then shift 'frame_bound', pending reduce 301
parser: Reduce 301 [frame_bound_s ::= frame_bound], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY sortlist range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'INTEGER' in state 7
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY sortlist range_or_rows BETWEEN frame_bound_s AND INTEGER]
parser: Input 'FOLLOWING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 7.
parser: ... then shift 'term', go to state 42
parser: Shift 'FOLLOWING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY sortlist range_or_rows BETWEEN frame_bound_s AND term FOLLOWING]
parser: Input 'RP' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 184.
parser: ... then shift 'frame_opt', pending reduce 293
parser: Reduce 293 [window ::= ORDER BY sortlist frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'SEMI' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[DROP TABLE IF EXISTS ttt;;INSERT INTO field1 VALUES(2, 2, 2);;INSERT INTO x VALUES(5, 2, 3);;INSERT INTO x VALUES(7, 1, 3);;INSERT INTO field1 VALUES(8, 2, 4);;INSERT INTO field1 VALUES(9, 3, 5);;
;SELECT abs(max(t1) OVER (ORDER BY t1)) FROM over GROUP BY t1;;
;SELECT sum(preceding) OVER (
    ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING
  ) FROM over;;
;SELECT max(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002, last_field ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER ( ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY preceding, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
         sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY last_field

;SELECT sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'DROP' in state 0
parser: Shift 'DROP', go to state 385
parser: Return. Stack=[DROP]
parser: Input 'TABLE' in state 385
parser: Shift 'TABLE', go to state 304
parser: Return. Stack=[DROP TABLE]
parser: Input 'IF' in state 304
parser: Shift 'IF', go to state 431
parser: Return. Stack=[DROP TABLE IF]
parser: Input 'EXISTS' in state 431
parser: Shift 'EXISTS', pending reduce 75
parser: Return. Stack=[DROP TABLE IF EXISTS]
parser: Input 'ID' with pending reduce 75
parser: Reduce 75 [ifexists ::= IF EXISTS], go to state 304.
parser: ... then shift 'ifexists', go to state 171
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[DROP TABLE ifexists ID]
parser: Input 'SEMI' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 171.
parser: ... then shift 'nm', go to state 459
parser: Reduce 110 [fullname ::= nm], go to state 171.
parser: ... then shift 'fullname', pending reduce 74
parser: Reduce 74 [cmd ::= DROP TABLE ifexists fullname], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[;INSERT INTO field1 VALUES(2, 2, 2);;INSERT INTO x VALUES(5, 2, 3);;INSERT INTO x VALUES(7, 1, 3);;INSERT INTO field1 VALUES(8, 2, 4);;INSERT INTO field1 VALUES(9, 3, 5);;
;SELECT abs(max(t1) OVER (ORDER BY t1)) FROM over GROUP BY t1;;
;SELECT sum(preceding) OVER (
    ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING
  ) FROM over;;
;SELECT max(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002, last_field ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER ( ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY preceding, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
         sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY last_field

;SELECT sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'INSERT' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'INSERT', go to state 311
parser: Return. Stack=[ecmd with INSERT]
parser: Input 'INTO' in state 311
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', pending reduce 156
parser: Reduce 156 [insert_cmd ::= INSERT orconf], go to state 219.
parser: ... then shift 'insert_cmd', go to state 427
parser: Shift 'INTO', go to state 164
parser: Return. Stack=[ecmd with insert_cmd INTO]
parser: Input 'ID' in state 164
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd with insert_cmd INTO ID]
parser: Input 'VALUES' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 164.
parser: ... then shift 'nm', go to state 393
parser: Reduce 112 [xfullname ::= nm], go to state 164.
parser: ... then shift 'xfullname', go to state 298
parser: Reduce 158 [idlist_opt ::=].
parser: ... then shift 'idlist_opt', go to state 35
parser: Shift 'VALUES', go to state 526
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES]
parser: Input 'LP' in state 526
parser: Shift 'LP', go to state 28
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP]
parser: Input 'INTEGER' in state 28
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 28.
parser: ... then shift 'term', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'INTEGER' in state 107
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'INTEGER' in state 107
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'RP', pending reduce 89
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist RP]
parser: Input 'SEMI' with pending reduce 89
parser: Reduce 89 [values ::= VALUES LP nexprlist RP], go to state 35.
parser: ... then shift 'values', go to state 532
parser: Reduce 348 [oneselect ::= values], go to state 35.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 35.
parser: ... then shift 'select', go to state 297
parser: Reduce 152 [upsert ::=].
parser: ... then shift 'upsert', pending reduce 150
parser: Reduce 150 [cmd ::= with insert_cmd INTO xfullname idlist_opt select upsert], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
parser: [[[;INSERT INTO x VALUES(5, 2, 3);;INSERT INTO x VALUES(7, 1, 3);;INSERT INTO field1 VALUES(8, 2, 4);;INSERT INTO field1 VALUES(9, 3, 5);;
;SELECT abs(max(t1) OVER (ORDER BY t1)) FROM over GROUP BY t1;;
;SELECT sum(preceding) OVER (
    ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING
  ) FROM over;;
;SELECT max(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002, last_field ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER ( ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY preceding, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
         sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY last_field

;SELECT sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'INSERT' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'INSERT', go to state 311
parser: Return. Stack=[ecmd with INSERT]
parser: Input 'INTO' in state 311
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', pending reduce 156
parser: Reduce 156 [insert_cmd ::= INSERT orconf], go to state 219.
parser: ... then shift 'insert_cmd', go to state 427
parser: Shift 'INTO', go to state 164
parser: Return. Stack=[ecmd with insert_cmd INTO]
parser: Input 'ID' in state 164
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd with insert_cmd INTO ID]
parser: Input 'VALUES' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 164.
parser: ... then shift 'nm', go to state 393
parser: Reduce 112 [xfullname ::= nm], go to state 164.
parser: ... then shift 'xfullname', go to state 298
parser: Reduce 158 [idlist_opt ::=].
parser: ... then shift 'idlist_opt', go to state 35
parser: Shift 'VALUES', go to state 526
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES]
parser: Input 'LP' in state 526
parser: Shift 'LP', go to state 28
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP]
parser: Input 'INTEGER' in state 28
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 28.
parser: ... then shift 'term', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'INTEGER' in state 107
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'INTEGER' in state 107
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'RP', pending reduce 89
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist RP]
parser: Input 'SEMI' with pending reduce 89
parser: Reduce 89 [values ::= VALUES LP nexprlist RP], go to state 35.
parser: ... then shift 'values', go to state 532
parser: Reduce 348 [oneselect ::= values], go to state 35.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 35.
parser: ... then shift 'select', go to state 297
parser: Reduce 152 [upsert ::=].
parser: ... then shift 'upsert', pending reduce 150
parser: Reduce 150 [cmd ::= with insert_cmd INTO xfullname idlist_opt select upsert], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
parser: [[[;INSERT INTO x VALUES(7, 1, 3);;INSERT INTO field1 VALUES(8, 2, 4);;INSERT INTO field1 VALUES(9, 3, 5);;
;SELECT abs(max(t1) OVER (ORDER BY t1)) FROM over GROUP BY t1;;
;SELECT sum(preceding) OVER (
    ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING
  ) FROM over;;
;SELECT max(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002, last_field ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER ( ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY preceding, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
         sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY last_field

;SELECT sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'INSERT' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'INSERT', go to state 311
parser: Return. Stack=[ecmd with INSERT]
parser: Input 'INTO' in state 311
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', pending reduce 156
parser: Reduce 156 [insert_cmd ::= INSERT orconf], go to state 219.
parser: ... then shift 'insert_cmd', go to state 427
parser: Shift 'INTO', go to state 164
parser: Return. Stack=[ecmd with insert_cmd INTO]
parser: Input 'ID' in state 164
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd with insert_cmd INTO ID]
parser: Input 'VALUES' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 164.
parser: ... then shift 'nm', go to state 393
parser: Reduce 112 [xfullname ::= nm], go to state 164.
parser: ... then shift 'xfullname', go to state 298
parser: Reduce 158 [idlist_opt ::=].
parser: ... then shift 'idlist_opt', go to state 35
parser: Shift 'VALUES', go to state 526
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES]
parser: Input 'LP' in state 526
parser: Shift 'LP', go to state 28
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP]
parser: Input 'INTEGER' in state 28
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 28.
parser: ... then shift 'term', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'INTEGER' in state 107
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'INTEGER' in state 107
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'RP', pending reduce 89
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist RP]
parser: Input 'SEMI' with pending reduce 89
parser: Reduce 89 [values ::= VALUES LP nexprlist RP], go to state 35.
parser: ... then shift 'values', go to state 532
parser: Reduce 348 [oneselect ::= values], go to state 35.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 35.
parser: ... then shift 'select', go to state 297
parser: Reduce 152 [upsert ::=].
parser: ... then shift 'upsert', pending reduce 150
parser: Reduce 150 [cmd ::= with insert_cmd INTO xfullname idlist_opt select upsert], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
parser: [[[;INSERT INTO field1 VALUES(8, 2, 4);;INSERT INTO field1 VALUES(9, 3, 5);;
;SELECT abs(max(t1) OVER (ORDER BY t1)) FROM over GROUP BY t1;;
;SELECT sum(preceding) OVER (
    ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING
  ) FROM over;;
;SELECT max(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002, last_field ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER ( ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY preceding, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
         sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY last_field

;SELECT sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'INSERT' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'INSERT', go to state 311
parser: Return. Stack=[ecmd with INSERT]
parser: Input 'INTO' in state 311
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', pending reduce 156
parser: Reduce 156 [insert_cmd ::= INSERT orconf], go to state 219.
parser: ... then shift 'insert_cmd', go to state 427
parser: Shift 'INTO', go to state 164
parser: Return. Stack=[ecmd with insert_cmd INTO]
parser: Input 'ID' in state 164
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd with insert_cmd INTO ID]
parser: Input 'VALUES' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 164.
parser: ... then shift 'nm', go to state 393
parser: Reduce 112 [xfullname ::= nm], go to state 164.
parser: ... then shift 'xfullname', go to state 298
parser: Reduce 158 [idlist_opt ::=].
parser: ... then shift 'idlist_opt', go to state 35
parser: Shift 'VALUES', go to state 526
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES]
parser: Input 'LP' in state 526
parser: Shift 'LP', go to state 28
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP]
parser: Input 'INTEGER' in state 28
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 28.
parser: ... then shift 'term', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'INTEGER' in state 107
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'INTEGER' in state 107
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'RP', pending reduce 89
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist RP]
parser: Input 'SEMI' with pending reduce 89
parser: Reduce 89 [values ::= VALUES LP nexprlist RP], go to state 35.
parser: ... then shift 'values', go to state 532
parser: Reduce 348 [oneselect ::= values], go to state 35.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 35.
parser: ... then shift 'select', go to state 297
parser: Reduce 152 [upsert ::=].
parser: ... then shift 'upsert', pending reduce 150
parser: Reduce 150 [cmd ::= with insert_cmd INTO xfullname idlist_opt select upsert], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
parser: [[[;INSERT INTO field1 VALUES(9, 3, 5);;
;SELECT abs(max(t1) OVER (ORDER BY t1)) FROM over GROUP BY t1;;
;SELECT sum(preceding) OVER (
    ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING
  ) FROM over;;
;SELECT max(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002, last_field ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER ( ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY preceding, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
         sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY last_field

;SELECT sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'INSERT' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'INSERT', go to state 311
parser: Return. Stack=[ecmd with INSERT]
parser: Input 'INTO' in state 311
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', pending reduce 156
parser: Reduce 156 [insert_cmd ::= INSERT orconf], go to state 219.
parser: ... then shift 'insert_cmd', go to state 427
parser: Shift 'INTO', go to state 164
parser: Return. Stack=[ecmd with insert_cmd INTO]
parser: Input 'ID' in state 164
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd with insert_cmd INTO ID]
parser: Input 'VALUES' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 164.
parser: ... then shift 'nm', go to state 393
parser: Reduce 112 [xfullname ::= nm], go to state 164.
parser: ... then shift 'xfullname', go to state 298
parser: Reduce 158 [idlist_opt ::=].
parser: ... then shift 'idlist_opt', go to state 35
parser: Shift 'VALUES', go to state 526
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES]
parser: Input 'LP' in state 526
parser: Shift 'LP', go to state 28
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP]
parser: Input 'INTEGER' in state 28
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 28.
parser: ... then shift 'term', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'INTEGER' in state 107
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'INTEGER' in state 107
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'RP', pending reduce 89
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist RP]
parser: Input 'SEMI' with pending reduce 89
parser: Reduce 89 [values ::= VALUES LP nexprlist RP], go to state 35.
parser: ... then shift 'values', go to state 532
parser: Reduce 348 [oneselect ::= values], go to state 35.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 35.
parser: ... then shift 'select', go to state 297
parser: Reduce 152 [upsert ::=].
parser: ... then shift 'upsert', pending reduce 150
parser: Reduce 150 [cmd ::= with insert_cmd INTO xfullname idlist_opt select upsert], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
parser: [[[;
;SELECT abs(max(t1) OVER (ORDER BY t1)) FROM over GROUP BY t1;;
;SELECT sum(preceding) OVER (
    ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING
  ) FROM over;;
;SELECT max(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002, last_field ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER ( ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY preceding, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
         sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY last_field

;SELECT sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'SEMI' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[ecmd SEMI]
parser: Input 'SELECT' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 1.
parser: ... then shift 'ecmd', pending reduce 318
parser: Reduce 318 [cmdlist ::= cmdlist ecmd], go to state 0.
parser: ... then shift 'cmdlist', go to state 1
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[cmdlist SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct ID LP distinct ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'ORDER' in state 32
parser: Shift 'ORDER', go to state 500
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct ID LP distinct exprlist RP filter_opt OVER LP ORDER]
parser: Input 'BY' in state 500
parser: Shift 'BY', go to state 22
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct ID LP distinct exprlist RP filter_opt OVER LP ORDER BY]
parser: Input 'ID' in state 22
parser: Shift 'ID', go to state 416
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct ID LP distinct exprlist RP filter_opt OVER LP ORDER BY ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 22.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 22.
parser: ... then shift 'sortlist', go to state 184
parser: Reduce 297 [frame_opt ::=].
parser: ... then shift 'frame_opt', pending reduce 293
parser: Reduce 293 [window ::= ORDER BY sortlist frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'RP' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'FROM' in state 192
parser: Reduce 173 [expr ::= ID|INDEXED LP distinct exprlist RP], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[cmdlist SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[cmdlist SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'GROUP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Shift 'GROUP', go to state 499
parser: Return. Stack=[cmdlist SELECT distinct selcollist from where_opt GROUP]
parser: Input 'BY' in state 499
parser: Shift 'BY', go to state 21
parser: Return. Stack=[cmdlist SELECT distinct selcollist from where_opt GROUP BY]
parser: Input 'ID' in state 21
parser: Shift 'ID', go to state 416
parser: Return. Stack=[cmdlist SELECT distinct selcollist from where_opt GROUP BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 21.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 21.
parser: ... then shift 'nexprlist', go to state 498
parser: Reduce 135 [groupby_opt ::= GROUP BY nexprlist], go to state 359.
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 1.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 1.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdlist cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping cmdlist
parser: [[[;
;SELECT sum(preceding) OVER (
    ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING
  ) FROM over;;
;SELECT max(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002, last_field ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER ( ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY preceding, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
         sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY last_field

;SELECT sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'SEMI' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[ecmd SEMI]
parser: Input 'SELECT' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 1.
parser: ... then shift 'ecmd', pending reduce 318
parser: Reduce 318 [cmdlist ::= cmdlist ecmd], go to state 0.
parser: ... then shift 'cmdlist', go to state 1
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[cmdlist SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP]
parser: Input 'PRECEDING' in state 266
parser: FALLBACK PRECEDING => ID
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct PRECEDING]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'ORDER' in state 32
parser: Shift 'ORDER', go to state 500
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER]
parser: Input 'BY' in state 500
parser: Shift 'BY', go to state 22
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY]
parser: Input 'FOLLOWING' in state 22
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY FOLLOWING]
parser: Input 'RANGE' in state 416
parser: FALLBACK RANGE => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 22.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK RANGE => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 22.
parser: ... then shift 'sortlist', go to state 184
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY sortlist RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 184.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY sortlist range_or_rows BETWEEN]
parser: Input 'CURRENT' in state 8
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY sortlist range_or_rows BETWEEN CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY sortlist range_or_rows BETWEEN CURRENT ROW]
parser: Input 'AND' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 8.
parser: ... then shift 'frame_bound', pending reduce 301
parser: Reduce 301 [frame_bound_s ::= frame_bound], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY sortlist range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'UNBOUNDED' in state 7
parser: Shift 'UNBOUNDED', go to state 505
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY sortlist range_or_rows BETWEEN frame_bound_s AND UNBOUNDED]
parser: Input 'FOLLOWING' in state 505
parser: Shift 'FOLLOWING', pending reduce 304
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY sortlist range_or_rows BETWEEN frame_bound_s AND UNBOUNDED FOLLOWING]
parser: Input 'RP' with pending reduce 304
parser: Reduce 304 [frame_bound_e ::= UNBOUNDED FOLLOWING], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 184.
parser: ... then shift 'frame_opt', pending reduce 293
parser: Reduce 293 [window ::= ORDER BY sortlist frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[cmdlist SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[cmdlist SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'SEMI' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 1.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 1.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdlist cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping cmdlist
parser: [[[;
;SELECT max(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002, last_field ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER ( ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY preceding, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
         sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY last_field

;SELECT sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'SEMI' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[ecmd SEMI]
parser: Input 'SELECT' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 1.
parser: ... then shift 'ecmd', pending reduce 318
parser: Reduce 318 [cmdlist ::= cmdlist ecmd], go to state 0.
parser: ... then shift 'cmdlist', go to state 1
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[cmdlist SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'FOLLOWING' in state 25
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY FOLLOWING]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'FOLLOWING' in state 26
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY FOLLOWING]
parser: Input 'RANGE' in state 416
parser: FALLBACK RANGE => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK RANGE => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK RANGE => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'UNBOUNDED' in state 8
parser: Shift 'UNBOUNDED', go to state 503
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED]
parser: Input 'PRECEDING' in state 503
parser: Shift 'PRECEDING', pending reduce 302
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED PRECEDING]
parser: Input 'AND' with pending reduce 302
parser: Reduce 302 [frame_bound_s ::= UNBOUNDED PRECEDING], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'CURRENT' in state 7
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT ROW]
parser: Input 'RP' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'COMMA' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[cmdlist SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'FOLLOWING' in state 25
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY FOLLOWING]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'FOLLOWING' in state 26
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY FOLLOWING]
parser: Input 'RANGE' in state 416
parser: FALLBACK RANGE => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK RANGE => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK RANGE => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'UNBOUNDED' in state 8
parser: Shift 'UNBOUNDED', go to state 503
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED]
parser: Input 'PRECEDING' in state 503
parser: Shift 'PRECEDING', pending reduce 302
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED PRECEDING]
parser: Input 'AND' with pending reduce 302
parser: Reduce 302 [frame_bound_s ::= UNBOUNDED PRECEDING], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'CURRENT' in state 7
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT ROW]
parser: Input 'RP' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[cmdlist SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[cmdlist SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ORDER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[cmdlist SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[cmdlist SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'FOLLOWING' in state 26
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[cmdlist SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY FOLLOWING]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 1.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 1.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdlist cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping cmdlist
parser: [[[SELECT max(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002, last_field ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER ( ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY preceding, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
         sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY last_field

;SELECT sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'PRECEDING' in state 266
parser: FALLBACK PRECEDING => ID
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct PRECEDING]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'ID' in state 25
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY ID]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY ID]
parser: Input 'RANGE' in state 416
parser: FALLBACK RANGE => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK RANGE => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK RANGE => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'UNBOUNDED' in state 8
parser: Shift 'UNBOUNDED', go to state 503
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED]
parser: Input 'PRECEDING' in state 503
parser: Shift 'PRECEDING', pending reduce 302
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED PRECEDING]
parser: Input 'AND' with pending reduce 302
parser: Reduce 302 [frame_bound_s ::= UNBOUNDED PRECEDING], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'CURRENT' in state 7
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT ROW]
parser: Input 'RP' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'COMMA' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'PRECEDING' in state 266
parser: FALLBACK PRECEDING => ID
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct PRECEDING]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'ID' in state 25
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist COMMA]
parser: Input 'ID' in state 107
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist COMMA ID]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 107.
parser: ... then shift 'expr', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY ID]
parser: Input 'RANGE' in state 416
parser: FALLBACK RANGE => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK RANGE => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK RANGE => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'UNBOUNDED' in state 8
parser: Shift 'UNBOUNDED', go to state 503
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED]
parser: Input 'PRECEDING' in state 503
parser: Shift 'PRECEDING', pending reduce 302
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED PRECEDING]
parser: Input 'AND' with pending reduce 302
parser: Reduce 302 [frame_bound_s ::= UNBOUNDED PRECEDING], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'CURRENT' in state 7
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT ROW]
parser: Input 'RP' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ORDER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT sum(following) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002, last_field ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER ( ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY preceding, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
         sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY last_field

;SELECT sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'FOLLOWING' in state 266
parser: FALLBACK FOLLOWING => ID
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct FOLLOWING]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'FOLLOWING' in state 25
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY FOLLOWING]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'FOLLOWING' in state 26
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY FOLLOWING]
parser: Input 'RANGE' in state 416
parser: FALLBACK RANGE => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK RANGE => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK RANGE => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'UNBOUNDED' in state 8
parser: Shift 'UNBOUNDED', go to state 503
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED]
parser: Input 'PRECEDING' in state 503
parser: Shift 'PRECEDING', pending reduce 302
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED PRECEDING]
parser: Input 'AND' with pending reduce 302
parser: Reduce 302 [frame_bound_s ::= UNBOUNDED PRECEDING], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'CURRENT' in state 7
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT ROW]
parser: Input 'RP' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'COMMA' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'FOLLOWING' in state 266
parser: FALLBACK FOLLOWING => ID
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct FOLLOWING]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'ORDER' in state 32
parser: Shift 'ORDER', go to state 500
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER]
parser: Input 'BY' in state 500
parser: Shift 'BY', go to state 22
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY]
parser: Input 'FOLLOWING' in state 22
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY FOLLOWING]
parser: Input 'RANGE' in state 416
parser: FALLBACK RANGE => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 22.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK RANGE => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 22.
parser: ... then shift 'sortlist', go to state 184
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY sortlist RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 184.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY sortlist range_or_rows BETWEEN]
parser: Input 'UNBOUNDED' in state 8
parser: Shift 'UNBOUNDED', go to state 503
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY sortlist range_or_rows BETWEEN UNBOUNDED]
parser: Input 'PRECEDING' in state 503
parser: Shift 'PRECEDING', pending reduce 302
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY sortlist range_or_rows BETWEEN UNBOUNDED PRECEDING]
parser: Input 'AND' with pending reduce 302
parser: Reduce 302 [frame_bound_s ::= UNBOUNDED PRECEDING], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY sortlist range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'CURRENT' in state 7
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY sortlist range_or_rows BETWEEN frame_bound_s AND CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY sortlist range_or_rows BETWEEN frame_bound_s AND CURRENT ROW]
parser: Input 'RP' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 184.
parser: ... then shift 'frame_opt', pending reduce 293
parser: Reduce 293 [window ::= ORDER BY sortlist frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ORDER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'FOLLOWING' in state 26
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY FOLLOWING]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT max(last_field) OVER (PARTITION BY test002, last_field ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER ( ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY preceding, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
         sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY last_field

;SELECT sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'ID' in state 25
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist COMMA]
parser: Input 'ID' in state 107
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist COMMA ID]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 107.
parser: ... then shift 'expr', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY ID]
parser: Input 'RANGE' in state 416
parser: FALLBACK RANGE => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK RANGE => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK RANGE => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'UNBOUNDED' in state 8
parser: Shift 'UNBOUNDED', go to state 503
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED]
parser: Input 'PRECEDING' in state 503
parser: Shift 'PRECEDING', pending reduce 302
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED PRECEDING]
parser: Input 'AND' with pending reduce 302
parser: Reduce 302 [frame_bound_s ::= UNBOUNDED PRECEDING], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'CURRENT' in state 7
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT ROW]
parser: Input 'RP' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'COMMA' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'ID' in state 25
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY ID]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY ID]
parser: Input 'RANGE' in state 416
parser: FALLBACK RANGE => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK RANGE => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK RANGE => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'UNBOUNDED' in state 8
parser: Shift 'UNBOUNDED', go to state 503
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED]
parser: Input 'PRECEDING' in state 503
parser: Shift 'PRECEDING', pending reduce 302
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED PRECEDING]
parser: Input 'AND' with pending reduce 302
parser: Reduce 302 [frame_bound_s ::= UNBOUNDED PRECEDING], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'CURRENT' in state 7
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT ROW]
parser: Input 'RP' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ORDER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT max(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY t1, following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER ( ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY preceding, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
         sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY last_field

;SELECT sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'PRECEDING' in state 266
parser: FALLBACK PRECEDING => ID
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct PRECEDING]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'ID' in state 25
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist COMMA]
parser: Input 'FOLLOWING' in state 107
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist COMMA FOLLOWING]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 107.
parser: ... then shift 'expr', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'FOLLOWING' in state 26
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY FOLLOWING]
parser: Input 'RANGE' in state 416
parser: FALLBACK RANGE => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK RANGE => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK RANGE => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'UNBOUNDED' in state 8
parser: Shift 'UNBOUNDED', go to state 503
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED]
parser: Input 'PRECEDING' in state 503
parser: Shift 'PRECEDING', pending reduce 302
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED PRECEDING]
parser: Input 'AND' with pending reduce 302
parser: Reduce 302 [frame_bound_s ::= UNBOUNDED PRECEDING], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'CURRENT' in state 7
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT ROW]
parser: Input 'RP' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'COMMA' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'PRECEDING' in state 266
parser: FALLBACK PRECEDING => ID
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct PRECEDING]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'ID' in state 25
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist COMMA]
parser: Input 'FOLLOWING' in state 107
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist COMMA FOLLOWING]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 107.
parser: ... then shift 'expr', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'FOLLOWING' in state 26
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY FOLLOWING]
parser: Input 'RANGE' in state 416
parser: FALLBACK RANGE => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK RANGE => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK RANGE => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'UNBOUNDED' in state 8
parser: Shift 'UNBOUNDED', go to state 503
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED]
parser: Input 'PRECEDING' in state 503
parser: Shift 'PRECEDING', pending reduce 302
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED PRECEDING]
parser: Input 'AND' with pending reduce 302
parser: Reduce 302 [frame_bound_s ::= UNBOUNDED PRECEDING], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'CURRENT' in state 7
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT ROW]
parser: Input 'RP' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ORDER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'FOLLOWING' in state 26
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY FOLLOWING]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER ( ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY preceding, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
         sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY last_field

;SELECT sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'ID' in state 25
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist COMMA]
parser: Input 'ID' in state 107
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist COMMA ID]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 107.
parser: ... then shift 'expr', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY ID]
parser: Input 'RANGE' in state 416
parser: FALLBACK RANGE => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK RANGE => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK RANGE => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'UNBOUNDED' in state 8
parser: Shift 'UNBOUNDED', go to state 503
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED]
parser: Input 'PRECEDING' in state 503
parser: Shift 'PRECEDING', pending reduce 302
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED PRECEDING]
parser: Input 'AND' with pending reduce 302
parser: Reduce 302 [frame_bound_s ::= UNBOUNDED PRECEDING], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'CURRENT' in state 7
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT ROW]
parser: Input 'RP' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'COMMA' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'ID' in state 25
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist COMMA]
parser: Input 'ID' in state 107
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist COMMA ID]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 107.
parser: ... then shift 'expr', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY ID]
parser: Input 'RANGE' in state 416
parser: FALLBACK RANGE => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK RANGE => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK RANGE => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'UNBOUNDED' in state 8
parser: Shift 'UNBOUNDED', go to state 503
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED]
parser: Input 'PRECEDING' in state 503
parser: Shift 'PRECEDING', pending reduce 302
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED PRECEDING]
parser: Input 'AND' with pending reduce 302
parser: Reduce 302 [frame_bound_s ::= UNBOUNDED PRECEDING], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'CURRENT' in state 7
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT ROW]
parser: Input 'RP' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ORDER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT max(last_field) OVER (PARTITION BY last_field, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER ( ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY preceding, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
         sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY last_field

;SELECT sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'ID' in state 25
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist COMMA]
parser: Input 'ID' in state 107
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist COMMA ID]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 107.
parser: ... then shift 'expr', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY ID]
parser: Input 'RANGE' in state 416
parser: FALLBACK RANGE => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK RANGE => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK RANGE => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'UNBOUNDED' in state 8
parser: Shift 'UNBOUNDED', go to state 503
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED]
parser: Input 'PRECEDING' in state 503
parser: Shift 'PRECEDING', pending reduce 302
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED PRECEDING]
parser: Input 'AND' with pending reduce 302
parser: Reduce 302 [frame_bound_s ::= UNBOUNDED PRECEDING], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'CURRENT' in state 7
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT ROW]
parser: Input 'RP' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'COMMA' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'ID' in state 25
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY ID]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY ID]
parser: Input 'RANGE' in state 416
parser: FALLBACK RANGE => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK RANGE => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK RANGE => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'UNBOUNDED' in state 8
parser: Shift 'UNBOUNDED', go to state 503
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED]
parser: Input 'PRECEDING' in state 503
parser: Shift 'PRECEDING', pending reduce 302
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED PRECEDING]
parser: Input 'AND' with pending reduce 302
parser: Reduce 302 [frame_bound_s ::= UNBOUNDED PRECEDING], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'CURRENT' in state 7
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT ROW]
parser: Input 'RP' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ORDER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT sum(preceding) OVER ( ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY preceding, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
         sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY last_field

;SELECT sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'PRECEDING' in state 266
parser: FALLBACK PRECEDING => ID
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct PRECEDING]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'ORDER' in state 32
parser: Shift 'ORDER', go to state 500
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER]
parser: Input 'BY' in state 500
parser: Shift 'BY', go to state 22
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY]
parser: Input 'PRECEDING' in state 22
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY PRECEDING]
parser: Input 'RANGE' in state 416
parser: FALLBACK RANGE => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 22.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK RANGE => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 22.
parser: ... then shift 'sortlist', go to state 184
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY sortlist RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 184.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY sortlist range_or_rows BETWEEN]
parser: Input 'UNBOUNDED' in state 8
parser: Shift 'UNBOUNDED', go to state 503
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY sortlist range_or_rows BETWEEN UNBOUNDED]
parser: Input 'PRECEDING' in state 503
parser: Shift 'PRECEDING', pending reduce 302
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY sortlist range_or_rows BETWEEN UNBOUNDED PRECEDING]
parser: Input 'AND' with pending reduce 302
parser: Reduce 302 [frame_bound_s ::= UNBOUNDED PRECEDING], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY sortlist range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'CURRENT' in state 7
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY sortlist range_or_rows BETWEEN frame_bound_s AND CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY sortlist range_or_rows BETWEEN frame_bound_s AND CURRENT ROW]
parser: Input 'RP' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 184.
parser: ... then shift 'frame_opt', pending reduce 293
parser: Reduce 293 [window ::= ORDER BY sortlist frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'COMMA' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'PRECEDING' in state 266
parser: FALLBACK PRECEDING => ID
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct PRECEDING]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'FOLLOWING' in state 25
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY FOLLOWING]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'PRECEDING' in state 26
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY PRECEDING]
parser: Input 'RANGE' in state 416
parser: FALLBACK RANGE => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK RANGE => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK RANGE => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'UNBOUNDED' in state 8
parser: Shift 'UNBOUNDED', go to state 503
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED]
parser: Input 'PRECEDING' in state 503
parser: Shift 'PRECEDING', pending reduce 302
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED PRECEDING]
parser: Input 'AND' with pending reduce 302
parser: Reduce 302 [frame_bound_s ::= UNBOUNDED PRECEDING], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'CURRENT' in state 7
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT ROW]
parser: Input 'RP' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ORDER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'PRECEDING' in state 26
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY PRECEDING]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001, test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY preceding, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
         sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY last_field

;SELECT sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'ORDER' in state 32
parser: Shift 'ORDER', go to state 500
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER]
parser: Input 'BY' in state 500
parser: Shift 'BY', go to state 22
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY]
parser: Input 'ID' in state 22
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY ID]
parser: Input 'RANGE' in state 416
parser: FALLBACK RANGE => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 22.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK RANGE => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 22.
parser: ... then shift 'sortlist', go to state 184
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY sortlist RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 184.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY sortlist range_or_rows BETWEEN]
parser: Input 'UNBOUNDED' in state 8
parser: Shift 'UNBOUNDED', go to state 503
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY sortlist range_or_rows BETWEEN UNBOUNDED]
parser: Input 'PRECEDING' in state 503
parser: Shift 'PRECEDING', pending reduce 302
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY sortlist range_or_rows BETWEEN UNBOUNDED PRECEDING]
parser: Input 'AND' with pending reduce 302
parser: Reduce 302 [frame_bound_s ::= UNBOUNDED PRECEDING], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY sortlist range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'CURRENT' in state 7
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY sortlist range_or_rows BETWEEN frame_bound_s AND CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY sortlist range_or_rows BETWEEN frame_bound_s AND CURRENT ROW]
parser: Input 'RP' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 184.
parser: ... then shift 'frame_opt', pending reduce 293
parser: Reduce 293 [window ::= ORDER BY sortlist frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'COMMA' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'ID' in state 25
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist COMMA]
parser: Input 'ID' in state 107
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist COMMA ID]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 107.
parser: ... then shift 'expr', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY ID]
parser: Input 'RANGE' in state 416
parser: FALLBACK RANGE => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK RANGE => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK RANGE => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'UNBOUNDED' in state 8
parser: Shift 'UNBOUNDED', go to state 503
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED]
parser: Input 'PRECEDING' in state 503
parser: Shift 'PRECEDING', pending reduce 302
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED PRECEDING]
parser: Input 'AND' with pending reduce 302
parser: Reduce 302 [frame_bound_s ::= UNBOUNDED PRECEDING], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'CURRENT' in state 7
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT ROW]
parser: Input 'RP' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ORDER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT max(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER ( ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY preceding, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
         sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY last_field

;SELECT sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'ORDER' in state 32
parser: Shift 'ORDER', go to state 500
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER]
parser: Input 'BY' in state 500
parser: Shift 'BY', go to state 22
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY]
parser: Input 'FOLLOWING' in state 22
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY FOLLOWING]
parser: Input 'RANGE' in state 416
parser: FALLBACK RANGE => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 22.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK RANGE => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 22.
parser: ... then shift 'sortlist', go to state 184
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY sortlist RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 184.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY sortlist range_or_rows BETWEEN]
parser: Input 'UNBOUNDED' in state 8
parser: Shift 'UNBOUNDED', go to state 503
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY sortlist range_or_rows BETWEEN UNBOUNDED]
parser: Input 'PRECEDING' in state 503
parser: Shift 'PRECEDING', pending reduce 302
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY sortlist range_or_rows BETWEEN UNBOUNDED PRECEDING]
parser: Input 'AND' with pending reduce 302
parser: Reduce 302 [frame_bound_s ::= UNBOUNDED PRECEDING], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY sortlist range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'CURRENT' in state 7
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY sortlist range_or_rows BETWEEN frame_bound_s AND CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY sortlist range_or_rows BETWEEN frame_bound_s AND CURRENT ROW]
parser: Input 'RP' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 184.
parser: ... then shift 'frame_opt', pending reduce 293
parser: Reduce 293 [window ::= ORDER BY sortlist frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'COMMA' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'ORDER' in state 32
parser: Shift 'ORDER', go to state 500
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER]
parser: Input 'BY' in state 500
parser: Shift 'BY', go to state 22
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY]
parser: Input 'FOLLOWING' in state 22
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY FOLLOWING]
parser: Input 'RANGE' in state 416
parser: FALLBACK RANGE => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 22.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK RANGE => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 22.
parser: ... then shift 'sortlist', go to state 184
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY sortlist RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 184.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY sortlist range_or_rows BETWEEN]
parser: Input 'UNBOUNDED' in state 8
parser: Shift 'UNBOUNDED', go to state 503
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY sortlist range_or_rows BETWEEN UNBOUNDED]
parser: Input 'PRECEDING' in state 503
parser: Shift 'PRECEDING', pending reduce 302
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY sortlist range_or_rows BETWEEN UNBOUNDED PRECEDING]
parser: Input 'AND' with pending reduce 302
parser: Reduce 302 [frame_bound_s ::= UNBOUNDED PRECEDING], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY sortlist range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'CURRENT' in state 7
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY sortlist range_or_rows BETWEEN frame_bound_s AND CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY sortlist range_or_rows BETWEEN frame_bound_s AND CURRENT ROW]
parser: Input 'RP' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 184.
parser: ... then shift 'frame_opt', pending reduce 293
parser: Reduce 293 [window ::= ORDER BY sortlist frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ORDER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'FOLLOWING' in state 26
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY FOLLOWING]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT max(test002) OVER ( ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY preceding, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
         sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY last_field

;SELECT sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'ORDER' in state 32
parser: Shift 'ORDER', go to state 500
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER]
parser: Input 'BY' in state 500
parser: Shift 'BY', go to state 22
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY]
parser: Input 'ID' in state 22
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY ID]
parser: Input 'RANGE' in state 416
parser: FALLBACK RANGE => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 22.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK RANGE => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 22.
parser: ... then shift 'sortlist', go to state 184
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY sortlist RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 184.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY sortlist range_or_rows BETWEEN]
parser: Input 'UNBOUNDED' in state 8
parser: Shift 'UNBOUNDED', go to state 503
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY sortlist range_or_rows BETWEEN UNBOUNDED]
parser: Input 'PRECEDING' in state 503
parser: Shift 'PRECEDING', pending reduce 302
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY sortlist range_or_rows BETWEEN UNBOUNDED PRECEDING]
parser: Input 'AND' with pending reduce 302
parser: Reduce 302 [frame_bound_s ::= UNBOUNDED PRECEDING], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY sortlist range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'CURRENT' in state 7
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY sortlist range_or_rows BETWEEN frame_bound_s AND CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY sortlist range_or_rows BETWEEN frame_bound_s AND CURRENT ROW]
parser: Input 'RP' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 184.
parser: ... then shift 'frame_opt', pending reduce 293
parser: Reduce 293 [window ::= ORDER BY sortlist frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'COMMA' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'ID' in state 25
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY ID]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY ID]
parser: Input 'RANGE' in state 416
parser: FALLBACK RANGE => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK RANGE => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK RANGE => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'UNBOUNDED' in state 8
parser: Shift 'UNBOUNDED', go to state 503
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED]
parser: Input 'PRECEDING' in state 503
parser: Shift 'PRECEDING', pending reduce 302
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED PRECEDING]
parser: Input 'AND' with pending reduce 302
parser: Reduce 302 [frame_bound_s ::= UNBOUNDED PRECEDING], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'CURRENT' in state 7
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT ROW]
parser: Input 'RP' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ORDER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY preceding, t1 ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
         sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY last_field

;SELECT sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'PRECEDING' in state 266
parser: FALLBACK PRECEDING => ID
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct PRECEDING]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'ID' in state 25
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY ID]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY ID]
parser: Input 'RANGE' in state 416
parser: FALLBACK RANGE => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK RANGE => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK RANGE => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'UNBOUNDED' in state 8
parser: Shift 'UNBOUNDED', go to state 503
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED]
parser: Input 'PRECEDING' in state 503
parser: Shift 'PRECEDING', pending reduce 302
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED PRECEDING]
parser: Input 'AND' with pending reduce 302
parser: Reduce 302 [frame_bound_s ::= UNBOUNDED PRECEDING], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'CURRENT' in state 7
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT ROW]
parser: Input 'RP' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'COMMA' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'PRECEDING' in state 266
parser: FALLBACK PRECEDING => ID
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct PRECEDING]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'PRECEDING' in state 25
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY PRECEDING]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist COMMA]
parser: Input 'ID' in state 107
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist COMMA ID]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 107.
parser: ... then shift 'expr', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY ID]
parser: Input 'RANGE' in state 416
parser: FALLBACK RANGE => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK RANGE => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK RANGE => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'UNBOUNDED' in state 8
parser: Shift 'UNBOUNDED', go to state 503
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED]
parser: Input 'PRECEDING' in state 503
parser: Shift 'PRECEDING', pending reduce 302
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED PRECEDING]
parser: Input 'AND' with pending reduce 302
parser: Reduce 302 [frame_bound_s ::= UNBOUNDED PRECEDING], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'CURRENT' in state 7
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT ROW]
parser: Input 'RP' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ORDER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT max(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
         sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY last_field

;SELECT sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'ID' in state 25
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY ID]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY ID]
parser: Input 'RANGE' in state 416
parser: FALLBACK RANGE => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK RANGE => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK RANGE => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'UNBOUNDED' in state 8
parser: Shift 'UNBOUNDED', go to state 503
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED]
parser: Input 'PRECEDING' in state 503
parser: Shift 'PRECEDING', pending reduce 302
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED PRECEDING]
parser: Input 'AND' with pending reduce 302
parser: Reduce 302 [frame_bound_s ::= UNBOUNDED PRECEDING], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'CURRENT' in state 7
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT ROW]
parser: Input 'RP' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'COMMA' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'ID' in state 25
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY ID]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY ID]
parser: Input 'RANGE' in state 416
parser: FALLBACK RANGE => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK RANGE => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK RANGE => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'UNBOUNDED' in state 8
parser: Shift 'UNBOUNDED', go to state 503
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED]
parser: Input 'PRECEDING' in state 503
parser: Shift 'PRECEDING', pending reduce 302
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED PRECEDING]
parser: Input 'AND' with pending reduce 302
parser: Reduce 302 [frame_bound_s ::= UNBOUNDED PRECEDING], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'CURRENT' in state 7
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT ROW]
parser: Input 'RP' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ORDER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
         sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY last_field

;SELECT sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'ID' in state 25
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY ID]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY ID]
parser: Input 'RANGE' in state 416
parser: FALLBACK RANGE => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK RANGE => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK RANGE => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'UNBOUNDED' in state 8
parser: Shift 'UNBOUNDED', go to state 503
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED]
parser: Input 'PRECEDING' in state 503
parser: Shift 'PRECEDING', pending reduce 302
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED PRECEDING]
parser: Input 'AND' with pending reduce 302
parser: Reduce 302 [frame_bound_s ::= UNBOUNDED PRECEDING], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'CURRENT' in state 7
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT ROW]
parser: Input 'RP' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'COMMA' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'ID' in state 25
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY ID]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY ID]
parser: Input 'RANGE' in state 416
parser: FALLBACK RANGE => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK RANGE => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK RANGE => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'UNBOUNDED' in state 8
parser: Shift 'UNBOUNDED', go to state 503
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED]
parser: Input 'PRECEDING' in state 503
parser: Shift 'PRECEDING', pending reduce 302
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED PRECEDING]
parser: Input 'AND' with pending reduce 302
parser: Reduce 302 [frame_bound_s ::= UNBOUNDED PRECEDING], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'CURRENT' in state 7
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT ROW]
parser: Input 'RP' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ORDER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT max(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
         sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY last_field

;SELECT sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'FOLLOWING' in state 266
parser: FALLBACK FOLLOWING => ID
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct FOLLOWING]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'PRECEDING' in state 25
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY PRECEDING]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'PRECEDING' in state 26
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY PRECEDING]
parser: Input 'RANGE' in state 416
parser: FALLBACK RANGE => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK RANGE => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK RANGE => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'UNBOUNDED' in state 8
parser: Shift 'UNBOUNDED', go to state 503
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED]
parser: Input 'PRECEDING' in state 503
parser: Shift 'PRECEDING', pending reduce 302
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED PRECEDING]
parser: Input 'AND' with pending reduce 302
parser: Reduce 302 [frame_bound_s ::= UNBOUNDED PRECEDING], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'CURRENT' in state 7
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT ROW]
parser: Input 'RP' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'COMMA' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'FOLLOWING' in state 266
parser: FALLBACK FOLLOWING => ID
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct FOLLOWING]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'PRECEDING' in state 25
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY PRECEDING]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'PRECEDING' in state 26
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY PRECEDING]
parser: Input 'RANGE' in state 416
parser: FALLBACK RANGE => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK RANGE => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK RANGE => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'UNBOUNDED' in state 8
parser: Shift 'UNBOUNDED', go to state 503
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED]
parser: Input 'PRECEDING' in state 503
parser: Shift 'PRECEDING', pending reduce 302
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED PRECEDING]
parser: Input 'AND' with pending reduce 302
parser: Reduce 302 [frame_bound_s ::= UNBOUNDED PRECEDING], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'CURRENT' in state 7
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT ROW]
parser: Input 'RP' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ORDER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'PRECEDING' in state 26
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY PRECEDING]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
         sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY last_field

;SELECT sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'PRECEDING' in state 266
parser: FALLBACK PRECEDING => ID
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct PRECEDING]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'ID' in state 25
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY ID]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'FOLLOWING' in state 26
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY FOLLOWING]
parser: Input 'RANGE' in state 416
parser: FALLBACK RANGE => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK RANGE => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK RANGE => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'UNBOUNDED' in state 8
parser: Shift 'UNBOUNDED', go to state 503
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED]
parser: Input 'PRECEDING' in state 503
parser: Shift 'PRECEDING', pending reduce 302
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED PRECEDING]
parser: Input 'AND' with pending reduce 302
parser: Reduce 302 [frame_bound_s ::= UNBOUNDED PRECEDING], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'CURRENT' in state 7
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT ROW]
parser: Input 'RP' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'COMMA' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'PRECEDING' in state 266
parser: FALLBACK PRECEDING => ID
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct PRECEDING]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'ID' in state 25
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY ID]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'FOLLOWING' in state 26
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY FOLLOWING]
parser: Input 'RANGE' in state 416
parser: FALLBACK RANGE => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK RANGE => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK RANGE => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'UNBOUNDED' in state 8
parser: Shift 'UNBOUNDED', go to state 503
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED]
parser: Input 'PRECEDING' in state 503
parser: Shift 'PRECEDING', pending reduce 302
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED PRECEDING]
parser: Input 'AND' with pending reduce 302
parser: Reduce 302 [frame_bound_s ::= UNBOUNDED PRECEDING], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'CURRENT' in state 7
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT ROW]
parser: Input 'RP' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ORDER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'FOLLOWING' in state 26
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY FOLLOWING]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT max(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
         sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY last_field

;SELECT sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'ID' in state 25
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY ID]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'FOLLOWING' in state 26
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY FOLLOWING]
parser: Input 'RANGE' in state 416
parser: FALLBACK RANGE => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK RANGE => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK RANGE => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'UNBOUNDED' in state 8
parser: Shift 'UNBOUNDED', go to state 503
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED]
parser: Input 'PRECEDING' in state 503
parser: Shift 'PRECEDING', pending reduce 302
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED PRECEDING]
parser: Input 'AND' with pending reduce 302
parser: Reduce 302 [frame_bound_s ::= UNBOUNDED PRECEDING], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'CURRENT' in state 7
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT ROW]
parser: Input 'RP' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'COMMA' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'ID' in state 25
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY ID]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'FOLLOWING' in state 26
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY FOLLOWING]
parser: Input 'RANGE' in state 416
parser: FALLBACK RANGE => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK RANGE => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK RANGE => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'UNBOUNDED' in state 8
parser: Shift 'UNBOUNDED', go to state 503
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED]
parser: Input 'PRECEDING' in state 503
parser: Shift 'PRECEDING', pending reduce 302
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED PRECEDING]
parser: Input 'AND' with pending reduce 302
parser: Reduce 302 [frame_bound_s ::= UNBOUNDED PRECEDING], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'UNBOUNDED' in state 7
parser: Shift 'UNBOUNDED', go to state 505
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND UNBOUNDED]
parser: Input 'FOLLOWING' in state 505
parser: Shift 'FOLLOWING', pending reduce 304
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND UNBOUNDED FOLLOWING]
parser: Input 'RP' with pending reduce 304
parser: Reduce 304 [frame_bound_e ::= UNBOUNDED FOLLOWING], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ORDER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'FOLLOWING' in state 26
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY FOLLOWING]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test001) OVER (PARTITION BY test002 ORDER BY last_field RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
         sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY last_field

;SELECT sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'ID' in state 25
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY ID]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY ID]
parser: Input 'RANGE' in state 416
parser: FALLBACK RANGE => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK RANGE => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK RANGE => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'UNBOUNDED' in state 8
parser: Shift 'UNBOUNDED', go to state 503
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED]
parser: Input 'PRECEDING' in state 503
parser: Shift 'PRECEDING', pending reduce 302
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED PRECEDING]
parser: Input 'AND' with pending reduce 302
parser: Reduce 302 [frame_bound_s ::= UNBOUNDED PRECEDING], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'CURRENT' in state 7
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT ROW]
parser: Input 'RP' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'COMMA' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'ID' in state 25
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY ID]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY ID]
parser: Input 'RANGE' in state 416
parser: FALLBACK RANGE => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK RANGE => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK RANGE => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'UNBOUNDED' in state 8
parser: Shift 'UNBOUNDED', go to state 503
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED]
parser: Input 'PRECEDING' in state 503
parser: Shift 'PRECEDING', pending reduce 302
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED PRECEDING]
parser: Input 'AND' with pending reduce 302
parser: Reduce 302 [frame_bound_s ::= UNBOUNDED PRECEDING], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'UNBOUNDED' in state 7
parser: Shift 'UNBOUNDED', go to state 505
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND UNBOUNDED]
parser: Input 'FOLLOWING' in state 505
parser: Shift 'FOLLOWING', pending reduce 304
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND UNBOUNDED FOLLOWING]
parser: Input 'RP' with pending reduce 304
parser: Reduce 304 [frame_bound_e ::= UNBOUNDED FOLLOWING], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ORDER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT max(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
         sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY last_field

;SELECT sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'FOLLOWING' in state 266
parser: FALLBACK FOLLOWING => ID
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct FOLLOWING]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'PRECEDING' in state 25
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY PRECEDING]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'FOLLOWING' in state 26
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY FOLLOWING]
parser: Input 'RANGE' in state 416
parser: FALLBACK RANGE => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK RANGE => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK RANGE => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'UNBOUNDED' in state 8
parser: Shift 'UNBOUNDED', go to state 503
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED]
parser: Input 'PRECEDING' in state 503
parser: Shift 'PRECEDING', pending reduce 302
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED PRECEDING]
parser: Input 'AND' with pending reduce 302
parser: Reduce 302 [frame_bound_s ::= UNBOUNDED PRECEDING], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'CURRENT' in state 7
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT ROW]
parser: Input 'RP' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'COMMA' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'FOLLOWING' in state 266
parser: FALLBACK FOLLOWING => ID
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct FOLLOWING]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'PRECEDING' in state 25
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY PRECEDING]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'FOLLOWING' in state 26
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY FOLLOWING]
parser: Input 'RANGE' in state 416
parser: FALLBACK RANGE => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK RANGE => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK RANGE => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'CURRENT' in state 8
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN CURRENT ROW]
parser: Input 'AND' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 8.
parser: ... then shift 'frame_bound', pending reduce 301
parser: Reduce 301 [frame_bound_s ::= frame_bound], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'UNBOUNDED' in state 7
parser: Shift 'UNBOUNDED', go to state 505
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND UNBOUNDED]
parser: Input 'FOLLOWING' in state 505
parser: Shift 'FOLLOWING', pending reduce 304
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND UNBOUNDED FOLLOWING]
parser: Input 'RP' with pending reduce 304
parser: Reduce 304 [frame_bound_e ::= UNBOUNDED FOLLOWING], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ORDER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'FOLLOWING' in state 26
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY FOLLOWING]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
         sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY last_field

;SELECT sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'ID' in state 25
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY ID]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY ID]
parser: Input 'RANGE' in state 416
parser: FALLBACK RANGE => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK RANGE => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK RANGE => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'UNBOUNDED' in state 8
parser: Shift 'UNBOUNDED', go to state 503
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED]
parser: Input 'PRECEDING' in state 503
parser: Shift 'PRECEDING', pending reduce 302
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED PRECEDING]
parser: Input 'AND' with pending reduce 302
parser: Reduce 302 [frame_bound_s ::= UNBOUNDED PRECEDING], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'UNBOUNDED' in state 7
parser: Shift 'UNBOUNDED', go to state 505
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND UNBOUNDED]
parser: Input 'FOLLOWING' in state 505
parser: Shift 'FOLLOWING', pending reduce 304
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND UNBOUNDED FOLLOWING]
parser: Input 'RP' with pending reduce 304
parser: Reduce 304 [frame_bound_e ::= UNBOUNDED FOLLOWING], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'COMMA' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'ID' in state 25
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY ID]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY ID]
parser: Input 'RANGE' in state 416
parser: FALLBACK RANGE => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK RANGE => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK RANGE => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'UNBOUNDED' in state 8
parser: Shift 'UNBOUNDED', go to state 503
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED]
parser: Input 'PRECEDING' in state 503
parser: Shift 'PRECEDING', pending reduce 302
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED PRECEDING]
parser: Input 'AND' with pending reduce 302
parser: Reduce 302 [frame_bound_s ::= UNBOUNDED PRECEDING], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'CURRENT' in state 7
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT ROW]
parser: Input 'RP' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ORDER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
         sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY last_field

;SELECT sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'FOLLOWING' in state 266
parser: FALLBACK FOLLOWING => ID
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct FOLLOWING]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'PRECEDING' in state 25
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY PRECEDING]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'FOLLOWING' in state 26
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY FOLLOWING]
parser: Input 'RANGE' in state 416
parser: FALLBACK RANGE => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK RANGE => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK RANGE => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'UNBOUNDED' in state 8
parser: Shift 'UNBOUNDED', go to state 503
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED]
parser: Input 'PRECEDING' in state 503
parser: Shift 'PRECEDING', pending reduce 302
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED PRECEDING]
parser: Input 'AND' with pending reduce 302
parser: Reduce 302 [frame_bound_s ::= UNBOUNDED PRECEDING], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'UNBOUNDED' in state 7
parser: Shift 'UNBOUNDED', go to state 505
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND UNBOUNDED]
parser: Input 'FOLLOWING' in state 505
parser: Shift 'FOLLOWING', pending reduce 304
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND UNBOUNDED FOLLOWING]
parser: Input 'RP' with pending reduce 304
parser: Reduce 304 [frame_bound_e ::= UNBOUNDED FOLLOWING], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'COMMA' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'FOLLOWING' in state 266
parser: FALLBACK FOLLOWING => ID
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct FOLLOWING]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'PRECEDING' in state 25
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY PRECEDING]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'FOLLOWING' in state 26
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY FOLLOWING]
parser: Input 'RANGE' in state 416
parser: FALLBACK RANGE => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK RANGE => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK RANGE => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'UNBOUNDED' in state 8
parser: Shift 'UNBOUNDED', go to state 503
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED]
parser: Input 'PRECEDING' in state 503
parser: Shift 'PRECEDING', pending reduce 302
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED PRECEDING]
parser: Input 'AND' with pending reduce 302
parser: Reduce 302 [frame_bound_s ::= UNBOUNDED PRECEDING], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'UNBOUNDED' in state 7
parser: Shift 'UNBOUNDED', go to state 505
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND UNBOUNDED]
parser: Input 'FOLLOWING' in state 505
parser: Shift 'FOLLOWING', pending reduce 304
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND UNBOUNDED FOLLOWING]
parser: Input 'RP' with pending reduce 304
parser: Reduce 304 [frame_bound_e ::= UNBOUNDED FOLLOWING], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ORDER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'FOLLOWING' in state 26
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY FOLLOWING]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY preceding ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
         sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY last_field

;SELECT sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'PRECEDING' in state 266
parser: FALLBACK PRECEDING => ID
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct PRECEDING]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'PRECEDING' in state 25
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY PRECEDING]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY ID]
parser: Input 'RANGE' in state 416
parser: FALLBACK RANGE => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK RANGE => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK RANGE => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'UNBOUNDED' in state 8
parser: Shift 'UNBOUNDED', go to state 503
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED]
parser: Input 'PRECEDING' in state 503
parser: Shift 'PRECEDING', pending reduce 302
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED PRECEDING]
parser: Input 'AND' with pending reduce 302
parser: Reduce 302 [frame_bound_s ::= UNBOUNDED PRECEDING], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'UNBOUNDED' in state 7
parser: Shift 'UNBOUNDED', go to state 505
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND UNBOUNDED]
parser: Input 'FOLLOWING' in state 505
parser: Shift 'FOLLOWING', pending reduce 304
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND UNBOUNDED FOLLOWING]
parser: Input 'RP' with pending reduce 304
parser: Reduce 304 [frame_bound_e ::= UNBOUNDED FOLLOWING], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'COMMA' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'PRECEDING' in state 266
parser: FALLBACK PRECEDING => ID
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct PRECEDING]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'PRECEDING' in state 25
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY PRECEDING]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY ID]
parser: Input 'RANGE' in state 416
parser: FALLBACK RANGE => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK RANGE => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK RANGE => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'CURRENT' in state 8
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN CURRENT ROW]
parser: Input 'AND' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 8.
parser: ... then shift 'frame_bound', pending reduce 301
parser: Reduce 301 [frame_bound_s ::= frame_bound], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'CURRENT' in state 7
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT ROW]
parser: Input 'RP' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ORDER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT max(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 
  min(test002) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
         sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY last_field

;SELECT sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'ID' in state 25
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY ID]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY ID]
parser: Input 'RANGE' in state 416
parser: FALLBACK RANGE => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK RANGE => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK RANGE => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'UNBOUNDED' in state 8
parser: Shift 'UNBOUNDED', go to state 503
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED]
parser: Input 'PRECEDING' in state 503
parser: Shift 'PRECEDING', pending reduce 302
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED PRECEDING]
parser: Input 'AND' with pending reduce 302
parser: Reduce 302 [frame_bound_s ::= UNBOUNDED PRECEDING], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'UNBOUNDED' in state 7
parser: Shift 'UNBOUNDED', go to state 505
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND UNBOUNDED]
parser: Input 'FOLLOWING' in state 505
parser: Shift 'FOLLOWING', pending reduce 304
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND UNBOUNDED FOLLOWING]
parser: Input 'RP' with pending reduce 304
parser: Reduce 304 [frame_bound_e ::= UNBOUNDED FOLLOWING], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'COMMA' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'ID' in state 25
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY ID]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY ID]
parser: Input 'RANGE' in state 416
parser: FALLBACK RANGE => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK RANGE => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK RANGE => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'CURRENT' in state 8
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN CURRENT ROW]
parser: Input 'AND' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 8.
parser: ... then shift 'frame_bound', pending reduce 301
parser: Reduce 301 [frame_bound_s ::= frame_bound], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'UNBOUNDED' in state 7
parser: Shift 'UNBOUNDED', go to state 505
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND UNBOUNDED]
parser: Input 'FOLLOWING' in state 505
parser: Shift 'FOLLOWING', pending reduce 304
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND UNBOUNDED FOLLOWING]
parser: Input 'RP' with pending reduce 304
parser: Reduce 304 [frame_bound_e ::= UNBOUNDED FOLLOWING], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ORDER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
         sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY last_field

;SELECT sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'ID' in state 25
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY ID]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY ID]
parser: Input 'RANGE' in state 416
parser: FALLBACK RANGE => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK RANGE => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK RANGE => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'CURRENT' in state 8
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN CURRENT ROW]
parser: Input 'AND' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 8.
parser: ... then shift 'frame_bound', pending reduce 301
parser: Reduce 301 [frame_bound_s ::= frame_bound], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'CURRENT' in state 7
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT ROW]
parser: Input 'RP' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'COMMA' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'ID' in state 25
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY ID]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY ID]
parser: Input 'RANGE' in state 416
parser: FALLBACK RANGE => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK RANGE => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK RANGE => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'UNBOUNDED' in state 8
parser: Shift 'UNBOUNDED', go to state 503
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED]
parser: Input 'PRECEDING' in state 503
parser: Shift 'PRECEDING', pending reduce 302
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED PRECEDING]
parser: Input 'AND' with pending reduce 302
parser: Reduce 302 [frame_bound_s ::= UNBOUNDED PRECEDING], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'CURRENT' in state 7
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT ROW]
parser: Input 'RP' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ORDER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
         sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY last_field

;SELECT sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'ID' in state 25
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY ID]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY ID]
parser: Input 'RANGE' in state 416
parser: FALLBACK RANGE => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK RANGE => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK RANGE => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'CURRENT' in state 8
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN CURRENT ROW]
parser: Input 'AND' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 8.
parser: ... then shift 'frame_bound', pending reduce 301
parser: Reduce 301 [frame_bound_s ::= frame_bound], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'CURRENT' in state 7
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT ROW]
parser: Input 'RP' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'COMMA' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'ID' in state 25
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY ID]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY ID]
parser: Input 'RANGE' in state 416
parser: FALLBACK RANGE => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK RANGE => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK RANGE => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'UNBOUNDED' in state 8
parser: Shift 'UNBOUNDED', go to state 503
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED]
parser: Input 'PRECEDING' in state 503
parser: Shift 'PRECEDING', pending reduce 302
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED PRECEDING]
parser: Input 'AND' with pending reduce 302
parser: Reduce 302 [frame_bound_s ::= UNBOUNDED PRECEDING], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'UNBOUNDED' in state 7
parser: Shift 'UNBOUNDED', go to state 505
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND UNBOUNDED]
parser: Input 'FOLLOWING' in state 505
parser: Shift 'FOLLOWING', pending reduce 304
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND UNBOUNDED FOLLOWING]
parser: Input 'RP' with pending reduce 304
parser: Reduce 304 [frame_bound_e ::= UNBOUNDED FOLLOWING], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ORDER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
         sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY last_field

;SELECT sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'FOLLOWING' in state 266
parser: FALLBACK FOLLOWING => ID
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct FOLLOWING]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'ID' in state 25
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY ID]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'PRECEDING' in state 26
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY PRECEDING]
parser: Input 'RANGE' in state 416
parser: FALLBACK RANGE => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK RANGE => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK RANGE => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'CURRENT' in state 8
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN CURRENT ROW]
parser: Input 'AND' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 8.
parser: ... then shift 'frame_bound', pending reduce 301
parser: Reduce 301 [frame_bound_s ::= frame_bound], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'CURRENT' in state 7
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT ROW]
parser: Input 'RP' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'COMMA' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'FOLLOWING' in state 266
parser: FALLBACK FOLLOWING => ID
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct FOLLOWING]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'ID' in state 25
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY ID]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'PRECEDING' in state 26
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY PRECEDING]
parser: Input 'RANGE' in state 416
parser: FALLBACK RANGE => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK RANGE => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK RANGE => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'UNBOUNDED' in state 8
parser: Shift 'UNBOUNDED', go to state 503
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED]
parser: Input 'PRECEDING' in state 503
parser: Shift 'PRECEDING', pending reduce 302
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED PRECEDING]
parser: Input 'AND' with pending reduce 302
parser: Reduce 302 [frame_bound_s ::= UNBOUNDED PRECEDING], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'UNBOUNDED' in state 7
parser: Shift 'UNBOUNDED', go to state 505
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND UNBOUNDED]
parser: Input 'FOLLOWING' in state 505
parser: Shift 'FOLLOWING', pending reduce 304
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND UNBOUNDED FOLLOWING]
parser: Input 'RP' with pending reduce 304
parser: Reduce 304 [frame_bound_e ::= UNBOUNDED FOLLOWING], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ORDER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'PRECEDING' in state 26
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY PRECEDING]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT max(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
  min(following) OVER (PARTITION BY t1 ORDER BY t1 RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
         sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY last_field

;SELECT sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'FOLLOWING' in state 266
parser: FALLBACK FOLLOWING => ID
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct FOLLOWING]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'ID' in state 25
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY ID]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY ID]
parser: Input 'RANGE' in state 416
parser: FALLBACK RANGE => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK RANGE => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK RANGE => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'CURRENT' in state 8
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN CURRENT ROW]
parser: Input 'AND' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 8.
parser: ... then shift 'frame_bound', pending reduce 301
parser: Reduce 301 [frame_bound_s ::= frame_bound], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'CURRENT' in state 7
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT ROW]
parser: Input 'RP' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'COMMA' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'FOLLOWING' in state 266
parser: FALLBACK FOLLOWING => ID
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct FOLLOWING]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'ID' in state 25
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY ID]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY ID]
parser: Input 'RANGE' in state 416
parser: FALLBACK RANGE => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK RANGE => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK RANGE => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'CURRENT' in state 8
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN CURRENT ROW]
parser: Input 'AND' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 8.
parser: ... then shift 'frame_bound', pending reduce 301
parser: Reduce 301 [frame_bound_s ::= frame_bound], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'CURRENT' in state 7
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT ROW]
parser: Input 'RP' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ORDER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT max(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
         sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY last_field

;SELECT sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'ID' in state 25
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY ID]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'FOLLOWING' in state 26
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY FOLLOWING]
parser: Input 'RANGE' in state 416
parser: FALLBACK RANGE => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK RANGE => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK RANGE => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'CURRENT' in state 8
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN CURRENT ROW]
parser: Input 'AND' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 8.
parser: ... then shift 'frame_bound', pending reduce 301
parser: Reduce 301 [frame_bound_s ::= frame_bound], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'CURRENT' in state 7
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT ROW]
parser: Input 'RP' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'COMMA' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'ID' in state 25
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY ID]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'FOLLOWING' in state 26
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY FOLLOWING]
parser: Input 'RANGE' in state 416
parser: FALLBACK RANGE => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK RANGE => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK RANGE => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'CURRENT' in state 8
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN CURRENT ROW]
parser: Input 'AND' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 8.
parser: ... then shift 'frame_bound', pending reduce 301
parser: Reduce 301 [frame_bound_s ::= frame_bound], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'UNBOUNDED' in state 7
parser: Shift 'UNBOUNDED', go to state 505
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND UNBOUNDED]
parser: Input 'FOLLOWING' in state 505
parser: Shift 'FOLLOWING', pending reduce 304
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND UNBOUNDED FOLLOWING]
parser: Input 'RP' with pending reduce 304
parser: Reduce 304 [frame_bound_e ::= UNBOUNDED FOLLOWING], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ORDER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'FOLLOWING' in state 26
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY FOLLOWING]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT max(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
  min(last_field) OVER (PARTITION BY test002 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
         sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY last_field

;SELECT sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'ID' in state 25
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY ID]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY ID]
parser: Input 'RANGE' in state 416
parser: FALLBACK RANGE => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK RANGE => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK RANGE => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'CURRENT' in state 8
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN CURRENT ROW]
parser: Input 'AND' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 8.
parser: ... then shift 'frame_bound', pending reduce 301
parser: Reduce 301 [frame_bound_s ::= frame_bound], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'UNBOUNDED' in state 7
parser: Shift 'UNBOUNDED', go to state 505
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND UNBOUNDED]
parser: Input 'FOLLOWING' in state 505
parser: Shift 'FOLLOWING', pending reduce 304
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND UNBOUNDED FOLLOWING]
parser: Input 'RP' with pending reduce 304
parser: Reduce 304 [frame_bound_e ::= UNBOUNDED FOLLOWING], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'COMMA' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'ID' in state 25
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY ID]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY ID]
parser: Input 'RANGE' in state 416
parser: FALLBACK RANGE => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK RANGE => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK RANGE => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'UNBOUNDED' in state 8
parser: Shift 'UNBOUNDED', go to state 503
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED]
parser: Input 'PRECEDING' in state 503
parser: Shift 'PRECEDING', pending reduce 302
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED PRECEDING]
parser: Input 'AND' with pending reduce 302
parser: Reduce 302 [frame_bound_s ::= UNBOUNDED PRECEDING], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'CURRENT' in state 7
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT ROW]
parser: Input 'RP' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ORDER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
         sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY last_field

;SELECT sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'PRECEDING' in state 266
parser: FALLBACK PRECEDING => ID
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct PRECEDING]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'ID' in state 25
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY ID]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'FOLLOWING' in state 26
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY FOLLOWING]
parser: Input 'RANGE' in state 416
parser: FALLBACK RANGE => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK RANGE => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK RANGE => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'CURRENT' in state 8
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN CURRENT ROW]
parser: Input 'AND' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 8.
parser: ... then shift 'frame_bound', pending reduce 301
parser: Reduce 301 [frame_bound_s ::= frame_bound], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'UNBOUNDED' in state 7
parser: Shift 'UNBOUNDED', go to state 505
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND UNBOUNDED]
parser: Input 'FOLLOWING' in state 505
parser: Shift 'FOLLOWING', pending reduce 304
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND UNBOUNDED FOLLOWING]
parser: Input 'RP' with pending reduce 304
parser: Reduce 304 [frame_bound_e ::= UNBOUNDED FOLLOWING], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'COMMA' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'PRECEDING' in state 266
parser: FALLBACK PRECEDING => ID
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct PRECEDING]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'ID' in state 25
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY ID]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'FOLLOWING' in state 26
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY FOLLOWING]
parser: Input 'RANGE' in state 416
parser: FALLBACK RANGE => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK RANGE => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK RANGE => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'UNBOUNDED' in state 8
parser: Shift 'UNBOUNDED', go to state 503
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED]
parser: Input 'PRECEDING' in state 503
parser: Shift 'PRECEDING', pending reduce 302
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED PRECEDING]
parser: Input 'AND' with pending reduce 302
parser: Reduce 302 [frame_bound_s ::= UNBOUNDED PRECEDING], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'UNBOUNDED' in state 7
parser: Shift 'UNBOUNDED', go to state 505
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND UNBOUNDED]
parser: Input 'FOLLOWING' in state 505
parser: Shift 'FOLLOWING', pending reduce 304
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND UNBOUNDED FOLLOWING]
parser: Input 'RP' with pending reduce 304
parser: Reduce 304 [frame_bound_e ::= UNBOUNDED FOLLOWING], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ORDER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'FOLLOWING' in state 26
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY FOLLOWING]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY last_field RANGE BETWEEN CURRENT ROW AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
         sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY last_field

;SELECT sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'ID' in state 25
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY ID]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY ID]
parser: Input 'RANGE' in state 416
parser: FALLBACK RANGE => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK RANGE => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK RANGE => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'CURRENT' in state 8
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN CURRENT ROW]
parser: Input 'AND' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 8.
parser: ... then shift 'frame_bound', pending reduce 301
parser: Reduce 301 [frame_bound_s ::= frame_bound], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'UNBOUNDED' in state 7
parser: Shift 'UNBOUNDED', go to state 505
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND UNBOUNDED]
parser: Input 'FOLLOWING' in state 505
parser: Shift 'FOLLOWING', pending reduce 304
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND UNBOUNDED FOLLOWING]
parser: Input 'RP' with pending reduce 304
parser: Reduce 304 [frame_bound_e ::= UNBOUNDED FOLLOWING], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'COMMA' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'ID' in state 25
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY ID]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY ID]
parser: Input 'RANGE' in state 416
parser: FALLBACK RANGE => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK RANGE => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK RANGE => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'CURRENT' in state 8
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN CURRENT ROW]
parser: Input 'AND' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 8.
parser: ... then shift 'frame_bound', pending reduce 301
parser: Reduce 301 [frame_bound_s ::= frame_bound], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'CURRENT' in state 7
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT ROW]
parser: Input 'RP' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ORDER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), 
         sum(test001) OVER (PARTITION BY last_field ORDER BY test002 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
         sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY last_field

;SELECT sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'ID' in state 25
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY ID]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY ID]
parser: Input 'RANGE' in state 416
parser: FALLBACK RANGE => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK RANGE => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK RANGE => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'CURRENT' in state 8
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN CURRENT ROW]
parser: Input 'AND' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 8.
parser: ... then shift 'frame_bound', pending reduce 301
parser: Reduce 301 [frame_bound_s ::= frame_bound], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'UNBOUNDED' in state 7
parser: Shift 'UNBOUNDED', go to state 505
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND UNBOUNDED]
parser: Input 'FOLLOWING' in state 505
parser: Shift 'FOLLOWING', pending reduce 304
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND UNBOUNDED FOLLOWING]
parser: Input 'RP' with pending reduce 304
parser: Reduce 304 [frame_bound_e ::= UNBOUNDED FOLLOWING], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'COMMA' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'ID' in state 25
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY ID]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY ID]
parser: Input 'RANGE' in state 416
parser: FALLBACK RANGE => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK RANGE => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK RANGE => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'CURRENT' in state 8
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN CURRENT ROW]
parser: Input 'AND' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 8.
parser: ... then shift 'frame_bound', pending reduce 301
parser: Reduce 301 [frame_bound_s ::= frame_bound], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'UNBOUNDED' in state 7
parser: Shift 'UNBOUNDED', go to state 505
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND UNBOUNDED]
parser: Input 'FOLLOWING' in state 505
parser: Shift 'FOLLOWING', pending reduce 304
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND UNBOUNDED FOLLOWING]
parser: Input 'RP' with pending reduce 304
parser: Reduce 304 [frame_bound_e ::= UNBOUNDED FOLLOWING], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ORDER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT max(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(preceding) OVER (PARTITION BY following ORDER BY t1 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
         sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY last_field

;SELECT sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'PRECEDING' in state 266
parser: FALLBACK PRECEDING => ID
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct PRECEDING]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'FOLLOWING' in state 25
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY FOLLOWING]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY ID]
parser: Input 'ROWS' in state 416
parser: FALLBACK ROWS => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK ROWS => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK ROWS => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'ROWS', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt ROWS]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'INTEGER' in state 8
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN INTEGER]
parser: Input 'PRECEDING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 8.
parser: ... then shift 'term', go to state 42
parser: Shift 'PRECEDING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN term PRECEDING]
parser: Input 'AND' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 8.
parser: ... then shift 'frame_bound', pending reduce 301
parser: Reduce 301 [frame_bound_s ::= frame_bound], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'INTEGER' in state 7
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND INTEGER]
parser: Input 'FOLLOWING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 7.
parser: ... then shift 'term', go to state 42
parser: Shift 'FOLLOWING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND term FOLLOWING]
parser: Input 'RP' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'COMMA' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'PRECEDING' in state 266
parser: FALLBACK PRECEDING => ID
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct PRECEDING]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'FOLLOWING' in state 25
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY FOLLOWING]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY ID]
parser: Input 'ROWS' in state 416
parser: FALLBACK ROWS => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK ROWS => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK ROWS => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'ROWS', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt ROWS]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'INTEGER' in state 8
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN INTEGER]
parser: Input 'PRECEDING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 8.
parser: ... then shift 'term', go to state 42
parser: Shift 'PRECEDING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN term PRECEDING]
parser: Input 'AND' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 8.
parser: ... then shift 'frame_bound', pending reduce 301
parser: Reduce 301 [frame_bound_s ::= frame_bound], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'INTEGER' in state 7
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND INTEGER]
parser: Input 'FOLLOWING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 7.
parser: ... then shift 'term', go to state 42
parser: Shift 'FOLLOWING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND term FOLLOWING]
parser: Input 'RP' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ORDER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY preceding ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
         sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY last_field

;SELECT sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'PRECEDING' in state 266
parser: FALLBACK PRECEDING => ID
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct PRECEDING]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'ID' in state 25
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY ID]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'PRECEDING' in state 26
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY PRECEDING]
parser: Input 'ROWS' in state 416
parser: FALLBACK ROWS => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK ROWS => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK ROWS => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'ROWS', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt ROWS]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'INTEGER' in state 8
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN INTEGER]
parser: Input 'PRECEDING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 8.
parser: ... then shift 'term', go to state 42
parser: Shift 'PRECEDING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN term PRECEDING]
parser: Input 'AND' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 8.
parser: ... then shift 'frame_bound', pending reduce 301
parser: Reduce 301 [frame_bound_s ::= frame_bound], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'INTEGER' in state 7
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND INTEGER]
parser: Input 'FOLLOWING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 7.
parser: ... then shift 'term', go to state 42
parser: Shift 'FOLLOWING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND term FOLLOWING]
parser: Input 'RP' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'COMMA' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'PRECEDING' in state 266
parser: FALLBACK PRECEDING => ID
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct PRECEDING]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'ID' in state 25
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY ID]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'PRECEDING' in state 26
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY PRECEDING]
parser: Input 'ROWS' in state 416
parser: FALLBACK ROWS => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK ROWS => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK ROWS => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'ROWS', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt ROWS]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'INTEGER' in state 8
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN INTEGER]
parser: Input 'PRECEDING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 8.
parser: ... then shift 'term', go to state 42
parser: Shift 'PRECEDING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN term PRECEDING]
parser: Input 'AND' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 8.
parser: ... then shift 'frame_bound', pending reduce 301
parser: Reduce 301 [frame_bound_s ::= frame_bound], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'INTEGER' in state 7
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND INTEGER]
parser: Input 'FOLLOWING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 7.
parser: ... then shift 'term', go to state 42
parser: Shift 'FOLLOWING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND term FOLLOWING]
parser: Input 'RP' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ORDER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'PRECEDING' in state 26
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY PRECEDING]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
         sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY last_field

;SELECT sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'ID' in state 25
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY ID]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY ID]
parser: Input 'ROWS' in state 416
parser: FALLBACK ROWS => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK ROWS => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK ROWS => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'ROWS', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt ROWS]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'INTEGER' in state 8
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN INTEGER]
parser: Input 'PRECEDING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 8.
parser: ... then shift 'term', go to state 42
parser: Shift 'PRECEDING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN term PRECEDING]
parser: Input 'AND' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 8.
parser: ... then shift 'frame_bound', pending reduce 301
parser: Reduce 301 [frame_bound_s ::= frame_bound], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'INTEGER' in state 7
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND INTEGER]
parser: Input 'FOLLOWING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 7.
parser: ... then shift 'term', go to state 42
parser: Shift 'FOLLOWING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND term FOLLOWING]
parser: Input 'RP' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'COMMA' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'ID' in state 25
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY ID]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY ID]
parser: Input 'ROWS' in state 416
parser: FALLBACK ROWS => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK ROWS => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK ROWS => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'ROWS', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt ROWS]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'INTEGER' in state 8
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN INTEGER]
parser: Input 'PRECEDING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 8.
parser: ... then shift 'term', go to state 42
parser: Shift 'PRECEDING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN term PRECEDING]
parser: Input 'AND' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 8.
parser: ... then shift 'frame_bound', pending reduce 301
parser: Reduce 301 [frame_bound_s ::= frame_bound], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'INTEGER' in state 7
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND INTEGER]
parser: Input 'PRECEDING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 7.
parser: ... then shift 'term', go to state 42
parser: Shift 'PRECEDING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND term PRECEDING]
parser: Input 'RP' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ORDER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
         sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY last_field

;SELECT sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'PRECEDING' in state 25
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY PRECEDING]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'FOLLOWING' in state 26
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY FOLLOWING]
parser: Input 'ROWS' in state 416
parser: FALLBACK ROWS => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK ROWS => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK ROWS => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'ROWS', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt ROWS]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'INTEGER' in state 8
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN INTEGER]
parser: Input 'PRECEDING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 8.
parser: ... then shift 'term', go to state 42
parser: Shift 'PRECEDING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN term PRECEDING]
parser: Input 'AND' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 8.
parser: ... then shift 'frame_bound', pending reduce 301
parser: Reduce 301 [frame_bound_s ::= frame_bound], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'INTEGER' in state 7
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND INTEGER]
parser: Input 'FOLLOWING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 7.
parser: ... then shift 'term', go to state 42
parser: Shift 'FOLLOWING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND term FOLLOWING]
parser: Input 'RP' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'COMMA' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'PRECEDING' in state 25
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY PRECEDING]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'FOLLOWING' in state 26
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY FOLLOWING]
parser: Input 'ROWS' in state 416
parser: FALLBACK ROWS => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK ROWS => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK ROWS => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'ROWS', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt ROWS]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'INTEGER' in state 8
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN INTEGER]
parser: Input 'PRECEDING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 8.
parser: ... then shift 'term', go to state 42
parser: Shift 'PRECEDING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN term PRECEDING]
parser: Input 'AND' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 8.
parser: ... then shift 'frame_bound', pending reduce 301
parser: Reduce 301 [frame_bound_s ::= frame_bound], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'INTEGER' in state 7
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND INTEGER]
parser: Input 'PRECEDING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 7.
parser: ... then shift 'term', go to state 42
parser: Shift 'PRECEDING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND term PRECEDING]
parser: Input 'RP' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ORDER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'FOLLOWING' in state 26
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY FOLLOWING]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
         sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY last_field

;SELECT sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'ID' in state 25
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY ID]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY ID]
parser: Input 'ROWS' in state 416
parser: FALLBACK ROWS => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK ROWS => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK ROWS => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'ROWS', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt ROWS]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'INTEGER' in state 8
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN INTEGER]
parser: Input 'PRECEDING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 8.
parser: ... then shift 'term', go to state 42
parser: Shift 'PRECEDING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN term PRECEDING]
parser: Input 'AND' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 8.
parser: ... then shift 'frame_bound', pending reduce 301
parser: Reduce 301 [frame_bound_s ::= frame_bound], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'INTEGER' in state 7
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND INTEGER]
parser: Input 'FOLLOWING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 7.
parser: ... then shift 'term', go to state 42
parser: Shift 'FOLLOWING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND term FOLLOWING]
parser: Input 'RP' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'COMMA' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'ID' in state 25
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY ID]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY ID]
parser: Input 'ROWS' in state 416
parser: FALLBACK ROWS => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK ROWS => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK ROWS => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'ROWS', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt ROWS]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'INTEGER' in state 8
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN INTEGER]
parser: Input 'PRECEDING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 8.
parser: ... then shift 'term', go to state 42
parser: Shift 'PRECEDING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN term PRECEDING]
parser: Input 'AND' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 8.
parser: ... then shift 'frame_bound', pending reduce 301
parser: Reduce 301 [frame_bound_s ::= frame_bound], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'INTEGER' in state 7
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND INTEGER]
parser: Input 'PRECEDING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 7.
parser: ... then shift 'term', go to state 42
parser: Shift 'PRECEDING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND term PRECEDING]
parser: Input 'RP' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ORDER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
         sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY last_field

;SELECT sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'ID' in state 25
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY ID]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY ID]
parser: Input 'ROWS' in state 416
parser: FALLBACK ROWS => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK ROWS => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK ROWS => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'ROWS', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt ROWS]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'INTEGER' in state 8
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN INTEGER]
parser: Input 'PRECEDING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 8.
parser: ... then shift 'term', go to state 42
parser: Shift 'PRECEDING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN term PRECEDING]
parser: Input 'AND' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 8.
parser: ... then shift 'frame_bound', pending reduce 301
parser: Reduce 301 [frame_bound_s ::= frame_bound], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'INTEGER' in state 7
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND INTEGER]
parser: Input 'FOLLOWING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 7.
parser: ... then shift 'term', go to state 42
parser: Shift 'FOLLOWING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND term FOLLOWING]
parser: Input 'RP' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'COMMA' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'ID' in state 25
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY ID]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY ID]
parser: Input 'ROWS' in state 416
parser: FALLBACK ROWS => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK ROWS => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK ROWS => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'ROWS', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt ROWS]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'INTEGER' in state 8
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN INTEGER]
parser: Input 'FOLLOWING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 8.
parser: ... then shift 'term', go to state 42
parser: Shift 'FOLLOWING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN term FOLLOWING]
parser: Input 'AND' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 8.
parser: ... then shift 'frame_bound', pending reduce 301
parser: Reduce 301 [frame_bound_s ::= frame_bound], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'INTEGER' in state 7
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND INTEGER]
parser: Input 'FOLLOWING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 7.
parser: ... then shift 'term', go to state 42
parser: Shift 'FOLLOWING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND term FOLLOWING]
parser: Input 'RP' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ORDER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT max(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(t1) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
         sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY last_field

;SELECT sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'PRECEDING' in state 25
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY PRECEDING]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'FOLLOWING' in state 26
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY FOLLOWING]
parser: Input 'ROWS' in state 416
parser: FALLBACK ROWS => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK ROWS => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK ROWS => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'ROWS', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt ROWS]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'INTEGER' in state 8
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN INTEGER]
parser: Input 'PRECEDING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 8.
parser: ... then shift 'term', go to state 42
parser: Shift 'PRECEDING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN term PRECEDING]
parser: Input 'AND' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 8.
parser: ... then shift 'frame_bound', pending reduce 301
parser: Reduce 301 [frame_bound_s ::= frame_bound], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'INTEGER' in state 7
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND INTEGER]
parser: Input 'FOLLOWING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 7.
parser: ... then shift 'term', go to state 42
parser: Shift 'FOLLOWING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND term FOLLOWING]
parser: Input 'RP' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'COMMA' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'PRECEDING' in state 25
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY PRECEDING]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'FOLLOWING' in state 26
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY FOLLOWING]
parser: Input 'ROWS' in state 416
parser: FALLBACK ROWS => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK ROWS => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK ROWS => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'ROWS', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt ROWS]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'INTEGER' in state 8
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN INTEGER]
parser: Input 'PRECEDING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 8.
parser: ... then shift 'term', go to state 42
parser: Shift 'PRECEDING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN term PRECEDING]
parser: Input 'AND' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 8.
parser: ... then shift 'frame_bound', pending reduce 301
parser: Reduce 301 [frame_bound_s ::= frame_bound], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'INTEGER' in state 7
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND INTEGER]
parser: Input 'FOLLOWING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 7.
parser: ... then shift 'term', go to state 42
parser: Shift 'FOLLOWING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND term FOLLOWING]
parser: Input 'RP' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ORDER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'FOLLOWING' in state 26
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY FOLLOWING]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT max(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
  min(following) OVER (PARTITION BY following ORDER BY following ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
         sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY last_field

;SELECT sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'FOLLOWING' in state 266
parser: FALLBACK FOLLOWING => ID
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct FOLLOWING]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'FOLLOWING' in state 25
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY FOLLOWING]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'FOLLOWING' in state 26
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY FOLLOWING]
parser: Input 'ROWS' in state 416
parser: FALLBACK ROWS => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK ROWS => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK ROWS => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'ROWS', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt ROWS]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'INTEGER' in state 8
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN INTEGER]
parser: Input 'PRECEDING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 8.
parser: ... then shift 'term', go to state 42
parser: Shift 'PRECEDING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN term PRECEDING]
parser: Input 'AND' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 8.
parser: ... then shift 'frame_bound', pending reduce 301
parser: Reduce 301 [frame_bound_s ::= frame_bound], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'INTEGER' in state 7
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND INTEGER]
parser: Input 'FOLLOWING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 7.
parser: ... then shift 'term', go to state 42
parser: Shift 'FOLLOWING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND term FOLLOWING]
parser: Input 'RP' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'COMMA' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'FOLLOWING' in state 266
parser: FALLBACK FOLLOWING => ID
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct FOLLOWING]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'FOLLOWING' in state 25
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY FOLLOWING]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'FOLLOWING' in state 26
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY FOLLOWING]
parser: Input 'ROWS' in state 416
parser: FALLBACK ROWS => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK ROWS => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK ROWS => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'ROWS', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt ROWS]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'INTEGER' in state 8
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN INTEGER]
parser: Input 'PRECEDING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 8.
parser: ... then shift 'term', go to state 42
parser: Shift 'PRECEDING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN term PRECEDING]
parser: Input 'AND' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 8.
parser: ... then shift 'frame_bound', pending reduce 301
parser: Reduce 301 [frame_bound_s ::= frame_bound], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'INTEGER' in state 7
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND INTEGER]
parser: Input 'PRECEDING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 7.
parser: ... then shift 'term', go to state 42
parser: Shift 'PRECEDING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND term PRECEDING]
parser: Input 'RP' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ORDER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'FOLLOWING' in state 26
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY FOLLOWING]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING), 
         sum(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY last_field

;SELECT sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'ID' in state 25
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY ID]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY ID]
parser: Input 'ROWS' in state 416
parser: FALLBACK ROWS => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK ROWS => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK ROWS => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'ROWS', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt ROWS]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'INTEGER' in state 8
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN INTEGER]
parser: Input 'PRECEDING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 8.
parser: ... then shift 'term', go to state 42
parser: Shift 'PRECEDING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN term PRECEDING]
parser: Input 'AND' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 8.
parser: ... then shift 'frame_bound', pending reduce 301
parser: Reduce 301 [frame_bound_s ::= frame_bound], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'INTEGER' in state 7
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND INTEGER]
parser: Input 'FOLLOWING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 7.
parser: ... then shift 'term', go to state 42
parser: Shift 'FOLLOWING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND term FOLLOWING]
parser: Input 'RP' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'COMMA' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'ID' in state 25
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY ID]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY ID]
parser: Input 'ROWS' in state 416
parser: FALLBACK ROWS => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK ROWS => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK ROWS => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'ROWS', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt ROWS]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'INTEGER' in state 8
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN INTEGER]
parser: Input 'FOLLOWING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 8.
parser: ... then shift 'term', go to state 42
parser: Shift 'FOLLOWING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN term FOLLOWING]
parser: Input 'AND' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 8.
parser: ... then shift 'frame_bound', pending reduce 301
parser: Reduce 301 [frame_bound_s ::= frame_bound], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'INTEGER' in state 7
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND INTEGER]
parser: Input 'FOLLOWING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 7.
parser: ... then shift 'term', go to state 42
parser: Shift 'FOLLOWING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND term FOLLOWING]
parser: Input 'RP' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ORDER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY last_field

;SELECT sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'ID' in state 25
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY ID]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY ID]
parser: Input 'ROWS' in state 416
parser: FALLBACK ROWS => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK ROWS => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK ROWS => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'ROWS', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt ROWS]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'INTEGER' in state 8
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN INTEGER]
parser: Input 'PRECEDING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 8.
parser: ... then shift 'term', go to state 42
parser: Shift 'PRECEDING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN term PRECEDING]
parser: Input 'AND' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 8.
parser: ... then shift 'frame_bound', pending reduce 301
parser: Reduce 301 [frame_bound_s ::= frame_bound], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'INTEGER' in state 7
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND INTEGER]
parser: Input 'PRECEDING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 7.
parser: ... then shift 'term', go to state 42
parser: Shift 'PRECEDING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND term PRECEDING]
parser: Input 'RP' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'COMMA' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'ID' in state 25
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY ID]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY ID]
parser: Input 'ROWS' in state 416
parser: FALLBACK ROWS => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK ROWS => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK ROWS => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'ROWS', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt ROWS]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'INTEGER' in state 8
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN INTEGER]
parser: Input 'PRECEDING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 8.
parser: ... then shift 'term', go to state 42
parser: Shift 'PRECEDING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN term PRECEDING]
parser: Input 'AND' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 8.
parser: ... then shift 'frame_bound', pending reduce 301
parser: Reduce 301 [frame_bound_s ::= frame_bound], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'INTEGER' in state 7
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND INTEGER]
parser: Input 'PRECEDING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 7.
parser: ... then shift 'term', go to state 42
parser: Shift 'PRECEDING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND term PRECEDING]
parser: Input 'RP' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ORDER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(preceding) OVER (PARTITION BY t1 ORDER BY t1 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY last_field

;SELECT sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'PRECEDING' in state 266
parser: FALLBACK PRECEDING => ID
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct PRECEDING]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'ID' in state 25
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY ID]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY ID]
parser: Input 'ROWS' in state 416
parser: FALLBACK ROWS => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK ROWS => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK ROWS => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'ROWS', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt ROWS]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'INTEGER' in state 8
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN INTEGER]
parser: Input 'PRECEDING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 8.
parser: ... then shift 'term', go to state 42
parser: Shift 'PRECEDING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN term PRECEDING]
parser: Input 'AND' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 8.
parser: ... then shift 'frame_bound', pending reduce 301
parser: Reduce 301 [frame_bound_s ::= frame_bound], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'INTEGER' in state 7
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND INTEGER]
parser: Input 'PRECEDING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 7.
parser: ... then shift 'term', go to state 42
parser: Shift 'PRECEDING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND term PRECEDING]
parser: Input 'RP' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'COMMA' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'PRECEDING' in state 266
parser: FALLBACK PRECEDING => ID
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct PRECEDING]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'ID' in state 25
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY ID]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY ID]
parser: Input 'ROWS' in state 416
parser: FALLBACK ROWS => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK ROWS => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK ROWS => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'ROWS', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt ROWS]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'INTEGER' in state 8
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN INTEGER]
parser: Input 'PRECEDING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 8.
parser: ... then shift 'term', go to state 42
parser: Shift 'PRECEDING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN term PRECEDING]
parser: Input 'AND' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 8.
parser: ... then shift 'frame_bound', pending reduce 301
parser: Reduce 301 [frame_bound_s ::= frame_bound], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'INTEGER' in state 7
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND INTEGER]
parser: Input 'PRECEDING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 7.
parser: ... then shift 'term', go to state 42
parser: Shift 'PRECEDING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND term PRECEDING]
parser: Input 'RP' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ORDER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT max(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY last_field ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY last_field

;SELECT sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'ID' in state 25
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY ID]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY ID]
parser: Input 'ROWS' in state 416
parser: FALLBACK ROWS => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK ROWS => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK ROWS => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'ROWS', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt ROWS]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'INTEGER' in state 8
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN INTEGER]
parser: Input 'PRECEDING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 8.
parser: ... then shift 'term', go to state 42
parser: Shift 'PRECEDING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN term PRECEDING]
parser: Input 'AND' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 8.
parser: ... then shift 'frame_bound', pending reduce 301
parser: Reduce 301 [frame_bound_s ::= frame_bound], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'INTEGER' in state 7
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND INTEGER]
parser: Input 'PRECEDING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 7.
parser: ... then shift 'term', go to state 42
parser: Shift 'PRECEDING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND term PRECEDING]
parser: Input 'RP' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'COMMA' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'ID' in state 25
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY ID]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY ID]
parser: Input 'ROWS' in state 416
parser: FALLBACK ROWS => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK ROWS => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK ROWS => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'ROWS', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt ROWS]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'INTEGER' in state 8
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN INTEGER]
parser: Input 'PRECEDING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 8.
parser: ... then shift 'term', go to state 42
parser: Shift 'PRECEDING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN term PRECEDING]
parser: Input 'AND' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 8.
parser: ... then shift 'frame_bound', pending reduce 301
parser: Reduce 301 [frame_bound_s ::= frame_bound], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'INTEGER' in state 7
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND INTEGER]
parser: Input 'PRECEDING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 7.
parser: ... then shift 'term', go to state 42
parser: Shift 'PRECEDING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND term PRECEDING]
parser: Input 'RP' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ORDER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING), 
         sum(following) OVER (PARTITION BY following ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY preceding

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'FOLLOWING' in state 266
parser: FALLBACK FOLLOWING => ID
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct FOLLOWING]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'FOLLOWING' in state 25
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY FOLLOWING]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'PRECEDING' in state 26
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY PRECEDING]
parser: Input 'ROWS' in state 416
parser: FALLBACK ROWS => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK ROWS => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK ROWS => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'ROWS', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt ROWS]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'INTEGER' in state 8
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN INTEGER]
parser: Input 'PRECEDING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 8.
parser: ... then shift 'term', go to state 42
parser: Shift 'PRECEDING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN term PRECEDING]
parser: Input 'AND' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 8.
parser: ... then shift 'frame_bound', pending reduce 301
parser: Reduce 301 [frame_bound_s ::= frame_bound], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'INTEGER' in state 7
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND INTEGER]
parser: Input 'PRECEDING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 7.
parser: ... then shift 'term', go to state 42
parser: Shift 'PRECEDING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND term PRECEDING]
parser: Input 'RP' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'COMMA' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'FOLLOWING' in state 266
parser: FALLBACK FOLLOWING => ID
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct FOLLOWING]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'FOLLOWING' in state 25
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY FOLLOWING]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'PRECEDING' in state 26
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY PRECEDING]
parser: Input 'ROWS' in state 416
parser: FALLBACK ROWS => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK ROWS => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK ROWS => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'ROWS', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt ROWS]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'INTEGER' in state 8
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN INTEGER]
parser: Input 'FOLLOWING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 8.
parser: ... then shift 'term', go to state 42
parser: Shift 'FOLLOWING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN term FOLLOWING]
parser: Input 'AND' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 8.
parser: ... then shift 'frame_bound', pending reduce 301
parser: Reduce 301 [frame_bound_s ::= frame_bound], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'INTEGER' in state 7
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND INTEGER]
parser: Input 'FOLLOWING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 7.
parser: ... then shift 'term', go to state 42
parser: Shift 'FOLLOWING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND term FOLLOWING]
parser: Input 'RP' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ORDER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'PRECEDING' in state 26
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY PRECEDING]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'ID' in state 25
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY ID]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY ID]
parser: Input 'ROWS' in state 416
parser: FALLBACK ROWS => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK ROWS => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK ROWS => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'ROWS', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt ROWS]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'INTEGER' in state 8
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN INTEGER]
parser: Input 'PRECEDING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 8.
parser: ... then shift 'term', go to state 42
parser: Shift 'PRECEDING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN term PRECEDING]
parser: Input 'AND' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 8.
parser: ... then shift 'frame_bound', pending reduce 301
parser: Reduce 301 [frame_bound_s ::= frame_bound], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'INTEGER' in state 7
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND INTEGER]
parser: Input 'PRECEDING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 7.
parser: ... then shift 'term', go to state 42
parser: Shift 'PRECEDING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND term PRECEDING]
parser: Input 'RP' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'COMMA' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'ID' in state 25
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY ID]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY ID]
parser: Input 'ROWS' in state 416
parser: FALLBACK ROWS => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK ROWS => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK ROWS => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'ROWS', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt ROWS]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'INTEGER' in state 8
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN INTEGER]
parser: Input 'PRECEDING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 8.
parser: ... then shift 'term', go to state 42
parser: Shift 'PRECEDING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN term PRECEDING]
parser: Input 'AND' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 8.
parser: ... then shift 'frame_bound', pending reduce 301
parser: Reduce 301 [frame_bound_s ::= frame_bound], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'INTEGER' in state 7
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND INTEGER]
parser: Input 'FOLLOWING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 7.
parser: ... then shift 'term', go to state 42
parser: Shift 'FOLLOWING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND term FOLLOWING]
parser: Input 'RP' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ORDER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT max(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(following) OVER (PARTITION BY t1 ORDER BY following ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'FOLLOWING' in state 266
parser: FALLBACK FOLLOWING => ID
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct FOLLOWING]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'ID' in state 25
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY ID]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'FOLLOWING' in state 26
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY FOLLOWING]
parser: Input 'ROWS' in state 416
parser: FALLBACK ROWS => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK ROWS => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK ROWS => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'ROWS', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt ROWS]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'INTEGER' in state 8
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN INTEGER]
parser: Input 'PRECEDING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 8.
parser: ... then shift 'term', go to state 42
parser: Shift 'PRECEDING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN term PRECEDING]
parser: Input 'AND' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 8.
parser: ... then shift 'frame_bound', pending reduce 301
parser: Reduce 301 [frame_bound_s ::= frame_bound], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'INTEGER' in state 7
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND INTEGER]
parser: Input 'PRECEDING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 7.
parser: ... then shift 'term', go to state 42
parser: Shift 'PRECEDING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND term PRECEDING]
parser: Input 'RP' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'COMMA' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'FOLLOWING' in state 266
parser: FALLBACK FOLLOWING => ID
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct FOLLOWING]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'ID' in state 25
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY ID]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'FOLLOWING' in state 26
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY FOLLOWING]
parser: Input 'ROWS' in state 416
parser: FALLBACK ROWS => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK ROWS => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK ROWS => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'ROWS', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt ROWS]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'INTEGER' in state 8
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN INTEGER]
parser: Input 'PRECEDING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 8.
parser: ... then shift 'term', go to state 42
parser: Shift 'PRECEDING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN term PRECEDING]
parser: Input 'AND' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 8.
parser: ... then shift 'frame_bound', pending reduce 301
parser: Reduce 301 [frame_bound_s ::= frame_bound], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'INTEGER' in state 7
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND INTEGER]
parser: Input 'PRECEDING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 7.
parser: ... then shift 'term', go to state 42
parser: Shift 'PRECEDING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND term PRECEDING]
parser: Input 'RP' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ORDER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'FOLLOWING' in state 26
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY FOLLOWING]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test001

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'ID' in state 25
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY ID]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY ID]
parser: Input 'ROWS' in state 416
parser: FALLBACK ROWS => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK ROWS => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK ROWS => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'ROWS', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt ROWS]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'INTEGER' in state 8
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN INTEGER]
parser: Input 'PRECEDING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 8.
parser: ... then shift 'term', go to state 42
parser: Shift 'PRECEDING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN term PRECEDING]
parser: Input 'AND' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 8.
parser: ... then shift 'frame_bound', pending reduce 301
parser: Reduce 301 [frame_bound_s ::= frame_bound], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'INTEGER' in state 7
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND INTEGER]
parser: Input 'PRECEDING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 7.
parser: ... then shift 'term', go to state 42
parser: Shift 'PRECEDING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND term PRECEDING]
parser: Input 'RP' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'COMMA' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'ID' in state 25
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY ID]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY ID]
parser: Input 'ROWS' in state 416
parser: FALLBACK ROWS => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK ROWS => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK ROWS => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'ROWS', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt ROWS]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'INTEGER' in state 8
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN INTEGER]
parser: Input 'PRECEDING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 8.
parser: ... then shift 'term', go to state 42
parser: Shift 'PRECEDING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN term PRECEDING]
parser: Input 'AND' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 8.
parser: ... then shift 'frame_bound', pending reduce 301
parser: Reduce 301 [frame_bound_s ::= frame_bound], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'INTEGER' in state 7
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND INTEGER]
parser: Input 'PRECEDING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 7.
parser: ... then shift 'term', go to state 42
parser: Shift 'PRECEDING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND term PRECEDING]
parser: Input 'RP' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ORDER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING), 
  min(preceding) OVER (PARTITION BY preceding ORDER BY t1 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM over ORDER BY t1

;SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'PRECEDING' in state 266
parser: FALLBACK PRECEDING => ID
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct PRECEDING]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'PRECEDING' in state 25
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY PRECEDING]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY ID]
parser: Input 'ROWS' in state 416
parser: FALLBACK ROWS => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK ROWS => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK ROWS => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'ROWS', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt ROWS]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'INTEGER' in state 8
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN INTEGER]
parser: Input 'PRECEDING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 8.
parser: ... then shift 'term', go to state 42
parser: Shift 'PRECEDING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN term PRECEDING]
parser: Input 'AND' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 8.
parser: ... then shift 'frame_bound', pending reduce 301
parser: Reduce 301 [frame_bound_s ::= frame_bound], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'INTEGER' in state 7
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND INTEGER]
parser: Input 'PRECEDING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 7.
parser: ... then shift 'term', go to state 42
parser: Shift 'PRECEDING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND term PRECEDING]
parser: Input 'RP' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'COMMA' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'PRECEDING' in state 266
parser: FALLBACK PRECEDING => ID
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct PRECEDING]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'PRECEDING' in state 25
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY PRECEDING]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY ID]
parser: Input 'ROWS' in state 416
parser: FALLBACK ROWS => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK ROWS => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK ROWS => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'ROWS', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt ROWS]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'INTEGER' in state 8
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN INTEGER]
parser: Input 'FOLLOWING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 8.
parser: ... then shift 'term', go to state 42
parser: Shift 'FOLLOWING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN term FOLLOWING]
parser: Input 'AND' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 8.
parser: ... then shift 'frame_bound', pending reduce 301
parser: Reduce 301 [frame_bound_s ::= frame_bound], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'INTEGER' in state 7
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND INTEGER]
parser: Input 'FOLLOWING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 7.
parser: ... then shift 'term', go to state 42
parser: Shift 'FOLLOWING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND term FOLLOWING]
parser: Input 'RP' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ORDER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY test002 ORDER BY test002 ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING)
  FROM x ORDER BY test002

;SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'ID' in state 25
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY ID]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY ID]
parser: Input 'ROWS' in state 416
parser: FALLBACK ROWS => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK ROWS => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK ROWS => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'ROWS', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt ROWS]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'INTEGER' in state 8
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN INTEGER]
parser: Input 'FOLLOWING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 8.
parser: ... then shift 'term', go to state 42
parser: Shift 'FOLLOWING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN term FOLLOWING]
parser: Input 'AND' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 8.
parser: ... then shift 'frame_bound', pending reduce 301
parser: Reduce 301 [frame_bound_s ::= frame_bound], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'INTEGER' in state 7
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND INTEGER]
parser: Input 'FOLLOWING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 7.
parser: ... then shift 'term', go to state 42
parser: Shift 'FOLLOWING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND term FOLLOWING]
parser: Input 'RP' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'COMMA' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'ID' in state 25
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY ID]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY ID]
parser: Input 'ROWS' in state 416
parser: FALLBACK ROWS => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK ROWS => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK ROWS => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'ROWS', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt ROWS]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'INTEGER' in state 8
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN INTEGER]
parser: Input 'PRECEDING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 8.
parser: ... then shift 'term', go to state 42
parser: Shift 'PRECEDING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN term PRECEDING]
parser: Input 'AND' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 8.
parser: ... then shift 'frame_bound', pending reduce 301
parser: Reduce 301 [frame_bound_s ::= frame_bound], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'INTEGER' in state 7
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND INTEGER]
parser: Input 'FOLLOWING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 7.
parser: ... then shift 'term', go to state 42
parser: Shift 'FOLLOWING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND term FOLLOWING]
parser: Input 'RP' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ORDER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT max(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'FOLLOWING' in state 266
parser: FALLBACK FOLLOWING => ID
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct FOLLOWING]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'PRECEDING' in state 25
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY PRECEDING]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'FOLLOWING' in state 26
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY FOLLOWING]
parser: Input 'ROWS' in state 416
parser: FALLBACK ROWS => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK ROWS => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK ROWS => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'ROWS', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt ROWS]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'INTEGER' in state 8
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN INTEGER]
parser: Input 'FOLLOWING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 8.
parser: ... then shift 'term', go to state 42
parser: Shift 'FOLLOWING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN term FOLLOWING]
parser: Input 'AND' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 8.
parser: ... then shift 'frame_bound', pending reduce 301
parser: Reduce 301 [frame_bound_s ::= frame_bound], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'INTEGER' in state 7
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND INTEGER]
parser: Input 'FOLLOWING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 7.
parser: ... then shift 'term', go to state 42
parser: Shift 'FOLLOWING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND term FOLLOWING]
parser: Input 'RP' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'COMMA' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'FOLLOWING' in state 266
parser: FALLBACK FOLLOWING => ID
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct FOLLOWING]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'PRECEDING' in state 25
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY PRECEDING]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'FOLLOWING' in state 26
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY FOLLOWING]
parser: Input 'ROWS' in state 416
parser: FALLBACK ROWS => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK ROWS => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK ROWS => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'ROWS', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt ROWS]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'INTEGER' in state 8
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN INTEGER]
parser: Input 'PRECEDING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 8.
parser: ... then shift 'term', go to state 42
parser: Shift 'PRECEDING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN term PRECEDING]
parser: Input 'AND' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 8.
parser: ... then shift 'frame_bound', pending reduce 301
parser: Reduce 301 [frame_bound_s ::= frame_bound], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'INTEGER' in state 7
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND INTEGER]
parser: Input 'FOLLOWING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 7.
parser: ... then shift 'term', go to state 42
parser: Shift 'FOLLOWING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND term FOLLOWING]
parser: Input 'RP' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ORDER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'FOLLOWING' in state 26
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY FOLLOWING]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(following) OVER (PARTITION BY preceding ORDER BY following ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING)
  FROM over ORDER BY following

;SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'FOLLOWING' in state 266
parser: FALLBACK FOLLOWING => ID
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct FOLLOWING]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'PRECEDING' in state 25
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY PRECEDING]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'FOLLOWING' in state 26
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY FOLLOWING]
parser: Input 'ROWS' in state 416
parser: FALLBACK ROWS => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK ROWS => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK ROWS => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'ROWS', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt ROWS]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'INTEGER' in state 8
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN INTEGER]
parser: Input 'FOLLOWING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 8.
parser: ... then shift 'term', go to state 42
parser: Shift 'FOLLOWING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN term FOLLOWING]
parser: Input 'AND' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 8.
parser: ... then shift 'frame_bound', pending reduce 301
parser: Reduce 301 [frame_bound_s ::= frame_bound], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'INTEGER' in state 7
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND INTEGER]
parser: Input 'FOLLOWING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 7.
parser: ... then shift 'term', go to state 42
parser: Shift 'FOLLOWING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND term FOLLOWING]
parser: Input 'RP' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'COMMA' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'FOLLOWING' in state 266
parser: FALLBACK FOLLOWING => ID
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct FOLLOWING]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'PRECEDING' in state 25
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY PRECEDING]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'FOLLOWING' in state 26
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY FOLLOWING]
parser: Input 'ROWS' in state 416
parser: FALLBACK ROWS => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK ROWS => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK ROWS => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'ROWS', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt ROWS]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'INTEGER' in state 8
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN INTEGER]
parser: Input 'PRECEDING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 8.
parser: ... then shift 'term', go to state 42
parser: Shift 'PRECEDING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN term PRECEDING]
parser: Input 'AND' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 8.
parser: ... then shift 'frame_bound', pending reduce 301
parser: Reduce 301 [frame_bound_s ::= frame_bound], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'INTEGER' in state 7
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND INTEGER]
parser: Input 'FOLLOWING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 7.
parser: ... then shift 'term', go to state 42
parser: Shift 'FOLLOWING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND term FOLLOWING]
parser: Input 'RP' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ORDER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'FOLLOWING' in state 26
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY FOLLOWING]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT max(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(test001) OVER (PARTITION BY last_field ORDER BY test002 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)
  FROM x ORDER BY test002

;SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'ID' in state 25
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY ID]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY ID]
parser: Input 'ROWS' in state 416
parser: FALLBACK ROWS => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK ROWS => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK ROWS => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'ROWS', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt ROWS]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'INTEGER' in state 8
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN INTEGER]
parser: Input 'FOLLOWING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 8.
parser: ... then shift 'term', go to state 42
parser: Shift 'FOLLOWING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN term FOLLOWING]
parser: Input 'AND' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 8.
parser: ... then shift 'frame_bound', pending reduce 301
parser: Reduce 301 [frame_bound_s ::= frame_bound], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'INTEGER' in state 7
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND INTEGER]
parser: Input 'FOLLOWING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 7.
parser: ... then shift 'term', go to state 42
parser: Shift 'FOLLOWING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND term FOLLOWING]
parser: Input 'RP' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'COMMA' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'ID' in state 25
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY ID]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY ID]
parser: Input 'ROWS' in state 416
parser: FALLBACK ROWS => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK ROWS => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK ROWS => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'ROWS', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt ROWS]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'INTEGER' in state 8
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN INTEGER]
parser: Input 'PRECEDING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 8.
parser: ... then shift 'term', go to state 42
parser: Shift 'PRECEDING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN term PRECEDING]
parser: Input 'AND' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 8.
parser: ... then shift 'frame_bound', pending reduce 301
parser: Reduce 301 [frame_bound_s ::= frame_bound], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'INTEGER' in state 7
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND INTEGER]
parser: Input 'PRECEDING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 7.
parser: ... then shift 'term', go to state 42
parser: Shift 'PRECEDING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND term PRECEDING]
parser: Input 'RP' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ORDER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(t1) OVER (PARTITION BY preceding ORDER BY preceding ROWS BETWEEN 0 PRECEDING AND 1 PRECEDING)
  FROM over ORDER BY preceding

;SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'PRECEDING' in state 25
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY PRECEDING]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'PRECEDING' in state 26
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY PRECEDING]
parser: Input 'ROWS' in state 416
parser: FALLBACK ROWS => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK ROWS => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK ROWS => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'ROWS', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt ROWS]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'INTEGER' in state 8
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN INTEGER]
parser: Input 'FOLLOWING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 8.
parser: ... then shift 'term', go to state 42
parser: Shift 'FOLLOWING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN term FOLLOWING]
parser: Input 'AND' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 8.
parser: ... then shift 'frame_bound', pending reduce 301
parser: Reduce 301 [frame_bound_s ::= frame_bound], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'INTEGER' in state 7
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND INTEGER]
parser: Input 'FOLLOWING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 7.
parser: ... then shift 'term', go to state 42
parser: Shift 'FOLLOWING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND term FOLLOWING]
parser: Input 'RP' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'COMMA' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'PRECEDING' in state 25
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY PRECEDING]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'PRECEDING' in state 26
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY PRECEDING]
parser: Input 'ROWS' in state 416
parser: FALLBACK ROWS => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK ROWS => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK ROWS => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'ROWS', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt ROWS]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'INTEGER' in state 8
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN INTEGER]
parser: Input 'PRECEDING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 8.
parser: ... then shift 'term', go to state 42
parser: Shift 'PRECEDING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN term PRECEDING]
parser: Input 'AND' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 8.
parser: ... then shift 'frame_bound', pending reduce 301
parser: Reduce 301 [frame_bound_s ::= frame_bound], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'INTEGER' in state 7
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND INTEGER]
parser: Input 'PRECEDING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 7.
parser: ... then shift 'term', go to state 42
parser: Shift 'PRECEDING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND term PRECEDING]
parser: Input 'RP' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ORDER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'PRECEDING' in state 26
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY PRECEDING]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT max(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
  min(last_field) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'ID' in state 25
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY ID]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY ID]
parser: Input 'ROWS' in state 416
parser: FALLBACK ROWS => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK ROWS => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK ROWS => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'ROWS', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt ROWS]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'INTEGER' in state 8
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN INTEGER]
parser: Input 'FOLLOWING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 8.
parser: ... then shift 'term', go to state 42
parser: Shift 'FOLLOWING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN term FOLLOWING]
parser: Input 'AND' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 8.
parser: ... then shift 'frame_bound', pending reduce 301
parser: Reduce 301 [frame_bound_s ::= frame_bound], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'INTEGER' in state 7
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND INTEGER]
parser: Input 'FOLLOWING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 7.
parser: ... then shift 'term', go to state 42
parser: Shift 'FOLLOWING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND term FOLLOWING]
parser: Input 'RP' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'COMMA' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'ID' in state 25
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY ID]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY ID]
parser: Input 'ROWS' in state 416
parser: FALLBACK ROWS => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK ROWS => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK ROWS => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'ROWS', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt ROWS]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'INTEGER' in state 8
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN INTEGER]
parser: Input 'FOLLOWING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 8.
parser: ... then shift 'term', go to state 42
parser: Shift 'FOLLOWING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN term FOLLOWING]
parser: Input 'AND' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 8.
parser: ... then shift 'frame_bound', pending reduce 301
parser: Reduce 301 [frame_bound_s ::= frame_bound], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'INTEGER' in state 7
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND INTEGER]
parser: Input 'FOLLOWING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 7.
parser: ... then shift 'term', go to state 42
parser: Shift 'FOLLOWING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND term FOLLOWING]
parser: Input 'RP' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ORDER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING), 
         sum(test002) OVER (PARTITION BY last_field ORDER BY test001 ROWS BETWEEN 1 FOLLOWING AND 500 FOLLOWING)
  FROM x ORDER BY test001

;SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'ID' in state 25
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY ID]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY ID]
parser: Input 'ROWS' in state 416
parser: FALLBACK ROWS => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK ROWS => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK ROWS => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'ROWS', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt ROWS]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'INTEGER' in state 8
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN INTEGER]
parser: Input 'FOLLOWING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 8.
parser: ... then shift 'term', go to state 42
parser: Shift 'FOLLOWING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN term FOLLOWING]
parser: Input 'AND' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 8.
parser: ... then shift 'frame_bound', pending reduce 301
parser: Reduce 301 [frame_bound_s ::= frame_bound], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'INTEGER' in state 7
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND INTEGER]
parser: Input 'FOLLOWING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 7.
parser: ... then shift 'term', go to state 42
parser: Shift 'FOLLOWING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND term FOLLOWING]
parser: Input 'RP' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'COMMA' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'ID' in state 25
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY ID]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY ID]
parser: Input 'ROWS' in state 416
parser: FALLBACK ROWS => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK ROWS => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK ROWS => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'ROWS', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt ROWS]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'INTEGER' in state 8
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN INTEGER]
parser: Input 'FOLLOWING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 8.
parser: ... then shift 'term', go to state 42
parser: Shift 'FOLLOWING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN term FOLLOWING]
parser: Input 'AND' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 8.
parser: ... then shift 'frame_bound', pending reduce 301
parser: Reduce 301 [frame_bound_s ::= frame_bound], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'INTEGER' in state 7
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND INTEGER]
parser: Input 'FOLLOWING' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 7.
parser: ... then shift 'term', go to state 42
parser: Shift 'FOLLOWING', pending reduce 305
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND term FOLLOWING]
parser: Input 'RP' with pending reduce 305
parser: Reduce 305 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ORDER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT max(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test002) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'ID' in state 25
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY ID]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY ID]
parser: Input 'RANGE' in state 416
parser: FALLBACK RANGE => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK RANGE => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK RANGE => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'UNBOUNDED' in state 8
parser: Shift 'UNBOUNDED', go to state 503
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED]
parser: Input 'PRECEDING' in state 503
parser: Shift 'PRECEDING', pending reduce 302
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED PRECEDING]
parser: Input 'AND' with pending reduce 302
parser: Reduce 302 [frame_bound_s ::= UNBOUNDED PRECEDING], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'CURRENT' in state 7
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT ROW]
parser: Input 'RP' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'COMMA' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'ID' in state 25
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY ID]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY ID]
parser: Input 'RANGE' in state 416
parser: FALLBACK RANGE => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK RANGE => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK RANGE => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'UNBOUNDED' in state 8
parser: Shift 'UNBOUNDED', go to state 503
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED]
parser: Input 'PRECEDING' in state 503
parser: Shift 'PRECEDING', pending reduce 302
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED PRECEDING]
parser: Input 'AND' with pending reduce 302
parser: Reduce 302 [frame_bound_s ::= UNBOUNDED PRECEDING], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'CURRENT' in state 7
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT ROW]
parser: Input 'RP' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ORDER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'PRECEDING' in state 266
parser: FALLBACK PRECEDING => ID
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct PRECEDING]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'FOLLOWING' in state 25
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY FOLLOWING]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'FOLLOWING' in state 26
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY FOLLOWING]
parser: Input 'RANGE' in state 416
parser: FALLBACK RANGE => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK RANGE => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK RANGE => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'UNBOUNDED' in state 8
parser: Shift 'UNBOUNDED', go to state 503
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED]
parser: Input 'PRECEDING' in state 503
parser: Shift 'PRECEDING', pending reduce 302
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED PRECEDING]
parser: Input 'AND' with pending reduce 302
parser: Reduce 302 [frame_bound_s ::= UNBOUNDED PRECEDING], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'CURRENT' in state 7
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT ROW]
parser: Input 'RP' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'COMMA' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'PRECEDING' in state 266
parser: FALLBACK PRECEDING => ID
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct PRECEDING]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'FOLLOWING' in state 25
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY FOLLOWING]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'FOLLOWING' in state 26
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY FOLLOWING]
parser: Input 'RANGE' in state 416
parser: FALLBACK RANGE => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK RANGE => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK RANGE => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'UNBOUNDED' in state 8
parser: Shift 'UNBOUNDED', go to state 503
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED]
parser: Input 'PRECEDING' in state 503
parser: Shift 'PRECEDING', pending reduce 302
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED PRECEDING]
parser: Input 'AND' with pending reduce 302
parser: Reduce 302 [frame_bound_s ::= UNBOUNDED PRECEDING], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'CURRENT' in state 7
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT ROW]
parser: Input 'RP' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ORDER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'FOLLOWING' in state 26
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY FOLLOWING]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT max(preceding) OVER (PARTITION BY preceding ORDER BY following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(preceding) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'PRECEDING' in state 266
parser: FALLBACK PRECEDING => ID
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct PRECEDING]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'PRECEDING' in state 25
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY PRECEDING]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'FOLLOWING' in state 26
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY FOLLOWING]
parser: Input 'RANGE' in state 416
parser: FALLBACK RANGE => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK RANGE => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK RANGE => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'UNBOUNDED' in state 8
parser: Shift 'UNBOUNDED', go to state 503
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED]
parser: Input 'PRECEDING' in state 503
parser: Shift 'PRECEDING', pending reduce 302
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED PRECEDING]
parser: Input 'AND' with pending reduce 302
parser: Reduce 302 [frame_bound_s ::= UNBOUNDED PRECEDING], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'CURRENT' in state 7
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT ROW]
parser: Input 'RP' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'COMMA' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'PRECEDING' in state 266
parser: FALLBACK PRECEDING => ID
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct PRECEDING]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'PRECEDING' in state 25
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY PRECEDING]
parser: Input 'RANGE' in state 416
parser: FALLBACK RANGE => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: FALLBACK RANGE => ID
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: FALLBACK RANGE => ID
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'UNBOUNDED' in state 8
parser: Shift 'UNBOUNDED', go to state 503
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED]
parser: Input 'PRECEDING' in state 503
parser: Shift 'PRECEDING', pending reduce 302
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED PRECEDING]
parser: Input 'AND' with pending reduce 302
parser: Reduce 302 [frame_bound_s ::= UNBOUNDED PRECEDING], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'CURRENT' in state 7
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT ROW]
parser: Input 'RP' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ORDER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'FOLLOWING' in state 26
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY FOLLOWING]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT sum(test002) OVER (PARTITION BY test001 ORDER BY test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'ID' in state 25
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY ID]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY ID]
parser: Input 'RANGE' in state 416
parser: FALLBACK RANGE => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK RANGE => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK RANGE => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'UNBOUNDED' in state 8
parser: Shift 'UNBOUNDED', go to state 503
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED]
parser: Input 'PRECEDING' in state 503
parser: Shift 'PRECEDING', pending reduce 302
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED PRECEDING]
parser: Input 'AND' with pending reduce 302
parser: Reduce 302 [frame_bound_s ::= UNBOUNDED PRECEDING], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'CURRENT' in state 7
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT ROW]
parser: Input 'RP' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'COMMA' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'ID' in state 25
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY ID]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Shift 'COMMA', go to state 95
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY sortlist COMMA]
parser: Input 'ID' in state 95
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY sortlist COMMA ID]
parser: Input 'RANGE' in state 416
parser: FALLBACK RANGE => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 95.
parser: ... then shift 'expr', go to state 14
parser: FALLBACK RANGE => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 129
parser: Reduce 129 [sortlist ::= sortlist COMMA expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK RANGE => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'UNBOUNDED' in state 8
parser: Shift 'UNBOUNDED', go to state 503
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED]
parser: Input 'PRECEDING' in state 503
parser: Shift 'PRECEDING', pending reduce 302
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED PRECEDING]
parser: Input 'AND' with pending reduce 302
parser: Reduce 302 [frame_bound_s ::= UNBOUNDED PRECEDING], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'CURRENT' in state 7
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT ROW]
parser: Input 'RP' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ORDER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(preceding) OVER (PARTITION BY following ORDER BY t1 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'PRECEDING' in state 266
parser: FALLBACK PRECEDING => ID
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct PRECEDING]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'FOLLOWING' in state 25
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY FOLLOWING]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY ID]
parser: Input 'DESC' in state 416
parser: FALLBACK DESC => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Shift 'DESC', pending reduce 132
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY expr DESC]
parser: Input 'RANGE' with pending reduce 132
parser: Reduce 132 [sortorder ::= DESC], go to state 13.
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK RANGE => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'UNBOUNDED' in state 8
parser: Shift 'UNBOUNDED', go to state 503
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED]
parser: Input 'PRECEDING' in state 503
parser: Shift 'PRECEDING', pending reduce 302
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED PRECEDING]
parser: Input 'AND' with pending reduce 302
parser: Reduce 302 [frame_bound_s ::= UNBOUNDED PRECEDING], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'CURRENT' in state 7
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT ROW]
parser: Input 'RP' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'COMMA' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'PRECEDING' in state 266
parser: FALLBACK PRECEDING => ID
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct PRECEDING]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'FOLLOWING' in state 25
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY FOLLOWING]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY ID]
parser: Input 'DESC' in state 416
parser: FALLBACK DESC => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Shift 'DESC', pending reduce 132
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY expr DESC]
parser: Input 'RANGE' with pending reduce 132
parser: Reduce 132 [sortorder ::= DESC], go to state 13.
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK RANGE => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'UNBOUNDED' in state 8
parser: Shift 'UNBOUNDED', go to state 503
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED]
parser: Input 'PRECEDING' in state 503
parser: Shift 'PRECEDING', pending reduce 302
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED PRECEDING]
parser: Input 'AND' with pending reduce 302
parser: Reduce 302 [frame_bound_s ::= UNBOUNDED PRECEDING], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'CURRENT' in state 7
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT ROW]
parser: Input 'RP' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ORDER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'FOLLOWING' in state 266
parser: FALLBACK FOLLOWING => ID
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct FOLLOWING]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'PRECEDING' in state 25
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY PRECEDING]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'PRECEDING' in state 26
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY PRECEDING]
parser: Input 'DESC' in state 416
parser: FALLBACK DESC => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Shift 'DESC', pending reduce 132
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY expr DESC]
parser: Input 'RANGE' with pending reduce 132
parser: Reduce 132 [sortorder ::= DESC], go to state 13.
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK RANGE => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'UNBOUNDED' in state 8
parser: Shift 'UNBOUNDED', go to state 503
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED]
parser: Input 'PRECEDING' in state 503
parser: Shift 'PRECEDING', pending reduce 302
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED PRECEDING]
parser: Input 'AND' with pending reduce 302
parser: Reduce 302 [frame_bound_s ::= UNBOUNDED PRECEDING], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'CURRENT' in state 7
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT ROW]
parser: Input 'RP' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'COMMA' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'FOLLOWING' in state 266
parser: FALLBACK FOLLOWING => ID
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct FOLLOWING]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'PRECEDING' in state 25
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY PRECEDING]
parser: Input 'RANGE' in state 416
parser: FALLBACK RANGE => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: FALLBACK RANGE => ID
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: FALLBACK RANGE => ID
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'UNBOUNDED' in state 8
parser: Shift 'UNBOUNDED', go to state 503
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED]
parser: Input 'PRECEDING' in state 503
parser: Shift 'PRECEDING', pending reduce 302
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED PRECEDING]
parser: Input 'AND' with pending reduce 302
parser: Reduce 302 [frame_bound_s ::= UNBOUNDED PRECEDING], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'CURRENT' in state 7
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT ROW]
parser: Input 'RP' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ORDER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'PRECEDING' in state 26
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY PRECEDING]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT max(t1) OVER (PARTITION BY t1 ORDER BY preceding DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY t1 ORDER BY t1, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'ID' in state 25
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY ID]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'PRECEDING' in state 26
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY PRECEDING]
parser: Input 'DESC' in state 416
parser: FALLBACK DESC => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Shift 'DESC', pending reduce 132
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY expr DESC]
parser: Input 'RANGE' with pending reduce 132
parser: Reduce 132 [sortorder ::= DESC], go to state 13.
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK RANGE => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'UNBOUNDED' in state 8
parser: Shift 'UNBOUNDED', go to state 503
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED]
parser: Input 'PRECEDING' in state 503
parser: Shift 'PRECEDING', pending reduce 302
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED PRECEDING]
parser: Input 'AND' with pending reduce 302
parser: Reduce 302 [frame_bound_s ::= UNBOUNDED PRECEDING], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'CURRENT' in state 7
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT ROW]
parser: Input 'RP' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'COMMA' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'ID' in state 25
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY ID]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Shift 'COMMA', go to state 95
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY sortlist COMMA]
parser: Input 'PRECEDING' in state 95
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY sortlist COMMA PRECEDING]
parser: Input 'RANGE' in state 416
parser: FALLBACK RANGE => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 95.
parser: ... then shift 'expr', go to state 14
parser: FALLBACK RANGE => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 129
parser: Reduce 129 [sortlist ::= sortlist COMMA expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK RANGE => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'UNBOUNDED' in state 8
parser: Shift 'UNBOUNDED', go to state 503
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED]
parser: Input 'PRECEDING' in state 503
parser: Shift 'PRECEDING', pending reduce 302
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED PRECEDING]
parser: Input 'AND' with pending reduce 302
parser: Reduce 302 [frame_bound_s ::= UNBOUNDED PRECEDING], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'CURRENT' in state 7
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT ROW]
parser: Input 'RP' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ORDER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'PRECEDING' in state 26
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY PRECEDING]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT sum(t1) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(t1) OVER (PARTITION BY t1 ORDER BY following DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'ID' in state 25
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY ID]
parser: Input 'RANGE' in state 416
parser: FALLBACK RANGE => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: FALLBACK RANGE => ID
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: FALLBACK RANGE => ID
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'UNBOUNDED' in state 8
parser: Shift 'UNBOUNDED', go to state 503
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED]
parser: Input 'PRECEDING' in state 503
parser: Shift 'PRECEDING', pending reduce 302
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED PRECEDING]
parser: Input 'AND' with pending reduce 302
parser: Reduce 302 [frame_bound_s ::= UNBOUNDED PRECEDING], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'CURRENT' in state 7
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT ROW]
parser: Input 'RP' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'COMMA' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'ID' in state 25
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY ID]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'FOLLOWING' in state 26
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY FOLLOWING]
parser: Input 'DESC' in state 416
parser: FALLBACK DESC => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Shift 'DESC', pending reduce 132
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY expr DESC]
parser: Input 'RANGE' with pending reduce 132
parser: Reduce 132 [sortorder ::= DESC], go to state 13.
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK RANGE => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'UNBOUNDED' in state 8
parser: Shift 'UNBOUNDED', go to state 503
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED]
parser: Input 'PRECEDING' in state 503
parser: Shift 'PRECEDING', pending reduce 302
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED PRECEDING]
parser: Input 'AND' with pending reduce 302
parser: Reduce 302 [frame_bound_s ::= UNBOUNDED PRECEDING], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'CURRENT' in state 7
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT ROW]
parser: Input 'RP' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ORDER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'FOLLOWING' in state 26
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY FOLLOWING]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(test002) OVER (PARTITION BY test001  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY last_field

;SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'ID' in state 25
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY ID]
parser: Input 'RANGE' in state 416
parser: FALLBACK RANGE => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: FALLBACK RANGE => ID
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: FALLBACK RANGE => ID
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'UNBOUNDED' in state 8
parser: Shift 'UNBOUNDED', go to state 503
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED]
parser: Input 'PRECEDING' in state 503
parser: Shift 'PRECEDING', pending reduce 302
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED PRECEDING]
parser: Input 'AND' with pending reduce 302
parser: Reduce 302 [frame_bound_s ::= UNBOUNDED PRECEDING], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'CURRENT' in state 7
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT ROW]
parser: Input 'RP' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'COMMA' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'ID' in state 25
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY ID]
parser: Input 'RANGE' in state 416
parser: FALLBACK RANGE => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: FALLBACK RANGE => ID
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: FALLBACK RANGE => ID
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'UNBOUNDED' in state 8
parser: Shift 'UNBOUNDED', go to state 503
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED]
parser: Input 'PRECEDING' in state 503
parser: Shift 'PRECEDING', pending reduce 302
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED PRECEDING]
parser: Input 'AND' with pending reduce 302
parser: Reduce 302 [frame_bound_s ::= UNBOUNDED PRECEDING], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'CURRENT' in state 7
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT ROW]
parser: Input 'RP' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ORDER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT max(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'FOLLOWING' in state 266
parser: FALLBACK FOLLOWING => ID
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct FOLLOWING]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'PRECEDING' in state 25
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY PRECEDING]
parser: Input 'RANGE' in state 416
parser: FALLBACK RANGE => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: FALLBACK RANGE => ID
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: FALLBACK RANGE => ID
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'UNBOUNDED' in state 8
parser: Shift 'UNBOUNDED', go to state 503
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED]
parser: Input 'PRECEDING' in state 503
parser: Shift 'PRECEDING', pending reduce 302
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED PRECEDING]
parser: Input 'AND' with pending reduce 302
parser: Reduce 302 [frame_bound_s ::= UNBOUNDED PRECEDING], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'CURRENT' in state 7
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT ROW]
parser: Input 'RP' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'COMMA' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'FOLLOWING' in state 266
parser: FALLBACK FOLLOWING => ID
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct FOLLOWING]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'PRECEDING' in state 25
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY PRECEDING]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'PRECEDING' in state 26
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY PRECEDING]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Shift 'COMMA', go to state 95
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY sortlist COMMA]
parser: Input 'ID' in state 95
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY sortlist COMMA ID]
parser: Input 'RANGE' in state 416
parser: FALLBACK RANGE => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 95.
parser: ... then shift 'expr', go to state 14
parser: FALLBACK RANGE => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 129
parser: Reduce 129 [sortlist ::= sortlist COMMA expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK RANGE => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'UNBOUNDED' in state 8
parser: Shift 'UNBOUNDED', go to state 503
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED]
parser: Input 'PRECEDING' in state 503
parser: Shift 'PRECEDING', pending reduce 302
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED PRECEDING]
parser: Input 'AND' with pending reduce 302
parser: Reduce 302 [frame_bound_s ::= UNBOUNDED PRECEDING], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'CURRENT' in state 7
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT ROW]
parser: Input 'RP' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ORDER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT sum(following) OVER (PARTITION BY t1  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY t1 ORDER BY t1, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'FOLLOWING' in state 266
parser: FALLBACK FOLLOWING => ID
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct FOLLOWING]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'ID' in state 25
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY ID]
parser: Input 'RANGE' in state 416
parser: FALLBACK RANGE => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: FALLBACK RANGE => ID
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: FALLBACK RANGE => ID
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'UNBOUNDED' in state 8
parser: Shift 'UNBOUNDED', go to state 503
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED]
parser: Input 'PRECEDING' in state 503
parser: Shift 'PRECEDING', pending reduce 302
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED PRECEDING]
parser: Input 'AND' with pending reduce 302
parser: Reduce 302 [frame_bound_s ::= UNBOUNDED PRECEDING], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'CURRENT' in state 7
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT ROW]
parser: Input 'RP' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'COMMA' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'FOLLOWING' in state 266
parser: FALLBACK FOLLOWING => ID
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct FOLLOWING]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'ID' in state 25
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY ID]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Shift 'COMMA', go to state 95
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY sortlist COMMA]
parser: Input 'FOLLOWING' in state 95
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY sortlist COMMA FOLLOWING]
parser: Input 'RANGE' in state 416
parser: FALLBACK RANGE => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 95.
parser: ... then shift 'expr', go to state 14
parser: FALLBACK RANGE => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 129
parser: Reduce 129 [sortlist ::= sortlist COMMA expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK RANGE => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'UNBOUNDED' in state 8
parser: Shift 'UNBOUNDED', go to state 503
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED]
parser: Input 'PRECEDING' in state 503
parser: Shift 'PRECEDING', pending reduce 302
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED PRECEDING]
parser: Input 'AND' with pending reduce 302
parser: Reduce 302 [frame_bound_s ::= UNBOUNDED PRECEDING], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'CURRENT' in state 7
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT ROW]
parser: Input 'RP' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ORDER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'FOLLOWING' in state 26
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY FOLLOWING]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT max(t1) OVER (PARTITION BY preceding ORDER BY preceding, preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(t1) OVER (PARTITION BY preceding ORDER BY preceding RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY preceding

;SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'PRECEDING' in state 25
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY PRECEDING]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'PRECEDING' in state 26
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY PRECEDING]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Shift 'COMMA', go to state 95
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY sortlist COMMA]
parser: Input 'PRECEDING' in state 95
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY sortlist COMMA PRECEDING]
parser: Input 'RANGE' in state 416
parser: FALLBACK RANGE => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 95.
parser: ... then shift 'expr', go to state 14
parser: FALLBACK RANGE => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 129
parser: Reduce 129 [sortlist ::= sortlist COMMA expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK RANGE => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'UNBOUNDED' in state 8
parser: Shift 'UNBOUNDED', go to state 503
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED]
parser: Input 'PRECEDING' in state 503
parser: Shift 'PRECEDING', pending reduce 302
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED PRECEDING]
parser: Input 'AND' with pending reduce 302
parser: Reduce 302 [frame_bound_s ::= UNBOUNDED PRECEDING], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'CURRENT' in state 7
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT ROW]
parser: Input 'RP' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'COMMA' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'PRECEDING' in state 25
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY PRECEDING]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'PRECEDING' in state 26
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY PRECEDING]
parser: Input 'RANGE' in state 416
parser: FALLBACK RANGE => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK RANGE => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK RANGE => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'UNBOUNDED' in state 8
parser: Shift 'UNBOUNDED', go to state 503
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED]
parser: Input 'PRECEDING' in state 503
parser: Shift 'PRECEDING', pending reduce 302
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED PRECEDING]
parser: Input 'AND' with pending reduce 302
parser: Reduce 302 [frame_bound_s ::= UNBOUNDED PRECEDING], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'CURRENT' in state 7
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT ROW]
parser: Input 'RP' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ORDER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'PRECEDING' in state 26
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY PRECEDING]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT sum(last_field) OVER (PARTITION BY test001 ORDER BY test001, test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(last_field) OVER (PARTITION BY test001 ORDER BY test001 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test001

;SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'ID' in state 25
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY ID]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Shift 'COMMA', go to state 95
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY sortlist COMMA]
parser: Input 'ID' in state 95
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY sortlist COMMA ID]
parser: Input 'RANGE' in state 416
parser: FALLBACK RANGE => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 95.
parser: ... then shift 'expr', go to state 14
parser: FALLBACK RANGE => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 129
parser: Reduce 129 [sortlist ::= sortlist COMMA expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK RANGE => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'UNBOUNDED' in state 8
parser: Shift 'UNBOUNDED', go to state 503
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED]
parser: Input 'PRECEDING' in state 503
parser: Shift 'PRECEDING', pending reduce 302
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED PRECEDING]
parser: Input 'AND' with pending reduce 302
parser: Reduce 302 [frame_bound_s ::= UNBOUNDED PRECEDING], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'CURRENT' in state 7
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT ROW]
parser: Input 'RP' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'COMMA' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'ID' in state 25
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY ID]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY ID]
parser: Input 'RANGE' in state 416
parser: FALLBACK RANGE => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: FALLBACK RANGE => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK RANGE => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'UNBOUNDED' in state 8
parser: Shift 'UNBOUNDED', go to state 503
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED]
parser: Input 'PRECEDING' in state 503
parser: Shift 'PRECEDING', pending reduce 302
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED PRECEDING]
parser: Input 'AND' with pending reduce 302
parser: Reduce 302 [frame_bound_s ::= UNBOUNDED PRECEDING], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'CURRENT' in state 7
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT ROW]
parser: Input 'RP' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ORDER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT max(last_field) OVER (PARTITION BY test001 ORDER BY test001, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(last_field) OVER (PARTITION BY test001 ORDER BY test002 DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'ID' in state 25
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY ID]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Shift 'COMMA', go to state 95
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY sortlist COMMA]
parser: Input 'ID' in state 95
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY sortlist COMMA ID]
parser: Input 'RANGE' in state 416
parser: FALLBACK RANGE => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 95.
parser: ... then shift 'expr', go to state 14
parser: FALLBACK RANGE => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 129
parser: Reduce 129 [sortlist ::= sortlist COMMA expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK RANGE => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'UNBOUNDED' in state 8
parser: Shift 'UNBOUNDED', go to state 503
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED]
parser: Input 'PRECEDING' in state 503
parser: Shift 'PRECEDING', pending reduce 302
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED PRECEDING]
parser: Input 'AND' with pending reduce 302
parser: Reduce 302 [frame_bound_s ::= UNBOUNDED PRECEDING], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'CURRENT' in state 7
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT ROW]
parser: Input 'RP' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'COMMA' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'ID' in state 25
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY ID]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY ID]
parser: Input 'DESC' in state 416
parser: FALLBACK DESC => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Shift 'DESC', pending reduce 132
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY expr DESC]
parser: Input 'RANGE' with pending reduce 132
parser: Reduce 132 [sortorder ::= DESC], go to state 13.
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK RANGE => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'UNBOUNDED' in state 8
parser: Shift 'UNBOUNDED', go to state 503
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED]
parser: Input 'PRECEDING' in state 503
parser: Shift 'PRECEDING', pending reduce 302
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED PRECEDING]
parser: Input 'AND' with pending reduce 302
parser: Reduce 302 [frame_bound_s ::= UNBOUNDED PRECEDING], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'CURRENT' in state 7
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT ROW]
parser: Input 'RP' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ORDER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT sum(following) OVER (PARTITION BY preceding ORDER BY preceding, t1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY preceding  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY t1

;SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'FOLLOWING' in state 266
parser: FALLBACK FOLLOWING => ID
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct FOLLOWING]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'PRECEDING' in state 25
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY PRECEDING]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'PRECEDING' in state 26
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY PRECEDING]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Shift 'COMMA', go to state 95
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY sortlist COMMA]
parser: Input 'ID' in state 95
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY sortlist COMMA ID]
parser: Input 'RANGE' in state 416
parser: FALLBACK RANGE => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 95.
parser: ... then shift 'expr', go to state 14
parser: FALLBACK RANGE => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 129
parser: Reduce 129 [sortlist ::= sortlist COMMA expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK RANGE => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'UNBOUNDED' in state 8
parser: Shift 'UNBOUNDED', go to state 503
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED]
parser: Input 'PRECEDING' in state 503
parser: Shift 'PRECEDING', pending reduce 302
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED PRECEDING]
parser: Input 'AND' with pending reduce 302
parser: Reduce 302 [frame_bound_s ::= UNBOUNDED PRECEDING], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'CURRENT' in state 7
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT ROW]
parser: Input 'RP' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'COMMA' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'FOLLOWING' in state 266
parser: FALLBACK FOLLOWING => ID
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct FOLLOWING]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'PRECEDING' in state 25
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY PRECEDING]
parser: Input 'RANGE' in state 416
parser: FALLBACK RANGE => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: FALLBACK RANGE => ID
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: FALLBACK RANGE => ID
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'UNBOUNDED' in state 8
parser: Shift 'UNBOUNDED', go to state 503
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED]
parser: Input 'PRECEDING' in state 503
parser: Shift 'PRECEDING', pending reduce 302
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED PRECEDING]
parser: Input 'AND' with pending reduce 302
parser: Reduce 302 [frame_bound_s ::= UNBOUNDED PRECEDING], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'CURRENT' in state 7
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT ROW]
parser: Input 'RP' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ORDER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT max(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
  min(test001) OVER (PARTITION BY test002 ORDER BY test002, test002 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM x ORDER BY test002

;SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'ID' in state 25
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY ID]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Shift 'COMMA', go to state 95
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY sortlist COMMA]
parser: Input 'ID' in state 95
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY sortlist COMMA ID]
parser: Input 'RANGE' in state 416
parser: FALLBACK RANGE => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 95.
parser: ... then shift 'expr', go to state 14
parser: FALLBACK RANGE => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 129
parser: Reduce 129 [sortlist ::= sortlist COMMA expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK RANGE => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'UNBOUNDED' in state 8
parser: Shift 'UNBOUNDED', go to state 503
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED]
parser: Input 'PRECEDING' in state 503
parser: Shift 'PRECEDING', pending reduce 302
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED PRECEDING]
parser: Input 'AND' with pending reduce 302
parser: Reduce 302 [frame_bound_s ::= UNBOUNDED PRECEDING], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'CURRENT' in state 7
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT ROW]
parser: Input 'RP' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'COMMA' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'ID' in state 25
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY ID]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Shift 'COMMA', go to state 95
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY sortlist COMMA]
parser: Input 'ID' in state 95
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY sortlist COMMA ID]
parser: Input 'RANGE' in state 416
parser: FALLBACK RANGE => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 95.
parser: ... then shift 'expr', go to state 14
parser: FALLBACK RANGE => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 129
parser: Reduce 129 [sortlist ::= sortlist COMMA expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK RANGE => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'UNBOUNDED' in state 8
parser: Shift 'UNBOUNDED', go to state 503
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED]
parser: Input 'PRECEDING' in state 503
parser: Shift 'PRECEDING', pending reduce 302
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED PRECEDING]
parser: Input 'AND' with pending reduce 302
parser: Reduce 302 [frame_bound_s ::= UNBOUNDED PRECEDING], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'CURRENT' in state 7
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT ROW]
parser: Input 'RP' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ORDER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 
         sum(following) OVER (PARTITION BY following ORDER BY following, following RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  FROM over ORDER BY following

;DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'FOLLOWING' in state 266
parser: FALLBACK FOLLOWING => ID
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct FOLLOWING]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'FOLLOWING' in state 25
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY FOLLOWING]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'FOLLOWING' in state 26
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY FOLLOWING]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Shift 'COMMA', go to state 95
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY sortlist COMMA]
parser: Input 'FOLLOWING' in state 95
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY sortlist COMMA FOLLOWING]
parser: Input 'RANGE' in state 416
parser: FALLBACK RANGE => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 95.
parser: ... then shift 'expr', go to state 14
parser: FALLBACK RANGE => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 129
parser: Reduce 129 [sortlist ::= sortlist COMMA expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK RANGE => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'UNBOUNDED' in state 8
parser: Shift 'UNBOUNDED', go to state 503
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED]
parser: Input 'PRECEDING' in state 503
parser: Shift 'PRECEDING', pending reduce 302
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED PRECEDING]
parser: Input 'AND' with pending reduce 302
parser: Reduce 302 [frame_bound_s ::= UNBOUNDED PRECEDING], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'CURRENT' in state 7
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT ROW]
parser: Input 'RP' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'COMMA' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'FOLLOWING' in state 266
parser: FALLBACK FOLLOWING => ID
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct FOLLOWING]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 509
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION]
parser: Input 'BY' in state 509
parser: Shift 'BY', go to state 25
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY]
parser: Input 'FOLLOWING' in state 25
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY FOLLOWING]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY]
parser: Input 'FOLLOWING' in state 26
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY FOLLOWING]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Shift 'COMMA', go to state 95
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY sortlist COMMA]
parser: Input 'FOLLOWING' in state 95
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist ORDER BY sortlist COMMA FOLLOWING]
parser: Input 'RANGE' in state 416
parser: FALLBACK RANGE => ID
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 95.
parser: ... then shift 'expr', go to state 14
parser: FALLBACK RANGE => ID
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 129
parser: Reduce 129 [sortlist ::= sortlist COMMA expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: FALLBACK RANGE => ID
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 285.
parser: ... then shift 'orderby_opt', go to state 189
parser: Shift 'RANGE', pending reduce 300
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt RANGE]
parser: Input 'BETWEEN' with pending reduce 300
parser: Reduce 300 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 189.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN]
parser: Input 'UNBOUNDED' in state 8
parser: Shift 'UNBOUNDED', go to state 503
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED]
parser: Input 'PRECEDING' in state 503
parser: Shift 'PRECEDING', pending reduce 302
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN UNBOUNDED PRECEDING]
parser: Input 'AND' with pending reduce 302
parser: Reduce 302 [frame_bound_s ::= UNBOUNDED PRECEDING], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 506
parser: Shift 'AND', go to state 7
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'CURRENT' in state 7
parser: Shift 'CURRENT', go to state 504
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT]
parser: Input 'ROW' in state 504
parser: Shift 'ROW', pending reduce 306
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP PARTITION BY nexprlist orderby_opt range_or_rows BETWEEN frame_bound_s AND CURRENT ROW]
parser: Input 'RP' with pending reduce 306
parser: Reduce 306 [frame_bound ::= CURRENT ROW], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 303
parser: Reduce 303 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 350
parser: Reduce 307 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 299
parser: Reduce 299 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 189.
parser: ... then shift 'frame_opt', pending reduce 291
parser: Reduce 291 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ORDER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'FOLLOWING' in state 26
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY FOLLOWING]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[DROP TABLE IF EXISTS t1;;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'DROP' in state 0
parser: Shift 'DROP', go to state 385
parser: Return. Stack=[DROP]
parser: Input 'TABLE' in state 385
parser: Shift 'TABLE', go to state 304
parser: Return. Stack=[DROP TABLE]
parser: Input 'IF' in state 304
parser: Shift 'IF', go to state 431
parser: Return. Stack=[DROP TABLE IF]
parser: Input 'EXISTS' in state 431
parser: Shift 'EXISTS', pending reduce 75
parser: Return. Stack=[DROP TABLE IF EXISTS]
parser: Input 'ID' with pending reduce 75
parser: Reduce 75 [ifexists ::= IF EXISTS], go to state 304.
parser: ... then shift 'ifexists', go to state 171
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[DROP TABLE ifexists ID]
parser: Input 'SEMI' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 171.
parser: ... then shift 'nm', go to state 459
parser: Reduce 110 [fullname ::= nm], go to state 171.
parser: ... then shift 'fullname', pending reduce 74
parser: Reduce 74 [cmd ::= DROP TABLE ifexists fullname], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[;INSERT INTO x VALUES(1, 2);;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'INSERT' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'INSERT', go to state 311
parser: Return. Stack=[ecmd with INSERT]
parser: Input 'INTO' in state 311
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', pending reduce 156
parser: Reduce 156 [insert_cmd ::= INSERT orconf], go to state 219.
parser: ... then shift 'insert_cmd', go to state 427
parser: Shift 'INTO', go to state 164
parser: Return. Stack=[ecmd with insert_cmd INTO]
parser: Input 'ID' in state 164
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd with insert_cmd INTO ID]
parser: Input 'VALUES' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 164.
parser: ... then shift 'nm', go to state 393
parser: Reduce 112 [xfullname ::= nm], go to state 164.
parser: ... then shift 'xfullname', go to state 298
parser: Reduce 158 [idlist_opt ::=].
parser: ... then shift 'idlist_opt', go to state 35
parser: Shift 'VALUES', go to state 526
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES]
parser: Input 'LP' in state 526
parser: Shift 'LP', go to state 28
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP]
parser: Input 'INTEGER' in state 28
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 28.
parser: ... then shift 'term', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'INTEGER' in state 107
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'RP', pending reduce 89
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist RP]
parser: Input 'SEMI' with pending reduce 89
parser: Reduce 89 [values ::= VALUES LP nexprlist RP], go to state 35.
parser: ... then shift 'values', go to state 532
parser: Reduce 348 [oneselect ::= values], go to state 35.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 35.
parser: ... then shift 'select', go to state 297
parser: Reduce 152 [upsert ::=].
parser: ... then shift 'upsert', pending reduce 150
parser: Reduce 150 [cmd ::= with insert_cmd INTO xfullname idlist_opt select upsert], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
parser: [[[;INSERT INTO over VALUES(3, 4);SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'INSERT' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'INSERT', go to state 311
parser: Return. Stack=[ecmd with INSERT]
parser: Input 'INTO' in state 311
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', pending reduce 156
parser: Reduce 156 [insert_cmd ::= INSERT orconf], go to state 219.
parser: ... then shift 'insert_cmd', go to state 427
parser: Shift 'INTO', go to state 164
parser: Return. Stack=[ecmd with insert_cmd INTO]
parser: Input 'ID' in state 164
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd with insert_cmd INTO ID]
parser: Input 'VALUES' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 164.
parser: ... then shift 'nm', go to state 393
parser: Reduce 112 [xfullname ::= nm], go to state 164.
parser: ... then shift 'xfullname', go to state 298
parser: Reduce 158 [idlist_opt ::=].
parser: ... then shift 'idlist_opt', go to state 35
parser: Shift 'VALUES', go to state 526
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES]
parser: Input 'LP' in state 526
parser: Shift 'LP', go to state 28
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP]
parser: Input 'INTEGER' in state 28
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 28.
parser: ... then shift 'term', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'INTEGER' in state 107
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'RP', pending reduce 89
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist RP]
parser: Input 'SEMI' with pending reduce 89
parser: Reduce 89 [values ::= VALUES LP nexprlist RP], go to state 35.
parser: ... then shift 'values', go to state 532
parser: Reduce 348 [oneselect ::= values], go to state 35.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 35.
parser: ... then shift 'select', go to state 297
parser: Reduce 152 [upsert ::=].
parser: ... then shift 'upsert', pending reduce 150
parser: Reduce 150 [cmd ::= with insert_cmd INTO xfullname idlist_opt select upsert], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
parser: [[[SELECT lead(preceding, 2) OVER win FROM over
  WINDOW win AS (ORDER BY t1)

;SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'PRECEDING' in state 266
parser: FALLBACK PRECEDING => ID
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct PRECEDING]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct nexprlist COMMA]
parser: Input 'INTEGER' in state 107
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'ID' in state 204
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER ID]
parser: Input 'FROM' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 204.
parser: ... then shift 'nm', pending reduce 314
parser: Reduce 314 [over_clause ::= filter_opt OVER nm], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'WINDOW' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'WINDOW', go to state 136
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW]
parser: Input 'ID' in state 136
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW ID]
parser: Input 'AS' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 136.
parser: ... then shift 'nm', go to state 512
parser: Shift 'AS', go to state 511
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS]
parser: Input 'LP' in state 511
parser: Shift 'LP', go to state 33
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP]
parser: Input 'ORDER' in state 33
parser: Shift 'ORDER', go to state 500
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP ORDER]
parser: Input 'BY' in state 500
parser: Shift 'BY', go to state 22
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP ORDER BY]
parser: Input 'ID' in state 22
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP ORDER BY ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 22.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 22.
parser: ... then shift 'sortlist', go to state 184
parser: Reduce 297 [frame_opt ::=].
parser: ... then shift 'frame_opt', pending reduce 293
parser: Reduce 293 [window ::= ORDER BY sortlist frame_opt], go to state 33.
parser: ... then shift 'window', go to state 510
parser: Shift 'RP', pending reduce 290
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP window RP]
parser: Input 'SEMI' with pending reduce 290
parser: Reduce 290 [windowdefn ::= nm AS LP window RP], go to state 136.
parser: ... then shift 'windowdefn', pending reduce 288
parser: Reduce 288 [windowdefn_list ::= windowdefn], go to state 136.
parser: ... then shift 'windowdefn_list', go to state 513
parser: Reduce 312 [window_clause ::= WINDOW windowdefn_list], go to state 194.
parser: ... then shift 'window_clause', go to state 353
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 352
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 88
parser: Reduce 88 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt window_clause orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT lead(test001, 3, -1) OVER win FROM x
  WINDOW win AS (ORDER BY test001)

;SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct nexprlist COMMA]
parser: Input 'INTEGER' in state 107
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct nexprlist COMMA INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct nexprlist COMMA]
parser: Input 'MINUS' in state 107
parser: Shift 'MINUS', go to state 103
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct nexprlist COMMA MINUS]
parser: Input 'INTEGER' in state 103
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct nexprlist COMMA MINUS INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 103.
parser: ... then shift 'term', go to state 147
parser: Reduce 196 [expr ::= PLUS|MINUS expr], go to state 107.
parser: ... then shift 'expr', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'ID' in state 204
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER ID]
parser: Input 'FROM' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 204.
parser: ... then shift 'nm', pending reduce 314
parser: Reduce 314 [over_clause ::= filter_opt OVER nm], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'WINDOW' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'WINDOW', go to state 136
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW]
parser: Input 'ID' in state 136
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW ID]
parser: Input 'AS' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 136.
parser: ... then shift 'nm', go to state 512
parser: Shift 'AS', go to state 511
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS]
parser: Input 'LP' in state 511
parser: Shift 'LP', go to state 33
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP]
parser: Input 'ORDER' in state 33
parser: Shift 'ORDER', go to state 500
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP ORDER]
parser: Input 'BY' in state 500
parser: Shift 'BY', go to state 22
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP ORDER BY]
parser: Input 'ID' in state 22
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP ORDER BY ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 22.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 22.
parser: ... then shift 'sortlist', go to state 184
parser: Reduce 297 [frame_opt ::=].
parser: ... then shift 'frame_opt', pending reduce 293
parser: Reduce 293 [window ::= ORDER BY sortlist frame_opt], go to state 33.
parser: ... then shift 'window', go to state 510
parser: Shift 'RP', pending reduce 290
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP window RP]
parser: Input 'SEMI' with pending reduce 290
parser: Reduce 290 [windowdefn ::= nm AS LP window RP], go to state 136.
parser: ... then shift 'windowdefn', pending reduce 288
parser: Reduce 288 [windowdefn_list ::= windowdefn], go to state 136.
parser: ... then shift 'windowdefn_list', go to state 513
parser: Reduce 312 [window_clause ::= WINDOW windowdefn_list], go to state 194.
parser: ... then shift 'window_clause', go to state 353
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 352
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 88
parser: Reduce 88 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt window_clause orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT 
    lead(test002) OVER win, lead(test002) OVER win
  FROM x
  WINDOW win AS (ORDER BY last_field)

;SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'ID' in state 204
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER ID]
parser: Input 'COMMA' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 204.
parser: ... then shift 'nm', pending reduce 314
parser: Reduce 314 [over_clause ::= filter_opt OVER nm], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'ID' in state 204
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER ID]
parser: Input 'FROM' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 204.
parser: ... then shift 'nm', pending reduce 314
parser: Reduce 314 [over_clause ::= filter_opt OVER nm], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'WINDOW' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'WINDOW', go to state 136
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW]
parser: Input 'ID' in state 136
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW ID]
parser: Input 'AS' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 136.
parser: ... then shift 'nm', go to state 512
parser: Shift 'AS', go to state 511
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS]
parser: Input 'LP' in state 511
parser: Shift 'LP', go to state 33
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP]
parser: Input 'ORDER' in state 33
parser: Shift 'ORDER', go to state 500
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP ORDER]
parser: Input 'BY' in state 500
parser: Shift 'BY', go to state 22
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP ORDER BY]
parser: Input 'ID' in state 22
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP ORDER BY ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 22.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 22.
parser: ... then shift 'sortlist', go to state 184
parser: Reduce 297 [frame_opt ::=].
parser: ... then shift 'frame_opt', pending reduce 293
parser: Reduce 293 [window ::= ORDER BY sortlist frame_opt], go to state 33.
parser: ... then shift 'window', go to state 510
parser: Shift 'RP', pending reduce 290
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP window RP]
parser: Input 'SEMI' with pending reduce 290
parser: Reduce 290 [windowdefn ::= nm AS LP window RP], go to state 136.
parser: ... then shift 'windowdefn', pending reduce 288
parser: Reduce 288 [windowdefn_list ::= windowdefn], go to state 136.
parser: ... then shift 'windowdefn_list', go to state 513
parser: Reduce 312 [window_clause ::= WINDOW windowdefn_list], go to state 194.
parser: ... then shift 'window_clause', go to state 353
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 352
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 88
parser: Reduce 88 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt window_clause orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT 
    lead(following) OVER win, 
    lead(following, 2) OVER win, 
    lead(following, 3, -1) OVER win
  FROM over
  WINDOW win AS (ORDER BY t1)

;DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'FOLLOWING' in state 266
parser: FALLBACK FOLLOWING => ID
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct FOLLOWING]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'ID' in state 204
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER ID]
parser: Input 'COMMA' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 204.
parser: ... then shift 'nm', pending reduce 314
parser: Reduce 314 [over_clause ::= filter_opt OVER nm], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'FOLLOWING' in state 266
parser: FALLBACK FOLLOWING => ID
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct FOLLOWING]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct nexprlist COMMA]
parser: Input 'INTEGER' in state 107
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'ID' in state 204
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER ID]
parser: Input 'COMMA' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 204.
parser: ... then shift 'nm', pending reduce 314
parser: Reduce 314 [over_clause ::= filter_opt OVER nm], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'FOLLOWING' in state 266
parser: FALLBACK FOLLOWING => ID
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct FOLLOWING]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct nexprlist COMMA]
parser: Input 'INTEGER' in state 107
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct nexprlist COMMA INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct nexprlist COMMA]
parser: Input 'MINUS' in state 107
parser: Shift 'MINUS', go to state 103
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct nexprlist COMMA MINUS]
parser: Input 'INTEGER' in state 103
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct nexprlist COMMA MINUS INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 103.
parser: ... then shift 'term', go to state 147
parser: Reduce 196 [expr ::= PLUS|MINUS expr], go to state 107.
parser: ... then shift 'expr', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'ID' in state 204
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER ID]
parser: Input 'FROM' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 204.
parser: ... then shift 'nm', pending reduce 314
parser: Reduce 314 [over_clause ::= filter_opt OVER nm], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'WINDOW' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'WINDOW', go to state 136
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW]
parser: Input 'ID' in state 136
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW ID]
parser: Input 'AS' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 136.
parser: ... then shift 'nm', go to state 512
parser: Shift 'AS', go to state 511
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS]
parser: Input 'LP' in state 511
parser: Shift 'LP', go to state 33
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP]
parser: Input 'ORDER' in state 33
parser: Shift 'ORDER', go to state 500
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP ORDER]
parser: Input 'BY' in state 500
parser: Shift 'BY', go to state 22
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP ORDER BY]
parser: Input 'ID' in state 22
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP ORDER BY ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 22.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 22.
parser: ... then shift 'sortlist', go to state 184
parser: Reduce 297 [frame_opt ::=].
parser: ... then shift 'frame_opt', pending reduce 293
parser: Reduce 293 [window ::= ORDER BY sortlist frame_opt], go to state 33.
parser: ... then shift 'window', go to state 510
parser: Shift 'RP', pending reduce 290
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP window RP]
parser: Input 'SEMI' with pending reduce 290
parser: Reduce 290 [windowdefn ::= nm AS LP window RP], go to state 136.
parser: ... then shift 'windowdefn', pending reduce 288
parser: Reduce 288 [windowdefn_list ::= windowdefn], go to state 136.
parser: ... then shift 'windowdefn_list', go to state 513
parser: Reduce 312 [window_clause ::= WINDOW windowdefn_list], go to state 194.
parser: ... then shift 'window_clause', go to state 353
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 352
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 88
parser: Reduce 88 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt window_clause orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[DROP TABLE IF EXISTS x;;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'DROP' in state 0
parser: Shift 'DROP', go to state 385
parser: Return. Stack=[DROP]
parser: Input 'TABLE' in state 385
parser: Shift 'TABLE', go to state 304
parser: Return. Stack=[DROP TABLE]
parser: Input 'IF' in state 304
parser: Shift 'IF', go to state 431
parser: Return. Stack=[DROP TABLE IF]
parser: Input 'EXISTS' in state 431
parser: Shift 'EXISTS', pending reduce 75
parser: Return. Stack=[DROP TABLE IF EXISTS]
parser: Input 'ID' with pending reduce 75
parser: Reduce 75 [ifexists ::= IF EXISTS], go to state 304.
parser: ... then shift 'ifexists', go to state 171
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[DROP TABLE ifexists ID]
parser: Input 'SEMI' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 171.
parser: ... then shift 'nm', go to state 459
parser: Reduce 110 [fullname ::= nm], go to state 171.
parser: ... then shift 'fullname', pending reduce 74
parser: Reduce 74 [cmd ::= DROP TABLE ifexists fullname], go to state 0.
parser: [[[DELETE FROM 'main'.sqlite_master WHERE tbl_name='x' and type!='trigger']]]
parser: Input 'DELETE' in state 0
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'DELETE', go to state 430
parser: Return. Stack=[with DELETE]
parser: Input 'FROM' in state 430
parser: Shift 'FROM', go to state 166
parser: Return. Stack=[with DELETE FROM]
parser: Input 'STRING' in state 166
parser: Shift 'STRING', pending reduce 332
parser: Return. Stack=[with DELETE FROM STRING]
parser: Input 'DOT' with pending reduce 332
parser: Reduce 332 [nm ::= STRING], go to state 166.
parser: ... then shift 'nm', go to state 393
parser: Shift 'DOT', go to state 218
parser: Return. Stack=[with DELETE FROM nm DOT]
parser: Input 'ID' in state 218
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with DELETE FROM nm DOT ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 218.
parser: ... then shift 'nm', go to state 429
parser: Reduce 113 [xfullname ::= nm DOT nm], go to state 166.
parser: ... then shift 'xfullname', go to state 272
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 300
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[with DELETE FROM xfullname indexed_opt WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 416
parser: Return. Stack=[with DELETE FROM xfullname indexed_opt WHERE ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[with DELETE FROM xfullname indexed_opt WHERE expr EQ]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with DELETE FROM xfullname indexed_opt WHERE expr EQ STRING]
parser: Input 'AND' in state 537
parser: Reduce 168 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'AND', go to state 120
parser: Return. Stack=[with DELETE FROM xfullname indexed_opt WHERE expr AND]
parser: Input 'ID' in state 120
parser: Shift 'ID', go to state 416
parser: Return. Stack=[with DELETE FROM xfullname indexed_opt WHERE expr AND ID]
parser: Input 'NE' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Shift 'NE', go to state 117
parser: Return. Stack=[with DELETE FROM xfullname indexed_opt WHERE expr AND expr NE]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with DELETE FROM xfullname indexed_opt WHERE expr AND expr NE STRING]
parser: Input 'SEMI' in state 537
parser: Reduce 168 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Reduce 179 [expr ::= expr AND expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 300.
parser: ... then shift 'where_opt', pending reduce 142
parser: Reduce 142 [cmd ::= with DELETE FROM xfullname indexed_opt where_opt], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Input '$' with pending reduce 321
parser: Reduce 321 [ecmd ::= cmdx SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 317 [input ::= cmdlist], go to state 0.
parser: ... then shift 'input', pending reduce -2
parser: Accept!
parser: [[[UPDATE 'main'.sqlite_master SET rootpage=3 WHERE #2 AND rootpage=#2]]]
parser: Input 'UPDATE' in state 0
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'UPDATE', go to state 299
parser: Return. Stack=[with UPDATE]
parser: Input 'STRING' in state 299
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', go to state 165
parser: Shift 'STRING', pending reduce 332
parser: Return. Stack=[with UPDATE orconf STRING]
parser: Input 'DOT' with pending reduce 332
parser: Reduce 332 [nm ::= STRING], go to state 165.
parser: ... then shift 'nm', go to state 393
parser: Shift 'DOT', go to state 218
parser: Return. Stack=[with UPDATE orconf nm DOT]
parser: Input 'ID' in state 218
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf nm DOT ID]
parser: Input 'SET' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 218.
parser: ... then shift 'nm', go to state 429
parser: Reduce 113 [xfullname ::= nm DOT nm], go to state 165.
parser: ... then shift 'xfullname', go to state 271
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 428
parser: Shift 'SET', go to state 153
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET]
parser: Input 'ID' in state 153
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 153.
parser: ... then shift 'nm', go to state 442
parser: Shift 'EQ', go to state 84
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ]
parser: Input 'INTEGER' in state 84
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ INTEGER]
parser: Input 'WHERE' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 84.
parser: ... then shift 'term', go to state 58
parser: Reduce 148 [setlist ::= nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE]
parser: Input 'VARIABLE' in state 93
parser: Shift 'VARIABLE', pending reduce 170
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE VARIABLE]
parser: Input 'AND' with pending reduce 170
parser: Reduce 170 [expr ::= VARIABLE], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'AND', go to state 120
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr AND]
parser: Input 'ID' in state 120
parser: Shift 'ID', go to state 416
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr AND ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr AND expr EQ]
parser: Input 'VARIABLE' in state 117
parser: Shift 'VARIABLE', pending reduce 170
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr AND expr EQ VARIABLE]
parser: Input 'SEMI' with pending reduce 170
parser: Reduce 170 [expr ::= VARIABLE], go to state 117.
parser: ... then shift 'expr', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Reduce 179 [expr ::= expr AND expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 270.
parser: ... then shift 'where_opt', pending reduce 145
parser: Reduce 145 [cmd ::= with UPDATE orconf xfullname indexed_opt SET setlist where_opt], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Input '$' with pending reduce 321
parser: Reduce 321 [ecmd ::= cmdx SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 317 [input ::= cmdlist], go to state 0.
parser: ... then shift 'input', pending reduce -2
parser: Accept!
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[;INSERT INTO field1 VALUES(9, 10, 11, 12);;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'INSERT' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'INSERT', go to state 311
parser: Return. Stack=[ecmd with INSERT]
parser: Input 'INTO' in state 311
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', pending reduce 156
parser: Reduce 156 [insert_cmd ::= INSERT orconf], go to state 219.
parser: ... then shift 'insert_cmd', go to state 427
parser: Shift 'INTO', go to state 164
parser: Return. Stack=[ecmd with insert_cmd INTO]
parser: Input 'ID' in state 164
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd with insert_cmd INTO ID]
parser: Input 'VALUES' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 164.
parser: ... then shift 'nm', go to state 393
parser: Reduce 112 [xfullname ::= nm], go to state 164.
parser: ... then shift 'xfullname', go to state 298
parser: Reduce 158 [idlist_opt ::=].
parser: ... then shift 'idlist_opt', go to state 35
parser: Shift 'VALUES', go to state 526
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES]
parser: Input 'LP' in state 526
parser: Shift 'LP', go to state 28
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP]
parser: Input 'INTEGER' in state 28
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 28.
parser: ... then shift 'term', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'INTEGER' in state 107
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'INTEGER' in state 107
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'INTEGER' in state 107
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'RP', pending reduce 89
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist RP]
parser: Input 'SEMI' with pending reduce 89
parser: Reduce 89 [values ::= VALUES LP nexprlist RP], go to state 35.
parser: ... then shift 'values', go to state 532
parser: Reduce 348 [oneselect ::= values], go to state 35.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 35.
parser: ... then shift 'select', go to state 297
parser: Reduce 152 [upsert ::=].
parser: ... then shift 'upsert', pending reduce 150
parser: Reduce 150 [cmd ::= with insert_cmd INTO xfullname idlist_opt select upsert], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
parser: [[[;
;SELECT row_number() OVER win,
         nth_value(test003,2) OVER win,
         lead(test003) OVER win
  FROM field1
  WINDOW win AS (ORDER BY field2)

;;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'SEMI' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[ecmd SEMI]
parser: Input 'SELECT' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 1.
parser: ... then shift 'ecmd', pending reduce 318
parser: Reduce 318 [cmdlist ::= cmdlist ecmd], go to state 0.
parser: ... then shift 'cmdlist', go to state 1
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[cmdlist SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP]
parser: Input 'RP' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Reduce 214 [exprlist ::=].
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'ID' in state 204
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER ID]
parser: Input 'COMMA' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 204.
parser: ... then shift 'nm', pending reduce 314
parser: Reduce 314 [over_clause ::= filter_opt OVER nm], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[cmdlist SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct nexprlist COMMA]
parser: Input 'INTEGER' in state 107
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'ID' in state 204
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER ID]
parser: Input 'COMMA' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 204.
parser: ... then shift 'nm', pending reduce 314
parser: Reduce 314 [over_clause ::= filter_opt OVER nm], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[cmdlist SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'ID' in state 204
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER ID]
parser: Input 'FROM' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 204.
parser: ... then shift 'nm', pending reduce 314
parser: Reduce 314 [over_clause ::= filter_opt OVER nm], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[cmdlist SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[cmdlist SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'WINDOW' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'WINDOW', go to state 136
parser: Return. Stack=[cmdlist SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW]
parser: Input 'ID' in state 136
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[cmdlist SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW ID]
parser: Input 'AS' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 136.
parser: ... then shift 'nm', go to state 512
parser: Shift 'AS', go to state 511
parser: Return. Stack=[cmdlist SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS]
parser: Input 'LP' in state 511
parser: Shift 'LP', go to state 33
parser: Return. Stack=[cmdlist SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP]
parser: Input 'ORDER' in state 33
parser: Shift 'ORDER', go to state 500
parser: Return. Stack=[cmdlist SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP ORDER]
parser: Input 'BY' in state 500
parser: Shift 'BY', go to state 22
parser: Return. Stack=[cmdlist SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP ORDER BY]
parser: Input 'ID' in state 22
parser: Shift 'ID', go to state 416
parser: Return. Stack=[cmdlist SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP ORDER BY ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 22.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 22.
parser: ... then shift 'sortlist', go to state 184
parser: Reduce 297 [frame_opt ::=].
parser: ... then shift 'frame_opt', pending reduce 293
parser: Reduce 293 [window ::= ORDER BY sortlist frame_opt], go to state 33.
parser: ... then shift 'window', go to state 510
parser: Shift 'RP', pending reduce 290
parser: Return. Stack=[cmdlist SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP window RP]
parser: Input 'SEMI' with pending reduce 290
parser: Reduce 290 [windowdefn ::= nm AS LP window RP], go to state 136.
parser: ... then shift 'windowdefn', pending reduce 288
parser: Reduce 288 [windowdefn_list ::= windowdefn], go to state 136.
parser: ... then shift 'windowdefn_list', go to state 513
parser: Reduce 312 [window_clause ::= WINDOW windowdefn_list], go to state 194.
parser: ... then shift 'window_clause', go to state 353
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 352
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 88
parser: Reduce 88 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt window_clause orderby_opt limit_opt], go to state 1.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 1.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdlist cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping cmdlist
parser: [[[;CREATE TABLE test005(field4 INTEGER);SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'CREATE' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[ecmd CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 1.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 388
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[ecmd createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 1.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[ecmd create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd create_table LP ID]
parser: Input 'ID' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 190
parser: Shift 'ID', pending reduce 335
parser: Return. Stack=[ecmd create_table LP nm ID]
parser: Input 'RP' with pending reduce 335
parser: Reduce 335 [typename ::= ID|STRING], go to state 190.
parser: ... then shift 'typename', go to state 390
parser: Reduce 334 [typetoken ::= typename], go to state 190.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 376
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 150
parser: Reduce 330 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Reduce 60 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 538
parser: Shift 'RP', go to state 361
parser: Return. Stack=[ecmd create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 361
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: [[[UPDATE 'main'.sqlite_master SET type='table', name='test005', tbl_name='test005', rootpage=#2, sql='CREATE TABLE test005(field4 INTEGER)' WHERE rowid=#1]]]
parser: Input 'UPDATE' in state 0
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'UPDATE', go to state 299
parser: Return. Stack=[with UPDATE]
parser: Input 'STRING' in state 299
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', go to state 165
parser: Shift 'STRING', pending reduce 332
parser: Return. Stack=[with UPDATE orconf STRING]
parser: Input 'DOT' with pending reduce 332
parser: Reduce 332 [nm ::= STRING], go to state 165.
parser: ... then shift 'nm', go to state 393
parser: Shift 'DOT', go to state 218
parser: Return. Stack=[with UPDATE orconf nm DOT]
parser: Input 'ID' in state 218
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf nm DOT ID]
parser: Input 'SET' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 218.
parser: ... then shift 'nm', go to state 429
parser: Reduce 113 [xfullname ::= nm DOT nm], go to state 165.
parser: ... then shift 'xfullname', go to state 271
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 428
parser: Shift 'SET', go to state 153
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET]
parser: Input 'ID' in state 153
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 153.
parser: ... then shift 'nm', go to state 442
parser: Shift 'EQ', go to state 84
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ]
parser: Input 'STRING' in state 84
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 84.
parser: ... then shift 'term', go to state 58
parser: Reduce 148 [setlist ::= nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'VARIABLE' in state 86
parser: Shift 'VARIABLE', pending reduce 170
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ VARIABLE]
parser: Input 'COMMA' with pending reduce 170
parser: Reduce 170 [expr ::= VARIABLE], go to state 86.
parser: ... then shift 'expr', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'WHERE' in state 537
parser: Reduce 168 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 416
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr EQ]
parser: Input 'VARIABLE' in state 117
parser: Shift 'VARIABLE', pending reduce 170
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr EQ VARIABLE]
parser: Input 'SEMI' with pending reduce 170
parser: Reduce 170 [expr ::= VARIABLE], go to state 117.
parser: ... then shift 'expr', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 270.
parser: ... then shift 'where_opt', pending reduce 145
parser: Reduce 145 [cmd ::= with UPDATE orconf xfullname indexed_opt SET setlist where_opt], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Input '$' with pending reduce 321
parser: Reduce 321 [ecmd ::= cmdx SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 317 [input ::= cmdlist], go to state 0.
parser: ... then shift 'input', pending reduce -2
parser: Accept!
parser: ... then shift 'create_table_args', pending reduce 328
parser: Reduce 328 [cmd ::= create_table create_table_args], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
parser: [[[SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='test005' AND type!='trigger' ORDER BY rowid]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'FROM' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'STRING' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'STRING', pending reduce 332
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix STRING]
parser: Input 'DOT' with pending reduce 332
parser: Reduce 332 [nm ::= STRING], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Shift 'DOT', go to state 245
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID' in state 245
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 245.
parser: ... then shift 'nm', pending reduce 109
parser: Reduce 109 [dbnm ::= DOT nm], go to state 349.
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[SELECT distinct selcollist from WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND' in state 537
parser: Reduce 168 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'AND', go to state 120
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID' in state 120
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'NE' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Shift 'NE', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr NE]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr NE STRING]
parser: Input 'ORDER' in state 537
parser: Reduce 168 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Reduce 179 [expr ::= expr AND expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[CREATE TABLE test005(field4 INTEGER)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 388
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP ID]
parser: Input 'ID' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 190
parser: Shift 'ID', pending reduce 335
parser: Return. Stack=[create_table LP nm ID]
parser: Input 'RP' with pending reduce 335
parser: Reduce 335 [typename ::= ID|STRING], go to state 190.
parser: ... then shift 'typename', go to state 390
parser: Reduce 334 [typetoken ::= typename], go to state 190.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 376
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 150
parser: Reduce 330 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Reduce 60 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 538
parser: Shift 'RP', go to state 361
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 361
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 328
parser: Reduce 328 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT DISTINCT field3, rank() OVER (ORDER BY field3) FROM field1 ORDER BY 1,2

;SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'DISTINCT' in state 288
parser: Shift 'DISTINCT', pending reduce 91
parser: Return. Stack=[SELECT DISTINCT]
parser: Input 'ID' with pending reduce 91
parser: Reduce 91 [distinct ::= DISTINCT], go to state 288.
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'RP' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Reduce 214 [exprlist ::=].
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'ORDER' in state 32
parser: Shift 'ORDER', go to state 500
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER]
parser: Input 'BY' in state 500
parser: Shift 'BY', go to state 22
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY]
parser: Input 'ID' in state 22
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 22.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 22.
parser: ... then shift 'sortlist', go to state 184
parser: Reduce 297 [frame_opt ::=].
parser: ... then shift 'frame_opt', pending reduce 293
parser: Reduce 293 [window ::= ORDER BY sortlist frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ORDER' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'INTEGER' in state 26
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 26.
parser: ... then shift 'term', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Shift 'COMMA', go to state 95
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY sortlist COMMA]
parser: Input 'INTEGER' in state 95
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY sortlist COMMA INTEGER]
parser: Input 'SEMI' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 95.
parser: ... then shift 'term', go to state 14
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 129
parser: Reduce 129 [sortlist ::= sortlist COMMA expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT percent_rank() OVER () FROM test005
;DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'RP' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Reduce 214 [exprlist ::=].
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'RP' in state 32
parser: Reduce 297 [frame_opt ::=].
parser: ... then shift 'frame_opt', pending reduce 295
parser: Reduce 295 [window ::= frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'SEMI' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[DROP TABLE IF EXISTS t7;;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'DROP' in state 0
parser: Shift 'DROP', go to state 385
parser: Return. Stack=[DROP]
parser: Input 'TABLE' in state 385
parser: Shift 'TABLE', go to state 304
parser: Return. Stack=[DROP TABLE]
parser: Input 'IF' in state 304
parser: Shift 'IF', go to state 431
parser: Return. Stack=[DROP TABLE IF]
parser: Input 'EXISTS' in state 431
parser: Shift 'EXISTS', pending reduce 75
parser: Return. Stack=[DROP TABLE IF EXISTS]
parser: Input 'ID' with pending reduce 75
parser: Reduce 75 [ifexists ::= IF EXISTS], go to state 304.
parser: ... then shift 'ifexists', go to state 171
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[DROP TABLE ifexists ID]
parser: Input 'SEMI' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 171.
parser: ... then shift 'nm', go to state 459
parser: Reduce 110 [fullname ::= nm], go to state 171.
parser: ... then shift 'fullname', pending reduce 74
parser: Reduce 74 [cmd ::= DROP TABLE ifexists fullname], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[;
;DROP VIEW IF EXISTS v8;;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'SEMI' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[ecmd SEMI]
parser: Input 'DROP' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 1.
parser: ... then shift 'ecmd', pending reduce 318
parser: Reduce 318 [cmdlist ::= cmdlist ecmd], go to state 0.
parser: ... then shift 'cmdlist', go to state 1
parser: Shift 'DROP', go to state 385
parser: Return. Stack=[cmdlist DROP]
parser: Input 'VIEW' in state 385
parser: Shift 'VIEW', go to state 303
parser: Return. Stack=[cmdlist DROP VIEW]
parser: Input 'IF' in state 303
parser: Shift 'IF', go to state 431
parser: Return. Stack=[cmdlist DROP VIEW IF]
parser: Input 'EXISTS' in state 431
parser: Shift 'EXISTS', pending reduce 75
parser: Return. Stack=[cmdlist DROP VIEW IF EXISTS]
parser: Input 'ID' with pending reduce 75
parser: Reduce 75 [ifexists ::= IF EXISTS], go to state 303.
parser: ... then shift 'ifexists', go to state 170
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[cmdlist DROP VIEW ifexists ID]
parser: Input 'SEMI' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 170.
parser: ... then shift 'nm', go to state 459
parser: Reduce 110 [fullname ::= nm], go to state 170.
parser: ... then shift 'fullname', pending reduce 78
parser: Reduce 78 [cmd ::= DROP VIEW ifexists fullname], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdlist cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping cmdlist
parser: [[[;CREATE TABLE test006(field5 INT, test007 INT);;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'CREATE' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[ecmd CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 1.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 388
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[ecmd createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 1.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[ecmd create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd create_table LP ID]
parser: Input 'ID' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 190
parser: Shift 'ID', pending reduce 335
parser: Return. Stack=[ecmd create_table LP nm ID]
parser: Input 'COMMA' with pending reduce 335
parser: Reduce 335 [typename ::= ID|STRING], go to state 190.
parser: ... then shift 'typename', go to state 390
parser: Reduce 334 [typetoken ::= typename], go to state 190.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 376
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 150
parser: Reduce 330 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[ecmd create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 190
parser: Shift 'ID', pending reduce 335
parser: Return. Stack=[ecmd create_table LP columnlist COMMA nm ID]
parser: Input 'RP' with pending reduce 335
parser: Reduce 335 [typename ::= ID|STRING], go to state 190.
parser: ... then shift 'typename', go to state 390
parser: Reduce 334 [typetoken ::= typename], go to state 190.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 383
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 151
parser: Reduce 329 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Reduce 60 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 538
parser: Shift 'RP', go to state 361
parser: Return. Stack=[ecmd create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 361
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: [[[UPDATE 'main'.sqlite_master SET type='table', name='test006', tbl_name='test006', rootpage=#2, sql='CREATE TABLE test006(field5 INT, test007 INT)' WHERE rowid=#1]]]
parser: Input 'UPDATE' in state 0
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'UPDATE', go to state 299
parser: Return. Stack=[with UPDATE]
parser: Input 'STRING' in state 299
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', go to state 165
parser: Shift 'STRING', pending reduce 332
parser: Return. Stack=[with UPDATE orconf STRING]
parser: Input 'DOT' with pending reduce 332
parser: Reduce 332 [nm ::= STRING], go to state 165.
parser: ... then shift 'nm', go to state 393
parser: Shift 'DOT', go to state 218
parser: Return. Stack=[with UPDATE orconf nm DOT]
parser: Input 'ID' in state 218
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf nm DOT ID]
parser: Input 'SET' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 218.
parser: ... then shift 'nm', go to state 429
parser: Reduce 113 [xfullname ::= nm DOT nm], go to state 165.
parser: ... then shift 'xfullname', go to state 271
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 428
parser: Shift 'SET', go to state 153
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET]
parser: Input 'ID' in state 153
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 153.
parser: ... then shift 'nm', go to state 442
parser: Shift 'EQ', go to state 84
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ]
parser: Input 'STRING' in state 84
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 84.
parser: ... then shift 'term', go to state 58
parser: Reduce 148 [setlist ::= nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'VARIABLE' in state 86
parser: Shift 'VARIABLE', pending reduce 170
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ VARIABLE]
parser: Input 'COMMA' with pending reduce 170
parser: Reduce 170 [expr ::= VARIABLE], go to state 86.
parser: ... then shift 'expr', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'WHERE' in state 537
parser: Reduce 168 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 416
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr EQ]
parser: Input 'VARIABLE' in state 117
parser: Shift 'VARIABLE', pending reduce 170
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr EQ VARIABLE]
parser: Input 'SEMI' with pending reduce 170
parser: Reduce 170 [expr ::= VARIABLE], go to state 117.
parser: ... then shift 'expr', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 270.
parser: ... then shift 'where_opt', pending reduce 145
parser: Reduce 145 [cmd ::= with UPDATE orconf xfullname indexed_opt SET setlist where_opt], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Input '$' with pending reduce 321
parser: Reduce 321 [ecmd ::= cmdx SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 317 [input ::= cmdlist], go to state 0.
parser: ... then shift 'input', pending reduce -2
parser: Accept!
parser: ... then shift 'create_table_args', pending reduce 328
parser: Reduce 328 [cmd ::= create_table create_table_args], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
parser: [[[SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='test006' AND type!='trigger' ORDER BY rowid]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'FROM' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'STRING' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'STRING', pending reduce 332
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix STRING]
parser: Input 'DOT' with pending reduce 332
parser: Reduce 332 [nm ::= STRING], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Shift 'DOT', go to state 245
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID' in state 245
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 245.
parser: ... then shift 'nm', pending reduce 109
parser: Reduce 109 [dbnm ::= DOT nm], go to state 349.
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[SELECT distinct selcollist from WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND' in state 537
parser: Reduce 168 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'AND', go to state 120
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID' in state 120
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'NE' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Shift 'NE', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr NE]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr NE STRING]
parser: Input 'ORDER' in state 537
parser: Reduce 168 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Reduce 179 [expr ::= expr AND expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[CREATE TABLE test006(field5 INT, test007 INT)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 388
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP ID]
parser: Input 'ID' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 190
parser: Shift 'ID', pending reduce 335
parser: Return. Stack=[create_table LP nm ID]
parser: Input 'COMMA' with pending reduce 335
parser: Reduce 335 [typename ::= ID|STRING], go to state 190.
parser: ... then shift 'typename', go to state 390
parser: Reduce 334 [typetoken ::= typename], go to state 190.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 376
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 150
parser: Reduce 330 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 190
parser: Shift 'ID', pending reduce 335
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'RP' with pending reduce 335
parser: Reduce 335 [typename ::= ID|STRING], go to state 190.
parser: ... then shift 'typename', go to state 390
parser: Reduce 334 [typetoken ::= typename], go to state 190.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 383
parser: Reduce 339 [carglist ::=].
parser: ... then shift 'carglist', go to state 151
parser: Reduce 329 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 362
parser: Reduce 60 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 538
parser: Shift 'RP', go to state 361
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 361
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 328
parser: Reduce 328 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[;INSERT INTO field1 VALUES(0,2);;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'INSERT' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'INSERT', go to state 311
parser: Return. Stack=[ecmd with INSERT]
parser: Input 'INTO' in state 311
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', pending reduce 156
parser: Reduce 156 [insert_cmd ::= INSERT orconf], go to state 219.
parser: ... then shift 'insert_cmd', go to state 427
parser: Shift 'INTO', go to state 164
parser: Return. Stack=[ecmd with insert_cmd INTO]
parser: Input 'ID' in state 164
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd with insert_cmd INTO ID]
parser: Input 'VALUES' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 164.
parser: ... then shift 'nm', go to state 393
parser: Reduce 112 [xfullname ::= nm], go to state 164.
parser: ... then shift 'xfullname', go to state 298
parser: Reduce 158 [idlist_opt ::=].
parser: ... then shift 'idlist_opt', go to state 35
parser: Shift 'VALUES', go to state 526
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES]
parser: Input 'LP' in state 526
parser: Shift 'LP', go to state 28
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP]
parser: Input 'INTEGER' in state 28
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP INTEGER]
parser: Input 'COMMA' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 28.
parser: ... then shift 'term', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'INTEGER' in state 107
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 215 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'RP', pending reduce 89
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist RP]
parser: Input 'SEMI' with pending reduce 89
parser: Reduce 89 [values ::= VALUES LP nexprlist RP], go to state 35.
parser: ... then shift 'values', go to state 532
parser: Reduce 348 [oneselect ::= values], go to state 35.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 35.
parser: ... then shift 'select', go to state 297
parser: Reduce 152 [upsert ::=].
parser: ... then shift 'upsert', pending reduce 150
parser: Reduce 150 [cmd ::= with insert_cmd INTO xfullname idlist_opt select upsert], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
parser: [[[;
;CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over;;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'SEMI' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[ecmd SEMI]
parser: Input 'CREATE' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 1.
parser: ... then shift 'ecmd', pending reduce 318
parser: Reduce 318 [cmdlist ::= cmdlist ecmd], go to state 0.
parser: ... then shift 'cmdlist', go to state 1
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[cmdlist CREATE]
parser: Input 'VIEW' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 1.
parser: ... then shift 'createkw', go to state 134
parser: FALLBACK VIEW => ID
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 388
parser: Shift 'VIEW', go to state 322
parser: Return. Stack=[cmdlist createkw temp VIEW]
parser: Input 'ID' in state 322
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 228
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists ID]
parser: Input 'AS' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 228.
parser: ... then shift 'nm', go to state 321
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 320
parser: Reduce 222 [eidlist_opt ::=].
parser: ... then shift 'eidlist_opt', go to state 461
parser: Shift 'AS', go to state 37
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS]
parser: Input 'SELECT' in state 37
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP]
parser: Input 'INTEGER' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 11.
parser: ... then shift 'term', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'ORDER' in state 32
parser: Shift 'ORDER', go to state 500
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER]
parser: Input 'BY' in state 500
parser: Shift 'BY', go to state 22
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY]
parser: Input 'PRECEDING' in state 22
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY PRECEDING]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 22.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 22.
parser: ... then shift 'sortlist', go to state 184
parser: Reduce 297 [frame_opt ::=].
parser: ... then shift 'frame_opt', pending reduce 293
parser: Reduce 293 [window ::= ORDER BY sortlist frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'MINUS' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Shift 'MINUS', go to state 115
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt expr MINUS]
parser: Input 'INTEGER' in state 115
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt expr MINUS INTEGER]
parser: Input 'AS' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 115.
parser: ... then shift 'term', go to state 132
parser: Reduce 184 [expr ::= expr PLUS|MINUS expr], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Shift 'AS', go to state 242
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt expr scanpt AS]
parser: Input 'ID' in state 242
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt expr scanpt AS ID]
parser: Input 'FROM' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 242.
parser: ... then shift 'nm', pending reduce 98
parser: Reduce 98 [as ::= AS nm], go to state 259.
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'SEMI' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 37.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 37.
parser: ... then shift 'select', pending reduce 77
parser: Reduce 77 [cmd ::= createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS select], go to state 1.
parser: [[[UPDATE 'main'.sqlite_master SET type='view', name='field6', tbl_name='field6', rootpage=#2, sql='CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over' WHERE rowid=#1]]]
parser: Input 'UPDATE' in state 0
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'UPDATE', go to state 299
parser: Return. Stack=[with UPDATE]
parser: Input 'STRING' in state 299
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', go to state 165
parser: Shift 'STRING', pending reduce 332
parser: Return. Stack=[with UPDATE orconf STRING]
parser: Input 'DOT' with pending reduce 332
parser: Reduce 332 [nm ::= STRING], go to state 165.
parser: ... then shift 'nm', go to state 393
parser: Shift 'DOT', go to state 218
parser: Return. Stack=[with UPDATE orconf nm DOT]
parser: Input 'ID' in state 218
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf nm DOT ID]
parser: Input 'SET' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 218.
parser: ... then shift 'nm', go to state 429
parser: Reduce 113 [xfullname ::= nm DOT nm], go to state 165.
parser: ... then shift 'xfullname', go to state 271
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 428
parser: Shift 'SET', go to state 153
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET]
parser: Input 'ID' in state 153
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 153.
parser: ... then shift 'nm', go to state 442
parser: Shift 'EQ', go to state 84
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ]
parser: Input 'STRING' in state 84
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 84.
parser: ... then shift 'term', go to state 58
parser: Reduce 148 [setlist ::= nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'COMMA' in state 537
parser: Reduce 168 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'VARIABLE' in state 86
parser: Shift 'VARIABLE', pending reduce 170
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ VARIABLE]
parser: Input 'COMMA' with pending reduce 170
parser: Reduce 170 [expr ::= VARIABLE], go to state 86.
parser: ... then shift 'expr', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 444
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'WHERE' in state 537
parser: Reduce 168 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 146 [setlist ::= setlist COMMA nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 416
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr EQ]
parser: Input 'VARIABLE' in state 117
parser: Shift 'VARIABLE', pending reduce 170
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr EQ VARIABLE]
parser: Input 'SEMI' with pending reduce 170
parser: Reduce 170 [expr ::= VARIABLE], go to state 117.
parser: ... then shift 'expr', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 270.
parser: ... then shift 'where_opt', pending reduce 145
parser: Reduce 145 [cmd ::= with UPDATE orconf xfullname indexed_opt SET setlist where_opt], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Input '$' with pending reduce 321
parser: Reduce 321 [ecmd ::= cmdx SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 317 [input ::= cmdlist], go to state 0.
parser: ... then shift 'input', pending reduce -2
parser: Accept!
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdlist cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping cmdlist
parser: [[[SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='field6' AND type!='trigger' ORDER BY rowid]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 349
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 349
parser: Reduce 349 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'FROM' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'STRING' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'STRING', pending reduce 332
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix STRING]
parser: Input 'DOT' with pending reduce 332
parser: Reduce 332 [nm ::= STRING], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Shift 'DOT', go to state 245
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID' in state 245
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 245.
parser: ... then shift 'nm', pending reduce 109
parser: Reduce 109 [dbnm ::= DOT nm], go to state 349.
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[SELECT distinct selcollist from WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND' in state 537
parser: Reduce 168 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'AND', go to state 120
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID' in state 120
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'NE' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Shift 'NE', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr NE]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr NE STRING]
parser: Input 'ORDER' in state 537
parser: Reduce 168 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Reduce 179 [expr ::= expr AND expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 360.
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 515
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 515
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 26.
parser: ... then shift 'sortlist', go to state 514
parser: Reduce 128 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[CREATE VIEW field6 AS SELECT NTILE(256) OVER (ORDER BY preceding) - 1 AS nt FROM over]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'VIEW' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: FALLBACK VIEW => ID
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 388
parser: Shift 'VIEW', go to state 322
parser: Return. Stack=[createkw temp VIEW]
parser: Input 'ID' in state 322
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 228
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp VIEW ifnotexists ID]
parser: Input 'AS' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 228.
parser: ... then shift 'nm', go to state 321
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 320
parser: Reduce 222 [eidlist_opt ::=].
parser: ... then shift 'eidlist_opt', go to state 461
parser: Shift 'AS', go to state 37
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS]
parser: Input 'SELECT' in state 37
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP]
parser: Input 'INTEGER' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 11.
parser: ... then shift 'term', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'ORDER' in state 32
parser: Shift 'ORDER', go to state 500
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER]
parser: Input 'BY' in state 500
parser: Shift 'BY', go to state 22
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY]
parser: Input 'PRECEDING' in state 22
parser: FALLBACK PRECEDING => ID
parser: Shift 'PRECEDING', go to state 416
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP ORDER BY PRECEDING]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 22.
parser: ... then shift 'expr', go to state 13
parser: Reduce 133 [sortorder ::=].
parser: ... then shift 'sortorder', pending reduce 130
parser: Reduce 130 [sortlist ::= expr sortorder], go to state 22.
parser: ... then shift 'sortlist', go to state 184
parser: Reduce 297 [frame_opt ::=].
parser: ... then shift 'frame_opt', pending reduce 293
parser: Reduce 293 [window ::= ORDER BY sortlist frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'MINUS' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Shift 'MINUS', go to state 115
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt expr MINUS]
parser: Input 'INTEGER' in state 115
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt expr MINUS INTEGER]
parser: Input 'AS' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 115.
parser: ... then shift 'term', go to state 132
parser: Reduce 184 [expr ::= expr PLUS|MINUS expr], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Shift 'AS', go to state 242
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt expr scanpt AS]
parser: Input 'ID' in state 242
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt expr scanpt AS ID]
parser: Input 'FROM' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 242.
parser: ... then shift 'nm', pending reduce 98
parser: Reduce 98 [as ::= AS nm], go to state 259.
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'SEMI' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 37.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 37.
parser: ... then shift 'select', pending reduce 77
parser: Reduce 77 [cmd ::= createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[;
;SELECT * FROM field6;;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'SEMI' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[ecmd SEMI]
parser: Input 'SELECT' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 1.
parser: ... then shift 'ecmd', pending reduce 318
parser: Reduce 318 [cmdlist ::= cmdlist ecmd], go to state 0.
parser: ... then shift 'cmdlist', go to state 1
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[cmdlist SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 96
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[cmdlist SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[cmdlist SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'SEMI' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 1.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 1.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdlist cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping cmdlist
parser: [[[;
;SELECT sum( min(field2) ) OVER () FROM field1 GROUP BY field2;;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'SEMI' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[ecmd SEMI]
parser: Input 'SELECT' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 1.
parser: ... then shift 'ecmd', pending reduce 318
parser: Reduce 318 [cmdlist ::= cmdlist ecmd], go to state 0.
parser: ... then shift 'cmdlist', go to state 1
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[cmdlist SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct ID LP distinct ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct ID LP distinct exprlist RP]
parser: Input 'RP' in state 192
parser: Reduce 173 [expr ::= ID|INDEXED LP distinct exprlist RP], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'RP' in state 32
parser: Reduce 297 [frame_opt ::=].
parser: ... then shift 'frame_opt', pending reduce 295
parser: Reduce 295 [window ::= frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[cmdlist SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[cmdlist SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'GROUP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Shift 'GROUP', go to state 499
parser: Return. Stack=[cmdlist SELECT distinct selcollist from where_opt GROUP]
parser: Input 'BY' in state 499
parser: Shift 'BY', go to state 21
parser: Return. Stack=[cmdlist SELECT distinct selcollist from where_opt GROUP BY]
parser: Input 'ID' in state 21
parser: Shift 'ID', go to state 416
parser: Return. Stack=[cmdlist SELECT distinct selcollist from where_opt GROUP BY ID]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 21.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 21.
parser: ... then shift 'nexprlist', go to state 498
parser: Reduce 135 [groupby_opt ::= GROUP BY nexprlist], go to state 359.
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 1.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 1.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdlist cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping cmdlist
parser: [[[;
;SELECT sum( max(following) ) OVER () FROM over GROUP BY following;
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'SEMI' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[ecmd SEMI]
parser: Input 'SELECT' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 1.
parser: ... then shift 'ecmd', pending reduce 318
parser: Reduce 318 [cmdlist ::= cmdlist ecmd], go to state 0.
parser: ... then shift 'cmdlist', go to state 1
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[cmdlist SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct ID LP]
parser: Input 'FOLLOWING' in state 266
parser: FALLBACK FOLLOWING => ID
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct ID LP distinct FOLLOWING]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct ID LP distinct exprlist RP]
parser: Input 'RP' in state 192
parser: Reduce 173 [expr ::= ID|INDEXED LP distinct exprlist RP], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'RP' in state 32
parser: Reduce 297 [frame_opt ::=].
parser: ... then shift 'frame_opt', pending reduce 295
parser: Reduce 295 [window ::= frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'FROM' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[cmdlist SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[cmdlist SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'GROUP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Shift 'GROUP', go to state 499
parser: Return. Stack=[cmdlist SELECT distinct selcollist from where_opt GROUP]
parser: Input 'BY' in state 499
parser: Shift 'BY', go to state 21
parser: Return. Stack=[cmdlist SELECT distinct selcollist from where_opt GROUP BY]
parser: Input 'FOLLOWING' in state 21
parser: FALLBACK FOLLOWING => ID
parser: Shift 'FOLLOWING', go to state 416
parser: Return. Stack=[cmdlist SELECT distinct selcollist from where_opt GROUP BY FOLLOWING]
parser: Input 'SEMI' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 21.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 21.
parser: ... then shift 'nexprlist', go to state 498
parser: Reduce 135 [groupby_opt ::= GROUP BY nexprlist], go to state 359.
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 1.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 1.
parser: ... then shift 'select', pending reduce 79
parser: Reduce 79 [cmd ::= select], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdlist cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping cmdlist
parser: [[[
;
;DROP TABLE IF EXISTS test005;;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'SEMI' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[ecmd SEMI]
parser: Input 'DROP' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 1.
parser: ... then shift 'ecmd', pending reduce 318
parser: Reduce 318 [cmdlist ::= cmdlist ecmd], go to state 0.
parser: ... then shift 'cmdlist', go to state 1
parser: Shift 'DROP', go to state 385
parser: Return. Stack=[cmdlist DROP]
parser: Input 'TABLE' in state 385
parser: Shift 'TABLE', go to state 304
parser: Return. Stack=[cmdlist DROP TABLE]
parser: Input 'IF' in state 304
parser: Shift 'IF', go to state 431
parser: Return. Stack=[cmdlist DROP TABLE IF]
parser: Input 'EXISTS' in state 431
parser: Shift 'EXISTS', pending reduce 75
parser: Return. Stack=[cmdlist DROP TABLE IF EXISTS]
parser: Input 'ID' with pending reduce 75
parser: Reduce 75 [ifexists ::= IF EXISTS], go to state 304.
parser: ... then shift 'ifexists', go to state 171
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[cmdlist DROP TABLE ifexists ID]
parser: Input 'SEMI' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 171.
parser: ... then shift 'nm', go to state 459
parser: Reduce 110 [fullname ::= nm], go to state 171.
parser: ... then shift 'fullname', pending reduce 74
parser: Reduce 74 [cmd ::= DROP TABLE ifexists fullname], go to state 1.
parser: [[[DELETE FROM 'main'.sqlite_master WHERE tbl_name='test005' and type!='trigger']]]
parser: Input 'DELETE' in state 0
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'DELETE', go to state 430
parser: Return. Stack=[with DELETE]
parser: Input 'FROM' in state 430
parser: Shift 'FROM', go to state 166
parser: Return. Stack=[with DELETE FROM]
parser: Input 'STRING' in state 166
parser: Shift 'STRING', pending reduce 332
parser: Return. Stack=[with DELETE FROM STRING]
parser: Input 'DOT' with pending reduce 332
parser: Reduce 332 [nm ::= STRING], go to state 166.
parser: ... then shift 'nm', go to state 393
parser: Shift 'DOT', go to state 218
parser: Return. Stack=[with DELETE FROM nm DOT]
parser: Input 'ID' in state 218
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with DELETE FROM nm DOT ID]
parser: Input 'WHERE' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 218.
parser: ... then shift 'nm', go to state 429
parser: Reduce 113 [xfullname ::= nm DOT nm], go to state 166.
parser: ... then shift 'xfullname', go to state 272
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 300
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[with DELETE FROM xfullname indexed_opt WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 416
parser: Return. Stack=[with DELETE FROM xfullname indexed_opt WHERE ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[with DELETE FROM xfullname indexed_opt WHERE expr EQ]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with DELETE FROM xfullname indexed_opt WHERE expr EQ STRING]
parser: Input 'AND' in state 537
parser: Reduce 168 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'AND', go to state 120
parser: Return. Stack=[with DELETE FROM xfullname indexed_opt WHERE expr AND]
parser: Input 'ID' in state 120
parser: Shift 'ID', go to state 416
parser: Return. Stack=[with DELETE FROM xfullname indexed_opt WHERE expr AND ID]
parser: Input 'NE' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Shift 'NE', go to state 117
parser: Return. Stack=[with DELETE FROM xfullname indexed_opt WHERE expr AND expr NE]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 537
parser: Return. Stack=[with DELETE FROM xfullname indexed_opt WHERE expr AND expr NE STRING]
parser: Input 'SEMI' in state 537
parser: Reduce 168 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Reduce 179 [expr ::= expr AND expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 300.
parser: ... then shift 'where_opt', pending reduce 142
parser: Reduce 142 [cmd ::= with DELETE FROM xfullname indexed_opt where_opt], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Input '$' with pending reduce 321
parser: Reduce 321 [ecmd ::= cmdx SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 317 [input ::= cmdlist], go to state 0.
parser: ... then shift 'input', pending reduce -2
parser: Accept!
parser: [[[UPDATE 'main'.sqlite_master SET rootpage=3 WHERE #2 AND rootpage=#2]]]
parser: Input 'UPDATE' in state 0
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'UPDATE', go to state 299
parser: Return. Stack=[with UPDATE]
parser: Input 'STRING' in state 299
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', go to state 165
parser: Shift 'STRING', pending reduce 332
parser: Return. Stack=[with UPDATE orconf STRING]
parser: Input 'DOT' with pending reduce 332
parser: Reduce 332 [nm ::= STRING], go to state 165.
parser: ... then shift 'nm', go to state 393
parser: Shift 'DOT', go to state 218
parser: Return. Stack=[with UPDATE orconf nm DOT]
parser: Input 'ID' in state 218
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf nm DOT ID]
parser: Input 'SET' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 218.
parser: ... then shift 'nm', go to state 429
parser: Reduce 113 [xfullname ::= nm DOT nm], go to state 165.
parser: ... then shift 'xfullname', go to state 271
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 428
parser: Shift 'SET', go to state 153
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET]
parser: Input 'ID' in state 153
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET ID]
parser: Input 'EQ' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 153.
parser: ... then shift 'nm', go to state 442
parser: Shift 'EQ', go to state 84
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ]
parser: Input 'INTEGER' in state 84
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ INTEGER]
parser: Input 'WHERE' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 84.
parser: ... then shift 'term', go to state 58
parser: Reduce 148 [setlist ::= nm EQ expr], go to state 153.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE]
parser: Input 'VARIABLE' in state 93
parser: Shift 'VARIABLE', pending reduce 170
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE VARIABLE]
parser: Input 'AND' with pending reduce 170
parser: Reduce 170 [expr ::= VARIABLE], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'AND', go to state 120
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr AND]
parser: Input 'ID' in state 120
parser: Shift 'ID', go to state 416
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr AND ID]
parser: Input 'EQ' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr AND expr EQ]
parser: Input 'VARIABLE' in state 117
parser: Shift 'VARIABLE', pending reduce 170
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr AND expr EQ VARIABLE]
parser: Input 'SEMI' with pending reduce 170
parser: Reduce 170 [expr ::= VARIABLE], go to state 117.
parser: ... then shift 'expr', go to state 129
parser: Reduce 182 [expr ::= expr EQ|NE expr], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Reduce 179 [expr ::= expr AND expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 144 [where_opt ::= WHERE expr], go to state 270.
parser: ... then shift 'where_opt', pending reduce 145
parser: Reduce 145 [cmd ::= with UPDATE orconf xfullname indexed_opt SET setlist where_opt], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdx SEMI]
parser: Input '$' with pending reduce 321
parser: Reduce 321 [ecmd ::= cmdx SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 317 [input ::= cmdlist], go to state 0.
parser: ... then shift 'input', pending reduce -2
parser: Accept!
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[cmdlist cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping cmdlist
parser: [[[;INSERT INTO test006 VALUES(1), (2), (3);SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 320
parser: Return. Stack=[SEMI]
parser: Input 'INSERT' with pending reduce 320
parser: Reduce 320 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 374 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'INSERT', go to state 311
parser: Return. Stack=[ecmd with INSERT]
parser: Input 'INTO' in state 311
parser: Reduce 70 [orconf ::=].
parser: ... then shift 'orconf', pending reduce 156
parser: Reduce 156 [insert_cmd ::= INSERT orconf], go to state 219.
parser: ... then shift 'insert_cmd', go to state 427
parser: Shift 'INTO', go to state 164
parser: Return. Stack=[ecmd with insert_cmd INTO]
parser: Input 'ID' in state 164
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[ecmd with insert_cmd INTO ID]
parser: Input 'VALUES' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 164.
parser: ... then shift 'nm', go to state 393
parser: Reduce 112 [xfullname ::= nm], go to state 164.
parser: ... then shift 'xfullname', go to state 298
parser: Reduce 158 [idlist_opt ::=].
parser: ... then shift 'idlist_opt', go to state 35
parser: Shift 'VALUES', go to state 526
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES]
parser: Input 'LP' in state 526
parser: Shift 'LP', go to state 28
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP]
parser: Input 'INTEGER' in state 28
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 28.
parser: ... then shift 'term', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 410
parser: Shift 'RP', pending reduce 89
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist RP]
parser: Input 'COMMA' with pending reduce 89
parser: Reduce 89 [values ::= VALUES LP nexprlist RP], go to state 35.
parser: ... then shift 'values', go to state 532
parser: Shift 'COMMA', go to state 531
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt values COMMA]
parser: Input 'LP' in state 531
parser: Shift 'LP', go to state 29
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt values COMMA LP]
parser: Input 'INTEGER' in state 29
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt values COMMA LP INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 29.
parser: ... then shift 'term', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 29.
parser: ... then shift 'nexprlist', go to state 414
parser: Shift 'RP', pending reduce 90
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt values COMMA LP nexprlist RP]
parser: Input 'COMMA' with pending reduce 90
parser: Reduce 90 [values ::= values COMMA LP nexprlist RP], go to state 35.
parser: ... then shift 'values', go to state 532
parser: Shift 'COMMA', go to state 531
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt values COMMA]
parser: Input 'LP' in state 531
parser: Shift 'LP', go to state 29
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt values COMMA LP]
parser: Input 'INTEGER' in state 29
parser: Shift 'INTEGER', pending reduce 169
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt values COMMA LP INTEGER]
parser: Input 'RP' with pending reduce 169
parser: Reduce 169 [term ::= INTEGER], go to state 29.
parser: ... then shift 'term', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 29.
parser: ... then shift 'nexprlist', go to state 414
parser: Shift 'RP', pending reduce 90
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt values COMMA LP nexprlist RP]
parser: Input 'SEMI' with pending reduce 90
parser: Reduce 90 [values ::= values COMMA LP nexprlist RP], go to state 35.
parser: ... then shift 'values', go to state 532
parser: Reduce 348 [oneselect ::= values], go to state 35.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 35.
parser: ... then shift 'select', go to state 297
parser: Reduce 152 [upsert ::=].
parser: ... then shift 'upsert', pending reduce 150
parser: Reduce 150 [cmd ::= with insert_cmd INTO xfullname idlist_opt select upsert], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 540
parser: Shift 'SEMI', pending reduce 321
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
parser: [[[SELECT 
    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) 
  FROM field1 GROUP BY test003
  ORDER BY 1
;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'LP' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'LP', go to state 4
parser: Return. Stack=[SELECT distinct sclp scanpt LP]
parser: Input 'SELECT' in state 4
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT distinct sclp scanpt LP SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt LP SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt LP SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt LP SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt LP SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'UNION' in state 192
parser: Reduce 173 [expr ::= ID|INDEXED LP distinct exprlist RP], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Reduce 100 [from ::=].
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 4.
parser: ... then shift 'oneselect', go to state 264
parser: Shift 'UNION', go to state 533
parser: Return. Stack=[SELECT distinct sclp scanpt LP oneselect UNION]
parser: Input 'SELECT' in state 533
parser: Reduce 84 [multiselect_op ::= UNION], go to state 264.
parser: ... then shift 'multiselect_op', go to state 195
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT distinct sclp scanpt LP oneselect multiselect_op SELECT]
parser: Input 'ID' in state 288
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 94 [sclp ::=].
parser: ... then shift 'sclp', go to state 381
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt LP oneselect multiselect_op SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 416
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt LP oneselect multiselect_op SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 93 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct sclp scanpt LP oneselect multiselect_op SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 517
parser: Reduce 353 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 482
parser: Shift 'RP', go to state 192
parser: Return. Stack=[SELECT distinct sclp scanpt LP oneselect multiselect_op SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'OVER' in state 192
parser: Reduce 315 [filter_opt ::=].
parser: ... then shift 'filter_opt', go to state 481
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[SELECT distinct sclp scanpt LP oneselect multiselect_op SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[SELECT distinct sclp scanpt LP oneselect multiselect_op SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP]
parser: Input 'RP' in state 32
parser: Reduce 297 [frame_opt ::=].
parser: ... then shift 'frame_opt', pending reduce 295
parser: Reduce 295 [window ::= frame_opt], go to state 32.
parser: ... then shift 'window', go to state 480
parser: Shift 'RP', pending reduce 313
parser: Return. Stack=[SELECT distinct sclp scanpt LP oneselect multiselect_op SELECT distinct sclp scanpt ID LP distinct exprlist RP filter_opt OVER LP window RP]
parser: Input 'RP' with pending reduce 313
parser: Reduce 313 [over_clause ::= filter_opt OVER LP window RP], go to state 192.
parser: ... then shift 'over_clause', pending reduce 175
parser: Reduce 175 [expr ::= ID|INDEXED LP distinct exprlist RP over_clause], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Reduce 100 [from ::=].
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Reduce 134 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 127 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 357
parser: Reduce 138 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 87
parser: Reduce 87 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 195.
parser: ... then shift 'oneselect', pending reduce 83
parser: Reduce 83 [selectnowith ::= selectnowith multiselect_op oneselect], go to state 4.
parser: ... then shift 'selectnowith', go to state 264
parser: Reduce 82 [select ::= selectnowith], go to state 4.
parser: ... then shift 'select', go to state 483
parser: Shift 'RP', pending reduce 203
parser: Return. Stack=[SELECT distinct sclp scanpt LP select RP]
parser: Input 'FROM' with pending reduce 203
parser: Reduce 203 [expr ::= LP select RP], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', pending reduce 95
parser: Reduce 95 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 103 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 331
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'GROUP' with pending reduce 331
parser: Reduce 331 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 349
parser: Reduce 108 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 99 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 122 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 348
parser: Reduce 121 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 347
parser: Reduce 126 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 104
parser: Reduce 104 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 101 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 360
parser: Reduce 143 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 359
parser: Shift 'GROUP', go to state 499
parser: Return. Stack=[SELECT distinct selcollist from where_opt GROUP]
parser: Input 'BY' in state 499
parser: Shift 'BY', go to state 21
parser: Return. Stack=[SELECT distinct selcollist from where_opt GROUP BY]
parser: Input 'ID' in state 21
parser: Shift 'ID', go to state 416
parser: Return. Stack=[SELECT distinct selcollist from where_opt GROUP BY ID]
parser: Input 'ORDER' in state 416
parser: Reduce 163 [expr ::= ID|INDEXED], go to state 21.
parser: ... then shift 'expr', go to state 70
parser: Reduce 216 [nexprlist ::= expr], go to state 21.
parser: ... then shift 'nexprlist', go to state 498
parser: Reduce 135 [groupby_opt ::= GROUP BY nexprlist], go to state 359.
parser: ... then shift 'groupby_opt', go to state 358
parser: Reduce 136 [having_opt ::=].
parser: ... then shift '
Program received signal SIGABRT, Aborted.
__GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:50
(gdb) #0  __GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:50
#1  0x00007f590089f859 in __GI_abort () at abort.c:79
#2  0x00007f590089f729 in __assert_fail_base (fmt=0x7f5900a35588 "%s%s%s:%u: %s%sAssertion `%s' failed.\n%n", assertion=0x211bd9 "pColExpr->op!=TK_AGG_COLUMN", file=0x22873d "sqlite3.c", line=126590, 
    function=<optimized out>) at assert.c:92
#3  0x00007f59008b0fd6 in __GI___assert_fail (assertion=0x211bd9 "pColExpr->op!=TK_AGG_COLUMN", file=0x22873d "sqlite3.c", line=126590, 
    function=0x221122 "int sqlite3ColumnsFromExprList(Parse *, ExprList *, i16 *, Column **)") at assert.c:101
#4  0x000000000032d160 in sqlite3ColumnsFromExprList (pParse=0x7ffd6302f580, pEList=0x11c2770, pnCol=0x11c7766, paCol=0x11c7728) at sqlite3.c:126590
#5  0x000000000033cf65 in sqlite3ExpandSubquery (pParse=0x7ffd6302f580, pFrom=0x11bce68) at sqlite3.c:129416
#6  0x00000000003a17f2 in sqlite3WindowRewrite (pParse=0x7ffd6302f580, p=0x11c1960) at sqlite3.c:146385
#7  0x00000000002fc6de in sqlite3Select (pParse=0x7ffd6302f580, p=0x11c1960, pDest=0x7ffd6302ddf0) at sqlite3.c:130281
#8  0x00000000003a45ed in multiSelect (pParse=0x7ffd6302f580, p=0x11c1960, pDest=0x7ffd6302e1f8) at sqlite3.c:127314
#9  0x00000000002fccf5 in sqlite3Select (pParse=0x7ffd6302f580, p=0x11c1960, pDest=0x7ffd6302e1f8) at sqlite3.c:130384
#10 0x000000000034f659 in sqlite3CodeSubselect (pParse=0x7ffd6302f580, pExpr=0x11cde40) at sqlite3.c:99820
#11 0x000000000034bbfd in sqlite3ExprCodeTarget (pParse=0x7ffd6302f580, pExpr=0x11cde40, target=10) at sqlite3.c:100770
#12 0x000000000034e9ee in sqlite3ExprCodeExprList (pParse=0x7ffd6302f580, pList=0x11cd990, target=10, srcReg=0, flags=1 '\001') at sqlite3.c:101202
#13 0x00000000003ae220 in pushOntoSorter (pParse=0x7ffd6302f580, pSort=0x7ffd6302e7a8, pSelect=0x11c6460, regData=11, regOrigData=0, nData=0, nPrefixReg=1) at sqlite3.c:125256
#14 0x00000000003a9edf in selectInnerLoop (pParse=0x7ffd6302f580, p=0x11c6460, srcTab=-1, pSort=0x7ffd6302e7a8, pDistinct=0x7ffd6302e860, pDest=0x7ffd6302e970, iContinue=27, iBreak=24) at sqlite3.c:125809
#15 0x00000000002ff58c in sqlite3Select (pParse=0x7ffd6302f580, p=0x11c6460, pDest=0x7ffd6302e970) at sqlite3.c:131068
#16 0x00000000002ecaa8 in yy_reduce (yypParser=0x7ffd6302eba0, yyruleno=79, yyLookahead=1, yyLookaheadToken=..., pParse=0x7ffd6302f580) at sqlite3.c:151581
#17 0x00000000002e92f8 in sqlite3Parser (yyp=0x7ffd6302eba0, yymajor=1, yyminor=...) at sqlite3.c:152877
#18 0x00000000002a68b3 in sqlite3RunParser (pParse=0x7ffd6302f580, zSql=0x11c8a51 ";", pzErrMsg=0x7ffd6302f760) at sqlite3.c:154013
#19 0x00000000002a1683 in sqlite3Prepare (db=0x11a62b0, zSql=0x11b8ec7 "SELECT \n    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) \n  FROM field1 GROUP BY test003\n  ORDER BY 1\n;", nBytes=114, prepFlags=128, 
    pReprepare=0x0, ppStmt=0x7ffd6302f898, pzTail=0x7ffd6302f880) at sqlite3.c:124303
#20 0x00000000002a0d4e in sqlite3LockAndPrepare (db=0x11a62b0, zSql=0x11b8ec7 "SELECT \n    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) \n  FROM field1 GROUP BY test003\n  ORDER BY 1\n;", nBytes=114, 
    prepFlags=128, pOld=0x0, ppStmt=0x7ffd6302f898, pzTail=0x7ffd6302f880) at sqlite3.c:124403
#21 0x000000000029247f in sqlite3_prepare_v2 (db=0x11a62b0, zSql=0x11b8ec7 "SELECT \n    (SELECT avg(test003) UNION SELECT min(test003) OVER ()) \n  FROM field1 GROUP BY test003\n  ORDER BY 1\n;", nBytes=114, 
    ppStmt=0x7ffd6302f898, pzTail=0x7ffd6302f880) at sqlite3.c:124487
#22 0x0000000000256bd0 in main (argc=1, argv=0x7ffd6302fa48) at target.cc:106
(gdb) quit
A debugging session is active.

	Inferior 1 [process 56636] will be killed.

Quit anyway? (y or n) [answered Y; input not from terminal]
