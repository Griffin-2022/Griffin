GNU gdb (Ubuntu 9.2-0ubuntu1~20.04.1) 9.2
Copyright (C) 2020 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type "show copying" and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
    <http://www.gnu.org/software/gdb/documentation/>.

For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from /root/sqlite_driver_fast...
(gdb) Starting program: /root/sqlite_driver_fast < "/root/out/default/crashes/id:000534,sig:06,src:021927+009052,time:38188214,execs:7379262,op:merge.so,pos:0"
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
SQL: [;PRAGMA vdbe_trace=on;]
VDBE Trace:
   0 Init             0    1    0               00 Start at 1
   1 Expire           0    0    0               00 
   2 Halt             0    0    0               00 
SQL: [;ALTER TABLE t1 RENAME TO t2;]
VDBE Trace:
   0 Init             0  140    0               00 Start at 140
 140 Transaction      0    1    1 1             01 usesStmtJournal=1
 141 Transaction      1    1    0 1             01 usesStmtJournal=1
 142 String8          0    9    0 index         00 r[9]='index'
REG[9] =   t5[index](8)
 143 String8          0   10    0 t1            00 r[10]='t1'
REG[10] =   t2[t1](8)
 144 String8          0   11    0 sqliteX_%     00 r[11]='sqliteX_%'
REG[11] =   t9[sqliteX_%](8)
 145 String8          0   13    0 X             00 r[13]='X'
REG[13] =   t1[X](8)
 146 String8          0   15    0 main          00 r[15]='main'
REG[15] =   t4[main](8)
 147 String8          0   19    0 t1            00 r[19]='t1'
REG[19] =   t2[t1](8)
 148 String8          0   20    0 t2            00 r[20]='t2'
REG[20] =   t2[t2](8)
 149 Integer          0   21    0               00 r[21]=0
REG[21] =  i:0
 150 String8          0   29    0 table         00 r[29]='table'
REG[29] =   t5[table](8)
 151 String8          0   30    0 trigger       00 r[30]='trigger'
REG[30] =   t7[trigger](8)
 152 String8          0   32    0 sqliteX_autoindex% 00 r[32]='sqliteX_autoindex%'
REG[32] =   t18[sqliteX_autoindex%](8)
 153 String8          0   34    0 X             00 r[34]='X'
REG[34] =   t1[X](8)
 154 String8          0   47    0 sqlite_autoindex_ 00 r[47]='sqlite_autoindex_'
REG[47] =   t17[sqlite_autoindex_](8)
 155 String8          0   83    0 t2            00 r[83]='t2'
REG[83] =   t2[t2](8)
 156 Concat          83   47   35               00 r[35]=r[47]+r[83]
REG[83] =   t2[t2](8)
REG[47] =   t17[sqlite_autoindex_](8)
REG[35] =   s19[sqlite_autoindex_t2](8)
 157 Integer          2   83    0               00 r[83]=2
REG[83] =  i:2
 158 Integer         18   47    0               00 r[47]=18
REG[47] =  i:18
 159 Add             47   83   37               00 r[37]=r[47]+r[83]
REG[47] =  i:18
REG[83] =  i:2
REG[37] =  i:20
 160 String8          0   45    0 view          00 r[45]='view'
REG[45] =   t4[view](8)
 161 String8          0   48    0 main          00 r[48]='main'
REG[48] =   t4[main](8)
 162 Integer          1   52    0               00 r[52]=1
REG[52] =  i:1
 163 String8          0   53    0 main          00 r[53]='main'
REG[53] =   t4[main](8)
 164 String8          0   57    0 t1            00 r[57]='t1'
REG[57] =   t2[t1](8)
 165 String8          0   58    0 t2            00 r[58]='t2'
REG[58] =   t2[t2](8)
 166 Integer          1   59    0               00 r[59]=1
REG[59] =  i:1
 167 String8          0   60    0 sqliteX_%     00 r[60]='sqliteX_%'
REG[60] =   t9[sqliteX_%](8)
 168 String8          0   62    0 X             00 r[62]='X'
REG[62] =   t1[X](8)
 169 String8          0   63    0 create virtual% 00 r[63]='create virtual%'
REG[63] =   t15[create virtual%](8)
 170 String8          0   65    0 main          00 r[65]='main'
REG[65] =   t4[main](8)
 171 Integer          0   69    0               00 r[69]=0
REG[69] =  i:0
 172 Null             0   70    0               00 r[70]=NULL
REG[70] =  NULL
 173 String8          0   72    0 sqliteX_%     00 r[72]='sqliteX_%'
REG[72] =   t9[sqliteX_%](8)
 174 String8          0   74    0 X             00 r[74]='X'
REG[74] =   t1[X](8)
 175 String8          0   75    0 create virtual% 00 r[75]='create virtual%'
REG[75] =   t15[create virtual%](8)
 176 String8          0   77    0 main          00 r[77]='main'
REG[77] =   t4[main](8)
 177 Integer          1   81    0               00 r[81]=1
REG[81] =  i:1
 178 Goto             0    1    0               00 
   1 Null             0    1    2               00 r[1..2]=NULL
REG[1] =  NULL
   2 OpenRead         0    1    0 3             00 root=1 iDb=0; sqlite_master
   3 Explain          3    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   15    0               00 
   5 Column           0    0    8               00 r[8]=sqlite_master.type
REG[8] =   s5[table](8)
   6 Ne               9    9    8 (BINARY)      42 if r[8]!=r[9] goto 9
REG[9] =   t5[index](8)
REG[8] =   s5[table](8)
   9 Column           0    1   12               00 r[12]=sqlite_master.name
REG[12] =   s2[t1](8)
  10 Function0        5   11    8 like(3)       03 r[8]=func(r[11..13])
REG[11] =   t9[sqliteX_%](8)
REG[12] =   s2[t1](8)
REG[13] =   t1[X](8)
REG[8] =  i:0
  11 If               8   14    1               00 
REG[8] =  i:0
  12 Rowid            0    2    0               00 r[2]=rowid
REG[2] =  i:1
  13 RowSetAdd        1    2    0               00 rowset(1)=r[2]
REG[1] =  NULL
REG[2] =  i:1
  14 Next             0    5    0               01 
  15 OpenWrite        0    1    0 5             00 root=1 iDb=0; sqlite_master
  16 RowSetRead       1   29    2               00 r[2]=rowset(1)
REG[1] =  (rowset)
REG[2] =  i:1
  17 NotExists        0   16    2               00 intkey=r[2]
REG[2] =  i:1
  18 Column           0    0    3               00 r[3]=sqlite_master.type
REG[3] =   s5[table](8)
  19 Column           0    1    4               00 r[4]=sqlite_master.name
REG[4] =   s2[t1](8)
  20 Column           0    2    5               00 r[5]=sqlite_master.tbl_name
REG[5] =   s2[t1](8)
  21 Column           0    3    6               00 r[6]=sqlite_master.rootpage
REG[6] =  i:2
  22 Column           0    0   16               00 r[16]=sqlite_master.type
REG[16] =   s5[table](8)
  23 Column           0    1   17               00 r[17]=sqlite_master.name
REG[17] =   s2[t1](8)
  24 Column           0    4   18               00 r[18]=sqlite_master.sql
REG[18] =   s18[CREATE TABLE t1(x)](8)
  25 Function0      113   15    7 sqlite_rename_table(7) 07 r[7]=func(r[15..21])
REG[15] =   t4[main](8)
REG[16] =   s5[table](8)
REG[17] =   s2[t1](8)
REG[18] =   s18[CREATE TABLE t1(x)](8)
REG[19] =   t2[t1](8)
REG[20] =   t2[t2](8)
REG[21] =  i:0
REG[7] =   s20[CREATE TABLE "t2"(x)](8)
  26 MakeRecord       3    5   14 BBBDB         00 r[14]=mkrec(r[3..7])
REG[3] =   s5[table](8)
REG[4] =   s2[t1](8)
REG[5] =   s2[t1](8)
REG[6] =  i:2
REG[7] =   s20[CREATE TABLE "t2"(x)](8)
REG[14] =  sx36[0617111101357461626C657431743102435245415445205441|.....5tablet1t1.CREATE TA]
  27 Insert           0   14    2               00 intkey=r[2] data=r[14]
REG[14] =  sx36[0617111101357461626C657431743102435245415445205441|.....5tablet1t1.CREATE TA]
REG[2] =  i:1
  28 Goto             0   16    0               00 
  16 RowSetRead       1   29    2               00 r[2]=rowset(1)
REG[1] =  (rowset)
REG[2] =  i:1
  29 Null             0   22   23               00 r[22..23]=NULL
REG[22] =  NULL
  30 OpenRead         1    1    0 3             00 root=1 iDb=0; sqlite_master
  31 Explain         31    0    0 SCAN TABLE sqlite_master 00 
  32 Rewind           1   44    0               00 
  33 Column           1    2    8               00 r[8]=sqlite_master.tbl_name
REG[8] =   s2[t1](8)
  34 Ne              10   43    8 (NOCASE)      52 if r[8]!=r[10] goto 43
REG[10] =   t2[t1](8)
REG[8] =   s2[t1](8)
  35 Column           1    0    8               00 r[8]=sqlite_master.type
REG[8] =   s5[table](8)
  36 Eq              29   41    8 (BINARY)      42 if r[8]==r[29] goto 41
REG[29] =   t5[table](8)
REG[8] =   s5[table](8)
  41 Rowid            1   23    0               00 r[23]=rowid
REG[23] =  i:1
  42 RowSetAdd       22   23    0               00 rowset(22)=r[23]
REG[22] =  NULL
REG[23] =  i:1
  43 Next             1   33    0               01 
  44 OpenWrite        1    1    0 5             00 root=1 iDb=0; sqlite_master
  45 RowSetRead      22   68   23               00 r[23]=rowset(22)
REG[22] =  (rowset)
REG[23] =  i:1
  46 NotExists        1   45   23               00 intkey=r[23]
REG[23] =  i:1
  47 Column           1    0   24               00 r[24]=sqlite_master.type
REG[24] =   s5[table](8)
  48 Column           1    0    8               00 r[8]=sqlite_master.type
REG[8] =   s5[table](8)
  49 Ne              29   52    8 (BINARY)      52 if r[8]!=r[29] goto 52
REG[29] =   t5[table](8)
REG[8] =   s5[table](8)
  50 String8          0   25    0 t2            00 r[25]='t2'
REG[25] =   t2[t2](8)
  51 Goto             0   62    0               00 
  62 String8          0   26    0 t2            00 r[26]='t2'
REG[26] =   t2[t2](8)
  63 Column           1    3   27               00 r[27]=sqlite_master.rootpage
REG[27] =  i:2
  64 Column           1    4   28               00 r[28]=sqlite_master.sql
REG[28] =   s20[CREATE TABLE "t2"(x)](8)
  65 MakeRecord      24    5   31 BBBDB         00 r[31]=mkrec(r[24..28])
REG[24] =   s5[table](8)
REG[25] =   t2[t2](8)
REG[26] =   t2[t2](8)
REG[27] =  i:2
REG[28] =   s20[CREATE TABLE "t2"(x)](8)
REG[31] =  sx36[0617111101357461626C657432743202435245415445205441|.....5tablet2t2.CREATE TA]
  66 Insert           1   31   23               00 intkey=r[23] data=r[31]
REG[31] =  sx36[0617111101357461626C657432743202435245415445205441|.....5tablet2t2.CREATE TA]
REG[23] =  i:1
  67 Goto             0   45    0               00 
  45 RowSetRead      22   68   23               00 r[23]=rowset(22)
REG[22] =  (rowset)
REG[23] =  i:1
  68 Null             0   38   39               00 r[38..39]=NULL
REG[38] =  NULL
  69 OpenRead         2    1    1 1             00 root=1 iDb=1; sqlite_temp_master
  70 Explain         70    0    0 SCAN TABLE sqlite_temp_master 00 
  71 Rewind           2   79    0               00 
  79 OpenWrite        2    1    1 5             00 root=1 iDb=1; sqlite_temp_master
  80 RowSetRead      38  102   39               00 r[39]=rowset(38)
REG[38] =  NULL
REG[39] =  NULL
 102 SetCookie        0    1    2               00 
 103 ParseSchema      0    0    0               00 
VDBE Trace:
   0 Init             0   13    0               00 Start at 13
  13 Transaction      0    0    2 2             00 usesStmtJournal=0
  14 Goto             0    1    0               00 
   1 Noop             1    7    0               00 
   2 OpenRead         0    1    0 5             00 root=1 iDb=0; sqlite_master
   3 Explain          3    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   12    0               00 
   5 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[table](8)
   6 Column           0    1    2               00 r[2]=sqlite_master.name
REG[2] =   s2[t2](8)
   7 Column           0    2    3               00 r[3]=sqlite_master.tbl_name
REG[3] =   s2[t2](8)
   8 Column           0    3    4               00 r[4]=sqlite_master.rootpage
REG[4] =  i:2
   9 Column           0    4    5               00 r[5]=sqlite_master.sql
REG[5] =   s20[CREATE TABLE "t2"(x)](8)
  10 ResultRow        1    5    0               00 output=r[1..5]
REG[1] =   s5[table](8)
REG[2] =   s2[t2](8)
REG[3] =   s2[t2](8)
REG[4] =  i:2
REG[5] =   s20[CREATE TABLE "t2"(x)](8)
  11 Next             0    5    0               01 
  12 Halt             0    0    0               00 
 104 ParseSchema      1    0    0               00 
VDBE Trace:
   0 Init             0   13    0               00 Start at 13
  13 Transaction      1    0    0 2             00 usesStmtJournal=0
  14 Goto             0    1    0               00 
   1 Noop             1    7    0               00 
   2 OpenRead         0    1    1 5             00 root=1 iDb=1; sqlite_temp_master
   3 Explain          3    0    0 SCAN TABLE sqlite_temp_master 00 
   4 Rewind           0   12    0               00 
  12 Halt             0    0    0               00 
 105 OpenRead         4    1    0 5             00 root=1 iDb=0; sqlite_master
 106 Explain        106    0    0 SCAN TABLE sqlite_master 00 
 107 Rewind           4  122    0               00 
 108 Column           4    1   61               00 r[61]=sqlite_master.name
REG[61] =   s2[t2](8)
 109 Function0        5   60   47 like(3)       03 r[47]=func(r[60..62])
REG[60] =   t9[sqliteX_%](8)
REG[61] =   s2[t2](8)
REG[62] =   t1[X](8)
REG[47] =  i:0
 110 If              47  121    1               00 
REG[47] =  i:0
 111 Column           4    4   64               00 r[64]=sqlite_master.sql
REG[64] =   s20[CREATE TABLE "t2"(x)](8)
 112 Function0        1   63   47 like(2)       02 r[47]=func(r[63..64])
REG[63] =   t15[create virtual%](8)
REG[64] =   s20[CREATE TABLE "t2"(x)](8)
REG[47] =  i:0
 113 If              47  121    1               00 
REG[47] =  i:0
 114 Column           4    4   66               00 r[66]=sqlite_master.sql
REG[66] =   s20[CREATE TABLE "t2"(x)](8)
 115 Column           4    0   67               00 r[67]=sqlite_master.type
REG[67] =   s5[table](8)
 116 Column           4    1   68               00 r[68]=sqlite_master.name
REG[68] =   s2[t2](8)
 117 Function0       17   65   47 sqlite_rename_test(5) 05 r[47]=func(r[65..69])
REG[65] =   t4[main](8)
REG[66] =   s20[CREATE TABLE "t2"(x)](8)
REG[67] =   s5[table](8)
REG[68] =   s2[t2](8)
REG[69] =  i:0
REG[47] =  NULL
 118 Ne              70  121   47               50 if r[47]!=r[70] goto 121
REG[70] =  NULL
REG[47] =  NULL
 121 Next             4  108    0               01 
 122 OpenRead         5    1    1 5             00 root=1 iDb=1; sqlite_temp_master
 123 Explain        123    0    0 SCAN TABLE sqlite_master 00 
 124 Rewind           5  139    0               00 
 139 Halt             0    0    0               00 
SQL: [;;
;CREATE TABLE t4(i1 INTEGER PRIMARY KEY, a, b TEXT);]
VDBE Trace:
   0 Init             0   28    0               00 Start at 28
  28 Transaction      0    1    2 2             01 usesStmtJournal=0
  29 Goto             0    1    0               00 
   1 ReadCookie       0    3    2               00 
REG[3] =  i:4
   2 If               3    5    0               00 
REG[3] =  i:4
   5 CreateBtree      0    2    1               00 r[2]=root iDb=0 flags=1
REG[2] =  i:3
   6 OpenWrite        0    1    0 5             00 root=1 iDb=0
   7 NewRowid         0    1    0               00 r[1]=rowid
REG[1] =  i:2
   8 Blob             6    3    0              00 r[3]= (len=6)
REG[3] =  tx6[060000000000|......]
   9 Insert           0    3    1               08 intkey=r[1] data=r[3]
REG[3] =  tx6[060000000000|......]
REG[1] =  i:2
  10 Close            0    0    0               00 
  11 Close            0    0    0               00 
  12 Null             0    4    5               00 r[4..5]=NULL
REG[4] =  NULL
  13 OpenWrite        1    1    0 5             00 root=1 iDb=0; sqlite_master
  14 Explain         14    0    0 SEARCH TABLE sqlite_master USING INTEGER PRIMARY KEY (rowid=?) 00 
  15 SeekRowid        1   17    1               00 intkey=r[1]
REG[1] =  i:2
  16 Rowid            1    5    0               00 r[5]=rowid
REG[5] =  i:2
  17 IsNull           5   25    0               00 if r[5]==NULL goto 25
REG[5] =  i:2
  18 String8          0    6    0 table         00 r[6]='table'
REG[6] =   t5[table](8)
  19 String8          0    7    0 t4            00 r[7]='t4'
REG[7] =   t2[t4](8)
  20 String8          0    8    0 t4            00 r[8]='t4'
REG[8] =   t2[t4](8)
  21 Copy             2    9    0               00 r[9]=r[2]
REG[9] =  i:3
  22 String8          0   10    0 CREATE TABLE t4(i1 INTEGER PRIMARY KEY, a, b TEXT) 00 r[10]='CREATE TABLE t4(i1 INTEGER PRIMARY KEY, a, b TEXT)'
REG[10] =   t50[CREATE TABLE t4(i1 INTEGE](8)
  23 MakeRecord       6    5    4 BBBDB         00 r[4]=mkrec(r[6..10])
REG[6] =   t5[table](8)
REG[7] =   t2[t4](8)
REG[8] =   t2[t4](8)
REG[9] =  i:3
REG[10] =   t50[CREATE TABLE t4(i1 INTEGE](8)
REG[4] =  sx66[0617111101717461626C657434743403435245415445205441|.....qtablet4t4.CREATE TA]
  24 Insert           1    4    5               00 intkey=r[5] data=r[4]
REG[4] =  sx66[0617111101717461626C657434743403435245415445205441|.....qtablet4t4.CREATE TA]
REG[5] =  i:2
  25 SetCookie        0    1    3               00 
  26 ParseSchema      0    0    0 tbl_name='t4' AND type!='trigger' 00 
VDBE Trace:
   0 Init             0   17    0               00 Start at 17
  17 Transaction      0    0    3 2             00 usesStmtJournal=0
  18 String8          0    2    0 t4            00 r[2]='t4'
REG[2] =   t2[t4](8)
  19 String8          0    3    0 trigger       00 r[3]='trigger'
REG[3] =   t7[trigger](8)
  20 Goto             0    1    0               00 
   1 Noop             1    7    0               00 
   2 OpenRead         0    1    0 5             00 root=1 iDb=0; sqlite_master
   3 Explain          3    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   16    0               00 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[t2](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t2[t4](8)
REG[1] =   s2[t2](8)
  15 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[t4](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t2[t4](8)
REG[1] =   s2[t4](8)
   7 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[table](8)
   8 Eq               3   15    1 (BINARY)      52 if r[1]==r[3] goto 15
REG[3] =   t7[trigger](8)
REG[1] =   s5[table](8)
   9 Column           0    0    4               00 r[4]=sqlite_master.type
REG[4] =   s5[table](8)
  10 Column           0    1    5               00 r[5]=sqlite_master.name
REG[5] =   s2[t4](8)
  11 Column           0    2    6               00 r[6]=sqlite_master.tbl_name
REG[6] =   s2[t4](8)
  12 Column           0    3    7               00 r[7]=sqlite_master.rootpage
REG[7] =  i:3
  13 Column           0    4    8               00 r[8]=sqlite_master.sql
REG[8] =   s50[CREATE TABLE t4(i1 INTEGE](8)
  14 ResultRow        4    5    0               00 output=r[4..8]
REG[4] =   s5[table](8)
REG[5] =   s2[t4](8)
REG[6] =   s2[t4](8)
REG[7] =  i:3
REG[8] =   s50[CREATE TABLE t4(i1 INTEGE](8)
  15 Next             0    5    0               01 
  16 Halt             0    0    0               00 
  27 Halt             0    0    0               00 
SQL: [;CREATE TABLE t4a(t5 INTEGER PRIMARY KEY);]
VDBE Trace:
   0 Init             0   28    0               00 Start at 28
  28 Transaction      0    1    3 2             01 usesStmtJournal=0
  29 Goto             0    1    0               00 
   1 ReadCookie       0    3    2               00 
REG[3] =  i:4
   2 If               3    5    0               00 
REG[3] =  i:4
   5 CreateBtree      0    2    1               00 r[2]=root iDb=0 flags=1
REG[2] =  i:4
   6 OpenWrite        0    1    0 5             00 root=1 iDb=0
   7 NewRowid         0    1    0               00 r[1]=rowid
REG[1] =  i:3
   8 Blob             6    3    0              00 r[3]= (len=6)
REG[3] =  tx6[060000000000|......]
   9 Insert           0    3    1               08 intkey=r[1] data=r[3]
REG[3] =  tx6[060000000000|......]
REG[1] =  i:3
  10 Close            0    0    0               00 
  11 Close            0    0    0               00 
  12 Null             0    4    5               00 r[4..5]=NULL
REG[4] =  NULL
  13 OpenWrite        1    1    0 5             00 root=1 iDb=0; sqlite_master
  14 Explain         14    0    0 SEARCH TABLE sqlite_master USING INTEGER PRIMARY KEY (rowid=?) 00 
  15 SeekRowid        1   17    1               00 intkey=r[1]
REG[1] =  i:3
  16 Rowid            1    5    0               00 r[5]=rowid
REG[5] =  i:3
  17 IsNull           5   25    0               00 if r[5]==NULL goto 25
REG[5] =  i:3
  18 String8          0    6    0 table         00 r[6]='table'
REG[6] =   t5[table](8)
  19 String8          0    7    0 t4a           00 r[7]='t4a'
REG[7] =   t3[t4a](8)
  20 String8          0    8    0 t4a           00 r[8]='t4a'
REG[8] =   t3[t4a](8)
  21 Copy             2    9    0               00 r[9]=r[2]
REG[9] =  i:4
  22 String8          0   10    0 CREATE TABLE t4a(t5 INTEGER PRIMARY KEY) 00 r[10]='CREATE TABLE t4a(t5 INTEGER PRIMARY KEY)'
REG[10] =   t40[CREATE TABLE t4a(t5 INTEG](8)
  23 MakeRecord       6    5    4 BBBDB         00 r[4]=mkrec(r[6..10])
REG[6] =   t5[table](8)
REG[7] =   t3[t4a](8)
REG[8] =   t3[t4a](8)
REG[9] =  i:4
REG[10] =   t40[CREATE TABLE t4a(t5 INTEG](8)
REG[4] =  sx58[06171313015D7461626C657434617434610443524541544520|.....]tablet4at4a.CREATE ]
  24 Insert           1    4    5               00 intkey=r[5] data=r[4]
REG[4] =  sx58[06171313015D7461626C657434617434610443524541544520|.....]tablet4at4a.CREATE ]
REG[5] =  i:3
  25 SetCookie        0    1    4               00 
  26 ParseSchema      0    0    0 tbl_name='t4a' AND type!='trigger' 00 
VDBE Trace:
   0 Init             0   17    0               00 Start at 17
  17 Transaction      0    0    4 2             00 usesStmtJournal=0
  18 String8          0    2    0 t4a           00 r[2]='t4a'
REG[2] =   t3[t4a](8)
  19 String8          0    3    0 trigger       00 r[3]='trigger'
REG[3] =   t7[trigger](8)
  20 Goto             0    1    0               00 
   1 Noop             1    7    0               00 
   2 OpenRead         0    1    0 5             00 root=1 iDb=0; sqlite_master
   3 Explain          3    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   16    0               00 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[t2](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t3[t4a](8)
REG[1] =   s2[t2](8)
  15 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[t4](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t3[t4a](8)
REG[1] =   s2[t4](8)
  15 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s3[t4a](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t3[t4a](8)
REG[1] =   s3[t4a](8)
   7 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[table](8)
   8 Eq               3   15    1 (BINARY)      52 if r[1]==r[3] goto 15
REG[3] =   t7[trigger](8)
REG[1] =   s5[table](8)
   9 Column           0    0    4               00 r[4]=sqlite_master.type
REG[4] =   s5[table](8)
  10 Column           0    1    5               00 r[5]=sqlite_master.name
REG[5] =   s3[t4a](8)
  11 Column           0    2    6               00 r[6]=sqlite_master.tbl_name
REG[6] =   s3[t4a](8)
  12 Column           0    3    7               00 r[7]=sqlite_master.rootpage
REG[7] =  i:4
  13 Column           0    4    8               00 r[8]=sqlite_master.sql
REG[8] =   s40[CREATE TABLE t4a(t5 INTEG](8)
  14 ResultRow        4    5    0               00 output=r[4..8]
REG[4] =   s5[table](8)
REG[5] =   s3[t4a](8)
REG[6] =   s3[t4a](8)
REG[7] =  i:4
REG[8] =   s40[CREATE TABLE t4a(t5 INTEG](8)
  15 Next             0    5    0               01 
  16 Halt             0    0    0               00 
  27 Halt             0    0    0               00 
SQL: [;
;WITH t5(t5col1) AS (
    SELECT (
      WITH t3(t3col1) AS (
        WITH t2 AS (
          WITH t4a AS (SELECT 1 AS c1 GROUP BY 1) 
          SELECT a.c1 FROM t4a AS a, t4a AS b
          WHERE anoncol1 = 1
        )
        SELECT (SELECT 1 FROM t2) FROM t2
      ) 
      SELECT t3col1 FROM t3 WHERE t3col1
    ) FROM (SELECT 1 AS anoncol1)
  )
  SELECT t5col1, t5col1 FROM t5

;]
VDBE Trace:
   0 Init             0  367    0               00 Start at 367
 367 Integer          1   19    0               00 r[19]=1
REG[19] =  i:1
 368 Goto             0    1    0               00 
   1 InitCoroutine    1    7    2               00 subquery_6
   7 Explain          7    0    0 SCAN SUBQUERY 6 00 
   8 InitCoroutine    1    0    2               00 
   9 Yield            1  366    0               00 next row of subquery_6
REG[1] =  i:1
REG[1] =  i:9
   2 Explain          2    0    0 CO-ROUTINE 6  00 
   3 Explain          3    2    0 SCAN CONSTANT ROW 00 
   4 Integer          1    2    0               00 r[2]=1
REG[2] =  i:1
   5 Yield            1    0    0               00 
REG[1] =  i:9
REG[1] =  i:5
  10 Explain         10    0    0 CORRELATED SCALAR SUBQUERY 5 00 
  11 Null             0    5    5               00 r[5..5]=NULL; Init subquery result
REG[5] =  NULL
  12 Integer         42    6    0               00 r[6]=42
REG[6] =  i:42
  13 Once             0   42    0               00 materialize "t4a"
  14 Explain         14   10    0 MATERIALIZE 1 00 
  15 OpenEphemeral    4    1    0               00 nColumn=1
  16 Noop             9    1    0               00 
  17 Integer          0    8    0               00 r[8]=0; clear abort flag
REG[8] =  i:0
  18 Null             0   11   11               00 r[11..11]=NULL
REG[11] =  NULL
  19 Gosub           10   40    0               00 
REG[10] =  i:19
  40 Integer          0    7    0               00 r[7]=0; indicate accumulator empty
REG[7] =  i:0
  41 Return          10    0    0               00 
REG[10] =  i:19
  20 Explain         20   14    0 SCAN CONSTANT ROW 00 
  21 Integer          1   12    0               00 r[12]=1
REG[12] =  i:1
  22 Compare         11   12    1 k(1,B)        00 r[11] <-> r[12]
REG[11] =  NULL
REG[12] =  i:1
  23 Jump            24   28   24               00 
  24 Move            12   11    1               00 r[11]=r[12]
REG[11] =  i:1
  25 Gosub            9   33    0               00 output one row
REG[9] =  i:25
  33 IfPos            7   35    0               00 if r[7]>0 then r[7]-=0, goto 35; Groupby result generator entry point
REG[7] =  i:0
  34 Return           9    0    0               00 
REG[9] =  i:25
  26 IfPos            8   42    0               00 if r[8]>0 then r[8]-=0, goto 42; check abort flag
REG[8] =  i:0
  27 Gosub           10   40    0               00 reset accumulator
REG[10] =  i:27
  40 Integer          0    7    0               00 r[7]=0; indicate accumulator empty
REG[7] =  i:0
  41 Return          10    0    0               00 
REG[10] =  i:27
  28 Integer          1    7    0               00 r[7]=1; indicate data in accumulator
REG[7] =  i:1
  29 Gosub            9   33    0               00 output final row
REG[9] =  i:29
  33 IfPos            7   35    0               00 if r[7]>0 then r[7]-=0, goto 35; Groupby result generator entry point
REG[7] =  i:1
  35 Integer          1   13    0               00 r[13]=1
REG[13] =  i:1
  36 MakeRecord      13    1   14               00 r[14]=mkrec(r[13])
REG[14] =  sx2[0209|..]
  37 NewRowid         4   15    0               00 r[15]=rowid
REG[15] =  i:1
  38 Insert           4   14   15               08 intkey=r[15] data=r[14]
REG[14] =  sx2[0209|..]
REG[15] =  i:1
  39 Return           9    0    0               00 end groupby result generator
REG[9] =  i:29
  30 Goto             0   42    0               00 
  42 Return           6    0    0               00 end t4a
REG[6] =  i:42
  43 Integer         46   16    0               00 r[16]=46
REG[16] =  i:46
  44 Once             0   46    0               00 materialize "t4a"
  45 OpenDup          5    4    0               00 
  46 Return          16    0    0               00 end t4a
REG[16] =  i:46
  47 Integer          1   17    0               00 r[17]=1; LIMIT counter
REG[17] =  i:1
  48 Copy             2   18    0               00 r[18]=r[2]; subquery_6.anoncol1
REG[18] =  i:1
  49 Ne              19  186   18 (BINARY)      50 if r[18]!=r[19] goto 186
REG[19] =  i:1
REG[18] =  i:1
  50 Explain         50   10    0 SCAN SUBQUERY 1 AS a 00 
  51 Rewind           4  186    0               00 
  52 Explain         52   10    0 CORRELATED SCALAR SUBQUERY 3 00 
  53 Null             0   20   20               00 r[20..20]=NULL; Init subquery result
REG[20] =  NULL
  54 Integer         86   21    0               00 r[21]=86
REG[21] =  i:86
  55 Once             0   86    0               00 materialize "t4a"
  56 Explain         56   52    0 MATERIALIZE 1 00 
  57 OpenEphemeral    7    1    0               00 nColumn=1
  58 Noop            10    1    0               00 
  59 Integer          0   23    0               00 r[23]=0; clear abort flag
REG[23] =  i:0
  60 Null             0   26   26               00 r[26..26]=NULL
REG[26] =  NULL
  61 Gosub           25   84    0               00 
REG[25] =  i:61
  84 Integer          0   22    0               00 r[22]=0; indicate accumulator empty
REG[22] =  i:0
  85 Return          25    0    0               00 
REG[25] =  i:61
  62 Explain         62   56    0 SCAN CONSTANT ROW 00 
  63 Integer          1   28    0               00 r[28]=1
REG[28] =  i:1
  64 Ne              19   73   28 (BINARY)      50 if r[28]!=r[19] goto 73
REG[19] =  i:1
REG[28] =  i:1
  65 Integer          1   27    0               00 r[27]=1
REG[27] =  i:1
  66 Compare         26   27    1 k(1,B)        00 r[26] <-> r[27]
REG[26] =  NULL
REG[27] =  i:1
  67 Jump            68   72   68               00 
  68 Move            27   26    1               00 r[26]=r[27]
REG[26] =  i:1
  69 Gosub           24   77    0               00 output one row
REG[24] =  i:69
  77 IfPos           22   79    0               00 if r[22]>0 then r[22]-=0, goto 79; Groupby result generator entry point
REG[22] =  i:0
  78 Return          24    0    0               00 
REG[24] =  i:69
  70 IfPos           23   86    0               00 if r[23]>0 then r[23]-=0, goto 86; check abort flag
REG[23] =  i:0
  71 Gosub           25   84    0               00 reset accumulator
REG[25] =  i:71
  84 Integer          0   22    0               00 r[22]=0; indicate accumulator empty
REG[22] =  i:0
  85 Return          25    0    0               00 
REG[25] =  i:71
  72 Integer          1   22    0               00 r[22]=1; indicate data in accumulator
REG[22] =  i:1
  73 Gosub           24   77    0               00 output final row
REG[24] =  i:73
  77 IfPos           22   79    0               00 if r[22]>0 then r[22]-=0, goto 79; Groupby result generator entry point
REG[22] =  i:1
  79 Integer          1   29    0               00 r[29]=1
REG[29] =  i:1
  80 MakeRecord      29    1   28               00 r[28]=mkrec(r[29])
REG[28] =  sx2[0209|..]
  81 NewRowid         7   30    0               00 r[30]=rowid
REG[30] =  i:1
  82 Insert           7   28   30               08 intkey=r[30] data=r[28]
REG[28] =  sx2[0209|..]
REG[30] =  i:1
  83 Return          24    0    0               00 end groupby result generator
REG[24] =  i:73
  74 Goto             0   86    0               00 
  86 Return          21    0    0               00 end t4a
REG[21] =  i:86
  87 Integer        119   31    0               00 r[31]=119
REG[31] =  i:119
  88 Once             0  119    0               00 materialize "t4a"
  89 Explain         89   52    0 MATERIALIZE 1 00 
  90 OpenEphemeral    8    1    0               00 nColumn=1
  91 Noop            11    1    0               00 
  92 Integer          0   33    0               00 r[33]=0; clear abort flag
REG[33] =  i:0
  93 Null             0   36   36               00 r[36..36]=NULL
REG[36] =  NULL
  94 Gosub           35  117    0               00 
REG[35] =  i:94
 117 Integer          0   32    0               00 r[32]=0; indicate accumulator empty
REG[32] =  i:0
 118 Return          35    0    0               00 
REG[35] =  i:94
  95 Explain         95   89    0 SCAN CONSTANT ROW 00 
  96 Integer          1   38    0               00 r[38]=1
REG[38] =  i:1
  97 Ne              19  106   38 (BINARY)      50 if r[38]!=r[19] goto 106
REG[19] =  i:1
REG[38] =  i:1
  98 Integer          1   37    0               00 r[37]=1
REG[37] =  i:1
  99 Compare         36   37    1 k(1,B)        00 r[36] <-> r[37]
REG[36] =  NULL
REG[37] =  i:1
 100 Jump           101  105  101               00 
 101 Move            37   36    1               00 r[36]=r[37]
REG[36] =  i:1
 102 Gosub           34  110    0               00 output one row
REG[34] =  i:102
 110 IfPos           32  112    0               00 if r[32]>0 then r[32]-=0, goto 112; Groupby result generator entry point
REG[32] =  i:0
 111 Return          34    0    0               00 
REG[34] =  i:102
 103 IfPos           33  119    0               00 if r[33]>0 then r[33]-=0, goto 119; check abort flag
REG[33] =  i:0
 104 Gosub           35  117    0               00 reset accumulator
REG[35] =  i:104
 117 Integer          0   32    0               00 r[32]=0; indicate accumulator empty
REG[32] =  i:0
 118 Return          35    0    0               00 
REG[35] =  i:104
 105 Integer          1   32    0               00 r[32]=1; indicate data in accumulator
REG[32] =  i:1
 106 Gosub           34  110    0               00 output final row
REG[34] =  i:106
 110 IfPos           32  112    0               00 if r[32]>0 then r[32]-=0, goto 112; Groupby result generator entry point
REG[32] =  i:1
 112 Integer          1   39    0               00 r[39]=1
REG[39] =  i:1
 113 MakeRecord      39    1   38               00 r[38]=mkrec(r[39])
REG[38] =  sx2[0209|..]
 114 NewRowid         8   40    0               00 r[40]=rowid
REG[40] =  i:1
 115 Insert           8   38   40               08 intkey=r[40] data=r[38]
REG[38] =  sx2[0209|..]
REG[40] =  i:1
 116 Return          34    0    0               00 end groupby result generator
REG[34] =  i:106
 107 Goto             0  119    0               00 
 119 Return          31    0    0               00 end t4a
REG[31] =  i:119
 120 Integer          1   41    0               00 r[41]=1; LIMIT counter
REG[41] =  i:1
 121 Integer          1   42    0               00 r[42]=1
REG[42] =  i:1
 122 Ne              19  131   42 (BINARY)      50 if r[42]!=r[19] goto 131
REG[19] =  i:1
REG[42] =  i:1
 123 Explain        123   52    0 SCAN SUBQUERY 1 AS a 00 
 124 Rewind           7  131    0               00 
 125 Explain        125   52    0 SCAN SUBQUERY 1 AS b 00 
 126 Rewind           8  131    0               00 
 127 Integer          1   20    0               00 r[20]=1
REG[20] =  i:1
 128 DecrJumpZero    41  131    0               00 if (--r[41])==0 goto 131
REG[41] =  i:1
 131 IfNot           20  185    1               00 
REG[20] =  i:1
 132 Explain        132   10    0 SCAN SUBQUERY 1 AS b 00 
 133 Rewind           5  186    0               00 
 134 Explain        134   10    0 CORRELATED SCALAR SUBQUERY 3 00 
 135 Null             0   43   43               00 r[43..43]=NULL; Init subquery result
REG[43] =  NULL
 136 Integer        166   44    0               00 r[44]=166
REG[44] =  i:166
 137 Once             0  166    0               00 materialize "t4a"
 138 Explain        138  134    0 MATERIALIZE 1 00 
 139 OpenEphemeral    7    1    0               00 nColumn=1
 140 Noop            12    1    0               00 
 141 Integer          0   46    0               00 r[46]=0; clear abort flag
REG[46] =  i:0
 142 Null             0   49   49               00 r[49..49]=NULL
REG[49] =  NULL
 143 Gosub           48  164    0               00 
REG[48] =  i:143
 164 Integer          0   45    0               00 r[45]=0; indicate accumulator empty
REG[45] =  i:0
 165 Return          48    0    0               00 
REG[48] =  i:143
 144 Explain        144  138    0 SCAN CONSTANT ROW 00 
 145 Integer          1   50    0               00 r[50]=1
REG[50] =  i:1
 146 Compare         49   50    1 k(1,B)        00 r[49] <-> r[50]
REG[49] =  NULL
REG[50] =  i:1
 147 Jump           148  152  148               00 
 148 Move            50   49    1               00 r[49]=r[50]
REG[49] =  i:1
 149 Gosub           47  157    0               00 output one row
REG[47] =  i:149
 157 IfPos           45  159    0               00 if r[45]>0 then r[45]-=0, goto 159; Groupby result generator entry point
REG[45] =  i:0
 158 Return          47    0    0               00 
REG[47] =  i:149
 150 IfPos           46  166    0               00 if r[46]>0 then r[46]-=0, goto 166; check abort flag
REG[46] =  i:0
 151 Gosub           48  164    0               00 reset accumulator
REG[48] =  i:151
 164 Integer          0   45    0               00 r[45]=0; indicate accumulator empty
REG[45] =  i:0
 165 Return          48    0    0               00 
REG[48] =  i:151
 152 Integer          1   45    0               00 r[45]=1; indicate data in accumulator
REG[45] =  i:1
 153 Gosub           47  157    0               00 output final row
REG[47] =  i:153
 157 IfPos           45  159    0               00 if r[45]>0 then r[45]-=0, goto 159; Groupby result generator entry point
REG[45] =  i:1
 159 Integer          1   51    0               00 r[51]=1
REG[51] =  i:1
 160 MakeRecord      51    1   18               00 r[18]=mkrec(r[51])
REG[18] =  sx2[0209|..]
 161 NewRowid         7   42    0               00 r[42]=rowid
REG[42] =  i:1
 162 Insert           7   18   42               08 intkey=r[42] data=r[18]
REG[18] =  sx2[0209|..]
REG[42] =  i:1
 163 Return          47    0    0               00 end groupby result generator
REG[47] =  i:153
 154 Goto             0  166    0               00 
 166 Return          44    0    0               00 end t4a
REG[44] =  i:166
 167 Integer        170   52    0               00 r[52]=170
REG[52] =  i:170
 168 Once             0  170    0               00 materialize "t4a"
 169 OpenDup          8    7    0               00 
 170 Return          52    0    0               00 end t4a
REG[52] =  i:170
 171 Integer          1   53    0               00 r[53]=1; LIMIT counter
REG[53] =  i:1
 172 Copy             2   54    0               00 r[54]=r[2]; subquery_6.anoncol1
REG[54] =  i:1
 173 Ne              19  182   54 (BINARY)      50 if r[54]!=r[19] goto 182
REG[19] =  i:1
REG[54] =  i:1
 174 Explain        174  134    0 SCAN SUBQUERY 1 AS a 00 
 175 Rewind           7  182    0               00 
 176 Explain        176  134    0 SCAN SUBQUERY 1 AS b 00 
 177 Rewind           8  182    0               00 
 178 Integer          1   43    0               00 r[43]=1
REG[43] =  i:1
 179 DecrJumpZero    53  182    0               00 if (--r[53])==0 goto 182
REG[53] =  i:1
 182 Copy            43    5    0               00 r[5]=r[43]
REG[5] =  i:1
 183 DecrJumpZero    17  186    0               00 if (--r[17])==0 goto 186
REG[17] =  i:1
 186 Copy             5    3    0               00 r[3]=r[5]
REG[3] =  i:1
 187 Explain        187    0    0 CORRELATED SCALAR SUBQUERY 5 00 
 188 Null             0   55   55               00 r[55..55]=NULL; Init subquery result
REG[55] =  NULL
 189 Integer        219   56    0               00 r[56]=219
REG[56] =  i:219
 190 Once             0  219    0               00 materialize "t4a"
 191 Explain        191  187    0 MATERIALIZE 1 00 
 192 OpenEphemeral    4    1    0               00 nColumn=1
 193 Noop            13    1    0               00 
 194 Integer          0   58    0               00 r[58]=0; clear abort flag
REG[58] =  i:0
 195 Null             0   61   61               00 r[61..61]=NULL
REG[61] =  NULL
 196 Gosub           60  217    0               00 
REG[60] =  i:196
 217 Integer          0   57    0               00 r[57]=0; indicate accumulator empty
REG[57] =  i:0
 218 Return          60    0    0               00 
REG[60] =  i:196
 197 Explain        197  191    0 SCAN CONSTANT ROW 00 
 198 Integer          1   62    0               00 r[62]=1
REG[62] =  i:1
 199 Compare         61   62    1 k(1,B)        00 r[61] <-> r[62]
REG[61] =  NULL
REG[62] =  i:1
 200 Jump           201  205  201               00 
 201 Move            62   61    1               00 r[61]=r[62]
REG[61] =  i:1
 202 Gosub           59  210    0               00 output one row
REG[59] =  i:202
 210 IfPos           57  212    0               00 if r[57]>0 then r[57]-=0, goto 212; Groupby result generator entry point
REG[57] =  i:0
 211 Return          59    0    0               00 
REG[59] =  i:202
 203 IfPos           58  219    0               00 if r[58]>0 then r[58]-=0, goto 219; check abort flag
REG[58] =  i:0
 204 Gosub           60  217    0               00 reset accumulator
REG[60] =  i:204
 217 Integer          0   57    0               00 r[57]=0; indicate accumulator empty
REG[57] =  i:0
 218 Return          60    0    0               00 
REG[60] =  i:204
 205 Integer          1   57    0               00 r[57]=1; indicate data in accumulator
REG[57] =  i:1
 206 Gosub           59  210    0               00 output final row
REG[59] =  i:206
 210 IfPos           57  212    0               00 if r[57]>0 then r[57]-=0, goto 212; Groupby result generator entry point
REG[57] =  i:1
 212 Integer          1   63    0               00 r[63]=1
REG[63] =  i:1
 213 MakeRecord      63    1   54               00 r[54]=mkrec(r[63])
REG[54] =  sx2[0209|..]
 214 NewRowid         4   64    0               00 r[64]=rowid
REG[64] =  i:1
 215 Insert           4   54   64               08 intkey=r[64] data=r[54]
REG[54] =  sx2[0209|..]
REG[64] =  i:1
 216 Return          59    0    0               00 end groupby result generator
REG[59] =  i:206
 207 Goto             0  219    0               00 
 219 Return          56    0    0               00 end t4a
REG[56] =  i:219
 220 Integer        223   65    0               00 r[65]=223
REG[65] =  i:223
 221 Once             0  223    0               00 materialize "t4a"
 222 OpenDup          5    4    0               00 
 223 Return          65    0    0               00 end t4a
REG[65] =  i:223
 224 Integer          1   66    0               00 r[66]=1; LIMIT counter
REG[66] =  i:1
 225 Copy             2   67    0               00 r[67]=r[2]; subquery_6.anoncol1
REG[67] =  i:1
 226 Ne              19  363   67 (BINARY)      50 if r[67]!=r[19] goto 363
REG[19] =  i:1
REG[67] =  i:1
 227 Explain        227  187    0 SCAN SUBQUERY 1 AS a 00 
 228 Rewind           4  363    0               00 
 229 Explain        229  187    0 CORRELATED SCALAR SUBQUERY 3 00 
 230 Null             0   68   68               00 r[68..68]=NULL; Init subquery result
REG[68] =  NULL
 231 Integer        263   69    0               00 r[69]=263
REG[69] =  i:263
 232 Once             0  263    0               00 materialize "t4a"
 233 Explain        233  229    0 MATERIALIZE 1 00 
 234 OpenEphemeral    7    1    0               00 nColumn=1
 235 Noop            14    1    0               00 
 236 Integer          0   71    0               00 r[71]=0; clear abort flag
REG[71] =  i:0
 237 Null             0   74   74               00 r[74..74]=NULL
REG[74] =  NULL
 238 Gosub           73  261    0               00 
REG[73] =  i:238
 261 Integer          0   70    0               00 r[70]=0; indicate accumulator empty
REG[70] =  i:0
 262 Return          73    0    0               00 
REG[73] =  i:238
 239 Explain        239  233    0 SCAN CONSTANT ROW 00 
 240 Integer          1   76    0               00 r[76]=1
REG[76] =  i:1
 241 Ne              19  250   76 (BINARY)      50 if r[76]!=r[19] goto 250
REG[19] =  i:1
REG[76] =  i:1
 242 Integer          1   75    0               00 r[75]=1
REG[75] =  i:1
 243 Compare         74   75    1 k(1,B)        00 r[74] <-> r[75]
REG[74] =  NULL
REG[75] =  i:1
 244 Jump           245  249  245               00 
 245 Move            75   74    1               00 r[74]=r[75]
REG[74] =  i:1
 246 Gosub           72  254    0               00 output one row
REG[72] =  i:246
 254 IfPos           70  256    0               00 if r[70]>0 then r[70]-=0, goto 256; Groupby result generator entry point
REG[70] =  i:0
 255 Return          72    0    0               00 
REG[72] =  i:246
 247 IfPos           71  263    0               00 if r[71]>0 then r[71]-=0, goto 263; check abort flag
REG[71] =  i:0
 248 Gosub           73  261    0               00 reset accumulator
REG[73] =  i:248
 261 Integer          0   70    0               00 r[70]=0; indicate accumulator empty
REG[70] =  i:0
 262 Return          73    0    0               00 
REG[73] =  i:248
 249 Integer          1   70    0               00 r[70]=1; indicate data in accumulator
REG[70] =  i:1
 250 Gosub           72  254    0               00 output final row
REG[72] =  i:250
 254 IfPos           70  256    0               00 if r[70]>0 then r[70]-=0, goto 256; Groupby result generator entry point
REG[70] =  i:1
 256 Integer          1   77    0               00 r[77]=1
REG[77] =  i:1
 257 MakeRecord      77    1   76               00 r[76]=mkrec(r[77])
REG[76] =  sx2[0209|..]
 258 NewRowid         7   78    0               00 r[78]=rowid
REG[78] =  i:1
 259 Insert           7   76   78               08 intkey=r[78] data=r[76]
REG[76] =  sx2[0209|..]
REG[78] =  i:1
 260 Return          72    0    0               00 end groupby result generator
REG[72] =  i:250
 251 Goto             0  263    0               00 
 263 Return          69    0    0               00 end t4a
REG[69] =  i:263
 264 Integer        296   79    0               00 r[79]=296
REG[79] =  i:296
 265 Once             0  296    0               00 materialize "t4a"
 266 Explain        266  229    0 MATERIALIZE 1 00 
 267 OpenEphemeral    8    1    0               00 nColumn=1
 268 Noop            15    1    0               00 
 269 Integer          0   81    0               00 r[81]=0; clear abort flag
REG[81] =  i:0
 270 Null             0   84   84               00 r[84..84]=NULL
REG[84] =  NULL
 271 Gosub           83  294    0               00 
REG[83] =  i:271
 294 Integer          0   80    0               00 r[80]=0; indicate accumulator empty
REG[80] =  i:0
 295 Return          83    0    0               00 
REG[83] =  i:271
 272 Explain        272  266    0 SCAN CONSTANT ROW 00 
 273 Integer          1   86    0               00 r[86]=1
REG[86] =  i:1
 274 Ne              19  283   86 (BINARY)      50 if r[86]!=r[19] goto 283
REG[19] =  i:1
REG[86] =  i:1
 275 Integer          1   85    0               00 r[85]=1
REG[85] =  i:1
 276 Compare         84   85    1 k(1,B)        00 r[84] <-> r[85]
REG[84] =  NULL
REG[85] =  i:1
 277 Jump           278  282  278               00 
 278 Move            85   84    1               00 r[84]=r[85]
REG[84] =  i:1
 279 Gosub           82  287    0               00 output one row
REG[82] =  i:279
 287 IfPos           80  289    0               00 if r[80]>0 then r[80]-=0, goto 289; Groupby result generator entry point
REG[80] =  i:0
 288 Return          82    0    0               00 
REG[82] =  i:279
 280 IfPos           81  296    0               00 if r[81]>0 then r[81]-=0, goto 296; check abort flag
REG[81] =  i:0
 281 Gosub           83  294    0               00 reset accumulator
REG[83] =  i:281
 294 Integer          0   80    0               00 r[80]=0; indicate accumulator empty
REG[80] =  i:0
 295 Return          83    0    0               00 
REG[83] =  i:281
 282 Integer          1   80    0               00 r[80]=1; indicate data in accumulator
REG[80] =  i:1
 283 Gosub           82  287    0               00 output final row
REG[82] =  i:283
 287 IfPos           80  289    0               00 if r[80]>0 then r[80]-=0, goto 289; Groupby result generator entry point
REG[80] =  i:1
 289 Integer          1   87    0               00 r[87]=1
REG[87] =  i:1
 290 MakeRecord      87    1   86               00 r[86]=mkrec(r[87])
REG[86] =  sx2[0209|..]
 291 NewRowid         8   88    0               00 r[88]=rowid
REG[88] =  i:2
 292 Insert           8   86   88               08 intkey=r[88] data=r[86]
REG[86] =  sx2[0209|..]
REG[88] =  i:2
 293 Return          82    0    0               00 end groupby result generator
REG[82] =  i:283
 284 Goto             0  296    0               00 
 296 Return          79    0    0               00 end t4a
REG[79] =  i:296
 297 Integer          1   89    0               00 r[89]=1; LIMIT counter
REG[89] =  i:1
 298 Integer          1   90    0               00 r[90]=1
REG[90] =  i:1
 299 Ne              19  308   90 (BINARY)      50 if r[90]!=r[19] goto 308
REG[19] =  i:1
REG[90] =  i:1
 300 Explain        300  229    0 SCAN SUBQUERY 1 AS a 00 
 301 Rewind           7  308    0               00 
 302 Explain        302  229    0 SCAN SUBQUERY 1 AS b 00 
 303 Rewind           8  308    0               00 
 304 Integer          1   68    0               00 r[68]=1
REG[68] =  i:1
 305 DecrJumpZero    89  308    0               00 if (--r[89])==0 goto 308
REG[89] =  i:1
 308 IfNot           68  362    1               00 
REG[68] =  i:1
 309 Explain        309  187    0 SCAN SUBQUERY 1 AS b 00 
 310 Rewind           5  363    0               00 
 311 Explain        311  187    0 CORRELATED SCALAR SUBQUERY 3 00 
 312 Null             0   91   91               00 r[91..91]=NULL; Init subquery result
REG[91] =  NULL
 313 Integer        343   92    0               00 r[92]=343
REG[92] =  i:343
 314 Once             0  343    0               00 materialize "t4a"
 315 Explain        315  311    0 MATERIALIZE 1 00 
 316 OpenEphemeral    7    1    0               00 nColumn=1
 317 Noop            16    1    0               00 
 318 Integer          0   94    0               00 r[94]=0; clear abort flag
REG[94] =  i:0
 319 Null             0   97   97               00 r[97..97]=NULL
REG[97] =  NULL
 320 Gosub           96  341    0               00 
REG[96] =  i:320
 341 Integer          0   93    0               00 r[93]=0; indicate accumulator empty
REG[93] =  i:0
 342 Return          96    0    0               00 
REG[96] =  i:320
 321 Explain        321  315    0 SCAN CONSTANT ROW 00 
 322 Integer          1   98    0               00 r[98]=1
REG[98] =  i:1
 323 Compare         97   98    1 k(1,B)        00 r[97] <-> r[98]
REG[97] =  NULL
REG[98] =  i:1
 324 Jump           325  329  325               00 
 325 Move            98   97    1               00 r[97]=r[98]
REG[97] =  i:1
 326 Gosub           95  334    0               00 output one row
REG[95] =  i:326
 334 IfPos           93  336    0               00 if r[93]>0 then r[93]-=0, goto 336; Groupby result generator entry point
REG[93] =  i:0
 335 Return          95    0    0               00 
REG[95] =  i:326
 327 IfPos           94  343    0               00 if r[94]>0 then r[94]-=0, goto 343; check abort flag
REG[94] =  i:0
 328 Gosub           96  341    0               00 reset accumulator
REG[96] =  i:328
 341 Integer          0   93    0               00 r[93]=0; indicate accumulator empty
REG[93] =  i:0
 342 Return          96    0    0               00 
REG[96] =  i:328
 329 Integer          1   93    0               00 r[93]=1; indicate data in accumulator
REG[93] =  i:1
 330 Gosub           95  334    0               00 output final row
REG[95] =  i:330
 334 IfPos           93  336    0               00 if r[93]>0 then r[93]-=0, goto 336; Groupby result generator entry point
REG[93] =  i:1
 336 Integer          1   99    0               00 r[99]=1
REG[99] =  i:1
 337 MakeRecord      99    1   67               00 r[67]=mkrec(r[99])
REG[67] =  sx2[0209|..]
 338 NewRowid         7   90    0               00 r[90]=rowid
REG[90] =  i:1
 339 Insert           7   67   90               08 intkey=r[90] data=r[67]
REG[67] =  sx2[0209|..]
REG[90] =  i:1
 340 Return          95    0    0               00 end groupby result generator
REG[95] =  i:330
 331 Goto             0  343    0               00 
 343 Return          92    0    0               00 end t4a
REG[92] =  i:343
 344 Integer        347  100    0               00 r[100]=347
REG[100] =  i:347
 345 Once             0  347    0               00 materialize "t4a"
 346 OpenDup          8    7    0               00 
 347 Return         100    0    0               00 end t4a
REG[100] =  i:347
 348 Integer          1  101    0               00 r[101]=1; LIMIT counter
REG[101] =  i:1
 349 Copy             2  102    0               00 r[102]=r[2]; subquery_6.anoncol1
REG[102] =  i:1
 350 Ne              19  359  102 (BINARY)      50 if r[102]!=r[19] goto 359
REG[19] =  i:1
REG[102] =  i:1
 351 Explain        351  311    0 SCAN SUBQUERY 1 AS a 00 
 352 Rewind           7  359    0               00 
 353 Explain        353  311    0 SCAN SUBQUERY 1 AS b 00 
 354 Rewind           8  359    0               00 
 355 Integer          1   91    0               00 r[91]=1
REG[91] =  i:1
 356 DecrJumpZero   101  359    0               00 if (--r[101])==0 goto 359
REG[101] =  i:1
 359 Copy            91   55    0               00 r[55]=r[91]
REG[55] =  i:1
 360 DecrJumpZero    66  363    0               00 if (--r[66])==0 goto 363
REG[66] =  i:1
 363 Copy            55    4    0               00 r[4]=r[55]
REG[4] =  i:1
 364 ResultRow        3    2    0               00 output=r[3..4]
REG[3] =  i:1
REG[4] =  i:1
 365 Goto             0    9    0               00 
   9 Yield            1  366    0               00 next row of subquery_6
REG[1] =  i:5
REG[1] =  i:9
   6 EndCoroutine     1    0    0               00 
REG[1] =  i:9
 366 Halt             0    0    0               00 
SQL: [SELECT EXISTS (
    WITH RECURSIVE Table0 AS (
      WITH RECURSIVE Table0(Col0) AS (SELECT ALL 1  ) 
      SELECT ALL (
        WITH RECURSIVE Table0 AS (
          WITH RECURSIVE Table0 AS (
            WITH RECURSIVE Table0 AS (SELECT DISTINCT 1  GROUP BY 1  ) 
            SELECT DISTINCT * FROM Table0 NATURAL INNER JOIN Table0
            WHERE Col0 = 1  
          )
          SELECT ALL (SELECT DISTINCT * FROM Table0) FROM Table0 WHERE Col0 = 1
        ) 
        SELECT ALL * FROM Table0  NATURAL INNER JOIN  Table0      
      ) FROM Table0 ) 
      SELECT DISTINCT * FROM Table0  NATURAL INNER JOIN  Table0      
    );]
VDBE Trace:
   0 Init             0 1152    0               00 Start at 1152
1152 Integer          1   21    0               00 r[21]=1
REG[21] =  i:1
1153 Goto             0    1    0               00 
   1 Explain          1    0    0 SCAN CONSTANT ROW 00 
   2 Integer       1148    2    0               00 r[2]=1148; return address
REG[2] =  i:1148
   3 Once             0 1148    0               00 
   4 Explain          4    0    0 SCALAR SUBQUERY 8 00 
   5 Integer          0    3    0               00 r[3]=0; Init EXISTS result
REG[3] =  i:0
   6 Integer         15    4    0               00 r[4]=15
REG[4] =  i:15
   7 Once             0   15    0               00 materialize "Table0"
   8 Explain          8    4    0 MATERIALIZE 1 00 
   9 OpenEphemeral    2    1    0               00 nColumn=1
  10 Explain         10    8    0 SCAN CONSTANT ROW 00 
  11 Integer          1    5    0               00 r[5]=1
REG[5] =  i:1
  12 MakeRecord       5    1    6               00 r[6]=mkrec(r[5])
REG[6] =  sx2[0209|..]
  13 NewRowid         2    7    0               00 r[7]=rowid
REG[7] =  i:1
  14 Insert           2    6    7               08 intkey=r[7] data=r[6]
REG[6] =  sx2[0209|..]
REG[7] =  i:1
  15 Return           4    0    0               00 end Table0
REG[4] =  i:15
  16 Integer         19    8    0               00 r[8]=19
REG[8] =  i:19
  17 Once             0   19    0               00 materialize "Table0"
  18 OpenDup         17    2    0               00 
  19 Return           8    0    0               00 end Table0
REG[8] =  i:19
  20 Integer          1    9    0               00 r[9]=1; LIMIT counter
REG[9] =  i:1
  21 Explain         21    4    0 SCAN SUBQUERY 1 00 
  22 Rewind           2 1148    0               00 
  23 Explain         23    4    0 SCAN SUBQUERY 1 00 
  24 Rewind          17 1148    0               00 
  25 Explain         25    4    0 CORRELATED SCALAR SUBQUERY 6 00 
  26 Null             0   11   11               00 r[11..11]=NULL; Init subquery result
REG[11] =  NULL
  27 Integer        137   12    0               00 r[12]=137
REG[12] =  i:137
  28 Noop             0    0    0               00 materialize "Table0"
  29 Explain         29   25    0 MATERIALIZE 3 00 
  30 Integer         67   13    0               00 r[13]=67
REG[13] =  i:67
  31 Once             0   67    0               00 materialize "Table0"
  32 Explain         32   29    0 MATERIALIZE 2 00 
  33 OpenEphemeral    6    1    0               00 nColumn=1
  34 OpenEphemeral   32    0    0 k(1,B)        08 nColumn=0
  35 Noop            33    1    0               00 
  36 Integer          0   15    0               00 r[15]=0; clear abort flag
REG[15] =  i:0
  37 Null             0   18   18               00 r[18..18]=NULL
REG[18] =  NULL
  38 Gosub           17   64    0               00 
REG[17] =  i:38
  64 Integer          0   14    0               00 r[14]=0; indicate accumulator empty
REG[14] =  i:0
  65 Return          17    0    0               00 
REG[17] =  i:38
  39 Explain         39   32    0 SCAN CONSTANT ROW 00 
  40 Integer          1   20    0               00 r[20]=1
REG[20] =  i:1
  41 Ne              21   50   20 (BINARY)      50 if r[20]!=r[21] goto 50
REG[21] =  i:1
REG[20] =  i:1
  42 Integer          1   19    0               00 r[19]=1
REG[19] =  i:1
  43 Compare         18   19    1 k(1,B)        00 r[18] <-> r[19]
REG[18] =  NULL
REG[19] =  i:1
  44 Jump            45   49   45               00 
  45 Move            19   18    1               00 r[18]=r[19]
REG[18] =  i:1
  46 Gosub           16   54    0               00 output one row
REG[16] =  i:46
  54 IfPos           14   56    0               00 if r[14]>0 then r[14]-=0, goto 56; Groupby result generator entry point
REG[14] =  i:0
  55 Return          16    0    0               00 
REG[16] =  i:46
  47 IfPos           15   66    0               00 if r[15]>0 then r[15]-=0, goto 66; check abort flag
REG[15] =  i:0
  48 Gosub           17   64    0               00 reset accumulator
REG[17] =  i:48
  64 Integer          0   14    0               00 r[14]=0; indicate accumulator empty
REG[14] =  i:0
  65 Return          17    0    0               00 
REG[17] =  i:48
  49 Integer          1   14    0               00 r[14]=1; indicate data in accumulator
REG[14] =  i:1
  50 Gosub           16   54    0               00 output final row
REG[16] =  i:50
  54 IfPos           14   56    0               00 if r[14]>0 then r[14]-=0, goto 56; Groupby result generator entry point
REG[14] =  i:1
  56 Integer          1   22    0               00 r[22]=1
REG[22] =  i:1
  57 Found           32   55   22 1             00 key=r[22]
REG[22] =  i:1
  58 MakeRecord      22    1   20               00 r[20]=mkrec(r[22])
REG[20] =  sx2[0209|..]
  59 IdxInsert       32   20   22 1             10 key=r[20]
REG[20] =  sx2[0209|..]
  60 MakeRecord      22    1   20               00 r[20]=mkrec(r[22])
REG[20] =  sx2[0209|..]
  61 NewRowid         6   23    0               00 r[23]=rowid
REG[23] =  i:1
  62 Insert           6   20   23               08 intkey=r[23] data=r[20]
REG[20] =  sx2[0209|..]
REG[23] =  i:1
  63 Return          16    0    0               00 end groupby result generator
REG[16] =  i:50
  51 Goto             0   66    0               00 
  66 Explain         66   32    0 USE TEMP B-TREE FOR DISTINCT 00 
  67 Return          13    0    0               00 end Table0
REG[13] =  i:67
  68 Integer        105   24    0               00 r[24]=105
REG[24] =  i:105
  69 Once             0  105    0               00 materialize "Table0"
  70 Explain         70   29    0 MATERIALIZE 2 00 
  71 OpenEphemeral    7    1    0               00 nColumn=1
  72 OpenEphemeral   34    0    0 k(1,B)        08 nColumn=0
  73 Noop            35    1    0               00 
  74 Integer          0   26    0               00 r[26]=0; clear abort flag
REG[26] =  i:0
  75 Null             0   29   29               00 r[29..29]=NULL
REG[29] =  NULL
  76 Gosub           28  102    0               00 
REG[28] =  i:76
 102 Integer          0   25    0               00 r[25]=0; indicate accumulator empty
REG[25] =  i:0
 103 Return          28    0    0               00 
REG[28] =  i:76
  77 Explain         77   70    0 SCAN CONSTANT ROW 00 
  78 Integer          1   31    0               00 r[31]=1
REG[31] =  i:1
  79 Ne              21   88   31 (BINARY)      50 if r[31]!=r[21] goto 88
REG[21] =  i:1
REG[31] =  i:1
  80 Integer          1   30    0               00 r[30]=1
REG[30] =  i:1
  81 Compare         29   30    1 k(1,B)        00 r[29] <-> r[30]
REG[29] =  NULL
REG[30] =  i:1
  82 Jump            83   87   83               00 
  83 Move            30   29    1               00 r[29]=r[30]
REG[29] =  i:1
  84 Gosub           27   92    0               00 output one row
REG[27] =  i:84
  92 IfPos           25   94    0               00 if r[25]>0 then r[25]-=0, goto 94; Groupby result generator entry point
REG[25] =  i:0
  93 Return          27    0    0               00 
REG[27] =  i:84
  85 IfPos           26  104    0               00 if r[26]>0 then r[26]-=0, goto 104; check abort flag
REG[26] =  i:0
  86 Gosub           28  102    0               00 reset accumulator
REG[28] =  i:86
 102 Integer          0   25    0               00 r[25]=0; indicate accumulator empty
REG[25] =  i:0
 103 Return          28    0    0               00 
REG[28] =  i:86
  87 Integer          1   25    0               00 r[25]=1; indicate data in accumulator
REG[25] =  i:1
  88 Gosub           27   92    0               00 output final row
REG[27] =  i:88
  92 IfPos           25   94    0               00 if r[25]>0 then r[25]-=0, goto 94; Groupby result generator entry point
REG[25] =  i:1
  94 Integer          1   32    0               00 r[32]=1
REG[32] =  i:1
  95 Found           34   93   32 1             00 key=r[32]
REG[32] =  i:1
  96 MakeRecord      32    1   31               00 r[31]=mkrec(r[32])
REG[31] =  sx2[0209|..]
  97 IdxInsert       34   31   32 1             10 key=r[31]
REG[31] =  sx2[0209|..]
  98 MakeRecord      32    1   31               00 r[31]=mkrec(r[32])
REG[31] =  sx2[0209|..]
  99 NewRowid         7   33    0               00 r[33]=rowid
REG[33] =  i:1
 100 Insert           7   31   33               08 intkey=r[33] data=r[31]
REG[31] =  sx2[0209|..]
REG[33] =  i:1
 101 Return          27    0    0               00 end groupby result generator
REG[27] =  i:88
  89 Goto             0  104    0               00 
 104 Explain        104   70    0 USE TEMP B-TREE FOR DISTINCT 00 
 105 Return          24    0    0               00 end Table0
REG[24] =  i:105
 106 OpenEphemeral    5    1    0               00 nColumn=1
 107 OpenEphemeral   36    0    0 k(1,B)        08 nColumn=0
 108 Column           2    0   34               00 r[34]=Table0.Col0
REG[34] =  i:1
 109 Ne              21  136   34 (BINARY)      50 if r[34]!=r[21] goto 136
REG[21] =  i:1
REG[34] =  i:1
 110 Integer          1   34    0               00 r[34]=1
REG[34] =  i:1
 111 Ne              21  136   34 (BINARY)      50 if r[34]!=r[21] goto 136
REG[21] =  i:1
REG[34] =  i:1
 112 Explain        112   29    0 SCAN SUBQUERY 2 00 
 113 Rewind           6  136    0               00 
 114 Once             0  122    0               00 
 115 OpenAutoindex   37    2    0 k(2,B,)       00 nColumn=2; for Table0
 116 Rewind           7  122    0               00 
 117 Column           7    0   35               00 r[35]=Table0.1
REG[35] =  i:1
 118 Rowid            7   36    0               00 r[36]=rowid
REG[36] =  i:1
 119 MakeRecord      35    2   34               00 r[34]=mkrec(r[35..36])
REG[34] =  sx3[030909|...]
 120 IdxInsert       37   34    0               10 key=r[34]
REG[34] =  sx3[030909|...]
 121 Next             7  117    0               03 
 122 Explain        122   29    0 SEARCH SUBQUERY 2 USING AUTOMATIC COVERING INDEX (1=?) 00 
 123 Column           6    0   37               00 r[37]=Table0.1
REG[37] =  i:1
 124 IsNull          37  135    0               00 if r[37]==NULL goto 135
REG[37] =  i:1
 125 SeekGE          37  135   37 1             00 key=r[37]
REG[37] =  i:1
 126 IdxGT           37  135   37 1             00 key=r[37]
REG[37] =  i:1
 127 Column           6    0   38               00 r[38]=Table0.1
REG[38] =  i:1
 128 Found           36  134   38 1             00 key=r[38]
REG[38] =  i:1
 129 MakeRecord      38    1   34               00 r[34]=mkrec(r[38])
REG[34] =  sx2[0209|..]
 130 IdxInsert       36   34   38 1             10 key=r[34]
REG[34] =  sx2[0209|..]
 131 MakeRecord      38    1   34               00 r[34]=mkrec(r[38])
REG[34] =  sx2[0209|..]
 132 NewRowid         5   39    0               00 r[39]=rowid
REG[39] =  i:1
 133 Insert           5   34   39               08 intkey=r[39] data=r[34]
REG[34] =  sx2[0209|..]
REG[39] =  i:1
 134 Next            37  126    0               00 
 135 Next             6  114    0               01 
 136 Explain        136   29    0 USE TEMP B-TREE FOR DISTINCT 00 
 137 Return          12    0    0               00 end Table0
REG[12] =  i:137
 138 Integer        248   40    0               00 r[40]=248
REG[40] =  i:248
 139 Noop             0    0    0               00 materialize "Table0"
 140 Explain        140   25    0 MATERIALIZE 3 00 
 141 Integer        178   41    0               00 r[41]=178
REG[41] =  i:178
 142 Once             0  178    0               00 materialize "Table0"
 143 Explain        143  140    0 MATERIALIZE 2 00 
 144 OpenEphemeral   12    1    0               00 nColumn=1
 145 OpenEphemeral   38    0    0 k(1,B)        08 nColumn=0
 146 Noop            39    1    0               00 
 147 Integer          0   43    0               00 r[43]=0; clear abort flag
REG[43] =  i:0
 148 Null             0   46   46               00 r[46..46]=NULL
REG[46] =  NULL
 149 Gosub           45  175    0               00 
REG[45] =  i:149
 175 Integer          0   42    0               00 r[42]=0; indicate accumulator empty
REG[42] =  i:0
 176 Return          45    0    0               00 
REG[45] =  i:149
 150 Explain        150  143    0 SCAN CONSTANT ROW 00 
 151 Integer          1   48    0               00 r[48]=1
REG[48] =  i:1
 152 Ne              21  161   48 (BINARY)      50 if r[48]!=r[21] goto 161
REG[21] =  i:1
REG[48] =  i:1
 153 Integer          1   47    0               00 r[47]=1
REG[47] =  i:1
 154 Compare         46   47    1 k(1,B)        00 r[46] <-> r[47]
REG[46] =  NULL
REG[47] =  i:1
 155 Jump           156  160  156               00 
 156 Move            47   46    1               00 r[46]=r[47]
REG[46] =  i:1
 157 Gosub           44  165    0               00 output one row
REG[44] =  i:157
 165 IfPos           42  167    0               00 if r[42]>0 then r[42]-=0, goto 167; Groupby result generator entry point
REG[42] =  i:0
 166 Return          44    0    0               00 
REG[44] =  i:157
 158 IfPos           43  177    0               00 if r[43]>0 then r[43]-=0, goto 177; check abort flag
REG[43] =  i:0
 159 Gosub           45  175    0               00 reset accumulator
REG[45] =  i:159
 175 Integer          0   42    0               00 r[42]=0; indicate accumulator empty
REG[42] =  i:0
 176 Return          45    0    0               00 
REG[45] =  i:159
 160 Integer          1   42    0               00 r[42]=1; indicate data in accumulator
REG[42] =  i:1
 161 Gosub           44  165    0               00 output final row
REG[44] =  i:161
 165 IfPos           42  167    0               00 if r[42]>0 then r[42]-=0, goto 167; Groupby result generator entry point
REG[42] =  i:1
 167 Integer          1   49    0               00 r[49]=1
REG[49] =  i:1
 168 Found           38  166   49 1             00 key=r[49]
REG[49] =  i:1
 169 MakeRecord      49    1   48               00 r[48]=mkrec(r[49])
REG[48] =  sx2[0209|..]
 170 IdxInsert       38   48   49 1             10 key=r[48]
REG[48] =  sx2[0209|..]
 171 MakeRecord      49    1   48               00 r[48]=mkrec(r[49])
REG[48] =  sx2[0209|..]
 172 NewRowid        12   50    0               00 r[50]=rowid
REG[50] =  i:1
 173 Insert          12   48   50               08 intkey=r[50] data=r[48]
REG[48] =  sx2[0209|..]
REG[50] =  i:1
 174 Return          44    0    0               00 end groupby result generator
REG[44] =  i:161
 162 Goto             0  177    0               00 
 177 Explain        177  143    0 USE TEMP B-TREE FOR DISTINCT 00 
 178 Return          41    0    0               00 end Table0
REG[41] =  i:178
 179 Integer        216   51    0               00 r[51]=216
REG[51] =  i:216
 180 Once             0  216    0               00 materialize "Table0"
 181 Explain        181  140    0 MATERIALIZE 2 00 
 182 OpenEphemeral   13    1    0               00 nColumn=1
 183 OpenEphemeral   40    0    0 k(1,B)        08 nColumn=0
 184 Noop            41    1    0               00 
 185 Integer          0   53    0               00 r[53]=0; clear abort flag
REG[53] =  i:0
 186 Null             0   56   56               00 r[56..56]=NULL
REG[56] =  NULL
 187 Gosub           55  213    0               00 
REG[55] =  i:187
 213 Integer          0   52    0               00 r[52]=0; indicate accumulator empty
REG[52] =  i:0
 214 Return          55    0    0               00 
REG[55] =  i:187
 188 Explain        188  181    0 SCAN CONSTANT ROW 00 
 189 Integer          1   58    0               00 r[58]=1
REG[58] =  i:1
 190 Ne              21  199   58 (BINARY)      50 if r[58]!=r[21] goto 199
REG[21] =  i:1
REG[58] =  i:1
 191 Integer          1   57    0               00 r[57]=1
REG[57] =  i:1
 192 Compare         56   57    1 k(1,B)        00 r[56] <-> r[57]
REG[56] =  NULL
REG[57] =  i:1
 193 Jump           194  198  194               00 
 194 Move            57   56    1               00 r[56]=r[57]
REG[56] =  i:1
 195 Gosub           54  203    0               00 output one row
REG[54] =  i:195
 203 IfPos           52  205    0               00 if r[52]>0 then r[52]-=0, goto 205; Groupby result generator entry point
REG[52] =  i:0
 204 Return          54    0    0               00 
REG[54] =  i:195
 196 IfPos           53  215    0               00 if r[53]>0 then r[53]-=0, goto 215; check abort flag
REG[53] =  i:0
 197 Gosub           55  213    0               00 reset accumulator
REG[55] =  i:197
 213 Integer          0   52    0               00 r[52]=0; indicate accumulator empty
REG[52] =  i:0
 214 Return          55    0    0               00 
REG[55] =  i:197
 198 Integer          1   52    0               00 r[52]=1; indicate data in accumulator
REG[52] =  i:1
 199 Gosub           54  203    0               00 output final row
REG[54] =  i:199
 203 IfPos           52  205    0               00 if r[52]>0 then r[52]-=0, goto 205; Groupby result generator entry point
REG[52] =  i:1
 205 Integer          1   59    0               00 r[59]=1
REG[59] =  i:1
 206 Found           40  204   59 1             00 key=r[59]
REG[59] =  i:1
 207 MakeRecord      59    1   58               00 r[58]=mkrec(r[59])
REG[58] =  sx2[0209|..]
 208 IdxInsert       40   58   59 1             10 key=r[58]
REG[58] =  sx2[0209|..]
 209 MakeRecord      59    1   58               00 r[58]=mkrec(r[59])
REG[58] =  sx2[0209|..]
 210 NewRowid        13   60    0               00 r[60]=rowid
REG[60] =  i:1
 211 Insert          13   58   60               08 intkey=r[60] data=r[58]
REG[58] =  sx2[0209|..]
REG[60] =  i:1
 212 Return          54    0    0               00 end groupby result generator
REG[54] =  i:199
 200 Goto             0  215    0               00 
 215 Explain        215  181    0 USE TEMP B-TREE FOR DISTINCT 00 
 216 Return          51    0    0               00 end Table0
REG[51] =  i:216
 217 OpenEphemeral   11    1    0               00 nColumn=1
 218 OpenEphemeral   42    0    0 k(1,B)        08 nColumn=0
 219 Column           2    0   61               00 r[61]=Table0.Col0
REG[61] =  i:1
 220 Ne              21  247   61 (BINARY)      50 if r[61]!=r[21] goto 247
REG[21] =  i:1
REG[61] =  i:1
 221 Integer          1   61    0               00 r[61]=1
REG[61] =  i:1
 222 Ne              21  247   61 (BINARY)      50 if r[61]!=r[21] goto 247
REG[21] =  i:1
REG[61] =  i:1
 223 Explain        223  140    0 SCAN SUBQUERY 2 00 
 224 Rewind          12  247    0               00 
 225 Once             0  233    0               00 
 226 OpenAutoindex   43    2    0 k(2,B,)       00 nColumn=2; for Table0
 227 Rewind          13  233    0               00 
 228 Column          13    0   62               00 r[62]=Table0.1
REG[62] =  i:1
 229 Rowid           13   63    0               00 r[63]=rowid
REG[63] =  i:1
 230 MakeRecord      62    2   61               00 r[61]=mkrec(r[62..63])
REG[61] =  sx3[030909|...]
 231 IdxInsert       43   61    0               10 key=r[61]
REG[61] =  sx3[030909|...]
 232 Next            13  228    0               03 
 233 Explain        233  140    0 SEARCH SUBQUERY 2 USING AUTOMATIC COVERING INDEX (1=?) 00 
 234 Column          12    0   64               00 r[64]=Table0.1
REG[64] =  i:1
 235 IsNull          64  246    0               00 if r[64]==NULL goto 246
REG[64] =  i:1
 236 SeekGE          43  246   64 1             00 key=r[64]
REG[64] =  i:1
 237 IdxGT           43  246   64 1             00 key=r[64]
REG[64] =  i:1
 238 Column          12    0   65               00 r[65]=Table0.1
REG[65] =  i:1
 239 Found           42  245   65 1             00 key=r[65]
REG[65] =  i:1
 240 MakeRecord      65    1   61               00 r[61]=mkrec(r[65])
REG[61] =  sx2[0209|..]
 241 IdxInsert       42   61   65 1             10 key=r[61]
REG[61] =  sx2[0209|..]
 242 MakeRecord      65    1   61               00 r[61]=mkrec(r[65])
REG[61] =  sx2[0209|..]
 243 NewRowid        11   66    0               00 r[66]=rowid
REG[66] =  i:1
 244 Insert          11   61   66               08 intkey=r[66] data=r[61]
REG[61] =  sx2[0209|..]
REG[66] =  i:1
 245 Next            43  237    0               00 
 246 Next            12  225    0               01 
 247 Explain        247  140    0 USE TEMP B-TREE FOR DISTINCT 00 
 248 Return          40    0    0               00 end Table0
REG[40] =  i:248
 249 Integer          1   67    0               00 r[67]=1; LIMIT counter
REG[67] =  i:1
 250 Integer          1   68    0               00 r[68]=1
REG[68] =  i:1
 251 Ne              21  584   68 (BINARY)      50 if r[68]!=r[21] goto 584
REG[21] =  i:1
REG[68] =  i:1
 252 Column           2    0   68               00 r[68]=Table0.Col0
REG[68] =  i:1
 253 Ne              21  584   68 (BINARY)      50 if r[68]!=r[21] goto 584
REG[21] =  i:1
REG[68] =  i:1
 254 Explain        254   25    0 SCAN SUBQUERY 3 00 
 255 Rewind           5  584    0               00 
 256 Explain        256   25    0 CORRELATED SCALAR SUBQUERY 4 00 
 257 Null             0   69   69               00 r[69..69]=NULL; Init subquery result
REG[69] =  NULL
 258 InitCoroutine   70  363  259               00 Table0
 363 Integer          1   96    0               00 r[96]=1; LIMIT counter
REG[96] =  i:1
 364 OpenEphemeral   50    0    0 k(1,B)        08 nColumn=0
 365 Explain        365  256    0 SCAN SUBQUERY 3 00 
 366 InitCoroutine   70    0  259               00 
 367 Yield           70  374    0               00 next row of Table0
REG[70] =  i:258
REG[70] =  i:367
 259 Explain        259  256    0 CO-ROUTINE 3  00 
 260 Integer        297   71    0               00 r[71]=297
REG[71] =  i:297
 261 Once             0  297    0               00 materialize "Table0"
 262 Explain        262  259    0 MATERIALIZE 2 00 
 263 OpenEphemeral    9    1    0               00 nColumn=1
 264 OpenEphemeral   44    0    0 k(1,B)        08 nColumn=0
 265 Noop            45    1    0               00 
 266 Integer          0   73    0               00 r[73]=0; clear abort flag
REG[73] =  i:0
 267 Null             0   76   76               00 r[76..76]=NULL
REG[76] =  NULL
 268 Gosub           75  294    0               00 
REG[75] =  i:268
 294 Integer          0   72    0               00 r[72]=0; indicate accumulator empty
REG[72] =  i:0
 295 Return          75    0    0               00 
REG[75] =  i:268
 269 Explain        269  262    0 SCAN CONSTANT ROW 00 
 270 Integer          1   78    0               00 r[78]=1
REG[78] =  i:1
 271 Ne              21  280   78 (BINARY)      50 if r[78]!=r[21] goto 280
REG[21] =  i:1
REG[78] =  i:1
 272 Integer          1   77    0               00 r[77]=1
REG[77] =  i:1
 273 Compare         76   77    1 k(1,B)        00 r[76] <-> r[77]
REG[76] =  NULL
REG[77] =  i:1
 274 Jump           275  279  275               00 
 275 Move            77   76    1               00 r[76]=r[77]
REG[76] =  i:1
 276 Gosub           74  284    0               00 output one row
REG[74] =  i:276
 284 IfPos           72  286    0               00 if r[72]>0 then r[72]-=0, goto 286; Groupby result generator entry point
REG[72] =  i:0
 285 Return          74    0    0               00 
REG[74] =  i:276
 277 IfPos           73  296    0               00 if r[73]>0 then r[73]-=0, goto 296; check abort flag
REG[73] =  i:0
 278 Gosub           75  294    0               00 reset accumulator
REG[75] =  i:278
 294 Integer          0   72    0               00 r[72]=0; indicate accumulator empty
REG[72] =  i:0
 295 Return          75    0    0               00 
REG[75] =  i:278
 279 Integer          1   72    0               00 r[72]=1; indicate data in accumulator
REG[72] =  i:1
 280 Gosub           74  284    0               00 output final row
REG[74] =  i:280
 284 IfPos           72  286    0               00 if r[72]>0 then r[72]-=0, goto 286; Groupby result generator entry point
REG[72] =  i:1
 286 Integer          1   79    0               00 r[79]=1
REG[79] =  i:1
 287 Found           44  285   79 1             00 key=r[79]
REG[79] =  i:1
 288 MakeRecord      79    1   78               00 r[78]=mkrec(r[79])
REG[78] =  sx2[0209|..]
 289 IdxInsert       44   78   79 1             10 key=r[78]
REG[78] =  sx2[0209|..]
 290 MakeRecord      79    1   78               00 r[78]=mkrec(r[79])
REG[78] =  sx2[0209|..]
 291 NewRowid         9   80    0               00 r[80]=rowid
REG[80] =  i:1
 292 Insert           9   78   80               08 intkey=r[80] data=r[78]
REG[78] =  sx2[0209|..]
REG[80] =  i:1
 293 Return          74    0    0               00 end groupby result generator
REG[74] =  i:280
 281 Goto             0  296    0               00 
 296 Explain        296  262    0 USE TEMP B-TREE FOR DISTINCT 00 
 297 Return          71    0    0               00 end Table0
REG[71] =  i:297
 298 Integer        335   81    0               00 r[81]=335
REG[81] =  i:335
 299 Once             0  335    0               00 materialize "Table0"
 300 Explain        300  259    0 MATERIALIZE 2 00 
 301 OpenEphemeral   10    1    0               00 nColumn=1
 302 OpenEphemeral   46    0    0 k(1,B)        08 nColumn=0
 303 Noop            47    1    0               00 
 304 Integer          0   83    0               00 r[83]=0; clear abort flag
REG[83] =  i:0
 305 Null             0   86   86               00 r[86..86]=NULL
REG[86] =  NULL
 306 Gosub           85  332    0               00 
REG[85] =  i:306
 332 Integer          0   82    0               00 r[82]=0; indicate accumulator empty
REG[82] =  i:0
 333 Return          85    0    0               00 
REG[85] =  i:306
 307 Explain        307  300    0 SCAN CONSTANT ROW 00 
 308 Integer          1   88    0               00 r[88]=1
REG[88] =  i:1
 309 Ne              21  318   88 (BINARY)      50 if r[88]!=r[21] goto 318
REG[21] =  i:1
REG[88] =  i:1
 310 Integer          1   87    0               00 r[87]=1
REG[87] =  i:1
 311 Compare         86   87    1 k(1,B)        00 r[86] <-> r[87]
REG[86] =  NULL
REG[87] =  i:1
 312 Jump           313  317  313               00 
 313 Move            87   86    1               00 r[86]=r[87]
REG[86] =  i:1
 314 Gosub           84  322    0               00 output one row
REG[84] =  i:314
 322 IfPos           82  324    0               00 if r[82]>0 then r[82]-=0, goto 324; Groupby result generator entry point
REG[82] =  i:0
 323 Return          84    0    0               00 
REG[84] =  i:314
 315 IfPos           83  334    0               00 if r[83]>0 then r[83]-=0, goto 334; check abort flag
REG[83] =  i:0
 316 Gosub           85  332    0               00 reset accumulator
REG[85] =  i:316
 332 Integer          0   82    0               00 r[82]=0; indicate accumulator empty
REG[82] =  i:0
 333 Return          85    0    0               00 
REG[85] =  i:316
 317 Integer          1   82    0               00 r[82]=1; indicate data in accumulator
REG[82] =  i:1
 318 Gosub           84  322    0               00 output final row
REG[84] =  i:318
 322 IfPos           82  324    0               00 if r[82]>0 then r[82]-=0, goto 324; Groupby result generator entry point
REG[82] =  i:1
 324 Integer          1   89    0               00 r[89]=1
REG[89] =  i:1
 325 Found           46  323   89 1             00 key=r[89]
REG[89] =  i:1
 326 MakeRecord      89    1   88               00 r[88]=mkrec(r[89])
REG[88] =  sx2[0209|..]
 327 IdxInsert       46   88   89 1             10 key=r[88]
REG[88] =  sx2[0209|..]
 328 MakeRecord      89    1   88               00 r[88]=mkrec(r[89])
REG[88] =  sx2[0209|..]
 329 NewRowid        10   90    0               00 r[90]=rowid
REG[90] =  i:1
 330 Insert          10   88   90               08 intkey=r[90] data=r[88]
REG[88] =  sx2[0209|..]
REG[90] =  i:1
 331 Return          84    0    0               00 end groupby result generator
REG[84] =  i:318
 319 Goto             0  334    0               00 
 334 Explain        334  300    0 USE TEMP B-TREE FOR DISTINCT 00 
 335 Return          81    0    0               00 end Table0
REG[81] =  i:335
 336 OpenEphemeral   48    0    0 k(1,B)        08 nColumn=0
 337 Integer          1   91    0               00 r[91]=1
REG[91] =  i:1
 338 Ne              21  361   91 (BINARY)      50 if r[91]!=r[21] goto 361
REG[21] =  i:1
REG[91] =  i:1
 339 Explain        339  259    0 SCAN SUBQUERY 2 00 
 340 Rewind           9  361    0               00 
 341 Once             0  349    0               00 
 342 OpenAutoindex   49    2    0 k(2,B,)       00 nColumn=2; for Table0
 343 Rewind          10  349    0               00 
 344 Column          10    0   92               00 r[92]=Table0.1
REG[92] =  i:1
 345 Rowid           10   93    0               00 r[93]=rowid
REG[93] =  i:1
 346 MakeRecord      92    2   91               00 r[91]=mkrec(r[92..93])
REG[91] =  sx3[030909|...]
 347 IdxInsert       49   91    0               10 key=r[91]
REG[91] =  sx3[030909|...]
 348 Next            10  344    0               03 
 349 Explain        349  259    0 SEARCH SUBQUERY 2 USING AUTOMATIC COVERING INDEX (1=?) 00 
 350 Column           9    0   94               00 r[94]=Table0.1
REG[94] =  i:1
 351 IsNull          94  360    0               00 if r[94]==NULL goto 360
REG[94] =  i:1
 352 SeekGE          49  360   94 1             00 key=r[94]
REG[94] =  i:1
 353 IdxGT           49  360   94 1             00 key=r[94]
REG[94] =  i:1
 354 Column           9    0   95               00 r[95]=Table0.1
REG[95] =  i:1
 355 Found           48  359   95 1             00 key=r[95]
REG[95] =  i:1
 356 MakeRecord      95    1   91               00 r[91]=mkrec(r[95])
REG[91] =  sx2[0209|..]
 357 IdxInsert       48   91   95 1             10 key=r[91]
REG[91] =  sx2[0209|..]
 358 Yield           70    0    0               00 
REG[70] =  i:367
REG[70] =  i:358
 368 Copy            95   69    0               00 r[69]=r[95]; Table0.1
REG[69] =  i:1
 369 Found           50  373   69 1             00 key=r[69]
REG[69] =  i:1
 370 MakeRecord      69    1   97               00 r[97]=mkrec(r[69])
REG[97] =  sx2[0209|..]
 371 IdxInsert       50   97   69 1             10 key=r[97]
REG[97] =  sx2[0209|..]
 372 DecrJumpZero    96  374    0               00 if (--r[96])==0 goto 374
REG[96] =  i:1
 374 Explain        374  256    0 USE TEMP B-TREE FOR DISTINCT 00 
 375 Explain        375   25    0 CORRELATED SCALAR SUBQUERY 4 00 
 376 Null             0   98   98               00 r[98..98]=NULL; Init subquery result
REG[98] =  NULL
 377 InitCoroutine   99  482  378               00 Table0
 482 Integer          1  124    0               00 r[124]=1; LIMIT counter
REG[124] =  i:1
 483 OpenEphemeral   57    0    0 k(1,B)        08 nColumn=0
 484 Explain        484  375    0 SCAN SUBQUERY 3 00 
 485 InitCoroutine   99    0  378               00 
 486 Yield           99  493    0               00 next row of Table0
REG[99] =  i:377
REG[99] =  i:486
 378 Explain        378  375    0 CO-ROUTINE 3  00 
 379 Integer        416  100    0               00 r[100]=416
REG[100] =  i:416
 380 Once             0  416    0               00 materialize "Table0"
 381 Explain        381  378    0 MATERIALIZE 2 00 
 382 OpenEphemeral   15    1    0               00 nColumn=1
 383 OpenEphemeral   51    0    0 k(1,B)        08 nColumn=0
 384 Noop            52    1    0               00 
 385 Integer          0  102    0               00 r[102]=0; clear abort flag
REG[102] =  i:0
 386 Null             0  105  105               00 r[105..105]=NULL
REG[105] =  NULL
 387 Gosub          104  413    0               00 
REG[104] =  i:387
 413 Integer          0  101    0               00 r[101]=0; indicate accumulator empty
REG[101] =  i:0
 414 Return         104    0    0               00 
REG[104] =  i:387
 388 Explain        388  381    0 SCAN CONSTANT ROW 00 
 389 Integer          1   97    0               00 r[97]=1
REG[97] =  i:1
 390 Ne              21  399   97 (BINARY)      50 if r[97]!=r[21] goto 399
REG[21] =  i:1
REG[97] =  i:1
 391 Integer          1  106    0               00 r[106]=1
REG[106] =  i:1
 392 Compare        105  106    1 k(1,B)        00 r[105] <-> r[106]
REG[105] =  NULL
REG[106] =  i:1
 393 Jump           394  398  394               00 
 394 Move           106  105    1               00 r[105]=r[106]
REG[105] =  i:1
 395 Gosub          103  403    0               00 output one row
REG[103] =  i:395
 403 IfPos          101  405    0               00 if r[101]>0 then r[101]-=0, goto 405; Groupby result generator entry point
REG[101] =  i:0
 404 Return         103    0    0               00 
REG[103] =  i:395
 396 IfPos          102  415    0               00 if r[102]>0 then r[102]-=0, goto 415; check abort flag
REG[102] =  i:0
 397 Gosub          104  413    0               00 reset accumulator
REG[104] =  i:397
 413 Integer          0  101    0               00 r[101]=0; indicate accumulator empty
REG[101] =  i:0
 414 Return         104    0    0               00 
REG[104] =  i:397
 398 Integer          1  101    0               00 r[101]=1; indicate data in accumulator
REG[101] =  i:1
 399 Gosub          103  403    0               00 output final row
REG[103] =  i:399
 403 IfPos          101  405    0               00 if r[101]>0 then r[101]-=0, goto 405; Groupby result generator entry point
REG[101] =  i:1
 405 Integer          1  107    0               00 r[107]=1
REG[107] =  i:1
 406 Found           51  404  107 1             00 key=r[107]
REG[107] =  i:1
 407 MakeRecord     107    1   97               00 r[97]=mkrec(r[107])
REG[97] =  sx2[0209|..]
 408 IdxInsert       51   97  107 1             10 key=r[97]
REG[97] =  sx2[0209|..]
 409 MakeRecord     107    1   97               00 r[97]=mkrec(r[107])
REG[97] =  sx2[0209|..]
 410 NewRowid        15  108    0               00 r[108]=rowid
REG[108] =  i:1
 411 Insert          15   97  108               08 intkey=r[108] data=r[97]
REG[97] =  sx2[0209|..]
REG[108] =  i:1
 412 Return         103    0    0               00 end groupby result generator
REG[103] =  i:399
 400 Goto             0  415    0               00 
 415 Explain        415  381    0 USE TEMP B-TREE FOR DISTINCT 00 
 416 Return         100    0    0               00 end Table0
REG[100] =  i:416
 417 Integer        454  109    0               00 r[109]=454
REG[109] =  i:454
 418 Once             0  454    0               00 materialize "Table0"
 419 Explain        419  378    0 MATERIALIZE 2 00 
 420 OpenEphemeral   16    1    0               00 nColumn=1
 421 OpenEphemeral   53    0    0 k(1,B)        08 nColumn=0
 422 Noop            54    1    0               00 
 423 Integer          0  111    0               00 r[111]=0; clear abort flag
REG[111] =  i:0
 424 Null             0  114  114               00 r[114..114]=NULL
REG[114] =  NULL
 425 Gosub          113  451    0               00 
REG[113] =  i:425
 451 Integer          0  110    0               00 r[110]=0; indicate accumulator empty
REG[110] =  i:0
 452 Return         113    0    0               00 
REG[113] =  i:425
 426 Explain        426  419    0 SCAN CONSTANT ROW 00 
 427 Integer          1  116    0               00 r[116]=1
REG[116] =  i:1
 428 Ne              21  437  116 (BINARY)      50 if r[116]!=r[21] goto 437
REG[21] =  i:1
REG[116] =  i:1
 429 Integer          1  115    0               00 r[115]=1
REG[115] =  i:1
 430 Compare        114  115    1 k(1,B)        00 r[114] <-> r[115]
REG[114] =  NULL
REG[115] =  i:1
 431 Jump           432  436  432               00 
 432 Move           115  114    1               00 r[114]=r[115]
REG[114] =  i:1
 433 Gosub          112  441    0               00 output one row
REG[112] =  i:433
 441 IfPos          110  443    0               00 if r[110]>0 then r[110]-=0, goto 443; Groupby result generator entry point
REG[110] =  i:0
 442 Return         112    0    0               00 
REG[112] =  i:433
 434 IfPos          111  453    0               00 if r[111]>0 then r[111]-=0, goto 453; check abort flag
REG[111] =  i:0
 435 Gosub          113  451    0               00 reset accumulator
REG[113] =  i:435
 451 Integer          0  110    0               00 r[110]=0; indicate accumulator empty
REG[110] =  i:0
 452 Return         113    0    0               00 
REG[113] =  i:435
 436 Integer          1  110    0               00 r[110]=1; indicate data in accumulator
REG[110] =  i:1
 437 Gosub          112  441    0               00 output final row
REG[112] =  i:437
 441 IfPos          110  443    0               00 if r[110]>0 then r[110]-=0, goto 443; Groupby result generator entry point
REG[110] =  i:1
 443 Integer          1  117    0               00 r[117]=1
REG[117] =  i:1
 444 Found           53  442  117 1             00 key=r[117]
REG[117] =  i:1
 445 MakeRecord     117    1  116               00 r[116]=mkrec(r[117])
REG[116] =  sx2[0209|..]
 446 IdxInsert       53  116  117 1             10 key=r[116]
REG[116] =  sx2[0209|..]
 447 MakeRecord     117    1  116               00 r[116]=mkrec(r[117])
REG[116] =  sx2[0209|..]
 448 NewRowid        16  118    0               00 r[118]=rowid
REG[118] =  i:1
 449 Insert          16  116  118               08 intkey=r[118] data=r[116]
REG[116] =  sx2[0209|..]
REG[118] =  i:1
 450 Return         112    0    0               00 end groupby result generator
REG[112] =  i:437
 438 Goto             0  453    0               00 
 453 Explain        453  419    0 USE TEMP B-TREE FOR DISTINCT 00 
 454 Return         109    0    0               00 end Table0
REG[109] =  i:454
 455 OpenEphemeral   55    0    0 k(1,B)        08 nColumn=0
 456 Integer          1  119    0               00 r[119]=1
REG[119] =  i:1
 457 Ne              21  480  119 (BINARY)      50 if r[119]!=r[21] goto 480
REG[21] =  i:1
REG[119] =  i:1
 458 Explain        458  378    0 SCAN SUBQUERY 2 00 
 459 Rewind          15  480    0               00 
 460 Once             0  468    0               00 
 461 OpenAutoindex   56    2    0 k(2,B,)       00 nColumn=2; for Table0
 462 Rewind          16  468    0               00 
 463 Column          16    0  120               00 r[120]=Table0.1
REG[120] =  i:1
 464 Rowid           16  121    0               00 r[121]=rowid
REG[121] =  i:1
 465 MakeRecord     120    2  119               00 r[119]=mkrec(r[120..121])
REG[119] =  sx3[030909|...]
 466 IdxInsert       56  119    0               10 key=r[119]
REG[119] =  sx3[030909|...]
 467 Next            16  463    0               03 
 468 Explain        468  378    0 SEARCH SUBQUERY 2 USING AUTOMATIC COVERING INDEX (1=?) 00 
 469 Column          15    0  122               00 r[122]=Table0.1
REG[122] =  i:1
 470 IsNull         122  479    0               00 if r[122]==NULL goto 479
REG[122] =  i:1
 471 SeekGE          56  479  122 1             00 key=r[122]
REG[122] =  i:1
 472 IdxGT           56  479  122 1             00 key=r[122]
REG[122] =  i:1
 473 Column          15    0  123               00 r[123]=Table0.1
REG[123] =  i:1
 474 Found           55  478  123 1             00 key=r[123]
REG[123] =  i:1
 475 MakeRecord     123    1  119               00 r[119]=mkrec(r[123])
REG[119] =  sx2[0209|..]
 476 IdxInsert       55  119  123 1             10 key=r[119]
REG[119] =  sx2[0209|..]
 477 Yield           99    0    0               00 
REG[99] =  i:486
REG[99] =  i:477
 487 Copy           123   98    0               00 r[98]=r[123]; Table0.1
REG[98] =  i:1
 488 Found           57  492   98 1             00 key=r[98]
REG[98] =  i:1
 489 MakeRecord      98    1  125               00 r[125]=mkrec(r[98])
REG[125] =  sx2[0209|..]
 490 IdxInsert       57  125   98 1             10 key=r[125]
REG[125] =  sx2[0209|..]
 491 DecrJumpZero   124  493    0               00 if (--r[124])==0 goto 493
REG[124] =  i:1
 493 Explain        493  375    0 USE TEMP B-TREE FOR DISTINCT 00 
 494 Ne              98  583   69 (BINARY)      50 if r[69]!=r[98] goto 583
REG[98] =  i:1
REG[69] =  i:1
 495 Explain        495   25    0 SCAN SUBQUERY 3 00 
 496 Rewind          11  584    0               00 
 497 Explain        497   25    0 CORRELATED SCALAR SUBQUERY 4 00 
 498 Null             0  126  126               00 r[126..126]=NULL; Init subquery result
REG[126] =  NULL
 499 InitCoroutine  127  568  500               00 Table0
 568 Integer          1  142    0               00 r[142]=1; LIMIT counter
REG[142] =  i:1
 569 OpenEphemeral   62    0    0 k(1,B)        08 nColumn=0
 570 Explain        570  497    0 SCAN SUBQUERY 3 00 
 571 InitCoroutine  127    0  500               00 
 572 Yield          127  579    0               00 next row of Table0
REG[127] =  i:499
REG[127] =  i:572
 500 Explain        500  497    0 CO-ROUTINE 3  00 
 501 Integer        536  128    0               00 r[128]=536
REG[128] =  i:536
 502 Once             0  536    0               00 materialize "Table0"
 503 Explain        503  500    0 MATERIALIZE 2 00 
 504 OpenEphemeral    9    1    0               00 nColumn=1
 505 OpenEphemeral   58    0    0 k(1,B)        08 nColumn=0
 506 Noop            59    1    0               00 
 507 Integer          0  130    0               00 r[130]=0; clear abort flag
REG[130] =  i:0
 508 Null             0  133  133               00 r[133..133]=NULL
REG[133] =  NULL
 509 Gosub          132  533    0               00 
REG[132] =  i:509
 533 Integer          0  129    0               00 r[129]=0; indicate accumulator empty
REG[129] =  i:0
 534 Return         132    0    0               00 
REG[132] =  i:509
 510 Explain        510  503    0 SCAN CONSTANT ROW 00 
 511 Integer          1  134    0               00 r[134]=1
REG[134] =  i:1
 512 Compare        133  134    1 k(1,B)        00 r[133] <-> r[134]
REG[133] =  NULL
REG[134] =  i:1
 513 Jump           514  518  514               00 
 514 Move           134  133    1               00 r[133]=r[134]
REG[133] =  i:1
 515 Gosub          131  523    0               00 output one row
REG[131] =  i:515
 523 IfPos          129  525    0               00 if r[129]>0 then r[129]-=0, goto 525; Groupby result generator entry point
REG[129] =  i:0
 524 Return         131    0    0               00 
REG[131] =  i:515
 516 IfPos          130  535    0               00 if r[130]>0 then r[130]-=0, goto 535; check abort flag
REG[130] =  i:0
 517 Gosub          132  533    0               00 reset accumulator
REG[132] =  i:517
 533 Integer          0  129    0               00 r[129]=0; indicate accumulator empty
REG[129] =  i:0
 534 Return         132    0    0               00 
REG[132] =  i:517
 518 Integer          1  129    0               00 r[129]=1; indicate data in accumulator
REG[129] =  i:1
 519 Gosub          131  523    0               00 output final row
REG[131] =  i:519
 523 IfPos          129  525    0               00 if r[129]>0 then r[129]-=0, goto 525; Groupby result generator entry point
REG[129] =  i:1
 525 Integer          1  135    0               00 r[135]=1
REG[135] =  i:1
 526 Found           58  524  135 1             00 key=r[135]
REG[135] =  i:1
 527 MakeRecord     135    1   68               00 r[68]=mkrec(r[135])
REG[68] =  sx2[0209|..]
 528 IdxInsert       58   68  135 1             10 key=r[68]
REG[68] =  sx2[0209|..]
 529 MakeRecord     135    1   68               00 r[68]=mkrec(r[135])
REG[68] =  sx2[0209|..]
 530 NewRowid         9  125    0               00 r[125]=rowid
REG[125] =  i:1
 531 Insert           9   68  125               08 intkey=r[125] data=r[68]
REG[68] =  sx2[0209|..]
REG[125] =  i:1
 532 Return         131    0    0               00 end groupby result generator
REG[131] =  i:519
 520 Goto             0  535    0               00 
 535 Explain        535  503    0 USE TEMP B-TREE FOR DISTINCT 00 
 536 Return         128    0    0               00 end Table0
REG[128] =  i:536
 537 Integer        540  136    0               00 r[136]=540
REG[136] =  i:540
 538 Once             0  540    0               00 materialize "Table0"
 539 OpenDup         10    9    0               00 
 540 Return         136    0    0               00 end Table0
REG[136] =  i:540
 541 OpenEphemeral   60    0    0 k(1,B)        08 nColumn=0
 542 Column           2    0  137               00 r[137]=Table0.Col0
REG[137] =  i:1
 543 Ne              21  566  137 (BINARY)      50 if r[137]!=r[21] goto 566
REG[21] =  i:1
REG[137] =  i:1
 544 Explain        544  500    0 SCAN SUBQUERY 2 00 
 545 Rewind           9  566    0               00 
 546 Once             0  554    0               00 
 547 OpenAutoindex   61    2    0 k(2,B,)       00 nColumn=2; for Table0
 548 Rewind          10  554    0               00 
 549 Column          10    0  138               00 r[138]=Table0.1
REG[138] =  i:1
 550 Rowid           10  139    0               00 r[139]=rowid
REG[139] =  i:1
 551 MakeRecord     138    2  137               00 r[137]=mkrec(r[138..139])
REG[137] =  sx3[030909|...]
 552 IdxInsert       61  137    0               10 key=r[137]
REG[137] =  sx3[030909|...]
 553 Next            10  549    0               03 
 554 Explain        554  500    0 SEARCH SUBQUERY 2 USING AUTOMATIC COVERING INDEX (1=?) 00 
 555 Column           9    0  140               00 r[140]=Table0.1
REG[140] =  i:1
 556 IsNull         140  565    0               00 if r[140]==NULL goto 565
REG[140] =  i:1
 557 SeekGE          61  565  140 1             00 key=r[140]
REG[140] =  i:1
 558 IdxGT           61  565  140 1             00 key=r[140]
REG[140] =  i:1
 559 Column           9    0  141               00 r[141]=Table0.1
REG[141] =  i:1
 560 Found           60  564  141 1             00 key=r[141]
REG[141] =  i:1
 561 MakeRecord     141    1  137               00 r[137]=mkrec(r[141])
REG[137] =  sx2[0209|..]
 562 IdxInsert       60  137  141 1             10 key=r[137]
REG[137] =  sx2[0209|..]
 563 Yield          127    0    0               00 
REG[127] =  i:572
REG[127] =  i:563
 573 Copy           141  126    0               00 r[126]=r[141]; Table0.1
REG[126] =  i:1
 574 Found           62  578  126 1             00 key=r[126]
REG[126] =  i:1
 575 MakeRecord     126    1  143               00 r[143]=mkrec(r[126])
REG[143] =  sx2[0209|..]
 576 IdxInsert       62  143  126 1             10 key=r[143]
REG[143] =  sx2[0209|..]
 577 DecrJumpZero   142  579    0               00 if (--r[142])==0 goto 579
REG[142] =  i:1
 579 Explain        579  497    0 USE TEMP B-TREE FOR DISTINCT 00 
 580 Copy           126   11    0               00 r[11]=r[126]
REG[11] =  i:1
 581 DecrJumpZero    67  584    0               00 if (--r[67])==0 goto 584
REG[67] =  i:1
 584 Explain        584    4    0 CORRELATED SCALAR SUBQUERY 6 00 
 585 Null             0  144  144               00 r[144..144]=NULL; Init subquery result
REG[144] =  NULL
 586 Integer        696  145    0               00 r[145]=696
REG[145] =  i:696
 587 Noop             0    0    0               00 materialize "Table0"
 588 Explain        588  584    0 MATERIALIZE 3 00 
 589 Integer        626  146    0               00 r[146]=626
REG[146] =  i:626
 590 Once             0  626    0               00 materialize "Table0"
 591 Explain        591  588    0 MATERIALIZE 2 00 
 592 OpenEphemeral   21    1    0               00 nColumn=1
 593 OpenEphemeral   63    0    0 k(1,B)        08 nColumn=0
 594 Noop            64    1    0               00 
 595 Integer          0  148    0               00 r[148]=0; clear abort flag
REG[148] =  i:0
 596 Null             0  151  151               00 r[151..151]=NULL
REG[151] =  NULL
 597 Gosub          150  623    0               00 
REG[150] =  i:597
 623 Integer          0  147    0               00 r[147]=0; indicate accumulator empty
REG[147] =  i:0
 624 Return         150    0    0               00 
REG[150] =  i:597
 598 Explain        598  591    0 SCAN CONSTANT ROW 00 
 599 Integer          1  143    0               00 r[143]=1
REG[143] =  i:1
 600 Ne              21  609  143 (BINARY)      50 if r[143]!=r[21] goto 609
REG[21] =  i:1
REG[143] =  i:1
 601 Integer          1  152    0               00 r[152]=1
REG[152] =  i:1
 602 Compare        151  152    1 k(1,B)        00 r[151] <-> r[152]
REG[151] =  NULL
REG[152] =  i:1
 603 Jump           604  608  604               00 
 604 Move           152  151    1               00 r[151]=r[152]
REG[151] =  i:1
 605 Gosub          149  613    0               00 output one row
REG[149] =  i:605
 613 IfPos          147  615    0               00 if r[147]>0 then r[147]-=0, goto 615; Groupby result generator entry point
REG[147] =  i:0
 614 Return         149    0    0               00 
REG[149] =  i:605
 606 IfPos          148  625    0               00 if r[148]>0 then r[148]-=0, goto 625; check abort flag
REG[148] =  i:0
 607 Gosub          150  623    0               00 reset accumulator
REG[150] =  i:607
 623 Integer          0  147    0               00 r[147]=0; indicate accumulator empty
REG[147] =  i:0
 624 Return         150    0    0               00 
REG[150] =  i:607
 608 Integer          1  147    0               00 r[147]=1; indicate data in accumulator
REG[147] =  i:1
 609 Gosub          149  613    0               00 output final row
REG[149] =  i:609
 613 IfPos          147  615    0               00 if r[147]>0 then r[147]-=0, goto 615; Groupby result generator entry point
REG[147] =  i:1
 615 Integer          1  153    0               00 r[153]=1
REG[153] =  i:1
 616 Found           63  614  153 1             00 key=r[153]
REG[153] =  i:1
 617 MakeRecord     153    1  143               00 r[143]=mkrec(r[153])
REG[143] =  sx2[0209|..]
 618 IdxInsert       63  143  153 1             10 key=r[143]
REG[143] =  sx2[0209|..]
 619 MakeRecord     153    1  143               00 r[143]=mkrec(r[153])
REG[143] =  sx2[0209|..]
 620 NewRowid        21  154    0               00 r[154]=rowid
REG[154] =  i:1
 621 Insert          21  143  154               08 intkey=r[154] data=r[143]
REG[143] =  sx2[0209|..]
REG[154] =  i:1
 622 Return         149    0    0               00 end groupby result generator
REG[149] =  i:609
 610 Goto             0  625    0               00 
 625 Explain        625  591    0 USE TEMP B-TREE FOR DISTINCT 00 
 626 Return         146    0    0               00 end Table0
REG[146] =  i:626
 627 Integer        664  155    0               00 r[155]=664
REG[155] =  i:664
 628 Once             0  664    0               00 materialize "Table0"
 629 Explain        629  588    0 MATERIALIZE 2 00 
 630 OpenEphemeral   22    1    0               00 nColumn=1
 631 OpenEphemeral   65    0    0 k(1,B)        08 nColumn=0
 632 Noop            66    1    0               00 
 633 Integer          0  157    0               00 r[157]=0; clear abort flag
REG[157] =  i:0
 634 Null             0  160  160               00 r[160..160]=NULL
REG[160] =  NULL
 635 Gosub          159  661    0               00 
REG[159] =  i:635
 661 Integer          0  156    0               00 r[156]=0; indicate accumulator empty
REG[156] =  i:0
 662 Return         159    0    0               00 
REG[159] =  i:635
 636 Explain        636  629    0 SCAN CONSTANT ROW 00 
 637 Integer          1  162    0               00 r[162]=1
REG[162] =  i:1
 638 Ne              21  647  162 (BINARY)      50 if r[162]!=r[21] goto 647
REG[21] =  i:1
REG[162] =  i:1
 639 Integer          1  161    0               00 r[161]=1
REG[161] =  i:1
 640 Compare        160  161    1 k(1,B)        00 r[160] <-> r[161]
REG[160] =  NULL
REG[161] =  i:1
 641 Jump           642  646  642               00 
 642 Move           161  160    1               00 r[160]=r[161]
REG[160] =  i:1
 643 Gosub          158  651    0               00 output one row
REG[158] =  i:643
 651 IfPos          156  653    0               00 if r[156]>0 then r[156]-=0, goto 653; Groupby result generator entry point
REG[156] =  i:0
 652 Return         158    0    0               00 
REG[158] =  i:643
 644 IfPos          157  663    0               00 if r[157]>0 then r[157]-=0, goto 663; check abort flag
REG[157] =  i:0
 645 Gosub          159  661    0               00 reset accumulator
REG[159] =  i:645
 661 Integer          0  156    0               00 r[156]=0; indicate accumulator empty
REG[156] =  i:0
 662 Return         159    0    0               00 
REG[159] =  i:645
 646 Integer          1  156    0               00 r[156]=1; indicate data in accumulator
REG[156] =  i:1
 647 Gosub          158  651    0               00 output final row
REG[158] =  i:647
 651 IfPos          156  653    0               00 if r[156]>0 then r[156]-=0, goto 653; Groupby result generator entry point
REG[156] =  i:1
 653 Integer          1  163    0               00 r[163]=1
REG[163] =  i:1
 654 Found           65  652  163 1             00 key=r[163]
REG[163] =  i:1
 655 MakeRecord     163    1  162               00 r[162]=mkrec(r[163])
REG[162] =  sx2[0209|..]
 656 IdxInsert       65  162  163 1             10 key=r[162]
REG[162] =  sx2[0209|..]
 657 MakeRecord     163    1  162               00 r[162]=mkrec(r[163])
REG[162] =  sx2[0209|..]
 658 NewRowid        22  164    0               00 r[164]=rowid
REG[164] =  i:1
 659 Insert          22  162  164               08 intkey=r[164] data=r[162]
REG[162] =  sx2[0209|..]
REG[164] =  i:1
 660 Return         158    0    0               00 end groupby result generator
REG[158] =  i:647
 648 Goto             0  663    0               00 
 663 Explain        663  629    0 USE TEMP B-TREE FOR DISTINCT 00 
 664 Return         155    0    0               00 end Table0
REG[155] =  i:664
 665 OpenEphemeral   20    1    0               00 nColumn=1
 666 OpenEphemeral   67    0    0 k(1,B)        08 nColumn=0
 667 Column          17    0  165               00 r[165]=Table0.Col0
REG[165] =  i:1
 668 Ne              21  695  165 (BINARY)      50 if r[165]!=r[21] goto 695
REG[21] =  i:1
REG[165] =  i:1
 669 Integer          1  165    0               00 r[165]=1
REG[165] =  i:1
 670 Ne              21  695  165 (BINARY)      50 if r[165]!=r[21] goto 695
REG[21] =  i:1
REG[165] =  i:1
 671 Explain        671  588    0 SCAN SUBQUERY 2 00 
 672 Rewind          21  695    0               00 
 673 Once             0  681    0               00 
 674 OpenAutoindex   68    2    0 k(2,B,)       00 nColumn=2; for Table0
 675 Rewind          22  681    0               00 
 676 Column          22    0  166               00 r[166]=Table0.1
REG[166] =  i:1
 677 Rowid           22  167    0               00 r[167]=rowid
REG[167] =  i:1
 678 MakeRecord     166    2  165               00 r[165]=mkrec(r[166..167])
REG[165] =  sx3[030909|...]
 679 IdxInsert       68  165    0               10 key=r[165]
REG[165] =  sx3[030909|...]
 680 Next            22  676    0               03 
 681 Explain        681  588    0 SEARCH SUBQUERY 2 USING AUTOMATIC COVERING INDEX (1=?) 00 
 682 Column          21    0  168               00 r[168]=Table0.1
REG[168] =  i:1
 683 IsNull         168  694    0               00 if r[168]==NULL goto 694
REG[168] =  i:1
 684 SeekGE          68  694  168 1             00 key=r[168]
REG[168] =  i:1
 685 IdxGT           68  694  168 1             00 key=r[168]
REG[168] =  i:1
 686 Column          21    0  169               00 r[169]=Table0.1
REG[169] =  i:1
 687 Found           67  693  169 1             00 key=r[169]
REG[169] =  i:1
 688 MakeRecord     169    1  165               00 r[165]=mkrec(r[169])
REG[165] =  sx2[0209|..]
 689 IdxInsert       67  165  169 1             10 key=r[165]
REG[165] =  sx2[0209|..]
 690 MakeRecord     169    1  165               00 r[165]=mkrec(r[169])
REG[165] =  sx2[0209|..]
 691 NewRowid        20  170    0               00 r[170]=rowid
REG[170] =  i:1
 692 Insert          20  165  170               08 intkey=r[170] data=r[165]
REG[165] =  sx2[0209|..]
REG[170] =  i:1
 693 Next            68  685    0               00 
 694 Next            21  673    0               01 
 695 Explain        695  588    0 USE TEMP B-TREE FOR DISTINCT 00 
 696 Return         145    0    0               00 end Table0
REG[145] =  i:696
 697 Integer        807  171    0               00 r[171]=807
REG[171] =  i:807
 698 Noop             0    0    0               00 materialize "Table0"
 699 Explain        699  584    0 MATERIALIZE 3 00 
 700 Integer        737  172    0               00 r[172]=737
REG[172] =  i:737
 701 Once             0  737    0               00 materialize "Table0"
 702 Explain        702  699    0 MATERIALIZE 2 00 
 703 OpenEphemeral   27    1    0               00 nColumn=1
 704 OpenEphemeral   69    0    0 k(1,B)        08 nColumn=0
 705 Noop            70    1    0               00 
 706 Integer          0  174    0               00 r[174]=0; clear abort flag
REG[174] =  i:0
 707 Null             0  177  177               00 r[177..177]=NULL
REG[177] =  NULL
 708 Gosub          176  734    0               00 
REG[176] =  i:708
 734 Integer          0  173    0               00 r[173]=0; indicate accumulator empty
REG[173] =  i:0
 735 Return         176    0    0               00 
REG[176] =  i:708
 709 Explain        709  702    0 SCAN CONSTANT ROW 00 
 710 Integer          1  179    0               00 r[179]=1
REG[179] =  i:1
 711 Ne              21  720  179 (BINARY)      50 if r[179]!=r[21] goto 720
REG[21] =  i:1
REG[179] =  i:1
 712 Integer          1  178    0               00 r[178]=1
REG[178] =  i:1
 713 Compare        177  178    1 k(1,B)        00 r[177] <-> r[178]
REG[177] =  NULL
REG[178] =  i:1
 714 Jump           715  719  715               00 
 715 Move           178  177    1               00 r[177]=r[178]
REG[177] =  i:1
 716 Gosub          175  724    0               00 output one row
REG[175] =  i:716
 724 IfPos          173  726    0               00 if r[173]>0 then r[173]-=0, goto 726; Groupby result generator entry point
REG[173] =  i:0
 725 Return         175    0    0               00 
REG[175] =  i:716
 717 IfPos          174  736    0               00 if r[174]>0 then r[174]-=0, goto 736; check abort flag
REG[174] =  i:0
 718 Gosub          176  734    0               00 reset accumulator
REG[176] =  i:718
 734 Integer          0  173    0               00 r[173]=0; indicate accumulator empty
REG[173] =  i:0
 735 Return         176    0    0               00 
REG[176] =  i:718
 719 Integer          1  173    0               00 r[173]=1; indicate data in accumulator
REG[173] =  i:1
 720 Gosub          175  724    0               00 output final row
REG[175] =  i:720
 724 IfPos          173  726    0               00 if r[173]>0 then r[173]-=0, goto 726; Groupby result generator entry point
REG[173] =  i:1
 726 Integer          1  180    0               00 r[180]=1
REG[180] =  i:1
 727 Found           69  725  180 1             00 key=r[180]
REG[180] =  i:1
 728 MakeRecord     180    1  179               00 r[179]=mkrec(r[180])
REG[179] =  sx2[0209|..]
 729 IdxInsert       69  179  180 1             10 key=r[179]
REG[179] =  sx2[0209|..]
 730 MakeRecord     180    1  179               00 r[179]=mkrec(r[180])
REG[179] =  sx2[0209|..]
 731 NewRowid        27  181    0               00 r[181]=rowid
REG[181] =  i:1
 732 Insert          27  179  181               08 intkey=r[181] data=r[179]
REG[179] =  sx2[0209|..]
REG[181] =  i:1
 733 Return         175    0    0               00 end groupby result generator
REG[175] =  i:720
 721 Goto             0  736    0               00 
 736 Explain        736  702    0 USE TEMP B-TREE FOR DISTINCT 00 
 737 Return         172    0    0               00 end Table0
REG[172] =  i:737
 738 Integer        775  182    0               00 r[182]=775
REG[182] =  i:775
 739 Once             0  775    0               00 materialize "Table0"
 740 Explain        740  699    0 MATERIALIZE 2 00 
 741 OpenEphemeral   28    1    0               00 nColumn=1
 742 OpenEphemeral   71    0    0 k(1,B)        08 nColumn=0
 743 Noop            72    1    0               00 
 744 Integer          0  184    0               00 r[184]=0; clear abort flag
REG[184] =  i:0
 745 Null             0  187  187               00 r[187..187]=NULL
REG[187] =  NULL
 746 Gosub          186  772    0               00 
REG[186] =  i:746
 772 Integer          0  183    0               00 r[183]=0; indicate accumulator empty
REG[183] =  i:0
 773 Return         186    0    0               00 
REG[186] =  i:746
 747 Explain        747  740    0 SCAN CONSTANT ROW 00 
 748 Integer          1  189    0               00 r[189]=1
REG[189] =  i:1
 749 Ne              21  758  189 (BINARY)      50 if r[189]!=r[21] goto 758
REG[21] =  i:1
REG[189] =  i:1
 750 Integer          1  188    0               00 r[188]=1
REG[188] =  i:1
 751 Compare        187  188    1 k(1,B)        00 r[187] <-> r[188]
REG[187] =  NULL
REG[188] =  i:1
 752 Jump           753  757  753               00 
 753 Move           188  187    1               00 r[187]=r[188]
REG[187] =  i:1
 754 Gosub          185  762    0               00 output one row
REG[185] =  i:754
 762 IfPos          183  764    0               00 if r[183]>0 then r[183]-=0, goto 764; Groupby result generator entry point
REG[183] =  i:0
 763 Return         185    0    0               00 
REG[185] =  i:754
 755 IfPos          184  774    0               00 if r[184]>0 then r[184]-=0, goto 774; check abort flag
REG[184] =  i:0
 756 Gosub          186  772    0               00 reset accumulator
REG[186] =  i:756
 772 Integer          0  183    0               00 r[183]=0; indicate accumulator empty
REG[183] =  i:0
 773 Return         186    0    0               00 
REG[186] =  i:756
 757 Integer          1  183    0               00 r[183]=1; indicate data in accumulator
REG[183] =  i:1
 758 Gosub          185  762    0               00 output final row
REG[185] =  i:758
 762 IfPos          183  764    0               00 if r[183]>0 then r[183]-=0, goto 764; Groupby result generator entry point
REG[183] =  i:1
 764 Integer          1  190    0               00 r[190]=1
REG[190] =  i:1
 765 Found           71  763  190 1             00 key=r[190]
REG[190] =  i:1
 766 MakeRecord     190    1  189               00 r[189]=mkrec(r[190])
REG[189] =  sx2[0209|..]
 767 IdxInsert       71  189  190 1             10 key=r[189]
REG[189] =  sx2[0209|..]
 768 MakeRecord     190    1  189               00 r[189]=mkrec(r[190])
REG[189] =  sx2[0209|..]
 769 NewRowid        28  191    0               00 r[191]=rowid
REG[191] =  i:1
 770 Insert          28  189  191               08 intkey=r[191] data=r[189]
REG[189] =  sx2[0209|..]
REG[191] =  i:1
 771 Return         185    0    0               00 end groupby result generator
REG[185] =  i:758
 759 Goto             0  774    0               00 
 774 Explain        774  740    0 USE TEMP B-TREE FOR DISTINCT 00 
 775 Return         182    0    0               00 end Table0
REG[182] =  i:775
 776 OpenEphemeral   26    1    0               00 nColumn=1
 777 OpenEphemeral   73    0    0 k(1,B)        08 nColumn=0
 778 Column          17    0  192               00 r[192]=Table0.Col0
REG[192] =  i:1
 779 Ne              21  806  192 (BINARY)      50 if r[192]!=r[21] goto 806
REG[21] =  i:1
REG[192] =  i:1
 780 Integer          1  192    0               00 r[192]=1
REG[192] =  i:1
 781 Ne              21  806  192 (BINARY)      50 if r[192]!=r[21] goto 806
REG[21] =  i:1
REG[192] =  i:1
 782 Explain        782  699    0 SCAN SUBQUERY 2 00 
 783 Rewind          27  806    0               00 
 784 Once             0  792    0               00 
 785 OpenAutoindex   74    2    0 k(2,B,)       00 nColumn=2; for Table0
 786 Rewind          28  792    0               00 
 787 Column          28    0  193               00 r[193]=Table0.1
REG[193] =  i:1
 788 Rowid           28  194    0               00 r[194]=rowid
REG[194] =  i:1
 789 MakeRecord     193    2  192               00 r[192]=mkrec(r[193..194])
REG[192] =  sx3[030909|...]
 790 IdxInsert       74  192    0               10 key=r[192]
REG[192] =  sx3[030909|...]
 791 Next            28  787    0               03 
 792 Explain        792  699    0 SEARCH SUBQUERY 2 USING AUTOMATIC COVERING INDEX (1=?) 00 
 793 Column          27    0  195               00 r[195]=Table0.1
REG[195] =  i:1
 794 IsNull         195  805    0               00 if r[195]==NULL goto 805
REG[195] =  i:1
 795 SeekGE          74  805  195 1             00 key=r[195]
REG[195] =  i:1
 796 IdxGT           74  805  195 1             00 key=r[195]
REG[195] =  i:1
 797 Column          27    0  196               00 r[196]=Table0.1
REG[196] =  i:1
 798 Found           73  804  196 1             00 key=r[196]
REG[196] =  i:1
 799 MakeRecord     196    1  192               00 r[192]=mkrec(r[196])
REG[192] =  sx2[0209|..]
 800 IdxInsert       73  192  196 1             10 key=r[192]
REG[192] =  sx2[0209|..]
 801 MakeRecord     196    1  192               00 r[192]=mkrec(r[196])
REG[192] =  sx2[0209|..]
 802 NewRowid        26  197    0               00 r[197]=rowid
REG[197] =  i:1
 803 Insert          26  192  197               08 intkey=r[197] data=r[192]
REG[192] =  sx2[0209|..]
REG[197] =  i:1
 804 Next            74  796    0               00 
 805 Next            27  784    0               01 
 806 Explain        806  699    0 USE TEMP B-TREE FOR DISTINCT 00 
 807 Return         171    0    0               00 end Table0
REG[171] =  i:807
 808 Integer          1  198    0               00 r[198]=1; LIMIT counter
REG[198] =  i:1
 809 Integer          1  199    0               00 r[199]=1
REG[199] =  i:1
 810 Ne              21 1143  199 (BINARY)      50 if r[199]!=r[21] goto 1143
REG[21] =  i:1
REG[199] =  i:1
 811 Column          17    0  199               00 r[199]=Table0.Col0
REG[199] =  i:1
 812 Ne              21 1143  199 (BINARY)      50 if r[199]!=r[21] goto 1143
REG[21] =  i:1
REG[199] =  i:1
 813 Explain        813  584    0 SCAN SUBQUERY 3 00 
 814 Rewind          20 1143    0               00 
 815 Explain        815  584    0 CORRELATED SCALAR SUBQUERY 4 00 
 816 Null             0  200  200               00 r[200..200]=NULL; Init subquery result
REG[200] =  NULL
 817 InitCoroutine  201  922  818               00 Table0
 922 Integer          1  227    0               00 r[227]=1; LIMIT counter
REG[227] =  i:1
 923 OpenEphemeral   81    0    0 k(1,B)        08 nColumn=0
 924 Explain        924  815    0 SCAN SUBQUERY 3 00 
 925 InitCoroutine  201    0  818               00 
 926 Yield          201  933    0               00 next row of Table0
REG[201] =  i:817
REG[201] =  i:926
 818 Explain        818  815    0 CO-ROUTINE 3  00 
 819 Integer        856  202    0               00 r[202]=856
REG[202] =  i:856
 820 Once             0  856    0               00 materialize "Table0"
 821 Explain        821  818    0 MATERIALIZE 2 00 
 822 OpenEphemeral   24    1    0               00 nColumn=1
 823 OpenEphemeral   75    0    0 k(1,B)        08 nColumn=0
 824 Noop            76    1    0               00 
 825 Integer          0  204    0               00 r[204]=0; clear abort flag
REG[204] =  i:0
 826 Null             0  207  207               00 r[207..207]=NULL
REG[207] =  NULL
 827 Gosub          206  853    0               00 
REG[206] =  i:827
 853 Integer          0  203    0               00 r[203]=0; indicate accumulator empty
REG[203] =  i:0
 854 Return         206    0    0               00 
REG[206] =  i:827
 828 Explain        828  821    0 SCAN CONSTANT ROW 00 
 829 Integer          1  209    0               00 r[209]=1
REG[209] =  i:1
 830 Ne              21  839  209 (BINARY)      50 if r[209]!=r[21] goto 839
REG[21] =  i:1
REG[209] =  i:1
 831 Integer          1  208    0               00 r[208]=1
REG[208] =  i:1
 832 Compare        207  208    1 k(1,B)        00 r[207] <-> r[208]
REG[207] =  NULL
REG[208] =  i:1
 833 Jump           834  838  834               00 
 834 Move           208  207    1               00 r[207]=r[208]
REG[207] =  i:1
 835 Gosub          205  843    0               00 output one row
REG[205] =  i:835
 843 IfPos          203  845    0               00 if r[203]>0 then r[203]-=0, goto 845; Groupby result generator entry point
REG[203] =  i:0
 844 Return         205    0    0               00 
REG[205] =  i:835
 836 IfPos          204  855    0               00 if r[204]>0 then r[204]-=0, goto 855; check abort flag
REG[204] =  i:0
 837 Gosub          206  853    0               00 reset accumulator
REG[206] =  i:837
 853 Integer          0  203    0               00 r[203]=0; indicate accumulator empty
REG[203] =  i:0
 854 Return         206    0    0               00 
REG[206] =  i:837
 838 Integer          1  203    0               00 r[203]=1; indicate data in accumulator
REG[203] =  i:1
 839 Gosub          205  843    0               00 output final row
REG[205] =  i:839
 843 IfPos          203  845    0               00 if r[203]>0 then r[203]-=0, goto 845; Groupby result generator entry point
REG[203] =  i:1
 845 Integer          1  210    0               00 r[210]=1
REG[210] =  i:1
 846 Found           75  844  210 1             00 key=r[210]
REG[210] =  i:1
 847 MakeRecord     210    1  209               00 r[209]=mkrec(r[210])
REG[209] =  sx2[0209|..]
 848 IdxInsert       75  209  210 1             10 key=r[209]
REG[209] =  sx2[0209|..]
 849 MakeRecord     210    1  209               00 r[209]=mkrec(r[210])
REG[209] =  sx2[0209|..]
 850 NewRowid        24  211    0               00 r[211]=rowid
REG[211] =  i:1
 851 Insert          24  209  211               08 intkey=r[211] data=r[209]
REG[209] =  sx2[0209|..]
REG[211] =  i:1
 852 Return         205    0    0               00 end groupby result generator
REG[205] =  i:839
 840 Goto             0  855    0               00 
 855 Explain        855  821    0 USE TEMP B-TREE FOR DISTINCT 00 
 856 Return         202    0    0               00 end Table0
REG[202] =  i:856
 857 Integer        894  212    0               00 r[212]=894
REG[212] =  i:894
 858 Once             0  894    0               00 materialize "Table0"
 859 Explain        859  818    0 MATERIALIZE 2 00 
 860 OpenEphemeral   25    1    0               00 nColumn=1
 861 OpenEphemeral   77    0    0 k(1,B)        08 nColumn=0
 862 Noop            78    1    0               00 
 863 Integer          0  214    0               00 r[214]=0; clear abort flag
REG[214] =  i:0
 864 Null             0  217  217               00 r[217..217]=NULL
REG[217] =  NULL
 865 Gosub          216  891    0               00 
REG[216] =  i:865
 891 Integer          0  213    0               00 r[213]=0; indicate accumulator empty
REG[213] =  i:0
 892 Return         216    0    0               00 
REG[216] =  i:865
 866 Explain        866  859    0 SCAN CONSTANT ROW 00 
 867 Integer          1  219    0               00 r[219]=1
REG[219] =  i:1
 868 Ne              21  877  219 (BINARY)      50 if r[219]!=r[21] goto 877
REG[21] =  i:1
REG[219] =  i:1
 869 Integer          1  218    0               00 r[218]=1
REG[218] =  i:1
 870 Compare        217  218    1 k(1,B)        00 r[217] <-> r[218]
REG[217] =  NULL
REG[218] =  i:1
 871 Jump           872  876  872               00 
 872 Move           218  217    1               00 r[217]=r[218]
REG[217] =  i:1
 873 Gosub          215  881    0               00 output one row
REG[215] =  i:873
 881 IfPos          213  883    0               00 if r[213]>0 then r[213]-=0, goto 883; Groupby result generator entry point
REG[213] =  i:0
 882 Return         215    0    0               00 
REG[215] =  i:873
 874 IfPos          214  893    0               00 if r[214]>0 then r[214]-=0, goto 893; check abort flag
REG[214] =  i:0
 875 Gosub          216  891    0               00 reset accumulator
REG[216] =  i:875
 891 Integer          0  213    0               00 r[213]=0; indicate accumulator empty
REG[213] =  i:0
 892 Return         216    0    0               00 
REG[216] =  i:875
 876 Integer          1  213    0               00 r[213]=1; indicate data in accumulator
REG[213] =  i:1
 877 Gosub          215  881    0               00 output final row
REG[215] =  i:877
 881 IfPos          213  883    0               00 if r[213]>0 then r[213]-=0, goto 883; Groupby result generator entry point
REG[213] =  i:1
 883 Integer          1  220    0               00 r[220]=1
REG[220] =  i:1
 884 Found           77  882  220 1             00 key=r[220]
REG[220] =  i:1
 885 MakeRecord     220    1  219               00 r[219]=mkrec(r[220])
REG[219] =  sx2[0209|..]
 886 IdxInsert       77  219  220 1             10 key=r[219]
REG[219] =  sx2[0209|..]
 887 MakeRecord     220    1  219               00 r[219]=mkrec(r[220])
REG[219] =  sx2[0209|..]
 888 NewRowid        25  221    0               00 r[221]=rowid
REG[221] =  i:1
 889 Insert          25  219  221               08 intkey=r[221] data=r[219]
REG[219] =  sx2[0209|..]
REG[221] =  i:1
 890 Return         215    0    0               00 end groupby result generator
REG[215] =  i:877
 878 Goto             0  893    0               00 
 893 Explain        893  859    0 USE TEMP B-TREE FOR DISTINCT 00 
 894 Return         212    0    0               00 end Table0
REG[212] =  i:894
 895 OpenEphemeral   79    0    0 k(1,B)        08 nColumn=0
 896 Integer          1  222    0               00 r[222]=1
REG[222] =  i:1
 897 Ne              21  920  222 (BINARY)      50 if r[222]!=r[21] goto 920
REG[21] =  i:1
REG[222] =  i:1
 898 Explain        898  818    0 SCAN SUBQUERY 2 00 
 899 Rewind          24  920    0               00 
 900 Once             0  908    0               00 
 901 OpenAutoindex   80    2    0 k(2,B,)       00 nColumn=2; for Table0
 902 Rewind          25  908    0               00 
 903 Column          25    0  223               00 r[223]=Table0.1
REG[223] =  i:1
 904 Rowid           25  224    0               00 r[224]=rowid
REG[224] =  i:1
 905 MakeRecord     223    2  222               00 r[222]=mkrec(r[223..224])
REG[222] =  sx3[030909|...]
 906 IdxInsert       80  222    0               10 key=r[222]
REG[222] =  sx3[030909|...]
 907 Next            25  903    0               03 
 908 Explain        908  818    0 SEARCH SUBQUERY 2 USING AUTOMATIC COVERING INDEX (1=?) 00 
 909 Column          24    0  225               00 r[225]=Table0.1
REG[225] =  i:1
 910 IsNull         225  919    0               00 if r[225]==NULL goto 919
REG[225] =  i:1
 911 SeekGE          80  919  225 1             00 key=r[225]
REG[225] =  i:1
 912 IdxGT           80  919  225 1             00 key=r[225]
REG[225] =  i:1
 913 Column          24    0  226               00 r[226]=Table0.1
REG[226] =  i:1
 914 Found           79  918  226 1             00 key=r[226]
REG[226] =  i:1
 915 MakeRecord     226    1  222               00 r[222]=mkrec(r[226])
REG[222] =  sx2[0209|..]
 916 IdxInsert       79  222  226 1             10 key=r[222]
REG[222] =  sx2[0209|..]
 917 Yield          201    0    0               00 
REG[201] =  i:926
REG[201] =  i:917
 927 Copy           226  200    0               00 r[200]=r[226]; Table0.1
REG[200] =  i:1
 928 Found           81  932  200 1             00 key=r[200]
REG[200] =  i:1
 929 MakeRecord     200    1  228               00 r[228]=mkrec(r[200])
REG[228] =  sx2[0209|..]
 930 IdxInsert       81  228  200 1             10 key=r[228]
REG[228] =  sx2[0209|..]
 931 DecrJumpZero   227  933    0               00 if (--r[227])==0 goto 933
REG[227] =  i:1
 933 Explain        933  815    0 USE TEMP B-TREE FOR DISTINCT 00 
 934 Explain        934  584    0 CORRELATED SCALAR SUBQUERY 4 00 
 935 Null             0  229  229               00 r[229..229]=NULL; Init subquery result
REG[229] =  NULL
 936 InitCoroutine  230 1041  937               00 Table0
1041 Integer          1  255    0               00 r[255]=1; LIMIT counter
REG[255] =  i:1
1042 OpenEphemeral   88    0    0 k(1,B)        08 nColumn=0
1043 Explain       1043  934    0 SCAN SUBQUERY 3 00 
1044 InitCoroutine  230    0  937               00 
1045 Yield          230 1052    0               00 next row of Table0
REG[230] =  i:936
REG[230] =  i:1045
 937 Explain        937  934    0 CO-ROUTINE 3  00 
 938 Integer        975  231    0               00 r[231]=975
REG[231] =  i:975
 939 Once             0  975    0               00 materialize "Table0"
 940 Explain        940  937    0 MATERIALIZE 2 00 
 941 OpenEphemeral   30    1    0               00 nColumn=1
 942 OpenEphemeral   82    0    0 k(1,B)        08 nColumn=0
 943 Noop            83    1    0               00 
 944 Integer          0  233    0               00 r[233]=0; clear abort flag
REG[233] =  i:0
 945 Null             0  236  236               00 r[236..236]=NULL
REG[236] =  NULL
 946 Gosub          235  972    0               00 
REG[235] =  i:946
 972 Integer          0  232    0               00 r[232]=0; indicate accumulator empty
REG[232] =  i:0
 973 Return         235    0    0               00 
REG[235] =  i:946
 947 Explain        947  940    0 SCAN CONSTANT ROW 00 
 948 Integer          1  228    0               00 r[228]=1
REG[228] =  i:1
 949 Ne              21  958  228 (BINARY)      50 if r[228]!=r[21] goto 958
REG[21] =  i:1
REG[228] =  i:1
 950 Integer          1  237    0               00 r[237]=1
REG[237] =  i:1
 951 Compare        236  237    1 k(1,B)        00 r[236] <-> r[237]
REG[236] =  NULL
REG[237] =  i:1
 952 Jump           953  957  953               00 
 953 Move           237  236    1               00 r[236]=r[237]
REG[236] =  i:1
 954 Gosub          234  962    0               00 output one row
REG[234] =  i:954
 962 IfPos          232  964    0               00 if r[232]>0 then r[232]-=0, goto 964; Groupby result generator entry point
REG[232] =  i:0
 963 Return         234    0    0               00 
REG[234] =  i:954
 955 IfPos          233  974    0               00 if r[233]>0 then r[233]-=0, goto 974; check abort flag
REG[233] =  i:0
 956 Gosub          235  972    0               00 reset accumulator
REG[235] =  i:956
 972 Integer          0  232    0               00 r[232]=0; indicate accumulator empty
REG[232] =  i:0
 973 Return         235    0    0               00 
REG[235] =  i:956
 957 Integer          1  232    0               00 r[232]=1; indicate data in accumulator
REG[232] =  i:1
 958 Gosub          234  962    0               00 output final row
REG[234] =  i:958
 962 IfPos          232  964    0               00 if r[232]>0 then r[232]-=0, goto 964; Groupby result generator entry point
REG[232] =  i:1
 964 Integer          1  238    0               00 r[238]=1
REG[238] =  i:1
 965 Found           82  963  238 1             00 key=r[238]
REG[238] =  i:1
 966 MakeRecord     238    1  228               00 r[228]=mkrec(r[238])
REG[228] =  sx2[0209|..]
 967 IdxInsert       82  228  238 1             10 key=r[228]
REG[228] =  sx2[0209|..]
 968 MakeRecord     238    1  228               00 r[228]=mkrec(r[238])
REG[228] =  sx2[0209|..]
 969 NewRowid        30  239    0               00 r[239]=rowid
REG[239] =  i:1
 970 Insert          30  228  239               08 intkey=r[239] data=r[228]
REG[228] =  sx2[0209|..]
REG[239] =  i:1
 971 Return         234    0    0               00 end groupby result generator
REG[234] =  i:958
 959 Goto             0  974    0               00 
 974 Explain        974  940    0 USE TEMP B-TREE FOR DISTINCT 00 
 975 Return         231    0    0               00 end Table0
REG[231] =  i:975
 976 Integer       1013  240    0               00 r[240]=1013
REG[240] =  i:1013
 977 Once             0 1013    0               00 materialize "Table0"
 978 Explain        978  937    0 MATERIALIZE 2 00 
 979 OpenEphemeral   31    1    0               00 nColumn=1
 980 OpenEphemeral   84    0    0 k(1,B)        08 nColumn=0
 981 Noop            85    1    0               00 
 982 Integer          0  242    0               00 r[242]=0; clear abort flag
REG[242] =  i:0
 983 Null             0  245  245               00 r[245..245]=NULL
REG[245] =  NULL
 984 Gosub          244 1010    0               00 
REG[244] =  i:984
1010 Integer          0  241    0               00 r[241]=0; indicate accumulator empty
REG[241] =  i:0
1011 Return         244    0    0               00 
REG[244] =  i:984
 985 Explain        985  978    0 SCAN CONSTANT ROW 00 
 986 Integer          1  247    0               00 r[247]=1
REG[247] =  i:1
 987 Ne              21  996  247 (BINARY)      50 if r[247]!=r[21] goto 996
REG[21] =  i:1
REG[247] =  i:1
 988 Integer          1  246    0               00 r[246]=1
REG[246] =  i:1
 989 Compare        245  246    1 k(1,B)        00 r[245] <-> r[246]
REG[245] =  NULL
REG[246] =  i:1
 990 Jump           991  995  991               00 
 991 Move           246  245    1               00 r[245]=r[246]
REG[245] =  i:1
 992 Gosub          243 1000    0               00 output one row
REG[243] =  i:992
1000 IfPos          241 1002    0               00 if r[241]>0 then r[241]-=0, goto 1002; Groupby result generator entry point
REG[241] =  i:0
1001 Return         243    0    0               00 
REG[243] =  i:992
 993 IfPos          242 1012    0               00 if r[242]>0 then r[242]-=0, goto 1012; check abort flag
REG[242] =  i:0
 994 Gosub          244 1010    0               00 reset accumulator
REG[244] =  i:994
1010 Integer          0  241    0               00 r[241]=0; indicate accumulator empty
REG[241] =  i:0
1011 Return         244    0    0               00 
REG[244] =  i:994
 995 Integer          1  241    0               00 r[241]=1; indicate data in accumulator
REG[241] =  i:1
 996 Gosub          243 1000    0               00 output final row
REG[243] =  i:996
1000 IfPos          241 1002    0               00 if r[241]>0 then r[241]-=0, goto 1002; Groupby result generator entry point
REG[241] =  i:1
1002 Integer          1  248    0               00 r[248]=1
REG[248] =  i:1
1003 Found           84 1001  248 1             00 key=r[248]
REG[248] =  i:1
1004 MakeRecord     248    1  247               00 r[247]=mkrec(r[248])
REG[247] =  sx2[0209|..]
1005 IdxInsert       84  247  248 1             10 key=r[247]
REG[247] =  sx2[0209|..]
1006 MakeRecord     248    1  247               00 r[247]=mkrec(r[248])
REG[247] =  sx2[0209|..]
1007 NewRowid        31  249    0               00 r[249]=rowid
REG[249] =  i:1
1008 Insert          31  247  249               08 intkey=r[249] data=r[247]
REG[247] =  sx2[0209|..]
REG[249] =  i:1
1009 Return         243    0    0               00 end groupby result generator
REG[243] =  i:996
 997 Goto             0 1012    0               00 
1012 Explain       1012  978    0 USE TEMP B-TREE FOR DISTINCT 00 
1013 Return         240    0    0               00 end Table0
REG[240] =  i:1013
1014 OpenEphemeral   86    0    0 k(1,B)        08 nColumn=0
1015 Integer          1  250    0               00 r[250]=1
REG[250] =  i:1
1016 Ne              21 1039  250 (BINARY)      50 if r[250]!=r[21] goto 1039
REG[21] =  i:1
REG[250] =  i:1
1017 Explain       1017  937    0 SCAN SUBQUERY 2 00 
1018 Rewind          30 1039    0               00 
1019 Once             0 1027    0               00 
1020 OpenAutoindex   87    2    0 k(2,B,)       00 nColumn=2; for Table0
1021 Rewind          31 1027    0               00 
1022 Column          31    0  251               00 r[251]=Table0.1
REG[251] =  i:1
1023 Rowid           31  252    0               00 r[252]=rowid
REG[252] =  i:1
1024 MakeRecord     251    2  250               00 r[250]=mkrec(r[251..252])
REG[250] =  sx3[030909|...]
1025 IdxInsert       87  250    0               10 key=r[250]
REG[250] =  sx3[030909|...]
1026 Next            31 1022    0               03 
1027 Explain       1027  937    0 SEARCH SUBQUERY 2 USING AUTOMATIC COVERING INDEX (1=?) 00 
1028 Column          30    0  253               00 r[253]=Table0.1
REG[253] =  i:1
1029 IsNull         253 1038    0               00 if r[253]==NULL goto 1038
REG[253] =  i:1
1030 SeekGE          87 1038  253 1             00 key=r[253]
REG[253] =  i:1
1031 IdxGT           87 1038  253 1             00 key=r[253]
REG[253] =  i:1
1032 Column          30    0  254               00 r[254]=Table0.1
REG[254] =  i:1
1033 Found           86 1037  254 1             00 key=r[254]
REG[254] =  i:1
1034 MakeRecord     254    1  250               00 r[250]=mkrec(r[254])
REG[250] =  sx2[0209|..]
1035 IdxInsert       86  250  254 1             10 key=r[250]
REG[250] =  sx2[0209|..]
1036 Yield          230    0    0               00 
REG[230] =  i:1045
REG[230] =  i:1036
1046 Copy           254  229    0               00 r[229]=r[254]; Table0.1
REG[229] =  i:1
1047 Found           88 1051  229 1             00 key=r[229]
REG[229] =  i:1
1048 MakeRecord     229    1  256               00 r[256]=mkrec(r[229])
REG[256] =  sx2[0209|..]
1049 IdxInsert       88  256  229 1             10 key=r[256]
REG[256] =  sx2[0209|..]
1050 DecrJumpZero   255 1052    0               00 if (--r[255])==0 goto 1052
REG[255] =  i:1
1052 Explain       1052  934    0 USE TEMP B-TREE FOR DISTINCT 00 
1053 Ne             229 1142  200 (BINARY)      50 if r[200]!=r[229] goto 1142
REG[229] =  i:1
REG[200] =  i:1
1054 Explain       1054  584    0 SCAN SUBQUERY 3 00 
1055 Rewind          26 1143    0               00 
1056 Explain       1056  584    0 CORRELATED SCALAR SUBQUERY 4 00 
1057 Null             0  257  257               00 r[257..257]=NULL; Init subquery result
REG[257] =  NULL
1058 InitCoroutine  258 1127 1059               00 Table0
1127 Integer          1  273    0               00 r[273]=1; LIMIT counter
REG[273] =  i:1
1128 OpenEphemeral   93    0    0 k(1,B)        08 nColumn=0
1129 Explain       1129 1056    0 SCAN SUBQUERY 3 00 
1130 InitCoroutine  258    0 1059               00 
1131 Yield          258 1138    0               00 next row of Table0
REG[258] =  i:1058
REG[258] =  i:1131
1059 Explain       1059 1056    0 CO-ROUTINE 3  00 
1060 Integer       1095  259    0               00 r[259]=1095
REG[259] =  i:1095
1061 Once             0 1095    0               00 materialize "Table0"
1062 Explain       1062 1059    0 MATERIALIZE 2 00 
1063 OpenEphemeral   24    1    0               00 nColumn=1
1064 OpenEphemeral   89    0    0 k(1,B)        08 nColumn=0
1065 Noop            90    1    0               00 
1066 Integer          0  261    0               00 r[261]=0; clear abort flag
REG[261] =  i:0
1067 Null             0  264  264               00 r[264..264]=NULL
REG[264] =  NULL
1068 Gosub          263 1092    0               00 
REG[263] =  i:1068
1092 Integer          0  260    0               00 r[260]=0; indicate accumulator empty
REG[260] =  i:0
1093 Return         263    0    0               00 
REG[263] =  i:1068
1069 Explain       1069 1062    0 SCAN CONSTANT ROW 00 
1070 Integer          1  265    0               00 r[265]=1
REG[265] =  i:1
1071 Compare        264  265    1 k(1,B)        00 r[264] <-> r[265]
REG[264] =  NULL
REG[265] =  i:1
1072 Jump          1073 1077 1073               00 
1073 Move           265  264    1               00 r[264]=r[265]
REG[264] =  i:1
1074 Gosub          262 1082    0               00 output one row
REG[262] =  i:1074
1082 IfPos          260 1084    0               00 if r[260]>0 then r[260]-=0, goto 1084; Groupby result generator entry point
REG[260] =  i:0
1083 Return         262    0    0               00 
REG[262] =  i:1074
1075 IfPos          261 1094    0               00 if r[261]>0 then r[261]-=0, goto 1094; check abort flag
REG[261] =  i:0
1076 Gosub          263 1092    0               00 reset accumulator
REG[263] =  i:1076
1092 Integer          0  260    0               00 r[260]=0; indicate accumulator empty
REG[260] =  i:0
1093 Return         263    0    0               00 
REG[263] =  i:1076
1077 Integer          1  260    0               00 r[260]=1; indicate data in accumulator
REG[260] =  i:1
1078 Gosub          262 1082    0               00 output final row
REG[262] =  i:1078
1082 IfPos          260 1084    0               00 if r[260]>0 then r[260]-=0, goto 1084; Groupby result generator entry point
REG[260] =  i:1
1084 Integer          1  266    0               00 r[266]=1
REG[266] =  i:1
1085 Found           89 1083  266 1             00 key=r[266]
REG[266] =  i:1
1086 MakeRecord     266    1  199               00 r[199]=mkrec(r[266])
REG[199] =  sx2[0209|..]
1087 IdxInsert       89  199  266 1             10 key=r[199]
REG[199] =  sx2[0209|..]
1088 MakeRecord     266    1  199               00 r[199]=mkrec(r[266])
REG[199] =  sx2[0209|..]
1089 NewRowid        24  256    0               00 r[256]=rowid
REG[256] =  i:1
1090 Insert          24  199  256               08 intkey=r[256] data=r[199]
REG[199] =  sx2[0209|..]
REG[256] =  i:1
1091 Return         262    0    0               00 end groupby result generator
REG[262] =  i:1078
1079 Goto             0 1094    0               00 
1094 Explain       1094 1062    0 USE TEMP B-TREE FOR DISTINCT 00 
1095 Return         259    0    0               00 end Table0
REG[259] =  i:1095
1096 Integer       1099  267    0               00 r[267]=1099
REG[267] =  i:1099
1097 Once             0 1099    0               00 materialize "Table0"
1098 OpenDup         25   24    0               00 
1099 Return         267    0    0               00 end Table0
REG[267] =  i:1099
1100 OpenEphemeral   91    0    0 k(1,B)        08 nColumn=0
1101 Column          17    0  268               00 r[268]=Table0.Col0
REG[268] =  i:1
1102 Ne              21 1125  268 (BINARY)      50 if r[268]!=r[21] goto 1125
REG[21] =  i:1
REG[268] =  i:1
1103 Explain       1103 1059    0 SCAN SUBQUERY 2 00 
1104 Rewind          24 1125    0               00 
1105 Once             0 1113    0               00 
1106 OpenAutoindex   92    2    0 k(2,B,)       00 nColumn=2; for Table0
1107 Rewind          25 1113    0               00 
1108 Column          25    0  269               00 r[269]=Table0.1
REG[269] =  i:1
1109 Rowid           25  270    0               00 r[270]=rowid
REG[270] =  i:1
1110 MakeRecord     269    2  268               00 r[268]=mkrec(r[269..270])
REG[268] =  sx3[030909|...]
1111 IdxInsert       92  268    0               10 key=r[268]
REG[268] =  sx3[030909|...]
1112 Next            25 1108    0               03 
1113 Explain       1113 1059    0 SEARCH SUBQUERY 2 USING AUTOMATIC COVERING INDEX (1=?) 00 
1114 Column          24    0  271               00 r[271]=Table0.1
REG[271] =  i:1
1115 IsNull         271 1124    0               00 if r[271]==NULL goto 1124
REG[271] =  i:1
1116 SeekGE          92 1124  271 1             00 key=r[271]
REG[271] =  i:1
1117 IdxGT           92 1124  271 1             00 key=r[271]
REG[271] =  i:1
1118 Column          24    0  272               00 r[272]=Table0.1
REG[272] =  i:1
1119 Found           91 1123  272 1             00 key=r[272]
REG[272] =  i:1
1120 MakeRecord     272    1  268               00 r[268]=mkrec(r[272])
REG[268] =  sx2[0209|..]
1121 IdxInsert       91  268  272 1             10 key=r[268]
REG[268] =  sx2[0209|..]
1122 Yield          258    0    0               00 
REG[258] =  i:1131
REG[258] =  i:1122
1132 Copy           272  257    0               00 r[257]=r[272]; Table0.1
REG[257] =  i:1
1133 Found           93 1137  257 1             00 key=r[257]
REG[257] =  i:1
1134 MakeRecord     257    1  274               00 r[274]=mkrec(r[257])
REG[274] =  sx2[0209|..]
1135 IdxInsert       93  274  257 1             10 key=r[274]
REG[274] =  sx2[0209|..]
1136 DecrJumpZero   273 1138    0               00 if (--r[273])==0 goto 1138
REG[273] =  i:1
1138 Explain       1138 1056    0 USE TEMP B-TREE FOR DISTINCT 00 
1139 Copy           257  144    0               00 r[144]=r[257]
REG[144] =  i:1
1140 DecrJumpZero   198 1143    0               00 if (--r[198])==0 goto 1143
REG[198] =  i:1
1143 Ne             144 1146   11 (BINARY)      50 if r[11]!=r[144] goto 1146
REG[144] =  i:1
REG[11] =  i:1
1144 Integer          1    3    0               00 r[3]=1
REG[3] =  i:1
1145 DecrJumpZero     9 1148    0               00 if (--r[9])==0 goto 1148
REG[9] =  i:1
1148 Return           2    0    0               00 
REG[2] =  i:1148
1149 Copy             3    1    0               00 r[1]=r[3]
REG[1] =  i:1
1150 ResultRow        1    1    0               00 output=r[1]
REG[1] =  i:1
1151 Halt             0    0    0               00 
SQL: [;
;SELECT (
    WITH t4a(a) AS (VALUES(1))
    SELECT (
      WITH t2(b) AS (
        WITH t3(c) AS (
          WITH t4(d) AS (VALUES('elvis'))
          SELECT t4a.d FROM t4 AS t4a JOIN t4 AS t4b LEFT JOIN t4 AS t4c
        )
        SELECT c FROM t3 WHERE a = 1
      )
      SELECT t2a.b FROM t2 AS t2a JOIN t2 AS t2x
    )
    FROM t4a GROUP BY 1
  )
  GROUP BY 1;]
VDBE Trace:
   0 Init             0  408    0               00 Start at 408
 408 Integer          1   24    0               00 r[24]=1
REG[24] =  i:1
 409 Goto             0    1    0               00 
   1 Noop            11    1    0               00 
   2 Integer          0    2    0               00 r[2]=0; clear abort flag
REG[2] =  i:0
   3 Null             0    5    5               00 r[5..5]=NULL
REG[5] =  NULL
   4 Gosub            4  405    0               00 
REG[4] =  i:4
 405 Integer          0    1    0               00 r[1]=0; indicate accumulator empty
REG[1] =  i:0
 406 Return           4    0    0               00 
REG[4] =  i:4
   5 Explain          5    0    0 SCAN CONSTANT ROW 00 
   6 Integer        196    7    0               00 r[7]=196; return address
REG[7] =  i:196
   7 Once             0  196    0               00 
   8 Explain          8    0    0 SCALAR SUBQUERY 6 00 
   9 Null             0    8    8               00 r[8..8]=NULL; Init subquery result
REG[8] =  NULL
  10 InitCoroutine    9   16   11               00 t4a
  16 Integer          1   11    0               00 r[11]=1; LIMIT counter
REG[11] =  i:1
  17 SorterOpen      12    2    0 k(1,B)        00 
  18 Integer          0   14    0               00 r[14]=0; clear abort flag
REG[14] =  i:0
  19 Null             0   17   17               00 r[17..17]=NULL
REG[17] =  NULL
  20 Gosub           16  193    0               00 
REG[16] =  i:20
 193 Null             0   12   12               00 r[12..12]=NULL
REG[12] =  NULL
 194 Integer          0   13    0               00 r[13]=0; indicate accumulator empty
REG[13] =  i:0
 195 Return          16    0    0               00 
REG[16] =  i:20
  21 Explain         21    8    0 SCAN SUBQUERY 1 00 
  22 InitCoroutine    9    0   11               00 
  23 Yield            9  105    0               00 next row of t4a
REG[9] =  i:10
REG[9] =  i:23
  11 Explain         11    8    0 CO-ROUTINE 1  00 
  12 Explain         12   11    0 SCAN CONSTANT ROW 00 
  13 Integer          1   10    0               00 r[10]=1
REG[10] =  i:1
  14 Yield            9    0    0               00 
REG[9] =  i:23
REG[9] =  i:14
  24 Explain         24    8    0 USE TEMP B-TREE FOR GROUP BY 00 
  25 Explain         25    8    0 CORRELATED SCALAR SUBQUERY 5 00 
  26 Null             0   21   21               00 r[21..21]=NULL; Init subquery result
REG[21] =  NULL
  27 Integer         38   22    0               00 r[22]=38
REG[22] =  i:38
  28 Once             0   38    0               00 materialize "t4"
  29 Explain         29   25    0 MATERIALIZE 2 00 
  30 OpenEphemeral    4    1    0               00 nColumn=1
  31 Explain         31   29    0 SCAN CONSTANT ROW 00 
  32 Integer          1   23    0               00 r[23]=1
REG[23] =  i:1
  33 Ne              24   38   23 (BINARY)      50 if r[23]!=r[24] goto 38
REG[24] =  i:1
REG[23] =  i:1
  34 String8          0   25    0 elvis         00 r[25]='elvis'
REG[25] =   t5[elvis](8)
  35 MakeRecord      25    1   23               00 r[23]=mkrec(r[25])
REG[23] =  sx7[0217656C766973|..elvis]
  36 NewRowid         4   26    0               00 r[26]=rowid
REG[26] =  i:1
  37 Insert           4   23   26               08 intkey=r[26] data=r[23]
REG[23] =  sx7[0217656C766973|..elvis]
REG[26] =  i:1
  38 Return          22    0    0               00 end t4
REG[22] =  i:38
  39 Integer         42   27    0               00 r[27]=42
REG[27] =  i:42
  40 Once             0   42    0               00 materialize "t4"
  41 OpenDup          5    4    0               00 
  42 Return          27    0    0               00 end t4
REG[27] =  i:42
  43 Integer         52   28    0               00 r[28]=52
REG[28] =  i:52
  44 Once             0   52    0               00 materialize "t4"
  45 Explain         45   25    0 MATERIALIZE 2 00 
  46 OpenEphemeral    6    1    0               00 nColumn=1
  47 Explain         47   45    0 SCAN CONSTANT ROW 00 
  48 String8          0   29    0 elvis         00 r[29]='elvis'
REG[29] =   t5[elvis](8)
  49 MakeRecord      29    1   30               00 r[30]=mkrec(r[29])
REG[30] =  sx7[0217656C766973|..elvis]
  50 NewRowid         6   31    0               00 r[31]=rowid
REG[31] =  i:1
  51 Insert           6   30   31               08 intkey=r[31] data=r[30]
REG[30] =  sx7[0217656C766973|..elvis]
REG[31] =  i:1
  52 Return          28    0    0               00 end t4
REG[28] =  i:52
  53 Integer         56   32    0               00 r[32]=56
REG[32] =  i:56
  54 Once             0   56    0               00 materialize "t4"
  55 OpenDup          8    4    0               00 
  56 Return          32    0    0               00 end t4
REG[32] =  i:56
  57 Integer         60   33    0               00 r[33]=60
REG[33] =  i:60
  58 Once             0   60    0               00 materialize "t4"
  59 OpenDup          9    4    0               00 
  60 Return          33    0    0               00 end t4
REG[33] =  i:60
  61 Integer         64   34    0               00 r[34]=64
REG[34] =  i:64
  62 Once             0   64    0               00 materialize "t4"
  63 OpenDup         10    6    0               00 
  64 Return          34    0    0               00 end t4
REG[34] =  i:64
  65 Integer          1   35    0               00 r[35]=1; LIMIT counter
REG[35] =  i:1
  66 Integer          1   36    0               00 r[36]=1
REG[36] =  i:1
  67 Ne              24  100   36 (BINARY)      50 if r[36]!=r[24] goto 100
REG[24] =  i:1
REG[36] =  i:1
  68 Copy            10   36    0               00 r[36]=r[10]; t4a.a
REG[36] =  i:1
  69 Ne              24  100   36 (BINARY)      50 if r[36]!=r[24] goto 100
REG[24] =  i:1
REG[36] =  i:1
  70 Explain         70   25    0 SCAN SUBQUERY 2 AS t4a 00 
  71 Rewind           4  100    0               00 
  72 Explain         72   25    0 SCAN SUBQUERY 2 AS t4b 00 
  73 Rewind           5  100    0               00 
  74 Explain         74   25    0 SCAN SUBQUERY 2 AS t4c 00 
  75 Integer          0   37    0               00 r[37]=0; init LEFT JOIN no-match flag
REG[37] =  i:0
  76 Rewind           6   95    0               00 
  77 Integer          1   37    0               00 r[37]=1; record LEFT JOIN hit
REG[37] =  i:1
  78 Explain         78   25    0 SCAN SUBQUERY 2 AS t4a 00 
  79 Rewind           8   95    0               00 
  80 Explain         80   25    0 SCAN SUBQUERY 2 AS t4b 00 
  81 Rewind           9   95    0               00 
  82 Explain         82   25    0 SCAN SUBQUERY 2 AS t4c 00 
  83 Integer          0   38    0               00 r[38]=0; init LEFT JOIN no-match flag
REG[38] =  i:0
  84 Rewind          10   89    0               00 
  85 Integer          1   38    0               00 r[38]=1; record LEFT JOIN hit
REG[38] =  i:1
  86 Column           4    0   21               00 r[21]=t4.d
REG[21] =   s5[elvis](8)
  87 DecrJumpZero    35  100    0               00 if (--r[35])==0 goto 100
REG[35] =  i:1
 100 SCopy           21   19    0               00 r[19]=r[21]
REG[19] =   e5[elvis](8)
 101 Copy            10   20    0               00 r[20]=r[10]; t4a.a
REG[20] =  i:1
 102 MakeRecord      19    2   36               00 r[36]=mkrec(r[19..20])
REG[36] =  sx8[031709656C766973|...elvis]
 103 SorterInsert    12   36    0               00 key=r[36]
REG[36] =  sx8[031709656C766973|...elvis]
 104 Goto             0   23    0               00 
  23 Yield            9  105    0               00 next row of t4a
REG[9] =  i:14
REG[9] =  i:23
  15 EndCoroutine     9    0    0               00 
REG[9] =  i:23
 105 OpenPseudo      13   36    2               00 2 columns in r[36]
 106 SorterSort      12  196    0               00 GROUP BY sort
 107 SorterData      12   36   13               00 r[36]=data
 108 Column          13    0   18               00 r[18]=
REG[18] =   s5[elvis](8)
 109 Compare         17   18    1 k(1,B)        00 r[17] <-> r[18]
REG[17] =  NULL
REG[18] =   s5[elvis](8)
 110 Jump           111  115  111               00 
 111 Move            18   17    1               00 r[17]=r[18]
REG[17] =   s5[elvis](8)
 112 Gosub           15  123    0               00 output one row
REG[15] =  i:112
 123 IfPos           13  125    0               00 if r[13]>0 then r[13]-=0, goto 125; Groupby result generator entry point
REG[13] =  i:0
 124 Return          15    0    0               00 
REG[15] =  i:112
 113 IfPos           14  196    0               00 if r[14]>0 then r[14]-=0, goto 196; check abort flag
REG[14] =  i:0
 114 Gosub           16  193    0               00 reset accumulator
REG[16] =  i:114
 193 Null             0   12   12               00 r[12..12]=NULL
REG[12] =  NULL
 194 Integer          0   13    0               00 r[13]=0; indicate accumulator empty
REG[13] =  i:0
 195 Return          16    0    0               00 
REG[16] =  i:114
 115 If              13  117    0               00 
REG[13] =  i:0
 116 Column          13    1   12               00 r[12]=
REG[12] =  i:1
 117 Integer          1   13    0               00 r[13]=1; indicate data in accumulator
REG[13] =  i:1
 118 SorterNext      12  107    0               00 
 119 Gosub           15  123    0               00 output final row
REG[15] =  i:119
 123 IfPos           13  125    0               00 if r[13]>0 then r[13]-=0, goto 125; Groupby result generator entry point
REG[13] =  i:1
 125 Explain        125    8    0 CORRELATED SCALAR SUBQUERY 5 00 
 126 Null             0   39   39               00 r[39..39]=NULL; Init subquery result
REG[39] =  NULL
 127 Integer        136   40    0               00 r[40]=136
REG[40] =  i:136
 128 Once             0  136    0               00 materialize "t4"
 129 Explain        129  125    0 MATERIALIZE 2 00 
 130 OpenEphemeral    4    1    0               00 nColumn=1
 131 Explain        131  129    0 SCAN CONSTANT ROW 00 
 132 String8          0   41    0 elvis         00 r[41]='elvis'
REG[41] =   t5[elvis](8)
 133 MakeRecord      41    1   42               00 r[42]=mkrec(r[41])
REG[42] =  sx7[0217656C766973|..elvis]
 134 NewRowid         4   43    0               00 r[43]=rowid
REG[43] =  i:1
 135 Insert           4   42   43               08 intkey=r[43] data=r[42]
REG[42] =  sx7[0217656C766973|..elvis]
REG[43] =  i:1
 136 Return          40    0    0               00 end t4
REG[40] =  i:136
 137 Integer        140   44    0               00 r[44]=140
REG[44] =  i:140
 138 Once             0  140    0               00 materialize "t4"
 139 OpenDup          5    4    0               00 
 140 Return          44    0    0               00 end t4
REG[44] =  i:140
 141 Integer        144   45    0               00 r[45]=144
REG[45] =  i:144
 142 Once             0  144    0               00 materialize "t4"
 143 OpenDup          6    4    0               00 
 144 Return          45    0    0               00 end t4
REG[45] =  i:144
 145 Integer        148   46    0               00 r[46]=148
REG[46] =  i:148
 146 Once             0  148    0               00 materialize "t4"
 147 OpenDup          8    4    0               00 
 148 Return          46    0    0               00 end t4
REG[46] =  i:148
 149 Integer        152   47    0               00 r[47]=152
REG[47] =  i:152
 150 Once             0  152    0               00 materialize "t4"
 151 OpenDup          9    4    0               00 
 152 Return          47    0    0               00 end t4
REG[47] =  i:152
 153 Integer        156   48    0               00 r[48]=156
REG[48] =  i:156
 154 Once             0  156    0               00 materialize "t4"
 155 OpenDup         10    4    0               00 
 156 Return          48    0    0               00 end t4
REG[48] =  i:156
 157 Integer          1   49    0               00 r[49]=1; LIMIT counter
REG[49] =  i:1
 158 Ne              24  190   12 (BINARY)      50 if r[12]!=r[24] goto 190
REG[24] =  i:1
REG[12] =  i:1
 159 Ne              24  190   12 (BINARY)      50 if r[12]!=r[24] goto 190
REG[24] =  i:1
REG[12] =  i:1
 160 Explain        160  125    0 SCAN SUBQUERY 2 AS t4a 00 
 161 Rewind           4  190    0               00 
 162 Explain        162  125    0 SCAN SUBQUERY 2 AS t4b 00 
 163 Rewind           5  190    0               00 
 164 Explain        164  125    0 SCAN SUBQUERY 2 AS t4c 00 
 165 Integer          0   51    0               00 r[51]=0; init LEFT JOIN no-match flag
REG[51] =  i:0
 166 Rewind           6  185    0               00 
 167 Integer          1   51    0               00 r[51]=1; record LEFT JOIN hit
REG[51] =  i:1
 168 Explain        168  125    0 SCAN SUBQUERY 2 AS t4a 00 
 169 Rewind           8  185    0               00 
 170 Explain        170  125    0 SCAN SUBQUERY 2 AS t4b 00 
 171 Rewind           9  185    0               00 
 172 Explain        172  125    0 SCAN SUBQUERY 2 AS t4c 00 
 173 Integer          0   52    0               00 r[52]=0; init LEFT JOIN no-match flag
REG[52] =  i:0
 174 Rewind          10  179    0               00 
 175 Integer          1   52    0               00 r[52]=1; record LEFT JOIN hit
REG[52] =  i:1
 176 Column           4    0   39               00 r[39]=t4.d
REG[39] =   s5[elvis](8)
 177 DecrJumpZero    49  190    0               00 if (--r[49])==0 goto 190
REG[49] =  i:1
 190 Copy            39    8    0               00 r[8]=r[39]
REG[8] =   s5[elvis](8)
 191 DecrJumpZero    11  121    0               00 if (--r[11])==0 goto 121
REG[11] =  i:1
 121 Integer          1   14    0               00 r[14]=1; set abort flag
REG[14] =  i:1
 122 Return          15    0    0               00 
REG[15] =  i:119
 120 Goto             0  196    0               00 
 196 Return           7    0    0               00 
REG[7] =  i:196
 197 SCopy            8    6    0               00 r[6]=r[8]
REG[6] =   e5[elvis](8)
 198 Compare          5    6    1 k(1,B)        00 r[5] <-> r[6]
REG[5] =  NULL
REG[6] =   e5[elvis](8)
 199 Jump           200  204  200               00 
 200 Move             6    5    1               00 r[5]=r[6]
REG[5] =   s5[elvis](8)
 201 Gosub            3  209    0               00 output one row
REG[3] =  i:201
 209 IfPos            1  211    0               00 if r[1]>0 then r[1]-=0, goto 211; Groupby result generator entry point
REG[1] =  i:0
 210 Return           3    0    0               00 
REG[3] =  i:201
 202 IfPos            2  407    0               00 if r[2]>0 then r[2]-=0, goto 407; check abort flag
REG[2] =  i:0
 203 Gosub            4  405    0               00 reset accumulator
REG[4] =  i:203
 405 Integer          0    1    0               00 r[1]=0; indicate accumulator empty
REG[1] =  i:0
 406 Return           4    0    0               00 
REG[4] =  i:203
 204 Integer          1    1    0               00 r[1]=1; indicate data in accumulator
REG[1] =  i:1
 205 Gosub            3  209    0               00 output final row
REG[3] =  i:205
 209 IfPos            1  211    0               00 if r[1]>0 then r[1]-=0, goto 211; Groupby result generator entry point
REG[1] =  i:1
 211 Integer        401   54    0               00 r[54]=401; return address
REG[54] =  i:401
 212 Once             0  401    0               00 
 213 Explain        213    0    0 SCALAR SUBQUERY 6 00 
 214 Null             0   55   55               00 r[55..55]=NULL; Init subquery result
REG[55] =  NULL
 215 InitCoroutine   56  221  216               00 t4a
 221 Integer          1   58    0               00 r[58]=1; LIMIT counter
REG[58] =  i:1
 222 SorterOpen      14    2    0 k(1,B)        00 
 223 Integer          0   61    0               00 r[61]=0; clear abort flag
REG[61] =  i:0
 224 Null             0   64   64               00 r[64..64]=NULL
REG[64] =  NULL
 225 Gosub           63  398    0               00 
REG[63] =  i:225
 398 Null             0   59   59               00 r[59..59]=NULL
REG[59] =  NULL
 399 Integer          0   60    0               00 r[60]=0; indicate accumulator empty
REG[60] =  i:0
 400 Return          63    0    0               00 
REG[63] =  i:225
 226 Explain        226  213    0 SCAN SUBQUERY 1 00 
 227 InitCoroutine   56    0  216               00 
 228 Yield           56  310    0               00 next row of t4a
REG[56] =  i:215
REG[56] =  i:228
 216 Explain        216  213    0 CO-ROUTINE 1  00 
 217 Explain        217  216    0 SCAN CONSTANT ROW 00 
 218 Integer          1   57    0               00 r[57]=1
REG[57] =  i:1
 219 Yield           56    0    0               00 
REG[56] =  i:228
REG[56] =  i:219
 229 Explain        229  213    0 USE TEMP B-TREE FOR GROUP BY 00 
 230 Explain        230  213    0 CORRELATED SCALAR SUBQUERY 5 00 
 231 Null             0   68   68               00 r[68..68]=NULL; Init subquery result
REG[68] =  NULL
 232 Integer        243   69    0               00 r[69]=243
REG[69] =  i:243
 233 Once             0  243    0               00 materialize "t4"
 234 Explain        234  230    0 MATERIALIZE 2 00 
 235 OpenEphemeral    4    1    0               00 nColumn=1
 236 Explain        236  234    0 SCAN CONSTANT ROW 00 
 237 Integer          1   70    0               00 r[70]=1
REG[70] =  i:1
 238 Ne              24  243   70 (BINARY)      50 if r[70]!=r[24] goto 243
REG[24] =  i:1
REG[70] =  i:1
 239 String8          0   71    0 elvis         00 r[71]='elvis'
REG[71] =   t5[elvis](8)
 240 MakeRecord      71    1   70               00 r[70]=mkrec(r[71])
REG[70] =  sx7[0217656C766973|..elvis]
 241 NewRowid         4   72    0               00 r[72]=rowid
REG[72] =  i:1
 242 Insert           4   70   72               08 intkey=r[72] data=r[70]
REG[70] =  sx7[0217656C766973|..elvis]
REG[72] =  i:1
 243 Return          69    0    0               00 end t4
REG[69] =  i:243
 244 Integer        247   73    0               00 r[73]=247
REG[73] =  i:247
 245 Once             0  247    0               00 materialize "t4"
 246 OpenDup          5    4    0               00 
 247 Return          73    0    0               00 end t4
REG[73] =  i:247
 248 Integer        257   74    0               00 r[74]=257
REG[74] =  i:257
 249 Once             0  257    0               00 materialize "t4"
 250 Explain        250  230    0 MATERIALIZE 2 00 
 251 OpenEphemeral    6    1    0               00 nColumn=1
 252 Explain        252  250    0 SCAN CONSTANT ROW 00 
 253 String8          0   75    0 elvis         00 r[75]='elvis'
REG[75] =   t5[elvis](8)
 254 MakeRecord      75    1   76               00 r[76]=mkrec(r[75])
REG[76] =  sx7[0217656C766973|..elvis]
 255 NewRowid         6   77    0               00 r[77]=rowid
REG[77] =  i:2
 256 Insert           6   76   77               08 intkey=r[77] data=r[76]
REG[76] =  sx7[0217656C766973|..elvis]
REG[77] =  i:2
 257 Return          74    0    0               00 end t4
REG[74] =  i:257
 258 Integer        261   78    0               00 r[78]=261
REG[78] =  i:261
 259 Once             0  261    0               00 materialize "t4"
 260 OpenDup          8    4    0               00 
 261 Return          78    0    0               00 end t4
REG[78] =  i:261
 262 Integer        265   79    0               00 r[79]=265
REG[79] =  i:265
 263 Once             0  265    0               00 materialize "t4"
 264 OpenDup          9    4    0               00 
 265 Return          79    0    0               00 end t4
REG[79] =  i:265
 266 Integer        269   80    0               00 r[80]=269
REG[80] =  i:269
 267 Once             0  269    0               00 materialize "t4"
 268 OpenDup         10    6    0               00 

Program received signal SIGABRT, Aborted.
__GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:50
(gdb) #0  __GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:50
#1  0x00007f66f9e0b859 in __GI_abort () at abort.c:79
#2  0x00007f66f9e0b729 in __assert_fail_base (fmt=0x7f66f9fa1588 "%s%s%s:%u: %s%sAssertion `%s' failed.\n%n", assertion=0x20438b "pOrig->pBtx!=0", file=0x2291f4 "sqlite3.c", line=87735, function=<optimized out>)
    at assert.c:92
#3  0x00007f66f9e1cfd6 in __GI___assert_fail (assertion=0x20438b "pOrig->pBtx!=0", file=0x2291f4 "sqlite3.c", line=87735, function=0x216a86 "int sqlite3VdbeExec(Vdbe *)") at assert.c:101
#4  0x00000000003d7d51 in sqlite3VdbeExec (p=0x23a69b0) at sqlite3.c:87735
#5  0x000000000041ba74 in sqlite3Step (p=0x23a69b0) at sqlite3.c:82300
#6  0x0000000000293d5d in sqlite3_step (pStmt=0x23a69b0) at sqlite3.c:82365
#7  0x0000000000258a39 in main (argc=1, argv=0x7fffc962dc38) at target.cc:139
(gdb) quit
A debugging session is active.

	Inferior 1 [process 43334] will be killed.

Quit anyway? (y or n) [answered Y; input not from terminal]
