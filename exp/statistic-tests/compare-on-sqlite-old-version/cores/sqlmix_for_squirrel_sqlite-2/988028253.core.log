GNU gdb (Ubuntu 9.2-0ubuntu1~20.04.1) 9.2
Copyright (C) 2020 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type "show copying" and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
    <http://www.gnu.org/software/gdb/documentation/>.

For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from /root/sqlite_driver_fast...
(gdb) Starting program: /root/sqlite_driver_fast < "/root/out/default/crashes/id:000164,sig:06,src:021594+009052,time:4109924,execs:750669,op:merge.so,pos:0"
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
SQL: [;PRAGMA vdbe_trace=on;]
VDBE Trace:
   0 Init             0    1    0               00 Start at 1
   1 Expire           0    0    0               00 
   2 Halt             0    0    0               00 
SQL: [;ATTACH 'attached-1.db' AS a1;]
VDBE Trace:
   0 Init             0    1    0               00 Start at 1
   1 String8          0    1    0 attached-1.db 00 r[1]='attached-1.db'
REG[1] =   t13[attached-1.db](8)
   2 String8          0    2    0 a1            00 r[2]='a1'
REG[2] =   t2[a1](8)
   3 Null             0    3    0               00 r[3]=NULL
REG[3] =  NULL
   4 Function0        0    1    4 sqlite_attach(3) 03 r[4]=func(r[1..3])
REG[1] =   t13[attached-1.db](8)
REG[2] =   t2[a1](8)
REG[3] =  NULL
VDBE Trace:
   0 Init             0   13    0               00 Start at 13
  13 Transaction      2    0    3 0             00 usesStmtJournal=0
  14 TableLock        2    1    0 sqlite_master 00 iDb=2 root=1 write=0
  15 Goto             0    1    0               00 
   1 Noop             1    7    0               00 
   2 OpenRead         0    1    2 5             00 root=1 iDb=2; sqlite_master
   3 Explain          3    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   12    0               00 
   5 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[table](8)
   6 Column           0    1    2               00 r[2]=sqlite_master.name
REG[2] =   s12[sqlite_stat1](8)
   7 Column           0    2    3               00 r[3]=sqlite_master.tbl_name
REG[3] =   s12[sqlite_stat1](8)
   8 Column           0    3    4               00 r[4]=sqlite_master.rootpage
REG[4] =  i:7
   9 Column           0    4    5               00 r[5]=sqlite_master.sql
REG[5] =   s39[CREATE TABLE sqlite_stat1](8)
  10 ResultRow        1    5    0               00 output=r[1..5]
REG[1] =   s5[table](8)
REG[2] =   s12[sqlite_stat1](8)
REG[3] =   s12[sqlite_stat1](8)
REG[4] =  i:7
REG[5] =   s39[CREATE TABLE sqlite_stat1](8)
  11 Next             0    5    0               01 
  12 Halt             0    0    0               00 
VDBE Trace:
   0 Init             0   10    0               00 Start at 10
  10 Transaction      2    0    3 0             00 usesStmtJournal=0
  11 TableLock        2    7    0 sqlite_stat1  00 iDb=2 root=7 write=0
  12 Goto             0    1    0               00 
   1 OpenRead         0    7    2 3             00 root=7 iDb=2; sqlite_stat1
   2 Explain          2    0    0 SCAN TABLE sqlite_stat1 00 
   3 Rewind           0    9    0               00 
   9 Halt             0    0    0               00 
REG[4] =  NULL
   5 Expire           1    0    0               00 
   6 Halt             0    0    0               00 
SQL: [SELECT*FROM"a1".sqlite_master ORDER BY rowid
;]
VDBE Trace:
   0 Init             0   13    0               00 Start at 13
  13 Transaction      2    0    3 0             01 usesStmtJournal=0
  14 TableLock        2    1    0 sqlite_master 00 iDb=2 root=1 write=0
  15 Goto             0    1    0               00 
   1 Noop             1    7    0               00 
   2 OpenRead         0    1    2 5             00 root=1 iDb=2; sqlite_master
   3 Explain          3    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   12    0               00 
   5 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[table](8)
   6 Column           0    1    2               00 r[2]=sqlite_master.name
REG[2] =   s12[sqlite_stat1](8)
   7 Column           0    2    3               00 r[3]=sqlite_master.tbl_name
REG[3] =   s12[sqlite_stat1](8)
   8 Column           0    3    4               00 r[4]=sqlite_master.rootpage
REG[4] =  i:7
   9 Column           0    4    5               00 r[5]=sqlite_master.sql
REG[5] =   s39[CREATE TABLE sqlite_stat1](8)
  10 ResultRow        1    5    0               00 output=r[1..5]
REG[1] =   s5[table](8)
REG[2] =   s12[sqlite_stat1](8)
REG[3] =   s12[sqlite_stat1](8)
REG[4] =  i:7
REG[5] =   s39[CREATE TABLE sqlite_stat1](8)
  11 Next             0    5    0               01 
  12 Halt             0    0    0               00 
SQL: [PRAGMA a1.journal_mode=WAL;]
VDBE Trace:
   0 Init             0    1    0               00 Start at 1
   1 JournalMode      2    1    5               00 
REG[1] =   t3[wal](8)
   2 ResultRow        1    1    0               00 output=r[1]
REG[1] =   t3[wal](8)
   3 Halt             0    0    0               00 
SQL: [;DELETE FROM a;]
VDBE Trace:
   0 Init             0    3    0               00 Start at 3
   3 Transaction      0    1    4 0             01 usesStmtJournal=0
   4 Goto             0    1    0               00 
   1 Clear            4    0   -1 a             00 
   2 Halt             0    0    0               00 
SQL: [;ATTACH 'attached-4.db' AS a4;]
VDBE Trace:
   0 Init             0    1    0               00 Start at 1
   1 String8          0    1    0 attached-4.db 00 r[1]='attached-4.db'
REG[1] =   t13[attached-4.db](8)
   2 String8          0    2    0 a4            00 r[2]='a4'
REG[2] =   t2[a4](8)
   3 Null             0    3    0               00 r[3]=NULL
REG[3] =  NULL
   4 Function0        0    1    4 sqlite_attach(3) 03 r[4]=func(r[1..3])
REG[1] =   t13[attached-4.db](8)
REG[2] =   t2[a4](8)
REG[3] =  NULL
VDBE Trace:
   0 Init             0   13    0               00 Start at 13
  13 Transaction      3    0    3 0             00 usesStmtJournal=0
  14 TableLock        3    1    0 sqlite_master 00 iDb=3 root=1 write=0
  15 Goto             0    1    0               00 
   1 Noop             1    7    0               00 
   2 OpenRead         0    1    3 5             00 root=1 iDb=3; sqlite_master
   3 Explain          3    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   12    0               00 
   5 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[table](8)
   6 Column           0    1    2               00 r[2]=sqlite_master.name
REG[2] =   s12[sqlite_stat1](8)
   7 Column           0    2    3               00 r[3]=sqlite_master.tbl_name
REG[3] =   s12[sqlite_stat1](8)
   8 Column           0    3    4               00 r[4]=sqlite_master.rootpage
REG[4] =  i:3
   9 Column           0    4    5               00 r[5]=sqlite_master.sql
REG[5] =   s39[CREATE TABLE sqlite_stat1](8)
  10 ResultRow        1    5    0               00 output=r[1..5]
REG[1] =   s5[table](8)
REG[2] =   s12[sqlite_stat1](8)
REG[3] =   s12[sqlite_stat1](8)
REG[4] =  i:3
REG[5] =   s39[CREATE TABLE sqlite_stat1](8)
  11 Next             0    5    0               01 
  12 Halt             0    0    0               00 
VDBE Trace:
   0 Init             0   10    0               00 Start at 10
  10 Transaction      3    0    3 0             00 usesStmtJournal=0
  11 TableLock        3    3    0 sqlite_stat1  00 iDb=3 root=3 write=0
  12 Goto             0    1    0               00 
   1 OpenRead         0    3    3 3             00 root=3 iDb=3; sqlite_stat1
   2 Explain          2    0    0 SCAN TABLE sqlite_stat1 00 
   3 Rewind           0    9    0               00 
   9 Halt             0    0    0               00 
REG[4] =  NULL
   5 Expire           1    0    0               00 
   6 Halt             0    0    0               00 
SQL: [SELECT*FROM"a4".sqlite_master WHERE tbl_name='a' AND type!='trigger' ORDER BY rowid
;]
VDBE Trace:
   0 Init             0   17    0               00 Start at 17
  17 Transaction      3    0    3 0             01 usesStmtJournal=0
  18 TableLock        3    1    0 sqlite_master 00 iDb=3 root=1 write=0
  19 String8          0    2    0 a             00 r[2]='a'
REG[2] =   t1[a](8)
  20 String8          0    3    0 trigger       00 r[3]='trigger'
REG[3] =   t7[trigger](8)
  21 Goto             0    1    0               00 
   1 Noop             1    7    0               00 
   2 OpenRead         0    1    3 5             00 root=1 iDb=3; sqlite_master
   3 Explain          3    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   16    0               00 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s12[sqlite_stat1](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t1[a](8)
REG[1] =   s12[sqlite_stat1](8)
  15 Next             0    5    0               01 
  16 Halt             0    0    0               00 
SQL: [;DELETE FROM x;]
VDBE Trace:
   0 Init             0    4    0               00 Start at 4
   4 Transaction      0    1    4 0             01 usesStmtJournal=0
   5 Goto             0    1    0               00 
   1 Clear            2    0   -1 x             00 
   2 Clear            3    0    0               00 
   3 Halt             0    0    0               00 
SQL: [;
;WITH t5(t5col1) AS (
    SELECT (
      WITH t3(t3col1) AS (
        WITH t2 AS (
          WITH a AS (SELECT 1 AS c1 GROUP BY 1) 
          SELECT a.c1 FROM a AS a, a AS b
          WHERE anoncol1 = 1
        )
        SELECT (SELECT 1 FROM t2) FROM t2
      ) 
      SELECT t3col1 FROM t3 WHERE t3col1
    ) FROM (SELECT 1 AS anoncol1)
  )
  SELECT t5col1, t5col1 FROM t5

;]
VDBE Trace:
   0 Init             0  367    0               00 Start at 367
 367 Integer          1   19    0               00 r[19]=1
REG[19] =  i:1
 368 Goto             0    1    0               00 
   1 InitCoroutine    1    7    2               00 subquery_6
   7 Explain          7    0    0 SCAN SUBQUERY 6 00 
   8 InitCoroutine    1    0    2               00 
   9 Yield            1  366    0               00 next row of subquery_6
REG[1] =  i:1
REG[1] =  i:9
   2 Explain          2    0    0 CO-ROUTINE 6  00 
   3 Explain          3    2    0 SCAN CONSTANT ROW 00 
   4 Integer          1    2    0               00 r[2]=1
REG[2] =  i:1
   5 Yield            1    0    0               00 
REG[1] =  i:9
REG[1] =  i:5
  10 Explain         10    0    0 CORRELATED SCALAR SUBQUERY 5 00 
  11 Null             0    5    5               00 r[5..5]=NULL; Init subquery result
REG[5] =  NULL
  12 Integer         42    6    0               00 r[6]=42
REG[6] =  i:42
  13 Once             0   42    0               00 materialize "a"
  14 Explain         14   10    0 MATERIALIZE 1 00 
  15 OpenEphemeral    4    1    0               00 nColumn=1
  16 Noop             9    1    0               00 
  17 Integer          0    8    0               00 r[8]=0; clear abort flag
REG[8] =  i:0
  18 Null             0   11   11               00 r[11..11]=NULL
REG[11] =  NULL
  19 Gosub           10   40    0               00 
REG[10] =  i:19
  40 Integer          0    7    0               00 r[7]=0; indicate accumulator empty
REG[7] =  i:0
  41 Return          10    0    0               00 
REG[10] =  i:19
  20 Explain         20   14    0 SCAN CONSTANT ROW 00 
  21 Integer          1   12    0               00 r[12]=1
REG[12] =  i:1
  22 Compare         11   12    1 k(1,B)        00 r[11] <-> r[12]
REG[11] =  NULL
REG[12] =  i:1
  23 Jump            24   28   24               00 
  24 Move            12   11    1               00 r[11]=r[12]
REG[11] =  i:1
  25 Gosub            9   33    0               00 output one row
REG[9] =  i:25
  33 IfPos            7   35    0               00 if r[7]>0 then r[7]-=0, goto 35; Groupby result generator entry point
REG[7] =  i:0
  34 Return           9    0    0               00 
REG[9] =  i:25
  26 IfPos            8   42    0               00 if r[8]>0 then r[8]-=0, goto 42; check abort flag
REG[8] =  i:0
  27 Gosub           10   40    0               00 reset accumulator
REG[10] =  i:27
  40 Integer          0    7    0               00 r[7]=0; indicate accumulator empty
REG[7] =  i:0
  41 Return          10    0    0               00 
REG[10] =  i:27
  28 Integer          1    7    0               00 r[7]=1; indicate data in accumulator
REG[7] =  i:1
  29 Gosub            9   33    0               00 output final row
REG[9] =  i:29
  33 IfPos            7   35    0               00 if r[7]>0 then r[7]-=0, goto 35; Groupby result generator entry point
REG[7] =  i:1
  35 Integer          1   13    0               00 r[13]=1
REG[13] =  i:1
  36 MakeRecord      13    1   14               00 r[14]=mkrec(r[13])
REG[14] =  sx2[0209|..]
  37 NewRowid         4   15    0               00 r[15]=rowid
REG[15] =  i:1
  38 Insert           4   14   15               08 intkey=r[15] data=r[14]
REG[14] =  sx2[0209|..]
REG[15] =  i:1
  39 Return           9    0    0               00 end groupby result generator
REG[9] =  i:29
  30 Goto             0   42    0               00 
  42 Return           6    0    0               00 end a
REG[6] =  i:42
  43 Integer         46   16    0               00 r[16]=46
REG[16] =  i:46
  44 Once             0   46    0               00 materialize "a"
  45 OpenDup          5    4    0               00 
  46 Return          16    0    0               00 end a
REG[16] =  i:46
  47 Integer          1   17    0               00 r[17]=1; LIMIT counter
REG[17] =  i:1
  48 Copy             2   18    0               00 r[18]=r[2]; subquery_6.anoncol1
REG[18] =  i:1
  49 Ne              19  186   18 (BINARY)      50 if r[18]!=r[19] goto 186
REG[19] =  i:1
REG[18] =  i:1
  50 Explain         50   10    0 SCAN SUBQUERY 1 AS a 00 
  51 Rewind           4  186    0               00 
  52 Explain         52   10    0 CORRELATED SCALAR SUBQUERY 3 00 
  53 Null             0   20   20               00 r[20..20]=NULL; Init subquery result
REG[20] =  NULL
  54 Integer         86   21    0               00 r[21]=86
REG[21] =  i:86
  55 Once             0   86    0               00 materialize "a"
  56 Explain         56   52    0 MATERIALIZE 1 00 
  57 OpenEphemeral    7    1    0               00 nColumn=1
  58 Noop            10    1    0               00 
  59 Integer          0   23    0               00 r[23]=0; clear abort flag
REG[23] =  i:0
  60 Null             0   26   26               00 r[26..26]=NULL
REG[26] =  NULL
  61 Gosub           25   84    0               00 
REG[25] =  i:61
  84 Integer          0   22    0               00 r[22]=0; indicate accumulator empty
REG[22] =  i:0
  85 Return          25    0    0               00 
REG[25] =  i:61
  62 Explain         62   56    0 SCAN CONSTANT ROW 00 
  63 Integer          1   28    0               00 r[28]=1
REG[28] =  i:1
  64 Ne              19   73   28 (BINARY)      50 if r[28]!=r[19] goto 73
REG[19] =  i:1
REG[28] =  i:1
  65 Integer          1   27    0               00 r[27]=1
REG[27] =  i:1
  66 Compare         26   27    1 k(1,B)        00 r[26] <-> r[27]
REG[26] =  NULL
REG[27] =  i:1
  67 Jump            68   72   68               00 
  68 Move            27   26    1               00 r[26]=r[27]
REG[26] =  i:1
  69 Gosub           24   77    0               00 output one row
REG[24] =  i:69
  77 IfPos           22   79    0               00 if r[22]>0 then r[22]-=0, goto 79; Groupby result generator entry point
REG[22] =  i:0
  78 Return          24    0    0               00 
REG[24] =  i:69
  70 IfPos           23   86    0               00 if r[23]>0 then r[23]-=0, goto 86; check abort flag
REG[23] =  i:0
  71 Gosub           25   84    0               00 reset accumulator
REG[25] =  i:71
  84 Integer          0   22    0               00 r[22]=0; indicate accumulator empty
REG[22] =  i:0
  85 Return          25    0    0               00 
REG[25] =  i:71
  72 Integer          1   22    0               00 r[22]=1; indicate data in accumulator
REG[22] =  i:1
  73 Gosub           24   77    0               00 output final row
REG[24] =  i:73
  77 IfPos           22   79    0               00 if r[22]>0 then r[22]-=0, goto 79; Groupby result generator entry point
REG[22] =  i:1
  79 Integer          1   29    0               00 r[29]=1
REG[29] =  i:1
  80 MakeRecord      29    1   28               00 r[28]=mkrec(r[29])
REG[28] =  sx2[0209|..]
  81 NewRowid         7   30    0               00 r[30]=rowid
REG[30] =  i:1
  82 Insert           7   28   30               08 intkey=r[30] data=r[28]
REG[28] =  sx2[0209|..]
REG[30] =  i:1
  83 Return          24    0    0               00 end groupby result generator
REG[24] =  i:73
  74 Goto             0   86    0               00 
  86 Return          21    0    0               00 end a
REG[21] =  i:86
  87 Integer        119   31    0               00 r[31]=119
REG[31] =  i:119
  88 Once             0  119    0               00 materialize "a"
  89 Explain         89   52    0 MATERIALIZE 1 00 
  90 OpenEphemeral    8    1    0               00 nColumn=1
  91 Noop            11    1    0               00 
  92 Integer          0   33    0               00 r[33]=0; clear abort flag
REG[33] =  i:0
  93 Null             0   36   36               00 r[36..36]=NULL
REG[36] =  NULL
  94 Gosub           35  117    0               00 
REG[35] =  i:94
 117 Integer          0   32    0               00 r[32]=0; indicate accumulator empty
REG[32] =  i:0
 118 Return          35    0    0               00 
REG[35] =  i:94
  95 Explain         95   89    0 SCAN CONSTANT ROW 00 
  96 Integer          1   38    0               00 r[38]=1
REG[38] =  i:1
  97 Ne              19  106   38 (BINARY)      50 if r[38]!=r[19] goto 106
REG[19] =  i:1
REG[38] =  i:1
  98 Integer          1   37    0               00 r[37]=1
REG[37] =  i:1
  99 Compare         36   37    1 k(1,B)        00 r[36] <-> r[37]
REG[36] =  NULL
REG[37] =  i:1
 100 Jump           101  105  101               00 
 101 Move            37   36    1               00 r[36]=r[37]
REG[36] =  i:1
 102 Gosub           34  110    0               00 output one row
REG[34] =  i:102
 110 IfPos           32  112    0               00 if r[32]>0 then r[32]-=0, goto 112; Groupby result generator entry point
REG[32] =  i:0
 111 Return          34    0    0               00 
REG[34] =  i:102
 103 IfPos           33  119    0               00 if r[33]>0 then r[33]-=0, goto 119; check abort flag
REG[33] =  i:0
 104 Gosub           35  117    0               00 reset accumulator
REG[35] =  i:104
 117 Integer          0   32    0               00 r[32]=0; indicate accumulator empty
REG[32] =  i:0
 118 Return          35    0    0               00 
REG[35] =  i:104
 105 Integer          1   32    0               00 r[32]=1; indicate data in accumulator
REG[32] =  i:1
 106 Gosub           34  110    0               00 output final row
REG[34] =  i:106
 110 IfPos           32  112    0               00 if r[32]>0 then r[32]-=0, goto 112; Groupby result generator entry point
REG[32] =  i:1
 112 Integer          1   39    0               00 r[39]=1
REG[39] =  i:1
 113 MakeRecord      39    1   38               00 r[38]=mkrec(r[39])
REG[38] =  sx2[0209|..]
 114 NewRowid         8   40    0               00 r[40]=rowid
REG[40] =  i:1
 115 Insert           8   38   40               08 intkey=r[40] data=r[38]
REG[38] =  sx2[0209|..]
REG[40] =  i:1
 116 Return          34    0    0               00 end groupby result generator
REG[34] =  i:106
 107 Goto             0  119    0               00 
 119 Return          31    0    0               00 end a
REG[31] =  i:119
 120 Integer          1   41    0               00 r[41]=1; LIMIT counter
REG[41] =  i:1
 121 Integer          1   42    0               00 r[42]=1
REG[42] =  i:1
 122 Ne              19  131   42 (BINARY)      50 if r[42]!=r[19] goto 131
REG[19] =  i:1
REG[42] =  i:1
 123 Explain        123   52    0 SCAN SUBQUERY 1 AS a 00 
 124 Rewind           7  131    0               00 
 125 Explain        125   52    0 SCAN SUBQUERY 1 AS b 00 
 126 Rewind           8  131    0               00 
 127 Integer          1   20    0               00 r[20]=1
REG[20] =  i:1
 128 DecrJumpZero    41  131    0               00 if (--r[41])==0 goto 131
REG[41] =  i:1
 131 IfNot           20  185    1               00 
REG[20] =  i:1
 132 Explain        132   10    0 SCAN SUBQUERY 1 AS b 00 
 133 Rewind           5  186    0               00 
 134 Explain        134   10    0 CORRELATED SCALAR SUBQUERY 3 00 
 135 Null             0   43   43               00 r[43..43]=NULL; Init subquery result
REG[43] =  NULL
 136 Integer        166   44    0               00 r[44]=166
REG[44] =  i:166
 137 Once             0  166    0               00 materialize "a"
 138 Explain        138  134    0 MATERIALIZE 1 00 
 139 OpenEphemeral    7    1    0               00 nColumn=1
 140 Noop            12    1    0               00 
 141 Integer          0   46    0               00 r[46]=0; clear abort flag
REG[46] =  i:0
 142 Null             0   49   49               00 r[49..49]=NULL
REG[49] =  NULL
 143 Gosub           48  164    0               00 
REG[48] =  i:143
 164 Integer          0   45    0               00 r[45]=0; indicate accumulator empty
REG[45] =  i:0
 165 Return          48    0    0               00 
REG[48] =  i:143
 144 Explain        144  138    0 SCAN CONSTANT ROW 00 
 145 Integer          1   50    0               00 r[50]=1
REG[50] =  i:1
 146 Compare         49   50    1 k(1,B)        00 r[49] <-> r[50]
REG[49] =  NULL
REG[50] =  i:1
 147 Jump           148  152  148               00 
 148 Move            50   49    1               00 r[49]=r[50]
REG[49] =  i:1
 149 Gosub           47  157    0               00 output one row
REG[47] =  i:149
 157 IfPos           45  159    0               00 if r[45]>0 then r[45]-=0, goto 159; Groupby result generator entry point
REG[45] =  i:0
 158 Return          47    0    0               00 
REG[47] =  i:149
 150 IfPos           46  166    0               00 if r[46]>0 then r[46]-=0, goto 166; check abort flag
REG[46] =  i:0
 151 Gosub           48  164    0               00 reset accumulator
REG[48] =  i:151
 164 Integer          0   45    0               00 r[45]=0; indicate accumulator empty
REG[45] =  i:0
 165 Return          48    0    0               00 
REG[48] =  i:151
 152 Integer          1   45    0               00 r[45]=1; indicate data in accumulator
REG[45] =  i:1
 153 Gosub           47  157    0               00 output final row
REG[47] =  i:153
 157 IfPos           45  159    0               00 if r[45]>0 then r[45]-=0, goto 159; Groupby result generator entry point
REG[45] =  i:1
 159 Integer          1   51    0               00 r[51]=1
REG[51] =  i:1
 160 MakeRecord      51    1   18               00 r[18]=mkrec(r[51])
REG[18] =  sx2[0209|..]
 161 NewRowid         7   42    0               00 r[42]=rowid
REG[42] =  i:1
 162 Insert           7   18   42               08 intkey=r[42] data=r[18]
REG[18] =  sx2[0209|..]
REG[42] =  i:1
 163 Return          47    0    0               00 end groupby result generator
REG[47] =  i:153
 154 Goto             0  166    0               00 
 166 Return          44    0    0               00 end a
REG[44] =  i:166
 167 Integer        170   52    0               00 r[52]=170
REG[52] =  i:170
 168 Once             0  170    0               00 materialize "a"
 169 OpenDup          8    7    0               00 
 170 Return          52    0    0               00 end a
REG[52] =  i:170
 171 Integer          1   53    0               00 r[53]=1; LIMIT counter
REG[53] =  i:1
 172 Copy             2   54    0               00 r[54]=r[2]; subquery_6.anoncol1
REG[54] =  i:1
 173 Ne              19  182   54 (BINARY)      50 if r[54]!=r[19] goto 182
REG[19] =  i:1
REG[54] =  i:1
 174 Explain        174  134    0 SCAN SUBQUERY 1 AS a 00 
 175 Rewind           7  182    0               00 
 176 Explain        176  134    0 SCAN SUBQUERY 1 AS b 00 
 177 Rewind           8  182    0               00 
 178 Integer          1   43    0               00 r[43]=1
REG[43] =  i:1
 179 DecrJumpZero    53  182    0               00 if (--r[53])==0 goto 182
REG[53] =  i:1
 182 Copy            43    5    0               00 r[5]=r[43]
REG[5] =  i:1
 183 DecrJumpZero    17  186    0               00 if (--r[17])==0 goto 186
REG[17] =  i:1
 186 Copy             5    3    0               00 r[3]=r[5]
REG[3] =  i:1
 187 Explain        187    0    0 CORRELATED SCALAR SUBQUERY 5 00 
 188 Null             0   55   55               00 r[55..55]=NULL; Init subquery result
REG[55] =  NULL
 189 Integer        219   56    0               00 r[56]=219
REG[56] =  i:219
 190 Once             0  219    0               00 materialize "a"
 191 Explain        191  187    0 MATERIALIZE 1 00 
 192 OpenEphemeral    4    1    0               00 nColumn=1
 193 Noop            13    1    0               00 
 194 Integer          0   58    0               00 r[58]=0; clear abort flag
REG[58] =  i:0
 195 Null             0   61   61               00 r[61..61]=NULL
REG[61] =  NULL
 196 Gosub           60  217    0               00 
REG[60] =  i:196
 217 Integer          0   57    0               00 r[57]=0; indicate accumulator empty
REG[57] =  i:0
 218 Return          60    0    0               00 
REG[60] =  i:196
 197 Explain        197  191    0 SCAN CONSTANT ROW 00 
 198 Integer          1   62    0               00 r[62]=1
REG[62] =  i:1
 199 Compare         61   62    1 k(1,B)        00 r[61] <-> r[62]
REG[61] =  NULL
REG[62] =  i:1
 200 Jump           201  205  201               00 
 201 Move            62   61    1               00 r[61]=r[62]
REG[61] =  i:1
 202 Gosub           59  210    0               00 output one row
REG[59] =  i:202
 210 IfPos           57  212    0               00 if r[57]>0 then r[57]-=0, goto 212; Groupby result generator entry point
REG[57] =  i:0
 211 Return          59    0    0               00 
REG[59] =  i:202
 203 IfPos           58  219    0               00 if r[58]>0 then r[58]-=0, goto 219; check abort flag
REG[58] =  i:0
 204 Gosub           60  217    0               00 reset accumulator
REG[60] =  i:204
 217 Integer          0   57    0               00 r[57]=0; indicate accumulator empty
REG[57] =  i:0
 218 Return          60    0    0               00 
REG[60] =  i:204
 205 Integer          1   57    0               00 r[57]=1; indicate data in accumulator
REG[57] =  i:1
 206 Gosub           59  210    0               00 output final row
REG[59] =  i:206
 210 IfPos           57  212    0               00 if r[57]>0 then r[57]-=0, goto 212; Groupby result generator entry point
REG[57] =  i:1
 212 Integer          1   63    0               00 r[63]=1
REG[63] =  i:1
 213 MakeRecord      63    1   54               00 r[54]=mkrec(r[63])
REG[54] =  sx2[0209|..]
 214 NewRowid         4   64    0               00 r[64]=rowid
REG[64] =  i:1
 215 Insert           4   54   64               08 intkey=r[64] data=r[54]
REG[54] =  sx2[0209|..]
REG[64] =  i:1
 216 Return          59    0    0               00 end groupby result generator
REG[59] =  i:206
 207 Goto             0  219    0               00 
 219 Return          56    0    0               00 end a
REG[56] =  i:219
 220 Integer        223   65    0               00 r[65]=223
REG[65] =  i:223
 221 Once             0  223    0               00 materialize "a"
 222 OpenDup          5    4    0               00 
 223 Return          65    0    0               00 end a
REG[65] =  i:223
 224 Integer          1   66    0               00 r[66]=1; LIMIT counter
REG[66] =  i:1
 225 Copy             2   67    0               00 r[67]=r[2]; subquery_6.anoncol1
REG[67] =  i:1
 226 Ne              19  363   67 (BINARY)      50 if r[67]!=r[19] goto 363
REG[19] =  i:1
REG[67] =  i:1
 227 Explain        227  187    0 SCAN SUBQUERY 1 AS a 00 
 228 Rewind           4  363    0               00 
 229 Explain        229  187    0 CORRELATED SCALAR SUBQUERY 3 00 
 230 Null             0   68   68               00 r[68..68]=NULL; Init subquery result
REG[68] =  NULL
 231 Integer        263   69    0               00 r[69]=263
REG[69] =  i:263
 232 Once             0  263    0               00 materialize "a"
 233 Explain        233  229    0 MATERIALIZE 1 00 
 234 OpenEphemeral    7    1    0               00 nColumn=1
 235 Noop            14    1    0               00 
 236 Integer          0   71    0               00 r[71]=0; clear abort flag
REG[71] =  i:0
 237 Null             0   74   74               00 r[74..74]=NULL
REG[74] =  NULL
 238 Gosub           73  261    0               00 
REG[73] =  i:238
 261 Integer          0   70    0               00 r[70]=0; indicate accumulator empty
REG[70] =  i:0
 262 Return          73    0    0               00 
REG[73] =  i:238
 239 Explain        239  233    0 SCAN CONSTANT ROW 00 
 240 Integer          1   76    0               00 r[76]=1
REG[76] =  i:1
 241 Ne              19  250   76 (BINARY)      50 if r[76]!=r[19] goto 250
REG[19] =  i:1
REG[76] =  i:1
 242 Integer          1   75    0               00 r[75]=1
REG[75] =  i:1
 243 Compare         74   75    1 k(1,B)        00 r[74] <-> r[75]
REG[74] =  NULL
REG[75] =  i:1
 244 Jump           245  249  245               00 
 245 Move            75   74    1               00 r[74]=r[75]
REG[74] =  i:1
 246 Gosub           72  254    0               00 output one row
REG[72] =  i:246
 254 IfPos           70  256    0               00 if r[70]>0 then r[70]-=0, goto 256; Groupby result generator entry point
REG[70] =  i:0
 255 Return          72    0    0               00 
REG[72] =  i:246
 247 IfPos           71  263    0               00 if r[71]>0 then r[71]-=0, goto 263; check abort flag
REG[71] =  i:0
 248 Gosub           73  261    0               00 reset accumulator
REG[73] =  i:248
 261 Integer          0   70    0               00 r[70]=0; indicate accumulator empty
REG[70] =  i:0
 262 Return          73    0    0               00 
REG[73] =  i:248
 249 Integer          1   70    0               00 r[70]=1; indicate data in accumulator
REG[70] =  i:1
 250 Gosub           72  254    0               00 output final row
REG[72] =  i:250
 254 IfPos           70  256    0               00 if r[70]>0 then r[70]-=0, goto 256; Groupby result generator entry point
REG[70] =  i:1
 256 Integer          1   77    0               00 r[77]=1
REG[77] =  i:1
 257 MakeRecord      77    1   76               00 r[76]=mkrec(r[77])
REG[76] =  sx2[0209|..]
 258 NewRowid         7   78    0               00 r[78]=rowid
REG[78] =  i:1
 259 Insert           7   76   78               08 intkey=r[78] data=r[76]
REG[76] =  sx2[0209|..]
REG[78] =  i:1
 260 Return          72    0    0               00 end groupby result generator
REG[72] =  i:250
 251 Goto             0  263    0               00 
 263 Return          69    0    0               00 end a
REG[69] =  i:263
 264 Integer        296   79    0               00 r[79]=296
REG[79] =  i:296
 265 Once             0  296    0               00 materialize "a"
 266 Explain        266  229    0 MATERIALIZE 1 00 
 267 OpenEphemeral    8    1    0               00 nColumn=1
 268 Noop            15    1    0               00 
 269 Integer          0   81    0               00 r[81]=0; clear abort flag
REG[81] =  i:0
 270 Null             0   84   84               00 r[84..84]=NULL
REG[84] =  NULL
 271 Gosub           83  294    0               00 
REG[83] =  i:271
 294 Integer          0   80    0               00 r[80]=0; indicate accumulator empty
REG[80] =  i:0
 295 Return          83    0    0               00 
REG[83] =  i:271
 272 Explain        272  266    0 SCAN CONSTANT ROW 00 
 273 Integer          1   86    0               00 r[86]=1
REG[86] =  i:1
 274 Ne              19  283   86 (BINARY)      50 if r[86]!=r[19] goto 283
REG[19] =  i:1
REG[86] =  i:1
 275 Integer          1   85    0               00 r[85]=1
REG[85] =  i:1
 276 Compare         84   85    1 k(1,B)        00 r[84] <-> r[85]
REG[84] =  NULL
REG[85] =  i:1
 277 Jump           278  282  278               00 
 278 Move            85   84    1               00 r[84]=r[85]
REG[84] =  i:1
 279 Gosub           82  287    0               00 output one row
REG[82] =  i:279
 287 IfPos           80  289    0               00 if r[80]>0 then r[80]-=0, goto 289; Groupby result generator entry point
REG[80] =  i:0
 288 Return          82    0    0               00 
REG[82] =  i:279
 280 IfPos           81  296    0               00 if r[81]>0 then r[81]-=0, goto 296; check abort flag
REG[81] =  i:0
 281 Gosub           83  294    0               00 reset accumulator
REG[83] =  i:281
 294 Integer          0   80    0               00 r[80]=0; indicate accumulator empty
REG[80] =  i:0
 295 Return          83    0    0               00 
REG[83] =  i:281
 282 Integer          1   80    0               00 r[80]=1; indicate data in accumulator
REG[80] =  i:1
 283 Gosub           82  287    0               00 output final row
REG[82] =  i:283
 287 IfPos           80  289    0               00 if r[80]>0 then r[80]-=0, goto 289; Groupby result generator entry point
REG[80] =  i:1
 289 Integer          1   87    0               00 r[87]=1
REG[87] =  i:1
 290 MakeRecord      87    1   86               00 r[86]=mkrec(r[87])
REG[86] =  sx2[0209|..]
 291 NewRowid         8   88    0               00 r[88]=rowid
REG[88] =  i:2
 292 Insert           8   86   88               08 intkey=r[88] data=r[86]
REG[86] =  sx2[0209|..]
REG[88] =  i:2
 293 Return          82    0    0               00 end groupby result generator
REG[82] =  i:283
 284 Goto             0  296    0               00 
 296 Return          79    0    0               00 end a
REG[79] =  i:296
 297 Integer          1   89    0               00 r[89]=1; LIMIT counter
REG[89] =  i:1
 298 Integer          1   90    0               00 r[90]=1
REG[90] =  i:1
 299 Ne              19  308   90 (BINARY)      50 if r[90]!=r[19] goto 308
REG[19] =  i:1
REG[90] =  i:1
 300 Explain        300  229    0 SCAN SUBQUERY 1 AS a 00 
 301 Rewind           7  308    0               00 
 302 Explain        302  229    0 SCAN SUBQUERY 1 AS b 00 
 303 Rewind           8  308    0               00 
 304 Integer          1   68    0               00 r[68]=1
REG[68] =  i:1
 305 DecrJumpZero    89  308    0               00 if (--r[89])==0 goto 308
REG[89] =  i:1
 308 IfNot           68  362    1               00 
REG[68] =  i:1
 309 Explain        309  187    0 SCAN SUBQUERY 1 AS b 00 
 310 Rewind           5  363    0               00 
 311 Explain        311  187    0 CORRELATED SCALAR SUBQUERY 3 00 
 312 Null             0   91   91               00 r[91..91]=NULL; Init subquery result
REG[91] =  NULL
 313 Integer        343   92    0               00 r[92]=343
REG[92] =  i:343
 314 Once             0  343    0               00 materialize "a"
 315 Explain        315  311    0 MATERIALIZE 1 00 
 316 OpenEphemeral    7    1    0               00 nColumn=1
 317 Noop            16    1    0               00 
 318 Integer          0   94    0               00 r[94]=0; clear abort flag
REG[94] =  i:0
 319 Null             0   97   97               00 r[97..97]=NULL
REG[97] =  NULL
 320 Gosub           96  341    0               00 
REG[96] =  i:320
 341 Integer          0   93    0               00 r[93]=0; indicate accumulator empty
REG[93] =  i:0
 342 Return          96    0    0               00 
REG[96] =  i:320
 321 Explain        321  315    0 SCAN CONSTANT ROW 00 
 322 Integer          1   98    0               00 r[98]=1
REG[98] =  i:1
 323 Compare         97   98    1 k(1,B)        00 r[97] <-> r[98]
REG[97] =  NULL
REG[98] =  i:1
 324 Jump           325  329  325               00 
 325 Move            98   97    1               00 r[97]=r[98]
REG[97] =  i:1
 326 Gosub           95  334    0               00 output one row
REG[95] =  i:326
 334 IfPos           93  336    0               00 if r[93]>0 then r[93]-=0, goto 336; Groupby result generator entry point
REG[93] =  i:0
 335 Return          95    0    0               00 
REG[95] =  i:326
 327 IfPos           94  343    0               00 if r[94]>0 then r[94]-=0, goto 343; check abort flag
REG[94] =  i:0
 328 Gosub           96  341    0               00 reset accumulator
REG[96] =  i:328
 341 Integer          0   93    0               00 r[93]=0; indicate accumulator empty
REG[93] =  i:0
 342 Return          96    0    0               00 
REG[96] =  i:328
 329 Integer          1   93    0               00 r[93]=1; indicate data in accumulator
REG[93] =  i:1
 330 Gosub           95  334    0               00 output final row
REG[95] =  i:330
 334 IfPos           93  336    0               00 if r[93]>0 then r[93]-=0, goto 336; Groupby result generator entry point
REG[93] =  i:1
 336 Integer          1   99    0               00 r[99]=1
REG[99] =  i:1
 337 MakeRecord      99    1   67               00 r[67]=mkrec(r[99])
REG[67] =  sx2[0209|..]
 338 NewRowid         7   90    0               00 r[90]=rowid
REG[90] =  i:1
 339 Insert           7   67   90               08 intkey=r[90] data=r[67]
REG[67] =  sx2[0209|..]
REG[90] =  i:1
 340 Return          95    0    0               00 end groupby result generator
REG[95] =  i:330
 331 Goto             0  343    0               00 
 343 Return          92    0    0               00 end a
REG[92] =  i:343
 344 Integer        347  100    0               00 r[100]=347
REG[100] =  i:347
 345 Once             0  347    0               00 materialize "a"
 346 OpenDup          8    7    0               00 
 347 Return         100    0    0               00 end a
REG[100] =  i:347
 348 Integer          1  101    0               00 r[101]=1; LIMIT counter
REG[101] =  i:1
 349 Copy             2  102    0               00 r[102]=r[2]; subquery_6.anoncol1
REG[102] =  i:1
 350 Ne              19  359  102 (BINARY)      50 if r[102]!=r[19] goto 359
REG[19] =  i:1
REG[102] =  i:1
 351 Explain        351  311    0 SCAN SUBQUERY 1 AS a 00 
 352 Rewind           7  359    0               00 
 353 Explain        353  311    0 SCAN SUBQUERY 1 AS b 00 
 354 Rewind           8  359    0               00 
 355 Integer          1   91    0               00 r[91]=1
REG[91] =  i:1
 356 DecrJumpZero   101  359    0               00 if (--r[101])==0 goto 359
REG[101] =  i:1
 359 Copy            91   55    0               00 r[55]=r[91]
REG[55] =  i:1
 360 DecrJumpZero    66  363    0               00 if (--r[66])==0 goto 363
REG[66] =  i:1
 363 Copy            55    4    0               00 r[4]=r[55]
REG[4] =  i:1
 364 ResultRow        3    2    0               00 output=r[3..4]
REG[3] =  i:1
REG[4] =  i:1
 365 Goto             0    9    0               00 
   9 Yield            1  366    0               00 next row of subquery_6
REG[1] =  i:5
REG[1] =  i:9
   6 EndCoroutine     1    0    0               00 
REG[1] =  i:9
 366 Halt             0    0    0               00 
SQL: [;
;SELECT (
    WITH a(a) AS (VALUES(1))
    SELECT (
      WITH t2(b) AS (
        WITH t3(c) AS (
          WITH t4(d) AS (VALUES('elvis'))
          SELECT t4a.d FROM t4 AS t4a JOIN t4 AS t4b LEFT JOIN t4 AS t4c
        )
        SELECT c FROM t3 WHERE a = 1
      )
      SELECT t2a.b FROM t2 AS t2a JOIN t2 AS t2x
    )
    FROM a GROUP BY 1
  )
  GROUP BY 1;]
VDBE Trace:
   0 Init             0  408    0               00 Start at 408
 408 Integer          1   24    0               00 r[24]=1
REG[24] =  i:1
 409 Goto             0    1    0               00 
   1 Noop            11    1    0               00 
   2 Integer          0    2    0               00 r[2]=0; clear abort flag
REG[2] =  i:0
   3 Null             0    5    5               00 r[5..5]=NULL
REG[5] =  NULL
   4 Gosub            4  405    0               00 
REG[4] =  i:4
 405 Integer          0    1    0               00 r[1]=0; indicate accumulator empty
REG[1] =  i:0
 406 Return           4    0    0               00 
REG[4] =  i:4
   5 Explain          5    0    0 SCAN CONSTANT ROW 00 
   6 Integer        196    7    0               00 r[7]=196; return address
REG[7] =  i:196
   7 Once             0  196    0               00 
   8 Explain          8    0    0 SCALAR SUBQUERY 6 00 
   9 Null             0    8    8               00 r[8..8]=NULL; Init subquery result
REG[8] =  NULL
  10 InitCoroutine    9   16   11               00 a
  16 Integer          1   11    0               00 r[11]=1; LIMIT counter
REG[11] =  i:1
  17 SorterOpen      12    2    0 k(1,B)        00 
  18 Integer          0   14    0               00 r[14]=0; clear abort flag
REG[14] =  i:0
  19 Null             0   17   17               00 r[17..17]=NULL
REG[17] =  NULL
  20 Gosub           16  193    0               00 
REG[16] =  i:20
 193 Null             0   12   12               00 r[12..12]=NULL
REG[12] =  NULL
 194 Integer          0   13    0               00 r[13]=0; indicate accumulator empty
REG[13] =  i:0
 195 Return          16    0    0               00 
REG[16] =  i:20
  21 Explain         21    8    0 SCAN SUBQUERY 1 00 
  22 InitCoroutine    9    0   11               00 
  23 Yield            9  105    0               00 next row of a
REG[9] =  i:10
REG[9] =  i:23
  11 Explain         11    8    0 CO-ROUTINE 1  00 
  12 Explain         12   11    0 SCAN CONSTANT ROW 00 
  13 Integer          1   10    0               00 r[10]=1
REG[10] =  i:1
  14 Yield            9    0    0               00 
REG[9] =  i:23
REG[9] =  i:14
  24 Explain         24    8    0 USE TEMP B-TREE FOR GROUP BY 00 
  25 Explain         25    8    0 CORRELATED SCALAR SUBQUERY 5 00 
  26 Null             0   21   21               00 r[21..21]=NULL; Init subquery result
REG[21] =  NULL
  27 Integer         38   22    0               00 r[22]=38
REG[22] =  i:38
  28 Once             0   38    0               00 materialize "t4"
  29 Explain         29   25    0 MATERIALIZE 2 00 
  30 OpenEphemeral    4    1    0               00 nColumn=1
  31 Explain         31   29    0 SCAN CONSTANT ROW 00 
  32 Integer          1   23    0               00 r[23]=1
REG[23] =  i:1
  33 Ne              24   38   23 (BINARY)      50 if r[23]!=r[24] goto 38
REG[24] =  i:1
REG[23] =  i:1
  34 String8          0   25    0 elvis         00 r[25]='elvis'
REG[25] =   t5[elvis](8)
  35 MakeRecord      25    1   23               00 r[23]=mkrec(r[25])
REG[23] =  sx7[0217656C766973|..elvis]
  36 NewRowid         4   26    0               00 r[26]=rowid
REG[26] =  i:1
  37 Insert           4   23   26               08 intkey=r[26] data=r[23]
REG[23] =  sx7[0217656C766973|..elvis]
REG[26] =  i:1
  38 Return          22    0    0               00 end t4
REG[22] =  i:38
  39 Integer         42   27    0               00 r[27]=42
REG[27] =  i:42
  40 Once             0   42    0               00 materialize "t4"
  41 OpenDup          5    4    0               00 
  42 Return          27    0    0               00 end t4
REG[27] =  i:42
  43 Integer         52   28    0               00 r[28]=52
REG[28] =  i:52
  44 Once             0   52    0               00 materialize "t4"
  45 Explain         45   25    0 MATERIALIZE 2 00 
  46 OpenEphemeral    6    1    0               00 nColumn=1
  47 Explain         47   45    0 SCAN CONSTANT ROW 00 
  48 String8          0   29    0 elvis         00 r[29]='elvis'
REG[29] =   t5[elvis](8)
  49 MakeRecord      29    1   30               00 r[30]=mkrec(r[29])
REG[30] =  sx7[0217656C766973|..elvis]
  50 NewRowid         6   31    0               00 r[31]=rowid
REG[31] =  i:1
  51 Insert           6   30   31               08 intkey=r[31] data=r[30]
REG[30] =  sx7[0217656C766973|..elvis]
REG[31] =  i:1
  52 Return          28    0    0               00 end t4
REG[28] =  i:52
  53 Integer         56   32    0               00 r[32]=56
REG[32] =  i:56
  54 Once             0   56    0               00 materialize "t4"
  55 OpenDup          8    4    0               00 
  56 Return          32    0    0               00 end t4
REG[32] =  i:56
  57 Integer         60   33    0               00 r[33]=60
REG[33] =  i:60
  58 Once             0   60    0               00 materialize "t4"
  59 OpenDup          9    4    0               00 
  60 Return          33    0    0               00 end t4
REG[33] =  i:60
  61 Integer         64   34    0               00 r[34]=64
REG[34] =  i:64
  62 Once             0   64    0               00 materialize "t4"
  63 OpenDup         10    6    0               00 
  64 Return          34    0    0               00 end t4
REG[34] =  i:64
  65 Integer          1   35    0               00 r[35]=1; LIMIT counter
REG[35] =  i:1
  66 Integer          1   36    0               00 r[36]=1
REG[36] =  i:1
  67 Ne              24  100   36 (BINARY)      50 if r[36]!=r[24] goto 100
REG[24] =  i:1
REG[36] =  i:1
  68 Copy            10   36    0               00 r[36]=r[10]; a.a
REG[36] =  i:1
  69 Ne              24  100   36 (BINARY)      50 if r[36]!=r[24] goto 100
REG[24] =  i:1
REG[36] =  i:1
  70 Explain         70   25    0 SCAN SUBQUERY 2 AS t4a 00 
  71 Rewind           4  100    0               00 
  72 Explain         72   25    0 SCAN SUBQUERY 2 AS t4b 00 
  73 Rewind           5  100    0               00 
  74 Explain         74   25    0 SCAN SUBQUERY 2 AS t4c 00 
  75 Integer          0   37    0               00 r[37]=0; init LEFT JOIN no-match flag
REG[37] =  i:0
  76 Rewind           6   95    0               00 
  77 Integer          1   37    0               00 r[37]=1; record LEFT JOIN hit
REG[37] =  i:1
  78 Explain         78   25    0 SCAN SUBQUERY 2 AS t4a 00 
  79 Rewind           8   95    0               00 
  80 Explain         80   25    0 SCAN SUBQUERY 2 AS t4b 00 
  81 Rewind           9   95    0               00 
  82 Explain         82   25    0 SCAN SUBQUERY 2 AS t4c 00 
  83 Integer          0   38    0               00 r[38]=0; init LEFT JOIN no-match flag
REG[38] =  i:0
  84 Rewind          10   89    0               00 
  85 Integer          1   38    0               00 r[38]=1; record LEFT JOIN hit
REG[38] =  i:1
  86 Column           4    0   21               00 r[21]=t4.d
REG[21] =   s5[elvis](8)
  87 DecrJumpZero    35  100    0               00 if (--r[35])==0 goto 100
REG[35] =  i:1
 100 SCopy           21   19    0               00 r[19]=r[21]
REG[19] =   e5[elvis](8)
 101 Copy            10   20    0               00 r[20]=r[10]; a.a
REG[20] =  i:1
 102 MakeRecord      19    2   36               00 r[36]=mkrec(r[19..20])
REG[36] =  sx8[031709656C766973|...elvis]
 103 SorterInsert    12   36    0               00 key=r[36]
REG[36] =  sx8[031709656C766973|...elvis]
 104 Goto             0   23    0               00 
  23 Yield            9  105    0               00 next row of a
REG[9] =  i:14
REG[9] =  i:23
  15 EndCoroutine     9    0    0               00 
REG[9] =  i:23
 105 OpenPseudo      13   36    2               00 2 columns in r[36]
 106 SorterSort      12  196    0               00 GROUP BY sort
 107 SorterData      12   36   13               00 r[36]=data
 108 Column          13    0   18               00 r[18]=
REG[18] =   s5[elvis](8)
 109 Compare         17   18    1 k(1,B)        00 r[17] <-> r[18]
REG[17] =  NULL
REG[18] =   s5[elvis](8)
 110 Jump           111  115  111               00 
 111 Move            18   17    1               00 r[17]=r[18]
REG[17] =   s5[elvis](8)
 112 Gosub           15  123    0               00 output one row
REG[15] =  i:112
 123 IfPos           13  125    0               00 if r[13]>0 then r[13]-=0, goto 125; Groupby result generator entry point
REG[13] =  i:0
 124 Return          15    0    0               00 
REG[15] =  i:112
 113 IfPos           14  196    0               00 if r[14]>0 then r[14]-=0, goto 196; check abort flag
REG[14] =  i:0
 114 Gosub           16  193    0               00 reset accumulator
REG[16] =  i:114
 193 Null             0   12   12               00 r[12..12]=NULL
REG[12] =  NULL
 194 Integer          0   13    0               00 r[13]=0; indicate accumulator empty
REG[13] =  i:0
 195 Return          16    0    0               00 
REG[16] =  i:114
 115 If              13  117    0               00 
REG[13] =  i:0
 116 Column          13    1   12               00 r[12]=
REG[12] =  i:1
 117 Integer          1   13    0               00 r[13]=1; indicate data in accumulator
REG[13] =  i:1
 118 SorterNext      12  107    0               00 
 119 Gosub           15  123    0               00 output final row
REG[15] =  i:119
 123 IfPos           13  125    0               00 if r[13]>0 then r[13]-=0, goto 125; Groupby result generator entry point
REG[13] =  i:1
 125 Explain        125    8    0 CORRELATED SCALAR SUBQUERY 5 00 
 126 Null             0   39   39               00 r[39..39]=NULL; Init subquery result
REG[39] =  NULL
 127 Integer        136   40    0               00 r[40]=136
REG[40] =  i:136
 128 Once             0  136    0               00 materialize "t4"
 129 Explain        129  125    0 MATERIALIZE 2 00 
 130 OpenEphemeral    4    1    0               00 nColumn=1
 131 Explain        131  129    0 SCAN CONSTANT ROW 00 
 132 String8          0   41    0 elvis         00 r[41]='elvis'
REG[41] =   t5[elvis](8)
 133 MakeRecord      41    1   42               00 r[42]=mkrec(r[41])
REG[42] =  sx7[0217656C766973|..elvis]
 134 NewRowid         4   43    0               00 r[43]=rowid
REG[43] =  i:1
 135 Insert           4   42   43               08 intkey=r[43] data=r[42]
REG[42] =  sx7[0217656C766973|..elvis]
REG[43] =  i:1
 136 Return          40    0    0               00 end t4
REG[40] =  i:136
 137 Integer        140   44    0               00 r[44]=140
REG[44] =  i:140
 138 Once             0  140    0               00 materialize "t4"
 139 OpenDup          5    4    0               00 
 140 Return          44    0    0               00 end t4
REG[44] =  i:140
 141 Integer        144   45    0               00 r[45]=144
REG[45] =  i:144
 142 Once             0  144    0               00 materialize "t4"
 143 OpenDup          6    4    0               00 
 144 Return          45    0    0               00 end t4
REG[45] =  i:144
 145 Integer        148   46    0               00 r[46]=148
REG[46] =  i:148
 146 Once             0  148    0               00 materialize "t4"
 147 OpenDup          8    4    0               00 
 148 Return          46    0    0               00 end t4
REG[46] =  i:148
 149 Integer        152   47    0               00 r[47]=152
REG[47] =  i:152
 150 Once             0  152    0               00 materialize "t4"
 151 OpenDup          9    4    0               00 
 152 Return          47    0    0               00 end t4
REG[47] =  i:152
 153 Integer        156   48    0               00 r[48]=156
REG[48] =  i:156
 154 Once             0  156    0               00 materialize "t4"
 155 OpenDup         10    4    0               00 
 156 Return          48    0    0               00 end t4
REG[48] =  i:156
 157 Integer          1   49    0               00 r[49]=1; LIMIT counter
REG[49] =  i:1
 158 Ne              24  190   12 (BINARY)      50 if r[12]!=r[24] goto 190
REG[24] =  i:1
REG[12] =  i:1
 159 Ne              24  190   12 (BINARY)      50 if r[12]!=r[24] goto 190
REG[24] =  i:1
REG[12] =  i:1
 160 Explain        160  125    0 SCAN SUBQUERY 2 AS t4a 00 
 161 Rewind           4  190    0               00 
 162 Explain        162  125    0 SCAN SUBQUERY 2 AS t4b 00 
 163 Rewind           5  190    0               00 
 164 Explain        164  125    0 SCAN SUBQUERY 2 AS t4c 00 
 165 Integer          0   51    0               00 r[51]=0; init LEFT JOIN no-match flag
REG[51] =  i:0
 166 Rewind           6  185    0               00 
 167 Integer          1   51    0               00 r[51]=1; record LEFT JOIN hit
REG[51] =  i:1
 168 Explain        168  125    0 SCAN SUBQUERY 2 AS t4a 00 
 169 Rewind           8  185    0               00 
 170 Explain        170  125    0 SCAN SUBQUERY 2 AS t4b 00 
 171 Rewind           9  185    0               00 
 172 Explain        172  125    0 SCAN SUBQUERY 2 AS t4c 00 
 173 Integer          0   52    0               00 r[52]=0; init LEFT JOIN no-match flag
REG[52] =  i:0
 174 Rewind          10  179    0               00 
 175 Integer          1   52    0               00 r[52]=1; record LEFT JOIN hit
REG[52] =  i:1
 176 Column           4    0   39               00 r[39]=t4.d
REG[39] =   s5[elvis](8)
 177 DecrJumpZero    49  190    0               00 if (--r[49])==0 goto 190
REG[49] =  i:1
 190 Copy            39    8    0               00 r[8]=r[39]
REG[8] =   s5[elvis](8)
 191 DecrJumpZero    11  121    0               00 if (--r[11])==0 goto 121
REG[11] =  i:1
 121 Integer          1   14    0               00 r[14]=1; set abort flag
REG[14] =  i:1
 122 Return          15    0    0               00 
REG[15] =  i:119
 120 Goto             0  196    0               00 
 196 Return           7    0    0               00 
REG[7] =  i:196
 197 SCopy            8    6    0               00 r[6]=r[8]
REG[6] =   e5[elvis](8)
 198 Compare          5    6    1 k(1,B)        00 r[5] <-> r[6]
REG[5] =  NULL
REG[6] =   e5[elvis](8)
 199 Jump           200  204  200               00 
 200 Move             6    5    1               00 r[5]=r[6]
REG[5] =   s5[elvis](8)
 201 Gosub            3  209    0               00 output one row
REG[3] =  i:201
 209 IfPos            1  211    0               00 if r[1]>0 then r[1]-=0, goto 211; Groupby result generator entry point
REG[1] =  i:0
 210 Return           3    0    0               00 
REG[3] =  i:201
 202 IfPos            2  407    0               00 if r[2]>0 then r[2]-=0, goto 407; check abort flag
REG[2] =  i:0
 203 Gosub            4  405    0               00 reset accumulator
REG[4] =  i:203
 405 Integer          0    1    0               00 r[1]=0; indicate accumulator empty
REG[1] =  i:0
 406 Return           4    0    0               00 
REG[4] =  i:203
 204 Integer          1    1    0               00 r[1]=1; indicate data in accumulator
REG[1] =  i:1
 205 Gosub            3  209    0               00 output final row
REG[3] =  i:205
 209 IfPos            1  211    0               00 if r[1]>0 then r[1]-=0, goto 211; Groupby result generator entry point
REG[1] =  i:1
 211 Integer        401   54    0               00 r[54]=401; return address
REG[54] =  i:401
 212 Once             0  401    0               00 
 213 Explain        213    0    0 SCALAR SUBQUERY 6 00 
 214 Null             0   55   55               00 r[55..55]=NULL; Init subquery result
REG[55] =  NULL
 215 InitCoroutine   56  221  216               00 a
 221 Integer          1   58    0               00 r[58]=1; LIMIT counter
REG[58] =  i:1
 222 SorterOpen      14    2    0 k(1,B)        00 
 223 Integer          0   61    0               00 r[61]=0; clear abort flag
REG[61] =  i:0
 224 Null             0   64   64               00 r[64..64]=NULL
REG[64] =  NULL
 225 Gosub           63  398    0               00 
REG[63] =  i:225
 398 Null             0   59   59               00 r[59..59]=NULL
REG[59] =  NULL
 399 Integer          0   60    0               00 r[60]=0; indicate accumulator empty
REG[60] =  i:0
 400 Return          63    0    0               00 
REG[63] =  i:225
 226 Explain        226  213    0 SCAN SUBQUERY 1 00 
 227 InitCoroutine   56    0  216               00 
 228 Yield           56  310    0               00 next row of a
REG[56] =  i:215
REG[56] =  i:228
 216 Explain        216  213    0 CO-ROUTINE 1  00 
 217 Explain        217  216    0 SCAN CONSTANT ROW 00 
 218 Integer          1   57    0               00 r[57]=1
REG[57] =  i:1
 219 Yield           56    0    0               00 
REG[56] =  i:228
REG[56] =  i:219
 229 Explain        229  213    0 USE TEMP B-TREE FOR GROUP BY 00 
 230 Explain        230  213    0 CORRELATED SCALAR SUBQUERY 5 00 
 231 Null             0   68   68               00 r[68..68]=NULL; Init subquery result
REG[68] =  NULL
 232 Integer        243   69    0               00 r[69]=243
REG[69] =  i:243
 233 Once             0  243    0               00 materialize "t4"
 234 Explain        234  230    0 MATERIALIZE 2 00 
 235 OpenEphemeral    4    1    0               00 nColumn=1
 236 Explain        236  234    0 SCAN CONSTANT ROW 00 
 237 Integer          1   70    0               00 r[70]=1
REG[70] =  i:1
 238 Ne              24  243   70 (BINARY)      50 if r[70]!=r[24] goto 243
REG[24] =  i:1
REG[70] =  i:1
 239 String8          0   71    0 elvis         00 r[71]='elvis'
REG[71] =   t5[elvis](8)
 240 MakeRecord      71    1   70               00 r[70]=mkrec(r[71])
REG[70] =  sx7[0217656C766973|..elvis]
 241 NewRowid         4   72    0               00 r[72]=rowid
REG[72] =  i:1
 242 Insert           4   70   72               08 intkey=r[72] data=r[70]
REG[70] =  sx7[0217656C766973|..elvis]
REG[72] =  i:1
 243 Return          69    0    0               00 end t4
REG[69] =  i:243
 244 Integer        247   73    0               00 r[73]=247
REG[73] =  i:247
 245 Once             0  247    0               00 materialize "t4"
 246 OpenDup          5    4    0               00 
 247 Return          73    0    0               00 end t4
REG[73] =  i:247
 248 Integer        257   74    0               00 r[74]=257
REG[74] =  i:257
 249 Once             0  257    0               00 materialize "t4"
 250 Explain        250  230    0 MATERIALIZE 2 00 
 251 OpenEphemeral    6    1    0               00 nColumn=1
 252 Explain        252  250    0 SCAN CONSTANT ROW 00 
 253 String8          0   75    0 elvis         00 r[75]='elvis'
REG[75] =   t5[elvis](8)
 254 MakeRecord      75    1   76               00 r[76]=mkrec(r[75])
REG[76] =  sx7[0217656C766973|..elvis]
 255 NewRowid         6   77    0               00 r[77]=rowid
REG[77] =  i:2
 256 Insert           6   76   77               08 intkey=r[77] data=r[76]
REG[76] =  sx7[0217656C766973|..elvis]
REG[77] =  i:2
 257 Return          74    0    0               00 end t4
REG[74] =  i:257
 258 Integer        261   78    0               00 r[78]=261
REG[78] =  i:261
 259 Once             0  261    0               00 materialize "t4"
 260 OpenDup          8    4    0               00 
 261 Return          78    0    0               00 end t4
REG[78] =  i:261
 262 Integer        265   79    0               00 r[79]=265
REG[79] =  i:265
 263 Once             0  265    0               00 materialize "t4"
 264 OpenDup          9    4    0               00 
 265 Return          79    0    0               00 end t4
REG[79] =  i:265
 266 Integer        269   80    0               00 r[80]=269
REG[80] =  i:269
 267 Once             0  269    0               00 materialize "t4"
 268 OpenDup         10    6    0               00 

Program received signal SIGABRT, Aborted.
__GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:50
(gdb) #0  __GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:50
#1  0x00007f65f538f859 in __GI_abort () at abort.c:79
#2  0x00007f65f538f729 in __assert_fail_base (fmt=0x7f65f5525588 "%s%s%s:%u: %s%sAssertion `%s' failed.\n%n", assertion=0x20438b "pOrig->pBtx!=0", file=0x2291f4 "sqlite3.c", line=87735, function=<optimized out>)
    at assert.c:92
#3  0x00007f65f53a0fd6 in __GI___assert_fail (assertion=0x20438b "pOrig->pBtx!=0", file=0x2291f4 "sqlite3.c", line=87735, function=0x216a86 "int sqlite3VdbeExec(Vdbe *)") at assert.c:101
#4  0x00000000003d7d51 in sqlite3VdbeExec (p=0x1dbf8d0) at sqlite3.c:87735
#5  0x000000000041ba74 in sqlite3Step (p=0x1dbf8d0) at sqlite3.c:82300
#6  0x0000000000293d5d in sqlite3_step (pStmt=0x1dbf8d0) at sqlite3.c:82365
#7  0x0000000000258a39 in main (argc=1, argv=0x7ffc1dd158b8) at target.cc:139
(gdb) quit
A debugging session is active.

	Inferior 1 [process 40072] will be killed.

Quit anyway? (y or n) [answered Y; input not from terminal]
