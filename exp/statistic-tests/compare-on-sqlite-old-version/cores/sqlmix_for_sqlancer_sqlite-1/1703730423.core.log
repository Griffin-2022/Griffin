GNU gdb (Ubuntu 9.2-0ubuntu1~20.04.1) 9.2
Copyright (C) 2020 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type "show copying" and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
    <http://www.gnu.org/software/gdb/documentation/>.

For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from /root/sqlite_driver_fast...
(gdb) Starting program: /root/sqlite_driver_fast < "/root/out/default/crashes/id:000430,sig:06,src:024380+021489,time:15124894,execs:4537940,op:merge.so,pos:0"
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
SQL: [;
;pragma vdbe_listing=on;]
VDBE Program Listing:
   0 Init             0    1    0               00 Start at 1
   1 Expire           0    0    0               00 
   2 Halt             0    0    0               00 
SQL: [;PRAGMA writable_schema = 1;]
VDBE Program Listing:
   0 Init             0    1    0               00 Start at 1
   1 Expire           0    0    0               00 
   2 Halt             0    0    0               00 
SQL: [;UPDATE t1 SET a = a, a = a, a = a;]
VDBE Program Listing:
   0 Init             0   25    0               00 Start at 25
   1 Null             0    4    5               00 r[4..5]=NULL
   2 OpenWrite        0    2    0 4             00 root=2 iDb=0; t1
   3 Explain          3    0    0 SCAN TABLE t1 00 
   4 Rewind           0   24    0               00 
   5 Rowid            0    5    0               00 r[5]=rowid
   6 Once             0    8    0               00 
   7 OpenWrite        2    5    0 k(2,,)        00 root=5 iDb=0; t4
   8 IsNull           5   24    0               00 if r[5]==NULL goto 24
   9 Column           0    0    6               00 r[6]=t1.x
  10 Column           0    1    7               00 r[7]=t1.t2
  11 Column           0    2    8               00 r[8]=t1.a
  12 Column           0    3    9               00 r[9]=t1.b
  13 Noop             0    0    0               00 uniqueness check for t4
  14 SCopy            8    2    0               00 r[2]=r[8]; a
  15 IntCopy          5    3    0               00 r[3]=r[5]; rowid
  16 MakeRecord       2    2    1               00 r[1]=mkrec(r[2..3]); for t4
  17 Column           0    2   10               00 r[10]=t1.a
  18 Rowid            0   11    0               00 r[11]=rowid
  19 IdxDelete        2   10    2               00 key=r[10..11]
  20 IdxInsert        2    1    2 2             00 key=r[1]
  21 MakeRecord       6    4   12               00 r[12]=mkrec(r[6..9])
  22 Insert           0   12    5 t1            07 intkey=r[5] data=r[12]
  23 Next             0    5    0               01 
  24 Halt             0    0    0               00 
  25 Transaction      0    1    4 0             01 usesStmtJournal=0
  26 Goto             0    1    0               00 
SQL: [;SELECT coalesce(
      CASE WHEN t2=2 THEN 123 END,
      CASE WHEN t2=3 THEN 234 END,
      CASE WHEN a=3 THEN 345 WHEN a=33 THEN 456 END,
      a
    )
    FROM t1 ORDER BY a;]
VDBE Program Listing:
   0 Init             0   33    0               00 Start at 33
   1 Noop             1    3    0               00 
   2 OpenRead         0    2    0 3             00 root=2 iDb=0; t1
   3 OpenRead         2    5    0 k(2,,)        00 root=5 iDb=0; t4
   4 Explain          4    0    0 SCAN TABLE t1 USING INDEX t4 00 
   5 Rewind           2   32    1 0             00 
   6 DeferredSeek     2    0    0               00 Move 0 to 2.rowid if needed
   7 Column           0    1    2               00 r[2]=t1.t2
   8 Ne               3   11    2 (BINARY)      51 if r[2]!=r[3] goto 11
   9 Integer        123    1    0               00 r[1]=123
  10 Goto             0   12    0               00 
  11 Null             0    1    0               00 r[1]=NULL
  12 NotNull          1   30    0               00 if r[1]!=NULL goto 30
  13 Column           0    1    2               00 r[2]=t1.t2
  14 Ne               4   17    2 (BINARY)      51 if r[2]!=r[4] goto 17
  15 Integer        234    1    0               00 r[1]=234
  16 Goto             0   18    0               00 
  17 Null             0    1    0               00 r[1]=NULL
  18 NotNull          1   30    0               00 if r[1]!=NULL goto 30
  19 Column           2    0    2               00 r[2]=t1.a
  20 Ne               4   23    2 (BINARY)      51 if r[2]!=r[4] goto 23
  21 Integer        345    1    0               00 r[1]=345
  22 Goto             0   28    0               00 
  23 Column           2    0    2               00 r[2]=t1.a
  24 Ne               5   27    2 (BINARY)      51 if r[2]!=r[5] goto 27
  25 Integer        456    1    0               00 r[1]=456
  26 Goto             0   28    0               00 
  27 Null             0    1    0               00 r[1]=NULL
  28 NotNull          1   30    0               00 if r[1]!=NULL goto 30
  29 Column           2    0    1               00 r[1]=t1.a
  30 ResultRow        1    1    0               00 output=r[1]
  31 Next             2    6    0               01 
  32 Halt             0    0    0               00 
  33 Transaction      0    0    4 0             01 usesStmtJournal=0
  34 Integer          2    3    0               00 r[3]=2
  35 Integer          3    4    0               00 r[4]=3
  36 Integer         33    5    0               00 r[5]=33
  37 Goto             0    1    0               00 
SQL: [;SELECT (
    SELECT a FROM t1 GROUP BY (
      SELECT bbb FROM (
        SELECT ccc AS bbb FROM (
           SELECT 1 ccc
        ) WHERE rowid IS NOT 1
      ) WHERE bbb = 1
    )
  );]
VDBE Program Listing:
   0 Init             0   87    0               00 Start at 87
   1 Explain          1    0    0 SCAN CONSTANT ROW 00 
   2 Integer         83    2    0               00 r[2]=83; return address
   3 Once             0   83    0               00 
   4 Explain          4    0    0 SCALAR SUBQUERY 4 00 
   5 Null             0    3    3               00 r[3..3]=NULL; Init subquery result
   6 Integer          1    4    0               00 r[4]=1; LIMIT counter
   7 SorterOpen       3    2    0 k(1,B)        00 
   8 Integer          0    7    0               00 r[7]=0; clear abort flag
   9 Null             0   10   10               00 r[10..10]=NULL
  10 Gosub            9   80    0               00 
  11 OpenRead         4    5    0 k(2,,)        00 root=5 iDb=0; t4
  12 Explain         12    4    0 SCAN TABLE t1 USING COVERING INDEX t4 00 
  13 Rewind           4   57   12 0             00 
  14 Explain         14    4    0 USE TEMP B-TREE FOR GROUP BY 00 
  15 Integer         51   14    0               00 r[14]=51; return address
  16 Once             0   51    0               00 
  17 Explain         17    4    0 SCALAR SUBQUERY 3 00 
  18 Null             0   15   15               00 r[15..15]=NULL; Init subquery result
  19 InitCoroutine   16   27   20               00 subquery_1
  20 Explain         20   17    0 CO-ROUTINE 1  00 
  21 Explain         21   20    0 SCAN CONSTANT ROW 00 
  22 Ne              17   26   17               51 if r[17]!=r[17] goto 26
  23 Eq              17   26   18               C4 if r[18]==r[17] goto 26
  24 Integer          1   19    0               00 r[19]=1
  25 Yield           16    0    0               00 
  26 EndCoroutine    16    0    0               00 
  27 Integer          1   20    0               00 r[20]=1; LIMIT counter
  28 Once             0   42    0               00 
  29 OpenAutoindex    5    2    0 k(2,B,)       00 nColumn=2; for subquery_1
  30 Integer          0   23    0               00 r[23]=0
  31 InitCoroutine   16    0   20               00 
  32 Yield           16   42    0               00 next row of subquery_1
  33 AddImm          21    1    0               00 r[21]=r[21]+1
  34 Eq              17   41   21               C4 if r[21]==r[17] goto 41
  35 Copy            19   21    0               00 r[21]=r[19]; subquery_1.ccc
  36 Ne              17   41   21 (BINARY)      51 if r[21]!=r[17] goto 41
  37 Copy            19   22    0               00 r[22]=r[19]; subquery_1.ccc
  38 AddImm          23    1    0               00 r[23]=r[23]+1
  39 MakeRecord      22    2   21               00 r[21]=mkrec(r[22..23])
  40 IdxInsert        5   21    0               10 key=r[21]
  41 Goto             0   32    0               03 
  42 Explain         42   17    0 SEARCH SUBQUERY 1 USING AUTOMATIC PARTIAL COVERING INDEX (ccc=?) 00 
  43 Integer          1   24    0               00 r[24]=1
  44 SeekGE           5   51   24 1             00 key=r[24]
  45 IdxGT            5   51   24 1             00 key=r[24]
  46 IdxRowid         5   21    0               00 r[21]=rowid
  47 Eq              17   50   21               C4 if r[21]==r[17] goto 50
  48 Column           5    0   15               00 r[15]=subquery_1.ccc
  49 DecrJumpZero    20   51    0               00 if (--r[20])==0 goto 51
  50 Next             5   45    0               00 
  51 Return          14    0    0               00 
  52 SCopy           15   12    0               00 r[12]=r[15]
  53 Column           4    0   13               00 r[13]=t1.a
  54 MakeRecord      12    2   21               00 r[21]=mkrec(r[12..13])
  55 SorterInsert     3   21    0               00 key=r[21]
  56 Next             4   14    0               01 
  57 OpenPseudo       6   21    2               00 2 columns in r[21]
  58 SorterSort       3   83    0               00 GROUP BY sort
  59 SorterData       3   21    6               00 r[21]=data
  60 Column           6    0   11               00 r[11]=
  61 Compare         10   11    1 k(1,B)        00 r[10] <-> r[11]
  62 Jump            63   67   63               00 
  63 Move            11   10    1               00 r[10]=r[11]
  64 Gosub            8   75    0               00 output one row
  65 IfPos            7   83    0               00 if r[7]>0 then r[7]-=0, goto 83; check abort flag
  66 Gosub            9   80    0               00 reset accumulator
  67 If               6   69    0               00 
  68 Column           6    1    5               00 r[5]=
  69 Integer          1    6    0               00 r[6]=1; indicate data in accumulator
  70 SorterNext       3   59    0               00 
  71 Gosub            8   75    0               00 output final row
  72 Goto             0   83    0               00 
  73 Integer          1    7    0               00 r[7]=1; set abort flag
  74 Return           8    0    0               00 
  75 IfPos            6   77    0               00 if r[6]>0 then r[6]-=0, goto 77; Groupby result generator entry point
  76 Return           8    0    0               00 
  77 Copy             5    3    0               00 r[3]=r[5]
  78 DecrJumpZero     4   73    0               00 if (--r[4])==0 goto 73
  79 Return           8    0    0               00 end groupby result generator
  80 Null             0    5    5               00 r[5..5]=NULL
  81 Integer          0    6    0               00 r[6]=0; indicate accumulator empty
  82 Return           9    0    0               00 
  83 Return           2    0    0               00 
  84 Copy             3    1    0               00 r[1]=r[3]
  85 ResultRow        1    1    0               00 output=r[1]
  86 Halt             0    0    0               00 
  87 Transaction      0    0    4 0             01 usesStmtJournal=0
  88 Integer          1   17    0               00 r[17]=1
  89 Null             0   18    0               00 r[18]=NULL
  90 Goto             0    1    0               00 

Program received signal SIGABRT, Aborted.
__GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:50
(gdb) #0  __GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:50
#1  0x00007fce7bd10859 in __GI_abort () at abort.c:79
#2  0x00007fce7bd10729 in __assert_fail_base (fmt=0x7fce7bea6588 "%s%s%s:%u: %s%sAssertion `%s' failed.\n%n", assertion=0x214f9b "memIsValid(&aMem[pOp->p1])", file=0x22873d "sqlite3.c", line=84308, function=<optimized out>)
    at assert.c:92
#3  0x00007fce7bd21fd6 in __GI___assert_fail (assertion=0x214f9b "memIsValid(&aMem[pOp->p1])", file=0x22873d "sqlite3.c", line=84308, function=0x216524 "int sqlite3VdbeExec(Vdbe *)") at assert.c:101
#4  0x00000000003bfd43 in sqlite3VdbeExec (p=0x241bc00) at sqlite3.c:84308
#5  0x0000000000411104 in sqlite3Step (p=0x241bc00) at sqlite3.c:81930
#6  0x000000000029128d in sqlite3_step (pStmt=0x241bc00) at sqlite3.c:81995
#7  0x00000000002570b9 in main (argc=1, argv=0x7fff26e1e188) at target.cc:139
(gdb) quit
A debugging session is active.

	Inferior 1 [process 54852] will be killed.

Quit anyway? (y or n) [answered Y; input not from terminal]
