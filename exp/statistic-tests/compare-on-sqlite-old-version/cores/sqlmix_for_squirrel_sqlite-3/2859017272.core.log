GNU gdb (Ubuntu 9.2-0ubuntu1~20.04.1) 9.2
Copyright (C) 2020 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type "show copying" and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
    <http://www.gnu.org/software/gdb/documentation/>.

For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from /root/sqlite_driver_fast...
(gdb) Starting program: /root/sqlite_driver_fast < "/root/out/default/crashes/id:000438,sig:06,src:025450+023048,time:16073992,execs:3175272,op:merge.so,pos:0"
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
SQL: [;PRAGMA vdbe_trace=on;]
VDBE Trace:
   0 Init             0    1    0               00 Start at 1
   1 Expire           0    0    0               00 
   2 Halt             0    0    0               00 
SQL: [CREATE INDEX v2 ON test(t1)
;]
VDBE Trace:
   0 Init             0   33    0               00 Start at 33
  33 Transaction      0    1    4 0             01 usesStmtJournal=1
  34 Goto             0    1    0               00 
   1 Noop             0   32    0               00 
   2 CreateBtree      0    1    2               00 r[1]=root iDb=0 flags=2
REG[1] =  i:8
   3 OpenWrite        0    1    0 5             00 root=1 iDb=0; sqlite_master
   4 NewRowid         0    2    0               00 r[2]=rowid
REG[2] =  i:7
   5 String8          0    3    0 index         00 r[3]='index'
REG[3] =   t5[index](8)
   6 String8          0    4    0 v2            00 r[4]='v2'
REG[4] =   t2[v2](8)
   7 String8          0    5    0 test          00 r[5]='test'
REG[5] =   t4[test](8)
   8 Copy             1    6    0               00 r[6]=r[1]
REG[6] =  i:8
   9 String8          0    7    0 CREATE INDEX v2 ON test(t1)
 00 r[7]='CREATE INDEX v2 ON test(t1)
'
REG[7] =   t28[CREATE INDEX v2 ON test(t](8)
  10 MakeRecord       3    5    8 BBBDB         00 r[8]=mkrec(r[3..7])
REG[3] =   t5[index](8)
REG[4] =   t2[v2](8)
REG[5] =   t4[test](8)
REG[6] =  i:8
REG[7] =   t28[CREATE INDEX v2 ON test(t](8)
REG[8] =  sx46[061711150145696E6465787632746573740843524541544520|.....Eindexv2test.CREATE ]
  11 Insert           0    8    2               18 intkey=r[2] data=r[8]
REG[8] =  sx46[061711150145696E6465787632746573740843524541544520|.....Eindexv2test.CREATE ]
REG[2] =  i:7
  12 SorterOpen       3    0    1 k(2,,)        00 
  13 OpenRead         1    2    0 1             00 root=2 iDb=0; test
  14 Rewind           1   20    0               00 
  20 OpenWrite        2    1    0 k(2,,)        11 root=1 iDb=0
  21 SorterSort       3   26    0               00 
  26 Close            1    0    0               00 
  27 Close            2    0    0               00 
  28 Close            3    0    0               00 
  29 SetCookie        0    1    5               00 
  30 ParseSchema      0    0    0 name='v2' AND type='index' 00 
VDBE Trace:
   0 Init             0   17    0               00 Start at 17
  17 Transaction      0    0    5 0             00 usesStmtJournal=0
  18 String8          0    2    0 v2            00 r[2]='v2'
REG[2] =   t2[v2](8)
  19 String8          0    3    0 index         00 r[3]='index'
REG[3] =   t5[index](8)
  20 Goto             0    1    0               00 
   1 Noop             1    7    0               00 
   2 OpenRead         0    1    0 5             00 root=1 iDb=0; sqlite_master
   3 Explain          3    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   16    0               00 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s4[test](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t2[v2](8)
REG[1] =   s4[test](8)
  15 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s1[a](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t2[v2](8)
REG[1] =   s1[a](8)
  15 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s9[log_entry](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t2[v2](8)
REG[1] =   s9[log_entry](8)
  15 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s28[sqlite_autoindex_log_entr](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t2[v2](8)
REG[1] =   s28[sqlite_autoindex_log_entr](8)
  15 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s28[sqlite_autoindex_log_entr](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t2[v2](8)
REG[1] =   s28[sqlite_autoindex_log_entr](8)
  15 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s7[newname](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t2[v2](8)
REG[1] =   s7[newname](8)
  15 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s2[v2](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t2[v2](8)
REG[1] =   s2[v2](8)
   7 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[index](8)
   8 Ne               3   15    1 (BINARY)      52 if r[1]!=r[3] goto 15
REG[3] =   t5[index](8)
REG[1] =   s5[index](8)
   9 Column           0    0    4               00 r[4]=sqlite_master.type
REG[4] =   s5[index](8)
  10 Column           0    1    5               00 r[5]=sqlite_master.name
REG[5] =   s2[v2](8)
  11 Column           0    2    6               00 r[6]=sqlite_master.tbl_name
REG[6] =   s4[test](8)
  12 Column           0    3    7               00 r[7]=sqlite_master.rootpage
REG[7] =  i:8
  13 Column           0    4    8               00 r[8]=sqlite_master.sql
REG[8] =   s28[CREATE INDEX v2 ON test(t](8)
  14 ResultRow        4    5    0               00 output=r[4..8]
REG[4] =   s5[index](8)
REG[5] =   s2[v2](8)
REG[6] =   s4[test](8)
REG[7] =  i:8
REG[8] =   s28[CREATE INDEX v2 ON test(t](8)
  15 Next             0    5    0               01 
  16 Halt             0    0    0               00 
  31 Expire           0    1    0               00 
  32 Halt             0    0    0               00 
SQL: [;
;ROLLBACK to two
;]
VDBE Trace:
   0 Init             0    1    0               00 Start at 1
   1 Savepoint        2    0    0 two           00 
SQL: [SELECT t1, sum(t1) OVER (
    ORDER BY t1 
    ROWS BETWEEN CURRENT ROW AND CURRENT ROW
  ) FROM test

;]
VDBE Trace:
   0 Init             0   66    0               00 Start at 66
  66 Transaction      0    0    5 0             01 usesStmtJournal=0
  67 Goto             0    1    0               00 
   1 Null             0    1    0               00 r[1]=NULL
REG[1] =  NULL
   2 OpenEphemeral    1    3    0               00 nColumn=3
   3 OpenDup          2    1    0               00 
   4 OpenDup          3    1    0               00 
   5 OpenDup          4    1    0               00 
   6 InitCoroutine    3   18    7               00 
  18 Integer          1    7    0               00 r[7]=1
REG[7] =  i:1
  19 Explain         19    0    0 SCAN SUBQUERY 2 00 
  20 InitCoroutine    3    0    7               00 
  21 Yield            3   45    0               00 next row of 
REG[3] =  i:6
REG[3] =  i:21
   7 Explain          7    0    0 CO-ROUTINE 2  00 
   8 Noop             6    5    0               00 
   9 OpenRead         7    8    0 k(2,,)        00 root=8 iDb=0; v2
  10 Explain         10    7    0 SCAN TABLE test USING COVERING INDEX v2 00 
  11 Rewind           7   17    4 0             00 
  17 EndCoroutine     3    0    0               00 
REG[3] =  i:21
  45 Rewind           2   58    0               00 
  58 ResetSorter      1    0    0               00 
  59 Goto             0   65    0               00 
  65 Halt             0    0    0               00 
SQL: [;PRAGMA journal_mode = WAL;]
VDBE Trace:
   0 Init             0    1    0               00 Start at 1
   1 JournalMode      1    1    5               00 
REG[1] =   t6[delete](8)
   2 JournalMode      0    1    5               00 
REG[1] =   t6[memory](8)
   3 ResultRow        1    1    0               00 output=r[1]
REG[1] =   t6[memory](8)
   4 Halt             0    0    0               00 
SQL: [
;SELECT name FROM sqlite_master WHERE type!='meta' ORDER BY name
;]
VDBE Trace:
   0 Init             0   19    0               00 Start at 19
  19 Transaction      0    0    5 0             01 usesStmtJournal=0
  20 String8          0    2    0 meta          00 r[2]='meta'
REG[2] =   t4[meta](8)
  21 Goto             0    1    0               00 
   1 SorterOpen       1    3    0 k(1,B)        00 
   2 OpenRead         0    1    0 2             00 root=1 iDb=0; sqlite_master
   3 Explain          3    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   11    0               00 
   5 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[table](8)
   6 Eq               2   10    1 (BINARY)      52 if r[1]==r[2] goto 10
REG[2] =   t4[meta](8)
REG[1] =   s5[table](8)
   7 Column           0    1    3               00 r[3]=sqlite_master.name
REG[3] =   s4[test](8)
   8 MakeRecord       3    1    5               00 r[5]=mkrec(r[3])
REG[5] =  sx6[021574657374|..test]
   9 SorterInsert     1    5    3 1             00 key=r[5]
REG[5] =  sx6[021574657374|..test]
  10 Next             0    5    0               01 
   5 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[table](8)
   6 Eq               2   10    1 (BINARY)      52 if r[1]==r[2] goto 10
REG[2] =   t4[meta](8)
REG[1] =   s5[table](8)
   7 Column           0    1    3               00 r[3]=sqlite_master.name
REG[3] =   s1[a](8)
   8 MakeRecord       3    1    5               00 r[5]=mkrec(r[3])
REG[5] =  sx3[020F61|..a]
   9 SorterInsert     1    5    3 1             00 key=r[5]
REG[5] =  sx3[020F61|..a]
  10 Next             0    5    0               01 
   5 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[table](8)
   6 Eq               2   10    1 (BINARY)      52 if r[1]==r[2] goto 10
REG[2] =   t4[meta](8)
REG[1] =   s5[table](8)
   7 Column           0    1    3               00 r[3]=sqlite_master.name
REG[3] =   s9[log_entry](8)
   8 MakeRecord       3    1    5               00 r[5]=mkrec(r[3])
REG[5] =  sx11[021F6C6F675F656E747279|..log_entry]
   9 SorterInsert     1    5    3 1             00 key=r[5]
REG[5] =  sx11[021F6C6F675F656E747279|..log_entry]
  10 Next             0    5    0               01 
   5 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[index](8)
   6 Eq               2   10    1 (BINARY)      52 if r[1]==r[2] goto 10
REG[2] =   t4[meta](8)
REG[1] =   s5[index](8)
   7 Column           0    1    3               00 r[3]=sqlite_master.name
REG[3] =   s28[sqlite_autoindex_log_entr](8)
   8 MakeRecord       3    1    5               00 r[5]=mkrec(r[3])
REG[5] =  sx30[024573716C6974655F6175746F696E6465785F6C6F675F656E|.Esqlite_autoindex_log_en]
   9 SorterInsert     1    5    3 1             00 key=r[5]
REG[5] =  sx30[024573716C6974655F6175746F696E6465785F6C6F675F656E|.Esqlite_autoindex_log_en]
  10 Next             0    5    0               01 
   5 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[index](8)
   6 Eq               2   10    1 (BINARY)      52 if r[1]==r[2] goto 10
REG[2] =   t4[meta](8)
REG[1] =   s5[index](8)
   7 Column           0    1    3               00 r[3]=sqlite_master.name
REG[3] =   s28[sqlite_autoindex_log_entr](8)
   8 MakeRecord       3    1    5               00 r[5]=mkrec(r[3])
REG[5] =  sx30[024573716C6974655F6175746F696E6465785F6C6F675F656E|.Esqlite_autoindex_log_en]
   9 SorterInsert     1    5    3 1             00 key=r[5]
REG[5] =  sx30[024573716C6974655F6175746F696E6465785F6C6F675F656E|.Esqlite_autoindex_log_en]
  10 Next             0    5    0               01 
   5 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[table](8)
   6 Eq               2   10    1 (BINARY)      52 if r[1]==r[2] goto 10
REG[2] =   t4[meta](8)
REG[1] =   s5[table](8)
   7 Column           0    1    3               00 r[3]=sqlite_master.name
REG[3] =   s7[newname](8)
   8 MakeRecord       3    1    5               00 r[5]=mkrec(r[3])
REG[5] =  sx9[021B6E65776E616D65|..newname]
   9 SorterInsert     1    5    3 1             00 key=r[5]
REG[5] =  sx9[021B6E65776E616D65|..newname]
  10 Next             0    5    0               01 
   5 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[index](8)
   6 Eq               2   10    1 (BINARY)      52 if r[1]==r[2] goto 10
REG[2] =   t4[meta](8)
REG[1] =   s5[index](8)
   7 Column           0    1    3               00 r[3]=sqlite_master.name
REG[3] =   s2[v2](8)
   8 MakeRecord       3    1    5               00 r[5]=mkrec(r[3])
REG[5] =  sx4[02117632|..v2]
   9 SorterInsert     1    5    3 1             00 key=r[5]
REG[5] =  sx4[02117632|..v2]
  10 Next             0    5    0               01 
  11 Explain         11    0    0 USE TEMP B-TREE FOR ORDER BY 00 
  12 OpenPseudo       2    6    3               00 3 columns in r[6]
  13 SorterSort       1   18    0               00 
  14 SorterData       1    6    2               00 r[6]=data
  15 Column           2    0    4               00 r[4]=name
REG[4] =   s1[a](8)
  16 ResultRow        4    1    0               00 output=r[4]
REG[4] =   s1[a](8)
  17 SorterNext       1   14    0               00 
  14 SorterData       1    6    2               00 r[6]=data
  15 Column           2    0    4               00 r[4]=name
REG[4] =   s9[log_entry](8)
  16 ResultRow        4    1    0               00 output=r[4]
REG[4] =   s9[log_entry](8)
  17 SorterNext       1   14    0               00 
  14 SorterData       1    6    2               00 r[6]=data
  15 Column           2    0    4               00 r[4]=name
REG[4] =   s7[newname](8)
  16 ResultRow        4    1    0               00 output=r[4]
REG[4] =   s7[newname](8)
  17 SorterNext       1   14    0               00 
  14 SorterData       1    6    2               00 r[6]=data
  15 Column           2    0    4               00 r[4]=name
REG[4] =   s28[sqlite_autoindex_log_entr](8)
  16 ResultRow        4    1    0               00 output=r[4]
REG[4] =   s28[sqlite_autoindex_log_entr](8)
  17 SorterNext       1   14    0               00 
  14 SorterData       1    6    2               00 r[6]=data
  15 Column           2    0    4               00 r[4]=name
REG[4] =   s28[sqlite_autoindex_log_entr](8)
  16 ResultRow        4    1    0               00 output=r[4]
REG[4] =   s28[sqlite_autoindex_log_entr](8)
  17 SorterNext       1   14    0               00 
  14 SorterData       1    6    2               00 r[6]=data
  15 Column           2    0    4               00 r[4]=name
REG[4] =   s4[test](8)
  16 ResultRow        4    1    0               00 output=r[4]
REG[4] =   s4[test](8)
  17 SorterNext       1   14    0               00 
  14 SorterData       1    6    2               00 r[6]=data
  15 Column           2    0    4               00 r[4]=name
REG[4] =   s2[v2](8)
  16 ResultRow        4    1    0               00 output=r[4]
REG[4] =   s2[v2](8)
  17 SorterNext       1   14    0               00 
  18 Halt             0    0    0               00 
SQL: [;
;SELECT x, sum(x) OVER (
    ORDER BY x
    ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
  ) FROM a ORDER BY x;]
VDBE Trace:
   0 Init             0   69    0               00 Start at 69
  69 Transaction      0    0    5 0             01 usesStmtJournal=0
  70 Goto             0    1    0               00 
   1 Null             0    1    0               00 r[1]=NULL
REG[1] =  NULL
   2 OpenEphemeral    1    3    0               00 nColumn=3
   3 OpenDup          2    1    0               00 
   4 OpenDup          3    1    0               00 
   5 OpenDup          4    1    0               00 
   6 InitCoroutine    3   28    7               00 
  28 Integer          1   10    0               00 r[10]=1
REG[10] =  i:1
  29 Explain         29    0    0 SCAN SUBQUERY 2 00 
  30 InitCoroutine    3    0    7               00 
  31 Yield            3   51    0               00 next row of 
REG[3] =  i:6
REG[3] =  i:31
   7 Explain          7    0    0 CO-ROUTINE 2  00 
   8 SorterOpen       6    5    0 k(1,B)        00 
   9 OpenRead         0    3    0 4             00 root=3 iDb=0; a
  10 Explain         10    7    0 SCAN TABLE a  00 
  11 Rewind           0   18    0               00 
  12 Column           0    3    5               00 r[5]=a.x
REG[5] =  NULL
  13 Column           0    3    6               00 r[6]=a.x
REG[6] =  NULL
  14 Column           0    3    4               00 r[4]=a.x
REG[4] =  NULL
  15 MakeRecord       4    3    8               00 r[8]=mkrec(r[4..6])
REG[8] =  sx4[04000000|....]
  16 SorterInsert     6    8    4 3             00 key=r[8]
REG[8] =  sx4[04000000|....]
  17 Next             0   12    0               01 
  18 Explain         18    7    0 USE TEMP B-TREE FOR ORDER BY 00 
  19 OpenPseudo       7    9    5               00 5 columns in r[9]
  20 SorterSort       6   27    0               00 
  21 SorterData       6    9    7               00 r[9]=data
  22 Column           7    0    7               00 r[7]=
REG[7] =  NULL
  23 Column           7    2    6               00 r[6]=
REG[6] =  NULL
  24 Column           7    1    5               00 r[5]=
REG[5] =  NULL
  25 Yield            3    0    0               00 
REG[3] =  i:31
REG[3] =  i:25
  32 Copy             5   12    0               00 r[12]=r[5]
REG[12] =  NULL
  33 Copy             6   13    0               00 r[13]=r[6]
REG[13] =  NULL
  34 Copy             7   14    0               00 r[14]=r[7]
REG[14] =  NULL
  35 MakeRecord      12    3   15               00 r[15]=mkrec(r[12..14])
REG[15] =  sx4[04000000|....]
  36 NewRowid         2   16    0               00 r[16]=rowid
REG[16] =  i:1
  37 Insert           2   15   16               00 intkey=r[16] data=r[15]
REG[15] =  sx4[04000000|....]
REG[16] =  i:1
  38 Ne              10   43   16               00 if r[16]!=r[10] goto 43
REG[10] =  i:1
REG[16] =  i:1
  39 Null             0    1    0               00 r[1]=NULL
REG[1] =  NULL
  40 Rewind           1    1    0               00 
  41 Rewind           4    1    0               00 
  42 Goto             0   50    0               00 
  50 Goto             0   31    0               00 
  31 Yield            3   51    0               00 next row of 
REG[3] =  i:25
REG[3] =  i:31
  26 SorterNext       6   21    0               00 
  27 EndCoroutine     3    0    0               00 
REG[3] =  i:31
  51 Rewind           2   61    0               00 
  52 Column           4    2   17               00 r[17]=
REG[17] =  NULL
  53 AggStep          0   17    1 sum(1)        01 accum=r[1] step(r[17])
REG[17] =  NULL
  54 Next             4   55    0               00 
  55 AggValue         1    1    2 sum(1)        00 r[2]=value N=1
  56 Gosub           11   63    0               00 
REG[11] =  i:56
  63 Noop             0    0    0               00 inner-loop subroutine
  64 Column           1    0   18               00 r[18]=.x
REG[18] =  NULL
  65 Copy             2   19    0               00 r[19]=r[2]
REG[19] =  NULL
  66 ResultRow       18    2    0               00 output=r[18..19]
REG[18] =  NULL
REG[19] =  NULL
  67 Return          11    0    0               00 end inner-loop subroutine
REG[11] =  i:56
  57 Delete           1    0    0               02 
  58 Next             1   60    0               00 
  59 Goto             0   61    0               00 
  61 ResetSorter      1    0    0               00 
  62 Goto             0   68    0               00 
  68 Halt             0    0    0               00 
SQL: [;
;SELECT c, sum(c) OVER (
    ORDER BY c
    RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
  ) FROM a ORDER BY c;]
VDBE Trace:
   0 Init             0   86    0               00 Start at 86
  86 Transaction      0    0    5 0             01 usesStmtJournal=0
  87 Goto             0    1    0               00 
   1 Null             0    1    0               00 r[1]=NULL
REG[1] =  NULL
   2 OpenEphemeral    1    3    0               00 nColumn=3
   3 OpenDup          2    1    0               00 
   4 OpenDup          3    1    0               00 
   5 OpenDup          4    1    0               00 
   6 InitCoroutine    3   28    7               00 
  28 Integer          1   10    0               00 r[10]=1
REG[10] =  i:1
  29 Explain         29    0    0 SCAN SUBQUERY 2 00 
  30 InitCoroutine    3    0    7               00 
  31 Yield            3   59    0               00 next row of 
REG[3] =  i:6
REG[3] =  i:31
   7 Explain          7    0    0 CO-ROUTINE 2  00 
   8 SorterOpen       6    5    0 k(1,B)        00 
   9 OpenRead         0    3    0 2             00 root=3 iDb=0; a
  10 Explain         10    7    0 SCAN TABLE a  00 
  11 Rewind           0   18    0               00 
  12 Column           0    1    5               00 r[5]=a.c
REG[5] =  NULL
  13 Column           0    1    6               00 r[6]=a.c
REG[6] =  NULL
  14 Column           0    1    4               00 r[4]=a.c
REG[4] =  NULL
  15 MakeRecord       4    3    8               00 r[8]=mkrec(r[4..6])
REG[8] =  sx4[04000000|....]
  16 SorterInsert     6    8    4 3             00 key=r[8]
REG[8] =  sx4[04000000|....]
  17 Next             0   12    0               01 
  18 Explain         18    7    0 USE TEMP B-TREE FOR ORDER BY 00 
  19 OpenPseudo       7    9    5               00 5 columns in r[9]
  20 SorterSort       6   27    0               00 
  21 SorterData       6    9    7               00 r[9]=data
  22 Column           7    0    7               00 r[7]=
REG[7] =  NULL
  23 Column           7    2    6               00 r[6]=
REG[6] =  NULL
  24 Column           7    1    5               00 r[5]=
REG[5] =  NULL
  25 Yield            3    0    0               00 
REG[3] =  i:31
REG[3] =  i:25
  32 Copy             5   12    0               00 r[12]=r[5]
REG[12] =  NULL
  33 Copy             6   13    0               00 r[13]=r[6]
REG[13] =  NULL
  34 Copy             7   14    0               00 r[14]=r[7]
REG[14] =  NULL
  35 MakeRecord      12    3   15               00 r[15]=mkrec(r[12..14])
REG[15] =  sx4[04000000|....]
  36 NewRowid         2   16    0               00 r[16]=rowid
REG[16] =  i:1
  37 Insert           2   15   16               00 intkey=r[16] data=r[15]
REG[15] =  sx4[04000000|....]
REG[16] =  i:1
  38 Ne              10   47   16               00 if r[16]!=r[10] goto 47
REG[10] =  i:1
REG[16] =  i:1
  39 Null             0    1    0               00 r[1]=NULL
REG[1] =  NULL
  40 Rewind           1    1    0               00 
  41 Rewind           4    1    0               00 
  42 Copy            13   17    0               00 r[17]=r[13]
REG[17] =  NULL
  43 Copy            17   18    0               00 r[18]=r[17]
REG[18] =  NULL
  44 Copy            17   19    0               00 r[19]=r[17]
REG[19] =  NULL
  45 Copy            17   20    0               00 r[20]=r[17]
REG[20] =  NULL
  46 Goto             0   58    0               00 
  58 Goto             0   31    0               00 
  31 Yield            3   59    0               00 next row of 
REG[3] =  i:25
REG[3] =  i:31
  26 SorterNext       6   21    0               00 
  27 EndCoroutine     3    0    0               00 
REG[3] =  i:31
  59 Rewind           2   78    0               00 
  60 Column           4    2   21               00 r[21]=
REG[21] =  NULL
  61 AggStep          0   21    1 sum(1)        01 accum=r[1] step(r[21])
REG[21] =  NULL
  62 Next             4   64    0               00 
  63 Goto             0   68    0               00 
  68 AggValue         1    1    2 sum(1)        00 r[2]=value N=1
  69 Gosub           11   80    0               00 
REG[11] =  i:69
  80 Noop             0    0    0               00 inner-loop subroutine
  81 Column           1    0   23               00 r[23]=.c
REG[23] =  NULL
  82 Copy             2   24    0               00 r[24]=r[2]
REG[24] =  NULL
  83 ResultRow       23    2    0               00 output=r[23..24]
REG[23] =  NULL
REG[24] =  NULL
  84 Return          11    0    0               00 end inner-loop subroutine
REG[11] =  i:69
  70 Delete           1    0    0               02 
  71 Next             1   73    0               00 
  72 Goto             0   78    0               00 
  78 ResetSorter      1    0    0               00 
  79 Goto             0   85    0               00 
  85 Halt             0    0    0               00 
SQL: [;
;ROLLBACK to two
;]
VDBE Trace:
   0 Init             0    1    0               00 Start at 1
   1 Savepoint        2    0    0 two           00 
SQL: [;
;DROP TABLE IF EXISTS newname;]
VDBE Trace:
   0 Init             0   38    0               00 Start at 38
  38 Transaction      0    1    5 0             01 usesStmtJournal=1
  39 String8          0    3    0 newname       00 r[3]='newname'
REG[3] =   t7[newname](8)
  40 String8          0    4    0 trigger       00 r[4]='trigger'
REG[4] =   t7[trigger](8)
  41 Goto             0    1    0               00 
   1 Null             0    1    0               00 r[1]=NULL
REG[1] =  NULL
   2 OpenWrite        0    1    0 5             00 root=1 iDb=0; sqlite_master
   3 Explain          3    0    0 SCAN TABLE sqlite_master 00 
   4 Last             0   13    0               00 
   5 Column           0    2    2               00 r[2]=sqlite_master.tbl_name
REG[2] =   s4[test](8)
   6 Ne               3   12    2 (BINARY)      52 if r[2]!=r[3] goto 12
REG[3] =   t7[newname](8)
REG[2] =   s4[test](8)
  12 Prev             0    5    0               01 
   5 Column           0    2    2               00 r[2]=sqlite_master.tbl_name
REG[2] =   s7[newname](8)
   6 Ne               3   12    2 (BINARY)      52 if r[2]!=r[3] goto 12
REG[3] =   t7[newname](8)
REG[2] =   s7[newname](8)
   7 Column           0    0    2               00 r[2]=sqlite_master.type
REG[2] =   s5[table](8)
   8 Eq               4   12    2 (BINARY)      52 if r[2]==r[4] goto 12
REG[4] =   t7[trigger](8)
REG[2] =   s5[table](8)
   9 Rowid            0    5    0               00 r[5]=rowid
REG[5] =  i:6
  10 Once             0   11    0               00 
  11 Delete           0    0    0               02 
  12 Prev             0    5    0               01 
   5 Column           0    2    2               00 r[2]=sqlite_master.tbl_name
REG[2] =   s9[log_entry](8)
   6 Ne               3   12    2 (BINARY)      52 if r[2]!=r[3] goto 12
REG[3] =   t7[newname](8)
REG[2] =   s9[log_entry](8)
  12 Prev             0    5    0               01 
   5 Column           0    2    2               00 r[2]=sqlite_master.tbl_name
REG[2] =   s9[log_entry](8)
   6 Ne               3   12    2 (BINARY)      52 if r[2]!=r[3] goto 12
REG[3] =   t7[newname](8)
REG[2] =   s9[log_entry](8)
  12 Prev             0    5    0               01 
   5 Column           0    2    2               00 r[2]=sqlite_master.tbl_name
REG[2] =   s9[log_entry](8)
   6 Ne               3   12    2 (BINARY)      52 if r[2]!=r[3] goto 12
REG[3] =   t7[newname](8)
REG[2] =   s9[log_entry](8)
  12 Prev             0    5    0               01 
   5 Column           0    2    2               00 r[2]=sqlite_master.tbl_name
REG[2] =   s1[a](8)
   6 Ne               3   12    2 (BINARY)      52 if r[2]!=r[3] goto 12
REG[3] =   t7[newname](8)
REG[2] =   s1[a](8)
  12 Prev             0    5    0               01 
   5 Column           0    2    2               00 r[2]=sqlite_master.tbl_name
REG[2] =   s4[test](8)
   6 Ne               3   12    2 (BINARY)      52 if r[2]!=r[3] goto 12
REG[3] =   t7[newname](8)
REG[2] =   s4[test](8)
  12 Prev             0    5    0               01 
  13 Destroy          7    2    0               00 
REG[2] =  i:0
  14 Null             0    6    7               00 r[6..7]=NULL
REG[6] =  NULL
  15 IfNot            2   24    1               00 
REG[2] =  i:0
  24 OpenWrite        1    1    0 5             00 root=1 iDb=0; sqlite_master
  25 RowSetRead       6   35    7               00 r[7]=rowset(6)
REG[6] =  NULL
REG[7] =  NULL
  35 DropTable        0    0    0 newname       00 
  36 SetCookie        0    1    6               00 
  37 Halt             0    0    0               00 
SQL: [DELETE FROM log_entry WHERE random()%10!=0;]
VDBE Trace:
   0 Init             0   20    0               00 Start at 20
  20 Transaction      0    1    6 0             01 usesStmtJournal=0
  21 Integer         10    4    0               00 r[4]=10
REG[4] =  i:10
  22 Integer          0    5    0               00 r[5]=0
REG[5] =  i:0
  23 Goto             0    1    0               00 
   1 Null             0    1    0               00 r[1]=NULL
REG[1] =  NULL
   2 OpenWrite        0    4    0 2             00 root=4 iDb=0; log_entry
   3 Explain          3    0    0 SCAN TABLE log_entry 00 
   4 Last             0   19    0               00 
   5 Function0        0    0    3 random(0)     00 r[3]=func(r[0])
REG[3] =  i:5253197396630558159
   6 Remainder        4    3    2               00 r[2]=r[3]%r[4]
REG[4] =  i:10
REG[3] =  i:5253197396630558159
REG[2] =  i:9
   7 Eq               5   18    2               50 if r[2]==r[5] goto 18
REG[5] =  i:0
REG[2] =  i:9
   8 Rowid            0    6    0               00 r[6]=rowid
REG[6] =  i:1
   9 Once             0   12    0               00 
  10 OpenWrite        1    6    0 k(2,,)        08 root=6 iDb=0; sqlite_autoindex_log_entry_2
  11 OpenWrite        2    5    0 k(2,,)        08 root=5 iDb=0; sqlite_autoindex_log_entry_1
  12 Column           0    1    7               00 r[7]=log_entry.tr1
REG[7] =  i:2
  13 Rowid            0    8    0               00 r[8]=rowid
REG[8] =  i:1
  14 IdxDelete        1    7    2               00 key=r[7..8]
  15 Column           0    0    7               00 r[7]=log_entry.col1
REG[7] =  NULL
  16 IdxDelete        2    7    2               00 key=r[7..8]
  17 Delete           0    1    0 log_entry     02 
  18 Prev             0    5    0               01 
  19 Halt             0    0    0               00 
SQL: [;DELETE FROM test WHERE random()%10;]
VDBE Trace:
   0 Init             0   17    0               00 Start at 17
  17 Transaction      0    1    6 0             01 usesStmtJournal=0
  18 Integer         10    4    0               00 r[4]=10
REG[4] =  i:10
  19 Goto             0    1    0               00 
   1 Null             0    1    0               00 r[1]=NULL
REG[1] =  NULL
   2 OpenWrite        0    2    0 1             00 root=2 iDb=0; test
   3 Explain          3    0    0 SCAN TABLE test 00 
   4 Last             0   16    0               00 
  16 Halt             0    0    0               00 
SQL: [;
;SELECT t1, sum(t1) OVER (
    RANGE BETWEEN CURRENT ROW AND CURRENT ROW
  ) FROM test ORDER BY t1;]
VDBE Trace:
   0 Init             0   87    0               00 Start at 87
  87 Transaction      0    0    6 0             01 usesStmtJournal=0
  88 Goto             0    1    0               00 
   1 Null             0    1    0               00 r[1]=NULL
REG[1] =  NULL
   2 OpenEphemeral    1    3    0               00 nColumn=3
   3 OpenDup          2    1    0               00 
   4 OpenDup          3    1    0               00 
   5 OpenDup          4    1    0               00 
   6 InitCoroutine    3   17    7               00 
  17 SorterOpen       6    4    0 k(1,B)        00 
  18 Integer          1    7    0               00 r[7]=1
REG[7] =  i:1
  19 Explain         19    0    0 SCAN SUBQUERY 2 00 
  20 InitCoroutine    3    0    7               00 
  21 Yield            3   52    0               00 next row of 
REG[3] =  i:6
REG[3] =  i:21
   7 Explain          7    0    0 CO-ROUTINE 2  00 
   8 OpenRead         0    2    0 1             00 root=2 iDb=0; test
   9 Explain          9    7    0 SCAN TABLE test 00 
  10 Last             0   16    0               00 
  16 EndCoroutine     3    0    0               00 
REG[3] =  i:21
  52 Rewind           2   70    0               00 
  70 ResetSorter      1    0    0               00 
  71 Goto             0   78    0               00 
  78 Explain         78    0    0 USE TEMP B-TREE FOR ORDER BY 00 
  79 OpenPseudo       7   19    4               00 4 columns in r[19]
  80 SorterSort       6   86    0               00 
  86 Halt             0    0    0               00 
SQL: [;
;SELECT b, sum(b) OVER (
    ROWS BETWEEN CURRENT ROW AND CURRENT ROW
  ) FROM a ORDER BY 1, 2;]
VDBE Trace:
   0 Init             0  135    0               00 Start at 135
 135 Transaction      0    0    6 0             01 usesStmtJournal=0
 136 Goto             0    1    0               00 
   1 Null             0    1    0               00 r[1]=NULL
REG[1] =  NULL
   2 OpenEphemeral    1    4    0               00 nColumn=4
   3 OpenDup          2    1    0               00 
   4 OpenDup          3    1    0               00 
   5 OpenDup          4    1    0               00 
   6 InitCoroutine    3   76    7               00 
  76 SorterOpen      11    5    0 k(2,B,B)      00 
  77 Integer          1   24    0               00 r[24]=1
REG[24] =  i:1
  78 Explain         78    0    0 SCAN SUBQUERY 2 00 
  79 InitCoroutine    3    0    7               00 
  80 Yield            3  105    0               00 next row of 
REG[3] =  i:6
REG[3] =  i:80
   7 Explain          7    0    0 CO-ROUTINE 2  00 
   8 Null             0    4    0               00 r[4]=NULL
REG[4] =  NULL
   9 OpenEphemeral    6    4    0               00 nColumn=4
  10 OpenDup          7    6    0               00 
  11 OpenDup          8    6    0               00 
  12 OpenDup          9    6    0               00 
  13 InitCoroutine    6   25   14               00 
  25 Integer          1   11    0               00 r[11]=1
REG[11] =  i:1
  26 Explain         26    7    0 SCAN SUBQUERY 3 00 
  27 InitCoroutine    6    0   14               00 
  28 Yield            6   53    0               00 next row of 
REG[6] =  i:13
REG[6] =  i:28
  14 Explain         14    7    0 CO-ROUTINE 3  00 
  15 OpenRead         0    3    0 0             00 root=3 iDb=0; a
  16 Explain         16   14    0 SCAN TABLE a  00 
  17 Last             0   24    0               00 
  18 Rowid            0    7    0               00 r[7]=rowid
REG[7] =  i:1
  19 Rowid            0    8    0               00 r[8]=rowid
REG[8] =  i:1
  20 Rowid            0    9    0               00 r[9]=rowid
REG[9] =  i:1
  21 Rowid            0   10    0               00 r[10]=rowid
REG[10] =  i:1
  22 Yield            6    0    0               00 
REG[6] =  i:28
REG[6] =  i:22
  29 Copy             7   13    0               00 r[13]=r[7]
REG[13] =  i:1
  30 Copy             8   14    0               00 r[14]=r[8]
REG[14] =  i:1
  31 Copy             9   15    0               00 r[15]=r[9]
REG[15] =  i:1
  32 Copy            10   16    0               00 r[16]=r[10]
REG[16] =  i:1
  33 MakeRecord      13    4   17               00 r[17]=mkrec(r[13..16])
REG[17] =  sx5[0509090909|.....]
  34 NewRowid         7   18    0               00 r[18]=rowid
REG[18] =  i:1
  35 Insert           7   17   18               00 intkey=r[18] data=r[17]
REG[17] =  sx5[0509090909|.....]
REG[18] =  i:1
  36 Ne              11   42   18               00 if r[18]!=r[11] goto 42
REG[11] =  i:1
REG[18] =  i:1
  37 Null             0    4    0               00 r[4]=NULL
REG[4] =  NULL
  38 Rewind           8    1    0               00 
  39 Rewind           6    1    0               00 
  40 Rewind           9    1    0               00 
  41 Goto             0   52    0               00 
  52 Goto             0   28    0               00 
  28 Yield            6   53    0               00 next row of 
REG[6] =  i:22
REG[6] =  i:28
  23 Prev             0   18    0               01 
  24 EndCoroutine     6    0    0               00 
REG[6] =  i:28
  53 Rewind           7   66    0               00 
  54 Column           9    3   19               00 r[19]=
REG[19] =  i:1
  55 AggStep          0   19    4 sum(1)        01 accum=r[4] step(r[19])
REG[19] =  i:1
  56 Next             9   57    0               00 
  57 AggValue         4    1    5 sum(1)        00 r[5]=value N=1
  58 Gosub           12   68    0               00 
REG[12] =  i:58
  68 Noop             0    0    0               00 inner-loop subroutine
  69 Column           6    0   20               00 r[20]=.b
REG[20] =  i:1
  70 Column           6    1   21               00 r[21]=.b:1
REG[21] =  i:1
  71 Copy             5   22    0               00 r[22]=r[5]
REG[22] =  i:1
  72 Column           6    2   23               00 r[23]=.b:2
REG[23] =  i:1
  73 Yield            3    0    0               00 
REG[3] =  i:80
REG[3] =  i:73
  81 Copy            20   26    0               00 r[26]=r[20]
REG[26] =  i:1
  82 Copy            21   27    0               00 r[27]=r[21]
REG[27] =  i:1
  83 Copy            22   28    0               00 r[28]=r[22]
REG[28] =  i:1
  84 Copy            23   29    0               00 r[29]=r[23]
REG[29] =  i:1
  85 MakeRecord      26    4   30               00 r[30]=mkrec(r[26..29])
REG[30] =  sx5[0509090909|.....]
  86 NewRowid         2   31    0               00 r[31]=rowid
REG[31] =  i:1
  87 Insert           2   30   31               00 intkey=r[31] data=r[30]
REG[30] =  sx5[0509090909|.....]
REG[31] =  i:1
  88 Ne              24   94   31               00 if r[31]!=r[24] goto 94
REG[24] =  i:1
REG[31] =  i:1
  89 Null             0    1    0               00 r[1]=NULL
REG[1] =  NULL
  90 Rewind           3    1    0               00 
  91 Rewind           1    1    0               00 
  92 Rewind           4    1    0               00 
  93 Goto             0  104    0               00 
 104 Goto             0   80    0               00 
  80 Yield            3  105    0               00 next row of 
REG[3] =  i:73
REG[3] =  i:80
  74 Return          12    0    0               00 end inner-loop subroutine
REG[12] =  i:58
  59 Next             6   61    0               00 
  60 Goto             0   66    0               00 
  66 ResetSorter      6    0    0               00 
  67 Goto             0   75    0               00 
  75 EndCoroutine     3    0    0               00 
REG[3] =  i:80
 105 Rewind           2  118    0               00 
 106 Column           4    3   32               00 r[32]=
REG[32] =  i:1
 107 AggStep          0   32    1 sum(1)        01 accum=r[1] step(r[32])
REG[32] =  i:1
 108 Next             4  109    0               00 
 109 AggValue         1    1    2 sum(1)        00 r[2]=value N=1
 110 Gosub           25  120    0               00 
REG[25] =  i:110
 120 Noop             0    0    0               00 inner-loop subroutine
 121 Column           1    1   33               00 r[33]=.b:1
REG[33] =  i:1
 122 Column           1    2   34               00 r[34]=.column3
REG[34] =  i:1
 123 MakeRecord      33    2   37               00 r[37]=mkrec(r[33..34])
REG[37] =  sx3[030909|...]
 124 SorterInsert    11   37   33 2             00 key=r[37]
REG[37] =  sx3[030909|...]
 125 Return          25    0    0               00 end inner-loop subroutine
REG[25] =  i:110
 111 Next             1  113    0               00 
 112 Goto             0  118    0               00 
 118 ResetSorter      1    0    0               00 
 119 Goto             0  126    0               00 
 126 Explain        126    0    0 USE TEMP B-TREE FOR ORDER BY 00 
 127 OpenPseudo      12   38    5               00 5 columns in r[38]
 128 SorterSort      11  134    0               00 
 129 SorterData      11   38   12               00 r[38]=data
 130 Column          12    1   36               00 r[36]=sum(b) OVER (
    ROWS BETWEEN CURRENT ROW AND CURRENT ROW
  )
REG[36] =  i:1
 131 Column          12    0   35               00 r[35]=b
REG[35] =  i:1
 132 ResultRow       35    2    0               00 output=r[35..36]
REG[35] =  i:1
REG[36] =  i:1
 133 SorterNext      11  129    0               00 
 134 Halt             0    0    0               00 
SQL: [;
;COMMIT
;]
VDBE Trace:
   0 Init             0    1    0               00 Start at 1
   1 AutoCommit       1    0    0               00 
SQL: [;
;SELECT DENSE_RANK() OVER(), LAG(0) OVER() FROM log_entry;]
VDBE Trace:
   0 Init             0  112    0               00 Start at 112
 112 Transaction      0    0    6 0             01 usesStmtJournal=0
 113 Goto             0    1    0               00 
   1 Null             0    1    0               00 r[1]=NULL
REG[1] =  NULL
   2 OpenEphemeral    1    1    0               00 nColumn=1
   3 OpenDup          2    1    0               00 
   4 OpenDup          3    1    0               00 
   5 OpenDup          4    1    0               00 
   6 InitCoroutine    3   67    7               00 
  67 Integer          1   16    0               00 r[16]=1
REG[16] =  i:1
  68 Explain         68    0    0 SCAN SUBQUERY 2 00 
  69 InitCoroutine    3    0    7               00 
  70 Yield            3   92    0               00 next row of 
REG[3] =  i:6
REG[3] =  i:70
   7 Explain          7    0    0 CO-ROUTINE 2  00 
   8 Null             0    4    0               00 r[4]=NULL
REG[4] =  NULL
   9 OpenEphemeral    6    1    0               00 nColumn=1
  10 OpenDup          7    6    0               00 
  11 OpenDup          8    6    0               00 
  12 OpenDup          9    6    0               00 
  13 InitCoroutine    6   22   14               00 
  22 Integer          1    8    0               00 r[8]=1
REG[8] =  i:1
  23 OpenDup         12    6    0               00 
  24 Explain         24    7    0 SCAN SUBQUERY 3 00 
  25 InitCoroutine    6    0   14               00 
  26 Yield            6   47    0               00 next row of 
REG[6] =  i:13
REG[6] =  i:26
  14 Explain         14    7    0 CO-ROUTINE 3  00 
  15 OpenRead        11    6    0 k(2,,)        00 root=6 iDb=0; sqlite_autoindex_log_entry_2
  16 Explain         16   14    0 SCAN TABLE log_entry USING COVERING INDEX sqlite_autoindex_log_entry_2 00 
  17 Last            11   21    7 0             00 
  21 EndCoroutine     6    0    0               00 
REG[6] =  i:26
  47 Rewind           7   60    0               00 
  60 ResetSorter      6    0    0               00 
  61 Goto             0   66    0               00 
  66 EndCoroutine     3    0    0               00 
REG[3] =  i:70
  92 Rewind           2  104    0               00 
 104 ResetSorter      1    0    0               00 
 105 Goto             0  111    0               00 
 111 Halt             0    0    0               00 
SQL: [;
;SELECT * FROM a WHERE 
      (0, a.b) IN (SELECT DENSE_RANK() OVER(), LAG(0) OVER() FROM a);]
VDBE Trace:
   0 Init             0  146    0               00 Start at 146
 146 Transaction      0    0    6 0             01 usesStmtJournal=0
 147 Integer          0   29    0               00 r[29]=0
REG[29] =  i:0
 148 Goto             0    1    0               00 
   1 OpenRead         0    3    0 4             00 root=3 iDb=0; a
   2 Explain          2    0    0 SEARCH TABLE a USING INTEGER PRIMARY KEY (rowid=?) 00 
   3 Integer         14    2    0               00 r[2]=14; return address
REG[2] =  i:14
   4 Once             0   14    0               00 
   5 OpenEphemeral    2    1    0 k(1,)         00 nColumn=1; Result of SELECT 1
   6 Explain          6    0    0 LIST SUBQUERY 1 00 
   7 OpenRead         1    3    0 0             00 root=3 iDb=0; a
   8 Explain          8    6    0 SCAN TABLE a  00 
   9 Last             1   14    0               00 
  10 SCopy            0    3    0               00 r[3]=r[0]
REG[3] =  undefined
  11 MakeRecord       3    1    4 D             00 r[4]=mkrec(r[3])

Program received signal SIGABRT, Aborted.
__GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:50
(gdb) #0  __GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:50
#1  0x00007f7279d79859 in __GI_abort () at abort.c:79
#2  0x00007f7279d79729 in __assert_fail_base (fmt=0x7f7279f0f588 "%s%s%s:%u: %s%sAssertion `%s' failed.\n%n", assertion=0x222142 "memIsValid(pRec)", file=0x2291f4 "sqlite3.c", line=86917, function=<optimized out>)
    at assert.c:92
#3  0x00007f7279d8afd6 in __GI___assert_fail (assertion=0x222142 "memIsValid(pRec)", file=0x2291f4 "sqlite3.c", line=86917, function=0x216a86 "int sqlite3VdbeExec(Vdbe *)") at assert.c:101
#4  0x00000000003d3831 in sqlite3VdbeExec (p=0x178d430) at sqlite3.c:86917
#5  0x000000000041ba74 in sqlite3Step (p=0x178d430) at sqlite3.c:82300
#6  0x0000000000293d5d in sqlite3_step (pStmt=0x178d430) at sqlite3.c:82365
#7  0x0000000000258a39 in main (argc=1, argv=0x7ffef0aa8f78) at target.cc:139
(gdb) quit
A debugging session is active.

	Inferior 1 [process 54793] will be killed.

Quit anyway? (y or n) [answered Y; input not from terminal]
