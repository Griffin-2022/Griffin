GNU gdb (Ubuntu 9.2-0ubuntu1~20.04.1) 9.2
Copyright (C) 2020 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type "show copying" and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
    <http://www.gnu.org/software/gdb/documentation/>.

For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from /root/sqlite_driver_fast...
(gdb) Starting program: /root/sqlite_driver_fast < "/root/out/default/crashes/id:000284,sig:06,src:021236+022435,time:5763954,execs:1095144,op:merge.so,pos:0"
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
SQL: [;PRAGMA vdbe_trace=on;]
VDBE Trace:
   0 Init             0    1    0               00 Start at 1
   1 Expire           0    0    0               00 
   2 Halt             0    0    0               00 
SQL: [select length(zeroblob(-1))
;]
VDBE Trace:
   0 Init             0    5    0               00 Start at 5
   5 Integer         -1    4    0               00 r[4]=-1
REG[4] =  i:-1
   6 Function0        1    4    3 zeroblob(1)   01 r[3]=func(r[4])
REG[4] =  i:-1
REG[3] =  sx0[|]+0z
   7 Function0        1    3    2 length(1)     01 r[2]=func(r[3])
REG[3] =  sx0[|]+0z
REG[2] =  i:0
   8 Goto             0    1    0               00 
   1 Explain          1    0    0 SCAN CONSTANT ROW 00 
   2 Copy             2    1    0               00 r[1]=r[2]
REG[1] =  i:0
   3 ResultRow        1    1    0               00 output=r[1]
REG[1] =  i:0
   4 Halt             0    0    0               00 
SQL: [;SELECT quote(a) FROM test ORDER BY rowid;]
VDBE Trace:
   0 Init             0   10    0               00 Start at 10
  10 Transaction      0    0    4 0             01 usesStmtJournal=0
  11 Goto             0    1    0               00 
   1 Noop             1    3    0               00 
   2 OpenRead         0    3    0 2             00 root=3 iDb=0; test
   3 Explain          3    0    0 SCAN TABLE test 00 
   4 Rewind           0    9    0               00 
   9 Halt             0    0    0               00 
SQL: [SELECT 000000000002e-0000000025*0.5e25
;]
VDBE Trace:
   0 Init             0    5    0               00 Start at 5
   5 Real             0    2    0 2e-25         00 r[2]=2e-25
REG[2] =  r:2.0000000000000001e-25
   6 Real             0    3    0 5e+24         00 r[3]=5e+24
REG[3] =  r:5.0000000000000005e+24
   7 Goto             0    1    0               00 
   1 Explain          1    0    0 SCAN CONSTANT ROW 00 
   2 Multiply         3    2    1               00 r[1]=r[3]*r[2]
REG[3] =  r:5.0000000000000005e+24
REG[2] =  r:2.0000000000000001e-25
REG[1] =  r:1.0000000000000002
   3 ResultRow        1    1    0               00 output=r[1]
REG[1] =  r:1.0000000000000002
   4 Halt             0    0    0               00 
SQL: [;CREATE VIEW newname AS SELECT main.one.b, one.b, a FROM test AS one;]
VDBE Trace:
   0 Init             0   28    0               00 Start at 28
  28 Transaction      0    1    4 0             01 usesStmtJournal=0
  29 Goto             0    1    0               00 
   1 ReadCookie       0    3    2               00 
REG[3] =  i:4
   2 If               3    5    0               00 
REG[3] =  i:4
   5 Integer          0    2    0               00 r[2]=0
REG[2] =  i:0
   6 OpenWrite        0    1    0 5             00 root=1 iDb=0
   7 NewRowid         0    1    0               00 r[1]=rowid
REG[1] =  i:5
   8 Blob             6    3    0              00 r[3]= (len=6)
REG[3] =  tx6[060000000000|......]
   9 Insert           0    3    1               08 intkey=r[1] data=r[3]
REG[3] =  tx6[060000000000|......]
REG[1] =  i:5
  10 Close            0    0    0               00 
  11 Close            0    0    0               00 
  12 Null             0    4    5               00 r[4..5]=NULL
REG[4] =  NULL
  13 OpenWrite        1    1    0 5             00 root=1 iDb=0; sqlite_master
  14 Explain         14    0    0 SEARCH TABLE sqlite_master USING INTEGER PRIMARY KEY (rowid=?) 00 
  15 SeekRowid        1   17    1               00 intkey=r[1]
REG[1] =  i:5
  16 Rowid            1    5    0               00 r[5]=rowid
REG[5] =  i:5
  17 IsNull           5   25    0               00 if r[5]==NULL goto 25
REG[5] =  i:5
  18 String8          0    6    0 view          00 r[6]='view'
REG[6] =   t4[view](8)
  19 String8          0    7    0 newname       00 r[7]='newname'
REG[7] =   t7[newname](8)
  20 String8          0    8    0 newname       00 r[8]='newname'
REG[8] =   t7[newname](8)
  21 Copy             2    9    0               00 r[9]=r[2]
REG[9] =  i:0
  22 String8          0   10    0 CREATE VIEW newname AS SELECT main.one.b, one.b, a FROM test AS one 00 r[10]='CREATE VIEW newname AS SELECT main.one.b, one.b, a FROM test AS one'
REG[10] =   t67[CREATE VIEW newname AS SE](8)
  23 MakeRecord       6    5    4 BBBDB         00 r[4]=mkrec(r[6..10])
REG[6] =   t4[view](8)
REG[7] =   t7[newname](8)
REG[8] =   t7[newname](8)
REG[9] =  i:0
REG[10] =   t67[CREATE VIEW newname AS SE](8)
REG[4] =  sx92[07151B1B088113766965776E65776E616D656E65776E616D65|.......viewnewnamenewname]
  24 Insert           1    4    5               00 intkey=r[5] data=r[4]
REG[4] =  sx92[07151B1B088113766965776E65776E616D656E65776E616D65|.......viewnewnamenewname]
REG[5] =  i:5
  25 SetCookie        0    1    5               00 
  26 ParseSchema      0    0    0 tbl_name='newname' AND type!='trigger' 00 
VDBE Trace:
   0 Init             0   17    0               00 Start at 17
  17 Transaction      0    0    5 0             00 usesStmtJournal=0
  18 String8          0    2    0 newname       00 r[2]='newname'
REG[2] =   t7[newname](8)
  19 String8          0    3    0 trigger       00 r[3]='trigger'
REG[3] =   t7[trigger](8)
  20 Goto             0    1    0               00 
   1 Noop             1    7    0               00 
   2 OpenRead         0    1    0 5             00 root=1 iDb=0; sqlite_master
   3 Explain          3    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   16    0               00 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s4[test](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t7[newname](8)
REG[1] =   s4[test](8)
  15 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s1[c](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t7[newname](8)
REG[1] =   s1[c](8)
  15 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s1[x](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t7[newname](8)
REG[1] =   s1[x](8)
  15 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s1[c](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t7[newname](8)
REG[1] =   s1[c](8)
  15 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s7[newname](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t7[newname](8)
REG[1] =   s7[newname](8)
   7 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s4[view](8)
   8 Eq               3   15    1 (BINARY)      52 if r[1]==r[3] goto 15
REG[3] =   t7[trigger](8)
REG[1] =   s4[view](8)
   9 Column           0    0    4               00 r[4]=sqlite_master.type
REG[4] =   s4[view](8)
  10 Column           0    1    5               00 r[5]=sqlite_master.name
REG[5] =   s7[newname](8)
  11 Column           0    2    6               00 r[6]=sqlite_master.tbl_name
REG[6] =   s7[newname](8)
  12 Column           0    3    7               00 r[7]=sqlite_master.rootpage
REG[7] =  i:0
  13 Column           0    4    8               00 r[8]=sqlite_master.sql
REG[8] =   s67[CREATE VIEW newname AS SE](8)
  14 ResultRow        4    5    0               00 output=r[4..8]
REG[4] =   s4[view](8)
REG[5] =   s7[newname](8)
REG[6] =   s7[newname](8)
REG[7] =  i:0
REG[8] =   s67[CREATE VIEW newname AS SE](8)
  15 Next             0    5    0               01 
  16 Halt             0    0    0               00 
  27 Halt             0    0    0               00 
SQL: [;INSERT INTO test(t1) VALUES(NULL);]
VDBE Trace:
   0 Init             0    7    0               00 Start at 7
   7 Transaction      0    1    5 0             01 usesStmtJournal=0
   8 Null             0    3    0               00 r[3]=NULL
REG[3] =  NULL
   9 Null             0    4    0               00 r[4]=NULL
REG[4] =  NULL
  10 Goto             0    1    0               00 
   1 OpenWrite        0    3    0 3             00 root=3 iDb=0; test
   2 NewRowid         0    1    0               00 r[1]=rowid
REG[1] =  i:1
   3 Null             0    2    0               00 r[2]=NULL
REG[2] =  NULL
   4 MakeRecord       2    3    5               00 r[5]=mkrec(r[2..4])
REG[5] =  sx4[04000000|....]
   5 Insert           0    5    1 test          39 intkey=r[1] data=r[5]
REG[5] =  sx4[04000000|....]
REG[1] =  i:1
   6 Halt             0    0    0               00 
SQL: [;INSERT INTO c(t2) VALUES(NULL),(5);]
VDBE Trace:
   0 Init             0   25    0               00 Start at 25
  25 Transaction      0    1    5 0             01 usesStmtJournal=1
  26 Goto             0    1    0               00 
   1 InitCoroutine    3    8    2               00 
   8 OpenWrite        0    4    0 1             00 root=4 iDb=0; c
   9 OpenWrite        1    6    0 k(2,,)        00 root=6 iDb=0; tr1
  10 Yield            3   24    0               00 
REG[3] =  i:1
REG[3] =  i:10
   2 Explain          2    0    0 SCAN 2 CONSTANT ROWS 00 
   3 Null             0    2    0               00 r[2]=NULL
REG[2] =  NULL
   4 Yield            3    0    0               00 
REG[3] =  i:10
REG[3] =  i:4
  11 NewRowid         0    1    0               00 r[1]=rowid
REG[1] =  i:1
  12 Abortable        0    0    0               00 
  13 Ne               2   15    2 (BINARY)      52 if r[2]!=r[2] goto 15
REG[2] =  NULL
REG[2] =  NULL
  15 Affinity         2    1    0 B             00 affinity(r[2])
REG[2] =  NULL
  16 Noop             0    0    0               00 uniqueness check for tr1
  17 SCopy            2    5    0               00 r[5]=r[2]; t2
REG[5] =  NULL
  18 IntCopy          1    6    0               00 r[6]=r[1]; rowid
REG[6] =  i:1
  19 MakeRecord       5    2    4               00 r[4]=mkrec(r[5..6]); for tr1
REG[4] =  sx3[030009|...]
  20 MakeRecord       2    1    7               00 r[7]=mkrec(r[2])
REG[7] =  sx2[0200|..]
  21 IdxInsert        1    4    5 2             10 key=r[4]
REG[4] =  sx3[030009|...]
  22 Insert           0    7    1 c             39 intkey=r[1] data=r[7]
REG[7] =  sx2[0200|..]
REG[1] =  i:1
  23 Goto             0   10    0               00 
  10 Yield            3   24    0               00 
REG[3] =  i:4
REG[3] =  i:10
   5 Integer          5    2    0               00 r[2]=5
REG[2] =  i:5
   6 Yield            3    0    0               00 
REG[3] =  i:10
REG[3] =  i:6
  11 NewRowid         0    1    0               00 r[1]=rowid
REG[1] =  i:2
  12 Abortable        0    0    0               00 
  13 Ne               2   15    2 (BINARY)      52 if r[2]!=r[2] goto 15

Program received signal SIGABRT, Aborted.
__GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:50
(gdb) #0  __GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:50
#1  0x00007f1202d99859 in __GI_abort () at abort.c:79
#2  0x00007f1202d99729 in __assert_fail_base (fmt=0x7f1202f2f588 "%s%s%s:%u: %s%sAssertion `%s' failed.\n%n", assertion=0x21dc88 "pIn1!=pIn3", file=0x2291f4 "sqlite3.c", line=86002, function=<optimized out>) at assert.c:92
#3  0x00007f1202daafd6 in __GI___assert_fail (assertion=0x21dc88 "pIn1!=pIn3", file=0x2291f4 "sqlite3.c", line=86002, function=0x216a86 "int sqlite3VdbeExec(Vdbe *)") at assert.c:101
#4  0x00000000003cf4ad in sqlite3VdbeExec (p=0x263e2c0) at sqlite3.c:86002
#5  0x000000000041ba74 in sqlite3Step (p=0x263e2c0) at sqlite3.c:82300
#6  0x0000000000293d5d in sqlite3_step (pStmt=0x263e2c0) at sqlite3.c:82365
#7  0x0000000000258a39 in main (argc=1, argv=0x7fffec508318) at target.cc:139
(gdb) quit
A debugging session is active.

	Inferior 1 [process 53380] will be killed.

Quit anyway? (y or n) [answered Y; input not from terminal]
