GNU gdb (Ubuntu 9.2-0ubuntu1~20.04.1) 9.2
Copyright (C) 2020 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type "show copying" and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
    <http://www.gnu.org/software/gdb/documentation/>.

For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from /root/sqlite_driver_fast...
(gdb) Starting program: /root/sqlite_driver_fast < "/root/out/default/crashes/id:000265,sig:06,src:008520+007008,time:8794013,execs:859478,op:merge.so,pos:0"
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
SQL: [;
PRAGMA vdbe_trace=on;]
VDBE Trace:
   0 Init             0    0    0               00 Start at 0
   1 Expire           0    0    0               00 
   2 Halt             0    0    0               00 
SQL: [PRAGMA mmap_size =    53248 ;]
VDBE Trace:
   0 Init             0    0    0               00 Start at 0
   1 Halt             0    0    0               00 
VDBE Trace:
   0 Init             0   12    0               00 Start at 12
  12 Transaction      0    0    0 0             00 usesStmtJournal=0
  13 TableLock        0    1    0 sqlite_master 00 iDb=0 root=1 write=0
  14 Goto             0    1    0               00 
   1 Noop             1    5    0               00 
   2 OpenRead         0    1    0 5             00 root=1 iDb=0; sqlite_master
   3 Explain          0    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   10    0               00 
  10 Close            0    0    0               00 
  11 Halt             0    0    0               00 
SQL: [SELECT count(*) FROM sqlite_temp_master;]
VDBE Trace:
   0 Init             0    7    0               00 Start at 7
   7 Transaction      1    0    0 0             01 usesStmtJournal=0
   8 TableLock        1    1    0 sqlite_temp_master 00 iDb=1 root=1 write=0
   9 Goto             0    1    0               00 
   1 OpenRead         1    1    1 1             00 root=1 iDb=1
   2 Count            1    1    0               00 r[1]=count()
REG[1] =  i:0
   3 Close            1    0    0               00 
   4 Copy             1    2    0               00 r[2]=r[1]
REG[2] =  i:0
   5 ResultRow        2    1    0               00 output=r[2]
REG[2] =  i:0
   6 Halt             0    0    0               00 
SQL: [PRAGMA multiplex_truncate;]
VDBE Trace:
   0 Init             0    0    0               00 Start at 0
   1 Halt             0    0    0               00 
SQL: [ATTACH 'test.db' AS db7;]
VDBE Trace:
   0 Init             0    0    0               00 Start at 0
   1 String8          0    1    0 test.db       00 r[1]='test.db'
REG[1] =   t7[test.db](8)
   2 String8          0    2    0 db7           00 r[2]='db7'
REG[2] =   t3[db7](8)
   3 Null             0    3    0               00 r[3]=NULL
REG[3] =  NULL
   4 Function0        0    1    4 sqlite_attach(3) 03 r[4]=func(r[1..3])
REG[1] =   t7[test.db](8)
REG[2] =   t3[db7](8)
REG[3] =  NULL
VDBE Trace:
   0 Init             0   12    0               00 Start at 12
  12 Transaction      2    0    9 0             00 usesStmtJournal=0
  13 TableLock        2    1    0 sqlite_master 00 iDb=2 root=1 write=0
  14 Goto             0    1    0               00 
   1 Noop             1    5    0               00 
   2 OpenRead         0    1    2 5             00 root=1 iDb=2; sqlite_master
   3 Explain          0    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   10    0               00 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s12[sqlite_stat1](8)
   6 Column           0    3    2               00 r[2]=sqlite_master.rootpage
REG[2] =  i:2
   7 Column           0    4    3               00 r[3]=sqlite_master.sql
REG[3] =   s39[CREATE TABLE sq](8)
   8 ResultRow        1    3    0               00 output=r[1..3]
REG[1] =   s12[sqlite_stat1](8)
REG[2] =  i:2
REG[3] =   s39[CREATE TABLE sq](8)
   9 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s3[oid](8)
   6 Column           0    3    2               00 r[2]=sqlite_master.rootpage
REG[2] =  i:3
   7 Column           0    4    3               00 r[3]=sqlite_master.sql
REG[3] =   s19[CREATE TABLE oi](8)
   8 ResultRow        1    3    0               00 output=r[1..3]
REG[1] =   s3[oid](8)
REG[2] =  i:3
REG[3] =   s19[CREATE TABLE oi](8)
   9 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s3[c00](8)
   6 Column           0    3    2               00 r[2]=sqlite_master.rootpage
REG[2] =  i:0
   7 Column           0    4    3               00 r[3]=sqlite_master.sql
REG[3] =   s96[CREATE TRIGGER ](8)
   8 ResultRow        1    3    0               00 output=r[1..3]
REG[1] =   s3[c00](8)
REG[2] =  i:0
REG[3] =   s96[CREATE TRIGGER ](8)
   9 Next             0    5    0               01 
  10 Close            0    0    0               00 
  11 Halt             0    0    0               00 
VDBE Trace:
   0 Init             0   11    0               00 Start at 11
  11 Transaction      2    0    9 0             00 usesStmtJournal=0
  12 TableLock        2    2    0 sqlite_stat1  00 iDb=2 root=2 write=0
  13 Goto             0    1    0               00 
   1 OpenRead         0    2    2 3             00 root=2 iDb=2; sqlite_stat1
   2 Explain          0    0    0 SCAN TABLE sqlite_stat1 00 
   3 Rewind           0    9    0               00 
   9 Close            0    0    0               00 
  10 Halt             0    0    0               00 
REG[4] =  NULL
   5 Expire           1    0    0               00 
   6 Halt             0    0    0               00 
SQL: [PRAGMA default_synchronous;]
VDBE Trace:
   0 Init             0    0    0               00 Start at 0
   1 Halt             0    0    0               00 
SQL: [;
PRAGMA synchronous;]
VDBE Trace:
   0 Init             0    0    0               00 Start at 0
   1 Int64            0    1    0 2             00 r[1]=2
REG[1] =  i:2
   2 ResultRow        1    1    0               00 output=r[1]
REG[1] =  i:2
   3 Halt             0    0    0               00 
SQL: [PRAGMA multiplex_truncate=0;]
VDBE Trace:
   0 Init             0    0    0               00 Start at 0
   1 Halt             0    0    0               00 
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[cmdlist explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping cmdlist
parser: Popping $
SQL: [;
PRAGMA parser_trace=ON;]
VDBE Trace:
   0 Init             0    0    0               00 Start at 0
   1 Halt             0    0    0               00 
parser: Initialize. Empty stack. State 0
parser: Input 'SEMI'
parser: Shift 'SEMI'
parser: Return. Stack=[SEMI]
parser: Input 'ATTACH'
parser: Reduce [ecmd ::= SEMI], go to state 0.
parser: Shift 'ecmd'
parser: Reduce [cmdlist ::= ecmd], go to state 0.
parser: Shift 'cmdlist', go to state 146
parser: FALLBACK ATTACH => ID
parser: Reduce [explain ::=], go to state 146.
parser: Shift 'explain', go to state 2
parser: Shift 'ATTACH', go to state 239
parser: Return. Stack=[cmdlist explain ATTACH]
parser: Input 'STRING'
parser: Reduce [database_kw_opt ::=], go to state 239.
parser: Shift 'database_kw_opt', go to state 58
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[cmdlist explain ATTACH database_kw_opt STRING]
parser: Input 'AS'
parser: Reduce [term ::= STRING], go to state 58.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 58.
parser: Shift 'expr', go to state 26
parser: Shift 'AS', go to state 57
parser: Return. Stack=[cmdlist explain ATTACH database_kw_opt expr AS]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain ATTACH database_kw_opt expr AS ID]
parser: Input 'SEMI'
parser: Reduce [expr ::= ID|INDEXED], go to state 57.
parser: Shift 'expr', go to state 11
parser: Reduce [key_opt ::=], go to state 11.
parser: Shift 'key_opt'
parser: Reduce [cmd ::= ATTACH database_kw_opt expr AS expr key_opt], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[cmdlist explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping cmdlist
parser: Popping $
SQL: [;
ATTACH 'test.db' as db9;]
VDBE Trace:
   0 Init             0    0    0               00 Start at 0
   1 String8          0    1    0 test.db       00 r[1]='test.db'
REG[1] =   t7[test.db](8)
   2 String8          0    2    0 db9           00 r[2]='db9'
REG[2] =   t3[db9](8)
   3 Null             0    3    0               00 r[3]=NULL
REG[3] =  NULL
   4 Function0        0    1    4 sqlite_attach(3) 03 r[4]=func(r[1..3])
REG[1] =   t7[test.db](8)
REG[2] =   t3[db9](8)
REG[3] =  NULL
parser: Initialize. Empty stack. State 0
parser: Input 'CREATE'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Shift 'CREATE'
parser: Return. Stack=[explain CREATE]
parser: Input 'TABLE'
parser: Reduce [createkw ::= CREATE], go to state 2.
parser: Shift 'createkw', go to state 107
parser: Reduce [temp ::=], go to state 107.
parser: Shift 'temp', go to state 319
parser: Shift 'TABLE', go to state 266
parser: Return. Stack=[explain createkw temp TABLE]
parser: Input 'ID'
parser: Reduce [ifnotexists ::=], go to state 266.
parser: Shift 'ifnotexists', go to state 183
parser: Shift 'ID'
parser: Return. Stack=[explain createkw temp TABLE ifnotexists ID]
parser: Input 'LP'
parser: Reduce [nm ::= ID|INDEXED], go to state 183.
parser: Shift 'nm', go to state 265
parser: Reduce [dbnm ::=], go to state 265.
parser: Shift 'dbnm'
parser: Reduce [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 2.
parser: Shift 'create_table', go to state 234
parser: Shift 'LP', go to state 111
parser: Return. Stack=[explain create_table LP]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP ID]
parser: Input 'ID'
parser: Reduce [nm ::= ID|INDEXED], go to state 111.
parser: Shift 'nm', go to state 148
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP nm ID]
parser: Input 'COMMA'
parser: Reduce [typename ::= ID|STRING], go to state 148.
parser: Shift 'typename', go to state 321
parser: Reduce [typetoken ::= typename], go to state 148.
parser: Shift 'typetoken'
parser: Reduce [columnname ::= nm typetoken], go to state 111.
parser: Shift 'columnname', go to state 311
parser: Reduce [carglist ::=], go to state 311.
parser: Shift 'carglist', go to state 119
parser: Reduce [columnlist ::= columnname carglist], go to state 111.
parser: Shift 'columnlist', go to state 300
parser: Shift 'COMMA', go to state 21
parser: Return. Stack=[explain create_table LP columnlist COMMA]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP columnlist COMMA ID]
parser: Input 'ID'
parser: Reduce [nm ::= ID|INDEXED], go to state 21.
parser: Shift 'nm', go to state 148
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP columnlist COMMA nm ID]
parser: Input 'COMMA'
parser: Reduce [typename ::= ID|STRING], go to state 148.
parser: Shift 'typename', go to state 321
parser: Reduce [typetoken ::= typename], go to state 148.
parser: Shift 'typetoken'
parser: Reduce [columnname ::= nm typetoken], go to state 21.
parser: Shift 'columnname', go to state 314
parser: Reduce [carglist ::=], go to state 314.
parser: Shift 'carglist', go to state 120
parser: Reduce [columnlist ::= columnlist COMMA columnname carglist], go to state 111.
parser: Shift 'columnlist', go to state 300
parser: Shift 'COMMA', go to state 21
parser: Return. Stack=[explain create_table LP columnlist COMMA]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP columnlist COMMA ID]
parser: Input 'ID'
parser: Reduce [nm ::= ID|INDEXED], go to state 21.
parser: Shift 'nm', go to state 148
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP columnlist COMMA nm ID]
parser: Input 'COMMA'
parser: Reduce [typename ::= ID|STRING], go to state 148.
parser: Shift 'typename', go to state 321
parser: Reduce [typetoken ::= typename], go to state 148.
parser: Shift 'typetoken'
parser: Reduce [columnname ::= nm typetoken], go to state 21.
parser: Shift 'columnname', go to state 314
parser: Reduce [carglist ::=], go to state 314.
parser: Shift 'carglist', go to state 120
parser: Reduce [columnlist ::= columnlist COMMA columnname carglist], go to state 111.
parser: Shift 'columnlist', go to state 300
parser: Shift 'COMMA', go to state 21
parser: Return. Stack=[explain create_table LP columnlist COMMA]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP columnlist COMMA ID]
parser: Input 'ID'
parser: Reduce [nm ::= ID|INDEXED], go to state 21.
parser: Shift 'nm', go to state 148
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP columnlist COMMA nm ID]
parser: Input 'COMMA'
parser: Reduce [typename ::= ID|STRING], go to state 148.
parser: Shift 'typename', go to state 321
parser: Reduce [typetoken ::= typename], go to state 148.
parser: Shift 'typetoken'
parser: Reduce [columnname ::= nm typetoken], go to state 21.
parser: Shift 'columnname', go to state 314
parser: Reduce [carglist ::=], go to state 314.
parser: Shift 'carglist', go to state 120
parser: Reduce [columnlist ::= columnlist COMMA columnname carglist], go to state 111.
parser: Shift 'columnlist', go to state 300
parser: Shift 'COMMA', go to state 21
parser: Return. Stack=[explain create_table LP columnlist COMMA]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP columnlist COMMA ID]
parser: Input 'ID'
parser: Reduce [nm ::= ID|INDEXED], go to state 21.
parser: Shift 'nm', go to state 148
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP columnlist COMMA nm ID]
parser: Input 'RP'
parser: Reduce [typename ::= ID|STRING], go to state 148.
parser: Shift 'typename', go to state 321
parser: Reduce [typetoken ::= typename], go to state 148.
parser: Shift 'typetoken'
parser: Reduce [columnname ::= nm typetoken], go to state 21.
parser: Shift 'columnname', go to state 314
parser: Reduce [carglist ::=], go to state 314.
parser: Shift 'carglist', go to state 120
parser: Reduce [columnlist ::= columnlist COMMA columnname carglist], go to state 111.
parser: Shift 'columnlist', go to state 300
parser: Reduce [conslist_opt ::=], go to state 300.
parser: Shift 'conslist_opt', go to state 437
parser: Shift 'RP', go to state 299
parser: Return. Stack=[explain create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI'
parser: Reduce [table_options ::=], go to state 299.
parser: Shift 'table_options'
parser: Reduce [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 234.
parser: Shift 'create_table_args'
parser: Reduce [cmd ::= create_table create_table_args], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'SELECT'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[explain with SELECT]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'FROM'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[explain with SELECT distinct selcollist FROM]
parser: Input 'ID'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'ID'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'DOT'
parser: Reduce [nm ::= ID|INDEXED], go to state 165.
parser: Shift 'nm', go to state 287
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'ORDER'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Reduce [where_opt ::=], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Shift 'ORDER', go to state 411
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY'
parser: Shift 'BY', go to state 17
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI'
parser: Reduce [expr ::= ID|INDEXED], go to state 17.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 17.
parser: Shift 'sortlist', go to state 410
parser: Reduce [orderby_opt ::= ORDER BY sortlist], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 22.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 2.
parser: Shift 'select'
parser: Reduce [cmd ::= select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
VDBE Trace:
   0 Init             0   12    0               00 Start at 12
  12 Transaction      3    0    9 0             00 usesStmtJournal=0
  13 TableLock        3    1    0 sqlite_master 00 iDb=3 root=1 write=0
  14 Goto             0    1    0               00 
   1 Noop             1    5    0               00 
   2 OpenRead         0    1    3 5             00 root=1 iDb=3; sqlite_master
   3 Explain          0    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   10    0               00 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s12[sqlite_stat1](8)
   6 Column           0    3    2               00 r[2]=sqlite_master.rootpage
REG[2] =  i:2
   7 Column           0    4    3               00 r[3]=sqlite_master.sql
REG[3] =   s39[CREATE TABLE sq](8)
   8 ResultRow        1    3    0               00 output=r[1..3]
REG[1] =   s12[sqlite_stat1](8)
REG[2] =  i:2
REG[3] =   s39[CREATE TABLE sq](8)
parser: Initialize. Empty stack. State 0
parser: Input 'CREATE'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Shift 'CREATE'
parser: Return. Stack=[explain CREATE]
parser: Input 'TABLE'
parser: Reduce [createkw ::= CREATE], go to state 2.
parser: Shift 'createkw', go to state 107
parser: Reduce [temp ::=], go to state 107.
parser: Shift 'temp', go to state 319
parser: Shift 'TABLE', go to state 266
parser: Return. Stack=[explain createkw temp TABLE]
parser: Input 'ID'
parser: Reduce [ifnotexists ::=], go to state 266.
parser: Shift 'ifnotexists', go to state 183
parser: Shift 'ID'
parser: Return. Stack=[explain createkw temp TABLE ifnotexists ID]
parser: Input 'LP'
parser: Reduce [nm ::= ID|INDEXED], go to state 183.
parser: Shift 'nm', go to state 265
parser: Reduce [dbnm ::=], go to state 265.
parser: Shift 'dbnm'
parser: Reduce [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 2.
parser: Shift 'create_table', go to state 234
parser: Shift 'LP', go to state 111
parser: Return. Stack=[explain create_table LP]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP ID]
parser: Input 'COMMA'
parser: Reduce [nm ::= ID|INDEXED], go to state 111.
parser: Shift 'nm', go to state 148
parser: Reduce [typetoken ::=], go to state 148.
parser: Shift 'typetoken'
parser: Reduce [columnname ::= nm typetoken], go to state 111.
parser: Shift 'columnname', go to state 311
parser: Reduce [carglist ::=], go to state 311.
parser: Shift 'carglist', go to state 119
parser: Reduce [columnlist ::= columnname carglist], go to state 111.
parser: Shift 'columnlist', go to state 300
parser: Shift 'COMMA', go to state 21
parser: Return. Stack=[explain create_table LP columnlist COMMA]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP columnlist COMMA ID]
parser: Input 'COMMA'
parser: Reduce [nm ::= ID|INDEXED], go to state 21.
parser: Shift 'nm', go to state 148
parser: Reduce [typetoken ::=], go to state 148.
parser: Shift 'typetoken'
parser: Reduce [columnname ::= nm typetoken], go to state 21.
parser: Shift 'columnname', go to state 314
parser: Reduce [carglist ::=], go to state 314.
parser: Shift 'carglist', go to state 120
parser: Reduce [columnlist ::= columnlist COMMA columnname carglist], go to state 111.
parser: Shift 'columnlist', go to state 300
parser: Shift 'COMMA', go to state 21
parser: Return. Stack=[explain create_table LP columnlist COMMA]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP columnlist COMMA ID]
parser: Input 'RP'
parser: Reduce [nm ::= ID|INDEXED], go to state 21.
parser: Shift 'nm', go to state 148
parser: Reduce [typetoken ::=], go to state 148.
parser: Shift 'typetoken'
parser: Reduce [columnname ::= nm typetoken], go to state 21.
parser: Shift 'columnname', go to state 314
parser: Reduce [carglist ::=], go to state 314.
parser: Shift 'carglist', go to state 120
parser: Reduce [columnlist ::= columnlist COMMA columnname carglist], go to state 111.
parser: Shift 'columnlist', go to state 300
parser: Reduce [conslist_opt ::=], go to state 300.
parser: Shift 'conslist_opt', go to state 437
parser: Shift 'RP', go to state 299
parser: Return. Stack=[explain create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI'
parser: Reduce [table_options ::=], go to state 299.
parser: Shift 'table_options'
parser: Reduce [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 234.
parser: Shift 'create_table_args'
parser: Reduce [cmd ::= create_table create_table_args], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
   9 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s3[oid](8)
   6 Column           0    3    2               00 r[2]=sqlite_master.rootpage
REG[2] =  i:3
   7 Column           0    4    3               00 r[3]=sqlite_master.sql
REG[3] =   s19[CREATE TABLE oi](8)
   8 ResultRow        1    3    0               00 output=r[1..3]
REG[1] =   s3[oid](8)
REG[2] =  i:3
REG[3] =   s19[CREATE TABLE oi](8)
parser: Initialize. Empty stack. State 0
parser: Input 'CREATE'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Shift 'CREATE'
parser: Return. Stack=[explain CREATE]
parser: Input 'TABLE'
parser: Reduce [createkw ::= CREATE], go to state 2.
parser: Shift 'createkw', go to state 107
parser: Reduce [temp ::=], go to state 107.
parser: Shift 'temp', go to state 319
parser: Shift 'TABLE', go to state 266
parser: Return. Stack=[explain createkw temp TABLE]
parser: Input 'ID'
parser: Reduce [ifnotexists ::=], go to state 266.
parser: Shift 'ifnotexists', go to state 183
parser: Shift 'ID'
parser: Return. Stack=[explain createkw temp TABLE ifnotexists ID]
parser: Input 'LP'
parser: Reduce [nm ::= ID|INDEXED], go to state 183.
parser: Shift 'nm', go to state 265
parser: Reduce [dbnm ::=], go to state 265.
parser: Shift 'dbnm'
parser: Reduce [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 2.
parser: Shift 'create_table', go to state 234
parser: Shift 'LP', go to state 111
parser: Return. Stack=[explain create_table LP]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP ID]
parser: Input 'RP'
parser: Reduce [nm ::= ID|INDEXED], go to state 111.
parser: Shift 'nm', go to state 148
parser: Reduce [typetoken ::=], go to state 148.
parser: Shift 'typetoken'
parser: Reduce [columnname ::= nm typetoken], go to state 111.
parser: Shift 'columnname', go to state 311
parser: Reduce [carglist ::=], go to state 311.
parser: Shift 'carglist', go to state 119
parser: Reduce [columnlist ::= columnname carglist], go to state 111.
parser: Shift 'columnlist', go to state 300
parser: Reduce [conslist_opt ::=], go to state 300.
parser: Shift 'conslist_opt', go to state 437
parser: Shift 'RP', go to state 299
parser: Return. Stack=[explain create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI'
parser: Reduce [table_options ::=], go to state 299.
parser: Shift 'table_options'
parser: Reduce [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 234.
parser: Shift 'create_table_args'
parser: Reduce [cmd ::= create_table create_table_args], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
   9 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s3[c00](8)
   6 Column           0    3    2               00 r[2]=sqlite_master.rootpage
REG[2] =  i:0
   7 Column           0    4    3               00 r[3]=sqlite_master.sql
REG[3] =   s96[CREATE TRIGGER ](8)
   8 ResultRow        1    3    0               00 output=r[1..3]
REG[1] =   s3[c00](8)
REG[2] =  i:0
REG[3] =   s96[CREATE TRIGGER ](8)
parser: Initialize. Empty stack. State 0
parser: Input 'CREATE'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Shift 'CREATE'
parser: Return. Stack=[explain CREATE]
parser: Input 'TRIGGER'
parser: Reduce [createkw ::= CREATE], go to state 2.
parser: Shift 'createkw', go to state 107
parser: FALLBACK TRIGGER => ID
parser: Reduce [temp ::=], go to state 107.
parser: Shift 'temp', go to state 319
parser: Shift 'TRIGGER', go to state 261
parser: Return. Stack=[explain createkw temp TRIGGER]
parser: Input 'ID'
parser: Reduce [ifnotexists ::=], go to state 261.
parser: Shift 'ifnotexists', go to state 181
parser: Shift 'ID'
parser: Return. Stack=[explain createkw temp TRIGGER ifnotexists ID]
parser: Input 'AFTER'
parser: Reduce [nm ::= ID|INDEXED], go to state 181.
parser: Shift 'nm', go to state 260
parser: FALLBACK AFTER => ID
parser: Reduce [dbnm ::=], go to state 260.
parser: Shift 'dbnm', go to state 210
parser: Shift 'AFTER'
parser: Return. Stack=[explain createkw temp TRIGGER ifnotexists nm dbnm AFTER]
parser: Input 'INSERT'
parser: Reduce [trigger_time ::= AFTER], go to state 210.
parser: Shift 'trigger_time', go to state 209
parser: Shift 'INSERT'
parser: Return. Stack=[explain createkw temp TRIGGER ifnotexists nm dbnm trigger_time INSERT]
parser: Input 'ON'
parser: Reduce [trigger_event ::= DELETE|INSERT], go to state 209.
parser: Shift 'trigger_event', go to state 376
parser: Shift 'ON', go to state 141
parser: Return. Stack=[explain createkw temp TRIGGER ifnotexists nm dbnm trigger_time trigger_event ON]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain createkw temp TRIGGER ifnotexists nm dbnm trigger_time trigger_event ON ID]
parser: Input 'DOT'
parser: Reduce [nm ::= ID|INDEXED], go to state 141.
parser: Shift 'nm', go to state 259
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[explain createkw temp TRIGGER ifnotexists nm dbnm trigger_time trigger_event ON nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain createkw temp TRIGGER ifnotexists nm dbnm trigger_time trigger_event ON nm DOT ID]
parser: Input 'BEGIN'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 259.
parser: Shift 'dbnm'
parser: Reduce [fullname ::= nm dbnm], go to state 141.
parser: Shift 'fullname', go to state 258
parser: FALLBACK BEGIN => ID
parser: Reduce [foreach_clause ::=], go to state 258.
parser: Shift 'foreach_clause', go to state 257
parser: FALLBACK BEGIN => ID
parser: Reduce [when_clause ::=], go to state 257.
parser: Shift 'when_clause'
parser: Reduce [trigger_decl ::= temp TRIGGER ifnotexists nm dbnm trigger_time trigger_event ON fullname foreach_clause when_clause], go to state 107.
parser: Shift 'trigger_decl', go to state 367
parser: Shift 'BEGIN', go to state 7
parser: Return. Stack=[explain createkw trigger_decl BEGIN]
parser: Input 'INSERT'
parser: Shift 'INSERT', go to state 253
parser: Return. Stack=[explain createkw trigger_decl BEGIN INSERT]
parser: Input 'INTO'
parser: Reduce [orconf ::=], go to state 253.
parser: Shift 'orconf'
parser: Reduce [insert_cmd ::= INSERT orconf], go to state 7.
parser: Shift 'insert_cmd', go to state 359
parser: Shift 'INTO', go to state 137
parser: Return. Stack=[explain createkw trigger_decl BEGIN insert_cmd INTO]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain createkw trigger_decl BEGIN insert_cmd INTO ID]
parser: Input 'LP'
parser: Reduce [nm ::= ID|INDEXED], go to state 137.
parser: Shift 'nm', go to state 365
parser: Reduce [trnm ::= nm], go to state 137.
parser: Shift 'trnm', go to state 251
parser: Shift 'LP', go to state 136
parser: Return. Stack=[explain createkw trigger_decl BEGIN insert_cmd INTO trnm LP]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain createkw trigger_decl BEGIN insert_cmd INTO trnm LP ID]
parser: Input 'RP'
parser: Reduce [nm ::= ID|INDEXED], go to state 136.
parser: Shift 'nm'
parser: Reduce [idlist ::= nm], go to state 136.
parser: Shift 'idlist', go to state 324
parser: Shift 'RP'
parser: Return. Stack=[explain createkw trigger_decl BEGIN insert_cmd INTO trnm LP idlist RP]
parser: Input 'VALUES'
parser: Reduce [idlist_opt ::= LP idlist RP], go to state 251.
parser: Shift 'idlist_opt', go to state 151
parser: Reduce [with ::=], go to state 151.
parser: Shift 'with', go to state 113
parser: Shift 'VALUES', go to state 397
parser: Return. Stack=[explain createkw trigger_decl BEGIN insert_cmd INTO trnm idlist_opt with VALUES]
parser: Input 'LP'
parser: Shift 'LP', go to state 15
parser: Return. Stack=[explain createkw trigger_decl BEGIN insert_cmd INTO trnm idlist_opt with VALUES LP]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain createkw trigger_decl BEGIN insert_cmd INTO trnm idlist_opt with VALUES LP ID]
parser: Input 'DOT'
parser: Reduce [nm ::= ID|INDEXED], go to state 15.
parser: Shift 'nm', go to state 434
parser: Shift 'DOT', go to state 202
parser: Return. Stack=[explain createkw trigger_decl BEGIN insert_cmd INTO trnm idlist_opt with VALUES LP nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain createkw trigger_decl BEGIN insert_cmd INTO trnm idlist_opt with VALUES LP nm DOT ID]
parser: Input 'RP'
parser: Reduce [nm ::= ID|INDEXED], go to state 202.
parser: Shift 'nm', go to state 433
parser: Reduce [expr ::= nm DOT nm], go to state 15.
parser: Shift 'expr', go to state 48
parser: Reduce [nexprlist ::= expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'RP'
parser: Return. Stack=[explain createkw trigger_decl BEGIN insert_cmd INTO trnm idlist_opt with VALUES LP nexprlist RP]
parser: Input 'SEMI'
parser: Reduce [values ::= VALUES LP nexprlist RP], go to state 113.
parser: Shift 'values', go to state 400
parser: Reduce [oneselect ::= values], go to state 113.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 113.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 151.
parser: Shift 'select'
parser: Reduce [trigger_cmd ::= insert_cmd INTO trnm idlist_opt select], go to state 7.
parser: Shift 'trigger_cmd', go to state 357
parser: Shift 'SEMI'
parser: Return. Stack=[explain createkw trigger_decl BEGIN trigger_cmd SEMI]
parser: Input 'END'
parser: Reduce [trigger_cmd_list ::= trigger_cmd SEMI], go to state 7.
parser: Shift 'trigger_cmd_list', go to state 23
parser: Shift 'END'
parser: Return. Stack=[explain createkw trigger_decl BEGIN trigger_cmd_list END]
parser: Input 'SEMI'
parser: Reduce [cmd ::= createkw trigger_decl BEGIN trigger_cmd_list END], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
   9 Next             0    5    0               01 
  10 Close            0    0    0               00 
  11 Halt             0    0    0               00 
parser: Initialize. Empty stack. State 0
parser: Input 'SELECT'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[explain with SELECT]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'FROM'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[explain with SELECT distinct selcollist FROM]
parser: Input 'STRING'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'STRING'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix STRING]
parser: Input 'DOT'
parser: Reduce [nm ::= STRING], go to state 165.
parser: Shift 'nm', go to state 287
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'SEMI'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Reduce [where_opt ::=], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Reduce [orderby_opt ::=], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 22.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 2.
parser: Shift 'select'
parser: Reduce [cmd ::= select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
VDBE Trace:
   0 Init             0   11    0               00 Start at 11
  11 Transaction      3    0    9 0             00 usesStmtJournal=0
  12 TableLock        3    2    0 sqlite_stat1  00 iDb=3 root=2 write=0
  13 Goto             0    1    0               00 
   1 OpenRead         0    2    3 3             00 root=2 iDb=3; sqlite_stat1
   2 Explain          0    0    0 SCAN TABLE sqlite_stat1 00 
   3 Rewind           0    9    0               00 
   9 Close            0    0    0               00 
  10 Halt             0    0    0               00 
REG[4] =  NULL
   5 Expire           1    0    0               00 
   6 Halt             0    0    0               00 
parser: Initialize. Empty stack. State 0
parser: Input 'SEMI'
parser: Shift 'SEMI'
parser: Return. Stack=[SEMI]
parser: Input 'PRAGMA'
parser: Reduce [ecmd ::= SEMI], go to state 0.
parser: Shift 'ecmd'
parser: Reduce [cmdlist ::= ecmd], go to state 0.
parser: Shift 'cmdlist', go to state 146
parser: FALLBACK PRAGMA => ID
parser: Reduce [explain ::=], go to state 146.
parser: Shift 'explain', go to state 2
parser: Shift 'PRAGMA', go to state 172
parser: Return. Stack=[cmdlist explain PRAGMA]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[cmdlist explain PRAGMA ID]
parser: Input 'EQ'
parser: Reduce [nm ::= ID|INDEXED], go to state 172.
parser: Shift 'nm', go to state 240
parser: Reduce [dbnm ::=], go to state 240.
parser: Shift 'dbnm', go to state 323
parser: Shift 'EQ', go to state 20
parser: Return. Stack=[cmdlist explain PRAGMA nm dbnm EQ]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[cmdlist explain PRAGMA nm dbnm EQ ID]
parser: Input 'SEMI'
parser: Reduce [nm ::= ID|INDEXED], go to state 20.
parser: Shift 'nm'
parser: Reduce [nmnum ::= nm], go to state 20.
parser: Shift 'nmnum'
parser: Reduce [cmd ::= PRAGMA nm dbnm EQ nmnum], go to state 2.
SQL: [;
PRAGMA parser_trace=OFF;]
VDBE Trace:
   0 Init             0    0    0               00 Start at 0
   1 Halt             0    0    0               00 
SQL: [PRAGMA page_size;]
VDBE Trace:
   0 Init             0    0    0               00 Start at 0
   1 Int64            0    1    0 4096          00 r[1]=4096
REG[1] =  i:4096
   2 ResultRow        1    1    0               00 output=r[1]
REG[1] =  i:4096
   3 Halt             0    0    0               00 
SQL: [SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;]
VDBE Trace:
   0 Init             0   12    0               00 Start at 12
  12 Transaction      0    0    0 0             01 usesStmtJournal=0
  13 TableLock        0    1    0 sqlite_master 00 iDb=0 root=1 write=0
  14 Goto             0    1    0               00 
   1 Noop             1    5    0               00 
   2 OpenRead         0    1    0 5             00 root=1 iDb=0; sqlite_master
   3 Explain          0    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   10    0               00 
  10 Close            0    0    0               00 
  11 Halt             0    0    0               00 
SQL: [;
ANALYZE;]
VDBE Trace:
   0 Init             0   55    0               00 Start at 55
  55 Transaction      0    1    0 0             01 usesStmtJournal=0
  56 Transaction      2    1    9 0             01 usesStmtJournal=0
  57 Transaction      3    1    9 0             01 usesStmtJournal=0
SQL: [ATTACH 'test.db3' AS aux3;]
VDBE Trace:
   0 Init             0    0    0               00 Start at 0
   1 String8          0    1    0 test.db3      00 r[1]='test.db3'
REG[1] =   t8[test.db3](8)
   2 String8          0    2    0 aux3          00 r[2]='aux3'
REG[2] =   t4[aux3](8)
   3 Null             0    3    0               00 r[3]=NULL
REG[3] =  NULL
   4 Function0        0    1    4 sqlite_attach(3) 03 r[4]=func(r[1..3])
REG[1] =   t8[test.db3](8)
REG[2] =   t4[aux3](8)
REG[3] =  NULL
VDBE Trace:
   0 Init             0   12    0               00 Start at 12
  12 Transaction      4    0   33 0             00 usesStmtJournal=0
  13 TableLock        4    1    0 sqlite_master 00 iDb=4 root=1 write=0
  14 Goto             0    1    0               00 
   1 Noop             1    5    0               00 
   2 OpenRead         0    1    4 5             00 root=1 iDb=4; sqlite_master
   3 Explain          0    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   10    0               00 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s2[n1](8)
   6 Column           0    3    2               00 r[2]=sqlite_master.rootpage
REG[2] =  i:3
   7 Column           0    4    3               00 r[3]=sqlite_master.sql
REG[3] =   s21[CREATE TABLE n1](8)
   8 ResultRow        1    3    0               00 output=r[1..3]
REG[1] =   s2[n1](8)
REG[2] =  i:3
REG[3] =   s21[CREATE TABLE n1](8)
   9 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s2[n2](8)
   6 Column           0    3    2               00 r[2]=sqlite_master.rootpage
REG[2] =  i:4
   7 Column           0    4    3               00 r[3]=sqlite_master.sql
REG[3] =   s21[CREATE TABLE n2](8)
   8 ResultRow        1    3    0               00 output=r[1..3]
REG[1] =   s2[n2](8)
REG[2] =  i:4
REG[3] =   s21[CREATE TABLE n2](8)
   9 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s2[n3](8)
   6 Column           0    3    2               00 r[2]=sqlite_master.rootpage
REG[2] =  i:5
   7 Column           0    4    3               00 r[3]=sqlite_master.sql
REG[3] =   s21[CREATE TABLE n3](8)
   8 ResultRow        1    3    0               00 output=r[1..3]
REG[1] =   s2[n3](8)
REG[2] =  i:5
REG[3] =   s21[CREATE TABLE n3](8)
   9 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s2[n4](8)
   6 Column           0    3    2               00 r[2]=sqlite_master.rootpage
REG[2] =  i:6
   7 Column           0    4    3               00 r[3]=sqlite_master.sql
REG[3] =   s21[CREATE TABLE n4](8)
   8 ResultRow        1    3    0               00 output=r[1..3]
REG[1] =   s2[n4](8)
REG[2] =  i:6
REG[3] =   s21[CREATE TABLE n4](8)
   9 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s2[n4](8)
   6 Column           0    3    2               00 r[2]=sqlite_master.rootpage
REG[2] =  i:0
   7 Column           0    4    3               00 r[3]=sqlite_master.sql
REG[3] =   s57[CREATE TRIGGER ](8)
   8 ResultRow        1    3    0               00 output=r[1..3]
REG[1] =   s2[n4](8)
REG[2] =  i:0
REG[3] =   s57[CREATE TRIGGER ](8)
   9 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s12[sqlite_stat1](8)
   6 Column           0    3    2               00 r[2]=sqlite_master.rootpage
REG[2] =  i:8
   7 Column           0    4    3               00 r[3]=sqlite_master.sql
REG[3] =   s39[CREATE TABLE sq](8)
   8 ResultRow        1    3    0               00 output=r[1..3]
REG[1] =   s12[sqlite_stat1](8)
REG[2] =  i:8
REG[3] =   s39[CREATE TABLE sq](8)
   9 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s3[tr1](8)
   6 Column           0    3    2               00 r[2]=sqlite_master.rootpage
REG[2] =  i:9
   7 Column           0    4    3               00 r[3]=sqlite_master.sql
REG[3] =   s22[CREATE TABLE tr](8)
   8 ResultRow        1    3    0               00 output=r[1..3]
REG[1] =   s3[tr1](8)
REG[2] =  i:9
REG[3] =   s22[CREATE TABLE tr](8)
   9 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s3[tr2](8)
   6 Column           0    3    2               00 r[2]=sqlite_master.rootpage
REG[2] =  i:11
   7 Column           0    4    3               00 r[3]=sqlite_master.sql
REG[3] =   s22[CREATE TABLE tr](8)
   8 ResultRow        1    3    0               00 output=r[1..3]
REG[1] =   s3[tr2](8)
REG[2] =  i:11
REG[3] =   s22[CREATE TABLE tr](8)
   9 Next             0    5    0               01 
  10 Close            0    0    0               00 
  11 Halt             0    0    0               00 
VDBE Trace:
   0 Init             0   11    0               00 Start at 11
  11 Transaction      4    0   33 0             00 usesStmtJournal=0
  12 TableLock        4    8    0 sqlite_stat1  00 iDb=4 root=8 write=0
  13 Goto             0    1    0               00 
   1 OpenRead         0    8    4 3             00 root=8 iDb=4; sqlite_stat1
   2 Explain          0    0    0 SCAN TABLE sqlite_stat1 00 
   3 Rewind           0    9    0               00 
   4 Column           0    0    1               00 r[1]=sqlite_stat1.tbl
REG[1] =   s2[n4](8)
   5 Column           0    1    2               00 r[2]=sqlite_stat1.idx
REG[2] =  NULL
   6 Column           0    2    3               00 r[3]=sqlite_stat1.stat
REG[3] =   s1[9](8)
   7 ResultRow        1    3    0               00 output=r[1..3]
REG[1] =   s2[n4](8)
REG[2] =  NULL
REG[3] =   s1[9](8)
   8 Next             0    4    0               01 
   4 Column           0    0    1               00 r[1]=sqlite_stat1.tbl
REG[1] =   s2[n3](8)
   5 Column           0    1    2               00 r[2]=sqlite_stat1.idx
REG[2] =  NULL
   6 Column           0    2    3               00 r[3]=sqlite_stat1.stat
REG[3] =   s1[9](8)
   7 ResultRow        1    3    0               00 output=r[1..3]
REG[1] =   s2[n3](8)
REG[2] =  NULL
REG[3] =   s1[9](8)
   8 Next             0    4    0               01 
   4 Column           0    0    1               00 r[1]=sqlite_stat1.tbl
REG[1] =   s2[n2](8)
   5 Column           0    1    2               00 r[2]=sqlite_stat1.idx
REG[2] =  NULL
   6 Column           0    2    3               00 r[3]=sqlite_stat1.stat
REG[3] =   s1[9](8)
   7 ResultRow        1    3    0               00 output=r[1..3]
REG[1] =   s2[n2](8)
REG[2] =  NULL
REG[3] =   s1[9](8)
   8 Next             0    4    0               01 
   4 Column           0    0    1               00 r[1]=sqlite_stat1.tbl
REG[1] =   s2[n1](8)
   5 Column           0    1    2               00 r[2]=sqlite_stat1.idx
REG[2] =  NULL
   6 Column           0    2    3               00 r[3]=sqlite_stat1.stat
REG[3] =   s1[9](8)
   7 ResultRow        1    3    0               00 output=r[1..3]
REG[1] =   s2[n1](8)
REG[2] =  NULL
REG[3] =   s1[9](8)
   8 Next             0    4    0               01 
   9 Close            0    0    0               00 
  10 Halt             0    0    0               00 
REG[4] =  NULL
   5 Expire           1    0    0               00 
   6 Halt             0    0    0               00 
SQL: [ATTACH 'test.db5' AS aux5;]
VDBE Trace:
   0 Init             0    0    0               00 Start at 0
   1 String8          0    1    0 test.db5      00 r[1]='test.db5'
REG[1] =   t8[test.db5](8)
   2 String8          0    2    0 aux5          00 r[2]='aux5'
REG[2] =   t4[aux5](8)
   3 Null             0    3    0               00 r[3]=NULL
REG[3] =  NULL
   4 Function0        0    1    4 sqlite_attach(3) 03 r[4]=func(r[1..3])
REG[1] =   t8[test.db5](8)
REG[2] =   t4[aux5](8)
REG[3] =  NULL
VDBE Trace:
   0 Init             0   12    0               00 Start at 12
  12 Transaction      5    0    2 0             00 usesStmtJournal=0
  13 TableLock        5    1    0 sqlite_master 00 iDb=5 root=1 write=0
  14 Goto             0    1    0               00 
   1 Noop             1    5    0               00 
   2 OpenRead         0    1    5 5             00 root=1 iDb=5; sqlite_master
   3 Explain          0    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   10    0               00 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s3[tbl](8)
   6 Column           0    3    2               00 r[2]=sqlite_master.rootpage
REG[2] =  i:2
   7 Column           0    4    3               00 r[3]=sqlite_master.sql
REG[3] =   s19[CREATE TABLE tb](8)
   8 ResultRow        1    3    0               00 output=r[1..3]
REG[1] =   s3[tbl](8)
REG[2] =  i:2
REG[3] =   s19[CREATE TABLE tb](8)
   9 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s12[sqlite_stat1](8)
   6 Column           0    3    2               00 r[2]=sqlite_master.rootpage
REG[2] =  i:3
   7 Column           0    4    3               00 r[3]=sqlite_master.sql
REG[3] =   s39[CREATE TABLE sq](8)
   8 ResultRow        1    3    0               00 output=r[1..3]
REG[1] =   s12[sqlite_stat1](8)
REG[2] =  i:3
REG[3] =   s39[CREATE TABLE sq](8)
   9 Next             0    5    0               01 
  10 Close            0    0    0               00 
  11 Halt             0    0    0               00 
VDBE Trace:
   0 Init             0   11    0               00 Start at 11
  11 Transaction      5    0    2 0             00 usesStmtJournal=0
  12 TableLock        5    3    0 sqlite_stat1  00 iDb=5 root=3 write=0
  13 Goto             0    1    0               00 
   1 OpenRead         0    3    5 3             00 root=3 iDb=5; sqlite_stat1
   2 Explain          0    0    0 SCAN TABLE sqlite_stat1 00 
   3 Rewind           0    9    0               00 
   4 Column           0    0    1               00 r[1]=sqlite_stat1.tbl
REG[1] =   s3[tbl](8)
   5 Column           0    1    2               00 r[2]=sqlite_stat1.idx
REG[2] =  NULL
   6 Column           0    2    3               00 r[3]=sqlite_stat1.stat
REG[3] =   s1[3](8)
   7 ResultRow        1    3    0               00 output=r[1..3]
REG[1] =   s3[tbl](8)
REG[2] =  NULL
REG[3] =   s1[3](8)
   8 Next             0    4    0               01 
   4 Column           0    0    1               00 r[1]=sqlite_stat1.tbl
REG[1] =   s2[t4](8)
   5 Column           0    1    2               00 r[2]=sqlite_stat1.idx
REG[2] =   s4[t1bc](8)
   6 Column           0    2    3               00 r[3]=sqlite_stat1.stat
REG[3] =   s12[1000000 10 9](8)
   7 ResultRow        1    3    0               00 output=r[1..3]
REG[1] =   s2[t4](8)
REG[2] =   s4[t1bc](8)
REG[3] =   s12[1000000 10 9](8)
   8 Next             0    4    0               01 
   9 Close            0    0    0               00 
  10 Halt             0    0    0               00 
REG[4] =  NULL
   5 Expire           1    0    0               00 
   6 Halt             0    0    0               00 
SQL: [ATTACH 'test.db' as db13;]
VDBE Trace:
   0 Init             0    0    0               00 Start at 0
   1 String8          0    1    0 test.db       00 r[1]='test.db'
REG[1] =   t7[test.db](8)
   2 String8          0    2    0 db13          00 r[2]='db13'
REG[2] =   t4[db13](8)
   3 Null             0    3    0               00 r[3]=NULL
REG[3] =  NULL
   4 Function0        0    1    4 sqlite_attach(3) 03 r[4]=func(r[1..3])
REG[1] =   t7[test.db](8)
REG[2] =   t4[db13](8)
REG[3] =  NULL
VDBE Trace:
   0 Init             0   12    0               00 Start at 12
  12 Transaction      6    0    9 0             00 usesStmtJournal=0
  13 TableLock        6    1    0 sqlite_master 00 iDb=6 root=1 write=0
  14 Goto             0    1    0               00 
   1 Noop             1    5    0               00 
   2 OpenRead         0    1    6 5             00 root=1 iDb=6; sqlite_master
   3 Explain          0    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   10    0               00 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s12[sqlite_stat1](8)
   6 Column           0    3    2               00 r[2]=sqlite_master.rootpage
REG[2] =  i:2
   7 Column           0    4    3               00 r[3]=sqlite_master.sql
REG[3] =   s39[CREATE TABLE sq](8)
   8 ResultRow        1    3    0               00 output=r[1..3]
REG[1] =   s12[sqlite_stat1](8)
REG[2] =  i:2
REG[3] =   s39[CREATE TABLE sq](8)
   9 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s3[oid](8)
   6 Column           0    3    2               00 r[2]=sqlite_master.rootpage
REG[2] =  i:3
   7 Column           0    4    3               00 r[3]=sqlite_master.sql
REG[3] =   s19[CREATE TABLE oi](8)
   8 ResultRow        1    3    0               00 output=r[1..3]
REG[1] =   s3[oid](8)
REG[2] =  i:3
REG[3] =   s19[CREATE TABLE oi](8)
   9 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s3[c00](8)
   6 Column           0    3    2               00 r[2]=sqlite_master.rootpage
REG[2] =  i:0
   7 Column           0    4    3               00 r[3]=sqlite_master.sql
REG[3] =   s96[CREATE TRIGGER ](8)
   8 ResultRow        1    3    0               00 output=r[1..3]
REG[1] =   s3[c00](8)
REG[2] =  i:0
REG[3] =   s96[CREATE TRIGGER ](8)
   9 Next             0    5    0               01 
  10 Close            0    0    0               00 
  11 Halt             0    0    0               00 
VDBE Trace:
   0 Init             0   11    0               00 Start at 11
  11 Transaction      6    0    9 0             00 usesStmtJournal=0
  12 TableLock        6    2    0 sqlite_stat1  00 iDb=6 root=2 write=0
  13 Goto             0    1    0               00 
   1 OpenRead         0    2    6 3             00 root=2 iDb=6; sqlite_stat1
   2 Explain          0    0    0 SCAN TABLE sqlite_stat1 00 
   3 Rewind           0    9    0               00 
   9 Close            0    0    0               00 
  10 Halt             0    0    0               00 
REG[4] =  NULL
   5 Expire           1    0    0               00 
   6 Halt             0    0    0               00 
SQL: [;
PRAGMA journal_mode=off;]
VDBE Trace:
   0 Init             0    0    0               00 Start at 0
   1 JournalMode      6    1    2               00 
REG[1] =   t3[off](8)
   2 JournalMode      5    1    2               00 
REG[1] =   t3[off](8)
   3 JournalMode      4    1    2               00 
REG[1] =   t3[off](8)
   4 JournalMode      3    1    2               00 
REG[1] =   t3[off](8)
   5 JournalMode      2    1    2               00 
REG[1] =   t3[off](8)
   6 JournalMode      1    1    2               00 
REG[1] =   t3[off](8)
   7 JournalMode      0    1    2               00 
REG[1] =   t3[off](8)
   8 ResultRow        1    1    0               00 output=r[1]
REG[1] =   t3[off](8)
   9 Halt             0    0    0               00 
SQL: [;
PRAGMA writable_schema=OFF;]
VDBE Trace:
   0 Init             0    0    0               00 Start at 0
   1 Expire           0    0    0               00 
   2 Halt             0    0    0               00 
SQL: [PRAGMA auto_vacuum = 0;]
VDBE Trace:
   0 Init             0    0    0               00 Start at 0
   1 Halt             0    0    0               00 
SQL: [SELECT name FROM sqlite_temp_master;]
VDBE Trace:
   0 Init             0    9    0               00 Start at 9
   9 Transaction      1    0    0 0             01 usesStmtJournal=0
  10 TableLock        1    1    0 sqlite_temp_master 00 iDb=1 root=1 write=0
  11 Goto             0    1    0               00 
   1 OpenRead         0    1    1 2             00 root=1 iDb=1; sqlite_temp_master
   2 Explain          0    0    0 SCAN TABLE sqlite_temp_master 00 
   3 Rewind           0    7    0               00 
   7 Close            0    0    0               00 
   8 Halt             0    0    0               00 
SQL: [;
DETACH db4;]
VDBE Trace:
   0 Init             0    0    0               00 Start at 0
   1 Null             0    1    0               00 r[1]=NULL
REG[1] =  NULL
   2 Null             0    2    0               00 r[2]=NULL
REG[2] =  NULL
   3 String8          0    3    0 db4           00 r[3]='db4'
REG[3] =   t3[db4](8)
   4 Function0        0    3    4 sqlite_detach(1) 01 r[4]=func(r[3])
REG[3] =   t3[db4](8)
SQL: [SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;]
VDBE Trace:
   0 Init             0   12    0               00 Start at 12
  12 Transaction      0    0    0 0             01 usesStmtJournal=0
  13 TableLock        0    1    0 sqlite_master 00 iDb=0 root=1 write=0
  14 Goto             0    1    0               00 
   1 Noop             1    5    0               00 
   2 OpenRead         0    1    0 5             00 root=1 iDb=0; sqlite_master
   3 Explain          0    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   10    0               00 
  10 Close            0    0    0               00 
  11 Halt             0    0    0               00 
SQL: [ATTACH DATABASE ':memory:' AS test1;]
VDBE Trace:
   0 Init             0    0    0               00 Start at 0
   1 String8          0    1    0 :memory:      00 r[1]=':memory:'
REG[1] =   t8[:memory:](8)
   2 String8          0    2    0 test1         00 r[2]='test1'
REG[2] =   t5[test1](8)
   3 Null             0    3    0               00 r[3]=NULL
REG[3] =  NULL
   4 Function0        0    1    4 sqlite_attach(3) 03 r[4]=func(r[1..3])
REG[1] =   t8[:memory:](8)
REG[2] =   t5[test1](8)
REG[3] =  NULL
VDBE Trace:
   0 Init             0   12    0               00 Start at 12
  12 Transaction      7    0    0 0             00 usesStmtJournal=0
  13 TableLock        7    1    0 sqlite_master 00 iDb=7 root=1 write=0
  14 Goto             0    1    0               00 
   1 Noop             1    5    0               00 
   2 OpenRead         0    1    7 5             00 root=1 iDb=7; sqlite_master
   3 Explain          0    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   10    0               00 
  10 Close            0    0    0               00 
  11 Halt             0    0    0               00 
REG[4] =  NULL
   5 Expire           1    0    0               00 
   6 Halt             0    0    0               00 
SQL: [;
DETACH db2;]
VDBE Trace:
   0 Init             0    0    0               00 Start at 0
   1 Null             0    1    0               00 r[1]=NULL
REG[1] =  NULL
   2 Null             0    2    0               00 r[2]=NULL
REG[2] =  NULL
   3 String8          0    3    0 db2           00 r[3]='db2'
REG[3] =   t3[db2](8)
   4 Function0        0    3    4 sqlite_detach(1) 01 r[4]=func(r[3])
REG[3] =   t3[db2](8)
SQL: [;
SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;]
VDBE Trace:
   0 Init             0   12    0               00 Start at 12
  12 Transaction      0    0    0 0             01 usesStmtJournal=0
  13 TableLock        0    1    0 sqlite_master 00 iDb=0 root=1 write=0
  14 Goto             0    1    0               00 
   1 Noop             1    5    0               00 
   2 OpenRead         0    1    0 5             00 root=1 iDb=0; sqlite_master
   3 Explain          0    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   10    0               00 
  10 Close            0    0    0               00 
  11 Halt             0    0    0               00 
SQL: [DETACH DATABASE test1;]
VDBE Trace:
   0 Init             0    0    0               00 Start at 0
   1 Null             0    1    0               00 r[1]=NULL
REG[1] =  NULL
   2 Null             0    2    0               00 r[2]=NULL
REG[2] =  NULL
   3 String8          0    3    0 test1         00 r[3]='test1'
REG[3] =   t5[test1](8)
   4 Function0        0    3    4 sqlite_detach(1) 01 r[4]=func(r[3])
REG[3] =   t5[test1](8)
REG[4] =  NULL
   5 Expire           0    0    0               00 
   6 Halt             0    0    0               00 
SQL: [;
SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;]
VDBE Trace:
   0 Init             0   12    0               00 Start at 12
  12 Transaction      0    0    0 0             01 usesStmtJournal=0
  13 TableLock        0    1    0 sqlite_master 00 iDb=0 root=1 write=0
  14 Goto             0    1    0               00 
   1 Noop             1    5    0               00 
   2 OpenRead         0    1    0 5             00 root=1 iDb=0; sqlite_master
   3 Explain          0    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   10    0               00 
  10 Close            0    0    0               00 
  11 Halt             0    0    0               00 
[Inferior 1 (process 10494) exited normally]
(gdb) (gdb) quit
