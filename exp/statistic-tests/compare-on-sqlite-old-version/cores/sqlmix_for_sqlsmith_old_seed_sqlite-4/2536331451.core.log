GNU gdb (Ubuntu 9.2-0ubuntu1~20.04.1) 9.2
Copyright (C) 2020 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type "show copying" and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
    <http://www.gnu.org/software/gdb/documentation/>.

For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from /root/sqlite_driver_fast...
(gdb) Starting program: /root/sqlite_driver_fast < "/root/out/default/crashes/id:000163,sig:06,src:005250+006786,time:5640985,execs:542830,op:merge.so,pos:0"
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
SQL: [;
PRAGMA vdbe_trace=on;]
VDBE Trace:
   0 Init             0    0    0               00 Start at 0
   1 Expire           0    0    0               00 
   2 Halt             0    0    0               00 
VDBE Trace:
   0 Init             0   12    0               00 Start at 12
  12 Transaction      0    0    0 0             00 usesStmtJournal=0
  13 TableLock        0    1    0 sqlite_master 00 iDb=0 root=1 write=0
  14 Goto             0    1    0               00 
   1 Noop             1    5    0               00 
   2 OpenRead         0    1    0 5             00 root=1 iDb=0; sqlite_master
   3 Explain          0    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   10    0               00 
  10 Close            0    0    0               00 
  11 Halt             0    0    0               00 
SQL: [CREATE VIRTUAL TABLE t3 USING echo(t0);]
VDBE Trace:
   0 Init             0   33    0               00 Start at 33
  33 Transaction      0    1    0 0             01 usesStmtJournal=0
  34 TableLock        0    1    1 sqlite_master 00 iDb=0 root=1 write=1
  35 Goto             0    1    0               00 
   1 VBegin           0    0    0               00 
   2 ReadCookie       0    3    2               00 
REG[3] =  i:0
   3 If               3    6    0               00 
REG[3] =  i:0
   4 SetCookie        0    2    4               00 
   5 SetCookie        0    5    1               00 
   6 Integer          0    2    0               00 r[2]=0
REG[2] =  i:0
   7 OpenWrite        0    1    0 5             00 root=1 iDb=0
   8 NewRowid         0    1    0               00 r[1]=rowid
REG[1] =  i:1
   9 Blob             6    3    0              00 r[3]= (len=6)
REG[3] =  t6[060000000000......](8)
  10 Insert           0    3    1               08 intkey=r[1] data=r[3]
REG[3] =  t6[060000000000......](8)
REG[1] =  i:1
  11 Close            0    0    0               00 
  12 Null             0    4    5               00 r[4..5]=NULL
REG[4] =  NULL
  13 OpenWrite        1    1    0 5             00 root=1 iDb=0; sqlite_master
  14 Explain          0    0    0 SEARCH TABLE sqlite_master USING INTEGER PRIMARY KEY (rowid=?) 00 
  15 MustBeInt        1   18    0               00 
REG[1] =  i:1
  16 NotExists        1   18    1               00 intkey=r[1]; pk
REG[1] =  i:1
  17 Rowid            1    5    0               00 r[5]=rowid
REG[5] =  i:1
  18 IsNull           5   26    0               00 if r[5]==NULL goto 26
REG[5] =  i:1
  19 String8          0    6    0 table         00 r[6]='table'
REG[6] =   t5[table](8)
  20 String8          0    7    0 t3            00 r[7]='t3'
REG[7] =   t2[t3](8)
  21 String8          0    8    0 t3            00 r[8]='t3'
REG[8] =   t2[t3](8)
  22 Integer          0    9    0               00 r[9]=0
REG[9] =  i:0
  23 String8          0   10    0 CREATE VIRTUAL TABLE t3 USING echo(t0) 00 r[10]='CREATE VIRTUAL TABLE t3 USING echo(t0)'
REG[10] =   t38[CREATE VIRTUAL ](8)
  24 MakeRecord       6    5   11 BBBDB         00 r[11]=mkrec(r[6..10])
REG[11] =  s53[0617111108597461626C657433743343.....Ytablet3t3C](8)
  25 Insert           1   11    5               00 intkey=r[5] data=r[11]
REG[11] =  s53[0617111108597461626C657433743343.....Ytablet3t3C](8)
REG[5] =  i:1
  26 Close            1    0    0               00 
  27 SetCookie        0    1    1               00 
  28 Expire           0    0    0               00 
  29 ParseSchema      0    0    0 name='t3' AND type='table' 00 
VDBE Trace:
   0 Init             0   16    0               00 Start at 16
  16 Transaction      0    0    1 0             00 usesStmtJournal=0
  17 TableLock        0    1    0 sqlite_master 00 iDb=0 root=1 write=0
  18 String8          0    2    0 t3            00 r[2]='t3'
REG[2] =   t2[t3](8)
  19 String8          0    4    0 table         00 r[4]='table'
REG[4] =   t5[table](8)
  20 Goto             0    1    0               00 
   1 Noop             1    5    0               00 
   2 OpenRead         0    1    0 5             00 root=1 iDb=0; sqlite_master
   3 Explain          0    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   14    0               00 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s2[t3](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t2[t3](8)
REG[1] =   s2[t3](8)
   7 Column           0    0    3               00 r[3]=sqlite_master.type
REG[3] =   s5[table](8)
   8 Ne               4   13    3 (BINARY)      52 if r[4]!=r[3] goto 13
REG[4] =   t5[table](8)
REG[3] =   s5[table](8)
   9 Copy             1    5    0               00 r[5]=r[1]
REG[5] =   s2[t3](8)
  10 Column           0    3    6               00 r[6]=sqlite_master.rootpage
REG[6] =  i:0
  11 Column           0    4    7               00 r[7]=sqlite_master.sql
REG[7] =   s38[CREATE VIRTUAL ](8)
  12 ResultRow        5    3    0               00 output=r[5..7]
REG[5] =   s2[t3](8)
REG[6] =  i:0
REG[7] =   s38[CREATE VIRTUAL ](8)
  13 Next             0    5    0               01 
  14 Close            0    0    0               00 
  15 Halt             0    0    0               00 
  30 String8          0   12    0 t3            00 r[12]='t3'
REG[12] =   t2[t3](8)
  31 VCreate          0   12    0               00 
VDBE Trace:
   0 Init             0   12    0               00 Start at 12
  12 Transaction      0    0    0 1             00 usesStmtJournal=0
  13 TableLock        0    1    0 sqlite_master 00 iDb=0 root=1 write=0
  14 Goto             0    1    0               00 
   1 Noop             1    5    0               00 
   2 OpenRead         0    1    0 5             00 root=1 iDb=0; sqlite_master
   3 Explain          0    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   10    0               00 
  10 Close            0    0    0               00 
  11 Halt             0    0    0               00 
SQL: [;
CREATE TABLE t1(a INTEGER PRIMARY KEY, b);]
VDBE Trace:
   0 Init             0   30    0               00 Start at 30
  30 Transaction      0    1    0 1             01 usesStmtJournal=0
  31 TableLock        0    1    1 sqlite_master 00 iDb=0 root=1 write=1
  32 Goto             0    1    0               00 
   1 ReadCookie       0    3    2               00 
REG[3] =  i:0
   2 If               3    5    0               00 
REG[3] =  i:0
   3 SetCookie        0    2    4               00 
   4 SetCookie        0    5    1               00 
   5 CreateTable      0    2    0               00 r[2]=root iDb=0
REG[2] =  i:2
   6 OpenWrite        0    1    0 5             00 root=1 iDb=0
   7 NewRowid         0    1    0               00 r[1]=rowid
REG[1] =  i:1
   8 Blob             6    3    0              00 r[3]= (len=6)
REG[3] =  t6[060000000000......](8)
   9 Insert           0    3    1               08 intkey=r[1] data=r[3]
REG[3] =  t6[060000000000......](8)
REG[1] =  i:1
  10 Close            0    0    0               00 
  11 Close            0    0    0               00 
  12 Null             0    4    5               00 r[4..5]=NULL
REG[4] =  NULL
  13 OpenWrite        1    1    0 5             00 root=1 iDb=0; sqlite_master
  14 Explain          0    0    0 SEARCH TABLE sqlite_master USING INTEGER PRIMARY KEY (rowid=?) 00 
  15 MustBeInt        1   18    0               00 
REG[1] =  i:1
  16 NotExists        1   18    1               00 intkey=r[1]; pk
REG[1] =  i:1
  17 Rowid            1    5    0               00 r[5]=rowid
REG[5] =  i:1
  18 IsNull           5   26    0               00 if r[5]==NULL goto 26
REG[5] =  i:1
  19 String8          0    6    0 table         00 r[6]='table'
REG[6] =   t5[table](8)
  20 String8          0    7    0 t1            00 r[7]='t1'
REG[7] =   t2[t1](8)
  21 String8          0    8    0 t1            00 r[8]='t1'
REG[8] =   t2[t1](8)
  22 Copy             2    9    0               00 r[9]=r[2]
REG[9] =  i:2
  23 String8          0   10    0 CREATE TABLE t1(a INTEGER PRIMARY KEY, b) 00 r[10]='CREATE TABLE t1(a INTEGER PRIMARY KEY, b)'
REG[10] =   t41[CREATE TABLE t1](8)
  24 MakeRecord       6    5   11 BBBDB         00 r[11]=mkrec(r[6..10])
REG[11] =  s57[06171111015F7461626C657431743102....._tablet1t1.](8)
  25 Insert           1   11    5               00 intkey=r[5] data=r[11]
REG[11] =  s57[06171111015F7461626C657431743102....._tablet1t1.](8)
REG[5] =  i:1
  26 Close            1    0    0               00 
  27 SetCookie        0    1    1               00 
  28 ParseSchema      0    0    0 tbl_name='t1' AND type!='trigger' 00 
VDBE Trace:
   0 Init             0   16    0               00 Start at 16
  16 Transaction      0    0    1 1             00 usesStmtJournal=0
  17 TableLock        0    1    0 sqlite_master 00 iDb=0 root=1 write=0
  18 String8          0    2    0 t1            00 r[2]='t1'
REG[2] =   t2[t1](8)
  19 String8          0    4    0 trigger       00 r[4]='trigger'
REG[4] =   t7[trigger](8)
  20 Goto             0    1    0               00 
   1 Noop             1    5    0               00 
   2 OpenRead         0    1    0 5             00 root=1 iDb=0; sqlite_master
   3 Explain          0    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   14    0               00 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[t1](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t2[t1](8)
REG[1] =   s2[t1](8)
   7 Column           0    0    3               00 r[3]=sqlite_master.type
REG[3] =   s5[table](8)
   8 Eq               4   13    3 (BINARY)      52 if r[4]==r[3] goto 13
REG[4] =   t7[trigger](8)
REG[3] =   s5[table](8)
   9 Column           0    1    5               00 r[5]=sqlite_master.name
REG[5] =   s2[t1](8)
  10 Column           0    3    6               00 r[6]=sqlite_master.rootpage
REG[6] =  i:2
  11 Column           0    4    7               00 r[7]=sqlite_master.sql
REG[7] =   s41[CREATE TABLE t1](8)
  12 ResultRow        5    3    0               00 output=r[5..7]
REG[5] =   s2[t1](8)
REG[6] =  i:2
REG[7] =   s41[CREATE TABLE t1](8)
  13 Next             0    5    0               01 
  14 Close            0    0    0               00 
  15 Halt             0    0    0               00 
  29 Halt             0    0    0               00 
SQL: [;
DELETE FROM t1 WHERE a = 1;]
VDBE Trace:
   0 Init             0   10    0               00 Start at 10
  10 Transaction      0    1    1 1             01 usesStmtJournal=0
  11 TableLock        0    2    1 t1            00 iDb=0 root=2 write=1
  12 Goto             0    1    0               00 
   1 Null             0    1    0               00 r[1]=NULL
REG[1] =  NULL
   2 OpenWrite        0    2    0 2             00 root=2 iDb=0; t1
   3 Explain          0    0    0 SEARCH TABLE t1 USING INTEGER PRIMARY KEY (rowid=?) 00 
   4 Integer          1    2    0               00 r[2]=1
REG[2] =  i:1
   5 MustBeInt        2    8    0               00 
REG[2] =  i:1
   6 NotExists        0    8    2               00 intkey=r[2]; pk
REG[2] =  i:1
   8 Noop             0    0    0               00 
   9 Halt             0    0    0               00 
SQL: [PRAGMA page_size=1024;]
VDBE Trace:
   0 Init             0    0    0               00 Start at 0
   1 Halt             0    0    0               00 
SQL: [;
SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;]
VDBE Trace:
   0 Init             0   12    0               00 Start at 12
  12 Transaction      0    0    1 1             01 usesStmtJournal=0
  13 TableLock        0    1    0 sqlite_master 00 iDb=0 root=1 write=0
  14 Goto             0    1    0               00 
   1 Noop             1    5    0               00 
   2 OpenRead         0    1    0 5             00 root=1 iDb=0; sqlite_master
   3 Explain          0    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   10    0               00 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s2[t1](8)
   6 Column           0    3    2               00 r[2]=sqlite_master.rootpage
REG[2] =  i:2
   7 Column           0    4    3               00 r[3]=sqlite_master.sql
REG[3] =   s41[CREATE TABLE t1](8)
   8 ResultRow        1    3    0               00 output=r[1..3]
REG[1] =   s2[t1](8)
REG[2] =  i:2
REG[3] =   s41[CREATE TABLE t1](8)
   9 Next             0    5    0               01 
  10 Close            0    0    0               00 
  11 Halt             0    0    0               00 
SQL: [CREATE TABLE numbers(x int, y int);]
VDBE Trace:
   0 Init             0   30    0               00 Start at 30
  30 Transaction      0    1    1 1             01 usesStmtJournal=0
  31 TableLock        0    1    1 sqlite_master 00 iDb=0 root=1 write=1
  32 Goto             0    1    0               00 
   1 ReadCookie       0    3    2               00 
REG[3] =  i:4
   2 If               3    5    0               00 
REG[3] =  i:4
   5 CreateTable      0    2    0               00 r[2]=root iDb=0
REG[2] =  i:3
   6 OpenWrite        0    1    0 5             00 root=1 iDb=0
   7 NewRowid         0    1    0               00 r[1]=rowid
REG[1] =  i:2
   8 Blob             6    3    0              00 r[3]= (len=6)
REG[3] =  t6[060000000000......](8)
   9 Insert           0    3    1               08 intkey=r[1] data=r[3]
REG[3] =  t6[060000000000......](8)
REG[1] =  i:2
  10 Close            0    0    0               00 
  11 Close            0    0    0               00 
  12 Null             0    4    5               00 r[4..5]=NULL
REG[4] =  NULL
  13 OpenWrite        1    1    0 5             00 root=1 iDb=0; sqlite_master
  14 Explain          0    0    0 SEARCH TABLE sqlite_master USING INTEGER PRIMARY KEY (rowid=?) 00 
  15 MustBeInt        1   18    0               00 
REG[1] =  i:2
  16 NotExists        1   18    1               00 intkey=r[1]; pk
REG[1] =  i:2
  17 Rowid            1    5    0               00 r[5]=rowid
REG[5] =  i:2
  18 IsNull           5   26    0               00 if r[5]==NULL goto 26
REG[5] =  i:2
  19 String8          0    6    0 table         00 r[6]='table'
REG[6] =   t5[table](8)
  20 String8          0    7    0 numbers       00 r[7]='numbers'
REG[7] =   t7[numbers](8)
  21 String8          0    8    0 numbers       00 r[8]='numbers'
REG[8] =   t7[numbers](8)
  22 Copy             2    9    0               00 r[9]=r[2]
REG[9] =  i:3
  23 String8          0   10    0 CREATE TABLE numbers(x int, y int) 00 r[10]='CREATE TABLE numbers(x int, y int)'
REG[10] =   t34[CREATE TABLE nu](8)
  24 MakeRecord       6    5   11 BBBDB         00 r[11]=mkrec(r[6..10])
REG[11] =  s60[06171B1B01517461626C656E756D6265.....Qtablenumbe](8)
  25 Insert           1   11    5               00 intkey=r[5] data=r[11]
REG[11] =  s60[06171B1B01517461626C656E756D6265.....Qtablenumbe](8)
REG[5] =  i:2
  26 Close            1    0    0               00 
  27 SetCookie        0    1    2               00 
  28 ParseSchema      0    0    0 tbl_name='numbers' AND type!='trigger' 00 
VDBE Trace:
   0 Init             0   16    0               00 Start at 16
  16 Transaction      0    0    2 1             00 usesStmtJournal=0
  17 TableLock        0    1    0 sqlite_master 00 iDb=0 root=1 write=0
  18 String8          0    2    0 numbers       00 r[2]='numbers'
REG[2] =   t7[numbers](8)
  19 String8          0    4    0 trigger       00 r[4]='trigger'
REG[4] =   t7[trigger](8)
  20 Goto             0    1    0               00 
   1 Noop             1    5    0               00 
   2 OpenRead         0    1    0 5             00 root=1 iDb=0; sqlite_master
   3 Explain          0    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   14    0               00 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[t1](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t7[numbers](8)
REG[1] =   s2[t1](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s7[numbers](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t7[numbers](8)
REG[1] =   s7[numbers](8)
   7 Column           0    0    3               00 r[3]=sqlite_master.type
REG[3] =   s5[table](8)
   8 Eq               4   13    3 (BINARY)      52 if r[4]==r[3] goto 13
REG[4] =   t7[trigger](8)
REG[3] =   s5[table](8)
   9 Column           0    1    5               00 r[5]=sqlite_master.name
REG[5] =   s7[numbers](8)
  10 Column           0    3    6               00 r[6]=sqlite_master.rootpage
REG[6] =  i:3
  11 Column           0    4    7               00 r[7]=sqlite_master.sql
REG[7] =   s34[CREATE TABLE nu](8)
  12 ResultRow        5    3    0               00 output=r[5..7]
REG[5] =   s7[numbers](8)
REG[6] =  i:3
REG[7] =   s34[CREATE TABLE nu](8)
  13 Next             0    5    0               01 
  14 Close            0    0    0               00 
  15 Halt             0    0    0               00 
  29 Halt             0    0    0               00 
SQL: [;
SELECT printf('|%7.8c|%-7.8c|','*','*');]
VDBE Trace:
   0 Init             0    4    0               00 Start at 4
   4 String8          0    2    0 |%7.8c|%-7.8c| 00 r[2]='|%7.8c|%-7.8c|'
REG[2] =   t14[|%7.8c|%-7.8c|](8)
   5 String8          0    3    0 *             00 r[3]='*'
REG[3] =   t1[*](8)
   6 String8          0    4    0 *             00 r[4]='*'
REG[4] =   t1[*](8)
   7 Goto             0    1    0               00 
   1 Function0        7    2    1 printf(-1)    03 r[1]=func(r[2..4])
REG[2] =   t14[|%7.8c|%-7.8c|](8)
REG[3] =   t1[*](8)
REG[4] =   t1[*](8)
REG[1] =   s19[|********|*****](8)
   2 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s19[|********|*****](8)
   3 Halt             0    0    0               00 
SQL: [;
UPDATE t1 SET a=0;]
VDBE Trace:
   0 Init             0   26    0               00 Start at 26
  26 Transaction      0    1    2 1             01 usesStmtJournal=1
  27 TableLock        0    2    1 t1            00 iDb=0 root=2 write=1
  28 Goto             0    1    0               00 
   1 Null             0    1    2               00 r[1..2]=NULL
REG[1] =  NULL
   2 OpenRead         0    2    0 0             00 root=2 iDb=0; t1
   3 Explain          0    0    0 SCAN TABLE t1 00 
   4 Rewind           0    8    0               00 
   8 Close            0    0    0               00 
   9 OpenWrite        0    2    0 2             00 root=2 iDb=0; t1
  10 RowSetRead       1   24    2               00 r[2]=rowset(1)
REG[1] =  NULL
REG[2] =  NULL
  24 Noop             0    0    0               00 
  25 Halt             0    0    0               00 
SQL: [PRAGMA default_cache_size;]
VDBE Trace:
   0 Init             0    0    0               00 Start at 0
   1 Transaction      0    0    0               00 
   2 ReadCookie       0    1    3               00 
REG[1] =  i:0
   3 IfPos            1    9    0               00 if r[1]>0 then r[1]-=0, goto 9
REG[1] =  i:0
   4 Integer          0    2    0               00 r[2]=0
REG[2] =  i:0
   5 Subtract         1    2    1               00 r[1]=r[2]-r[1]
REG[1] =  i:0
REG[2] =  i:0
REG[1] =  i:0
   6 IfPos            1    9    0               00 if r[1]>0 then r[1]-=0, goto 9
REG[1] =  i:0
   7 Integer       -2000    1    0               00 r[1]=-2000
REG[1] =  i:-2000
   8 Noop             0    0    0               00 
   9 ResultRow        1    1    0               00 output=r[1]
REG[1] =  i:-2000
  10 Halt             0    0    0               00 
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[cmdlist explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping cmdlist
parser: Popping $
SQL: [;
PRAGMA parser_trace=ON;]
VDBE Trace:
   0 Init             0    0    0               00 Start at 0
   1 Halt             0    0    0               00 
parser: Initialize. Empty stack. State 0
parser: Input 'SEMI'
parser: Shift 'SEMI'
parser: Return. Stack=[SEMI]
parser: Input 'CREATE'
parser: Reduce [ecmd ::= SEMI], go to state 0.
parser: Shift 'ecmd'
parser: Reduce [cmdlist ::= ecmd], go to state 0.
parser: Shift 'cmdlist', go to state 146
parser: Reduce [explain ::=], go to state 146.
parser: Shift 'explain', go to state 2
parser: Shift 'CREATE'
parser: Return. Stack=[cmdlist explain CREATE]
parser: Input 'INDEX'
parser: Reduce [createkw ::= CREATE], go to state 2.
parser: Shift 'createkw', go to state 107
parser: Reduce [uniqueflag ::=], go to state 107.
parser: Shift 'uniqueflag', go to state 370
parser: Shift 'INDEX', go to state 256
parser: Return. Stack=[cmdlist explain createkw uniqueflag INDEX]
parser: Input 'ID'
parser: Reduce [ifnotexists ::=], go to state 256.
parser: Shift 'ifnotexists', go to state 180
parser: Shift 'ID'
parser: Return. Stack=[cmdlist explain createkw uniqueflag INDEX ifnotexists ID]
parser: Input 'ON'
parser: Reduce [nm ::= ID|INDEXED], go to state 180.
parser: Shift 'nm', go to state 255
parser: Reduce [dbnm ::=], go to state 255.
parser: Shift 'dbnm', go to state 369
parser: Shift 'ON', go to state 179
parser: Return. Stack=[cmdlist explain createkw uniqueflag INDEX ifnotexists nm dbnm ON]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[cmdlist explain createkw uniqueflag INDEX ifnotexists nm dbnm ON ID]
parser: Input 'LP'
parser: Reduce [nm ::= ID|INDEXED], go to state 179.
parser: Shift 'nm', go to state 368
parser: Shift 'LP', go to state 12
parser: Return. Stack=[cmdlist explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP ID]
parser: Input 'RP'
parser: Reduce [expr ::= ID|INDEXED], go to state 12.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 12.
parser: Shift 'sortlist', go to state 325
parser: Shift 'RP', go to state 254
parser: Return. Stack=[cmdlist explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP]
parser: Input 'SEMI'
parser: Reduce [where_opt ::=], go to state 254.
parser: Shift 'where_opt'
parser: Reduce [cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt], go to state 2.
parser: Initialize. Empty stack. State 0
parser: Input 'INSERT'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'INSERT', go to state 253
parser: Return. Stack=[explain with INSERT]
parser: Input 'INTO'
parser: Reduce [orconf ::=], go to state 253.
parser: Shift 'orconf'
parser: Reduce [insert_cmd ::= INSERT orconf], go to state 22.
parser: Shift 'insert_cmd', go to state 351
parser: Shift 'INTO', go to state 127
parser: Return. Stack=[explain with insert_cmd INTO]
parser: Input 'STRING'
parser: Shift 'STRING'
parser: Return. Stack=[explain with insert_cmd INTO STRING]
parser: Input 'DOT'
parser: Reduce [nm ::= STRING], go to state 127.
parser: Shift 'nm', go to state 259
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[explain with insert_cmd INTO nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with insert_cmd INTO nm DOT ID]
parser: Input 'VALUES'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 259.
parser: Shift 'dbnm'
parser: Reduce [fullname ::= nm dbnm], go to state 127.
parser: Shift 'fullname', go to state 241
parser: Reduce [idlist_opt ::=], go to state 241.
parser: Shift 'idlist_opt', go to state 147
parser: Reduce [with ::=], go to state 147.
parser: Shift 'with', go to state 113
parser: Shift 'VALUES', go to state 397
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES]
parser: Input 'LP'
parser: Shift 'LP', go to state 15
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP STRING]
parser: Input 'COMMA'
parser: Reduce [term ::= STRING], go to state 15.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 15.
parser: Shift 'expr', go to state 48
parser: Reduce [nexprlist ::= expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'COMMA', go to state 70
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA STRING]
parser: Input 'COMMA'
parser: Reduce [term ::= STRING], go to state 70.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 70.
parser: Shift 'expr', go to state 43
parser: Reduce [nexprlist ::= nexprlist COMMA expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'COMMA', go to state 70
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA STRING]
parser: Input 'COMMA'
parser: Reduce [term ::= STRING], go to state 70.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 70.
parser: Shift 'expr', go to state 43
parser: Reduce [nexprlist ::= nexprlist COMMA expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'COMMA', go to state 70
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA]
parser: Input 'VARIABLE'
parser: Shift 'VARIABLE'
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA VARIABLE]
parser: Input 'COMMA'
parser: Reduce [expr ::= VARIABLE], go to state 70.
parser: Shift 'expr', go to state 43
parser: Reduce [nexprlist ::= nexprlist COMMA expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'COMMA', go to state 70
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA STRING]
parser: Input 'RP'
parser: Reduce [term ::= STRING], go to state 70.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 70.
parser: Shift 'expr', go to state 43
parser: Reduce [nexprlist ::= nexprlist COMMA expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'RP'
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist RP]
parser: Input 'SEMI'
parser: Reduce [values ::= VALUES LP nexprlist RP], go to state 113.
parser: Shift 'values', go to state 400
parser: Reduce [oneselect ::= values], go to state 113.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 113.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 147.
parser: Shift 'select'
parser: Reduce [cmd ::= with insert_cmd INTO fullname idlist_opt select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Input '$'
parser: Reduce [ecmd ::= explain cmdx SEMI], go to state 0.
parser: Shift 'ecmd'
parser: Reduce [cmdlist ::= ecmd], go to state 0.
parser: Shift 'cmdlist', go to state 146
parser: Reduce [input ::= cmdlist], go to state 0.
parser: Accept!
parser: Popping $
parser: Return. Stack=]
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[cmdlist explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping cmdlist
parser: Popping $
SQL: [;
CREATE INDEX t2 ON t1(a);]
VDBE Trace:
   0 Init             0   34    0               00 Start at 34
  34 Transaction      0    1    2 1             01 usesStmtJournal=0
  35 TableLock        0    1    1 sqlite_master 00 iDb=0 root=1 write=1
  36 TableLock        0    2    1 t1            00 iDb=0 root=2 write=1
  37 Goto             0    1    0               00 
   1 Noop             0   33    0               00 
   2 CreateIndex      0    1    0               00 r[1]=root iDb=0
REG[1] =  i:4
   3 OpenWrite        0    1    0 5             00 root=1 iDb=0; sqlite_master
   4 NewRowid         0    2    0               00 r[2]=rowid
REG[2] =  i:3
   5 String8          0    3    0 index         00 r[3]='index'
REG[3] =   t5[index](8)
   6 String8          0    4    0 t2            00 r[4]='t2'
REG[4] =   t2[t2](8)
   7 String8          0    5    0 t1            00 r[5]='t1'
REG[5] =   t2[t1](8)
   8 Copy             1    6    0               00 r[6]=r[1]
REG[6] =  i:4
   9 String8          0    7    0 CREATE INDEX t2 ON t1(a) 00 r[7]='CREATE INDEX t2 ON t1(a)'
REG[7] =   t24[CREATE INDEX t2](8)
  10 MakeRecord       3    5    8 BBBDB         00 r[8]=mkrec(r[3..7])
REG[8] =  s40[06171111013D696E6465787432743104.....=indext2t1.](8)
  11 Insert           0    8    2               18 intkey=r[2] data=r[8]
REG[8] =  s40[06171111013D696E6465787432743104.....=indext2t1.](8)
REG[2] =  i:3
  12 Close            0    0    0               00 
  13 SorterOpen       3    0    1 k(2,,)        00 
  14 OpenRead         1    2    0 2             00 root=2 iDb=0; t1
  15 Rewind           1   21    0               00 
  21 OpenWrite        2    1    0 k(2,,)        11 root=1 iDb=0
  22 SorterSort       3   27    0               00 
  27 Close            1    0    0               00 
  28 Close            2    0    0               00 
  29 Close            3    0    0               00 
  30 SetCookie        0    1    3               00 
  31 ParseSchema      0    0    0 name='t2' AND type='index' 00 
parser: Initialize. Empty stack. State 0
parser: Input 'SELECT'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[explain with SELECT]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'FROM'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[explain with SELECT distinct selcollist FROM]
parser: Input 'STRING'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'STRING'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix STRING]
parser: Input 'DOT'
parser: Reduce [nm ::= STRING], go to state 165.
parser: Shift 'nm', go to state 287
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Shift 'WHERE', go to state 65
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'AND', go to state 93
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 93.
parser: Shift 'expr', go to state 53
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND expr EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND expr EQ STRING]
parser: Input 'ORDER'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 93.
parser: Shift 'expr', go to state 53
parser: Reduce [expr ::= expr AND expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Reduce [where_opt ::= WHERE expr], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Shift 'ORDER', go to state 411
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY'
parser: Shift 'BY', go to state 17
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI'
parser: Reduce [expr ::= ID|INDEXED], go to state 17.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 17.
parser: Shift 'sortlist', go to state 410
parser: Reduce [orderby_opt ::= ORDER BY sortlist], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 22.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 2.
parser: Shift 'select'
parser: Reduce [cmd ::= select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
VDBE Trace:
   0 Init             0   16    0               00 Start at 16
  16 Transaction      0    0    3 1             00 usesStmtJournal=0
  17 TableLock        0    1    0 sqlite_master 00 iDb=0 root=1 write=0
  18 String8          0    2    0 t2            00 r[2]='t2'
REG[2] =   t2[t2](8)
  19 String8          0    4    0 index         00 r[4]='index'
REG[4] =   t5[index](8)
  20 Goto             0    1    0               00 
   1 Noop             1    5    0               00 
   2 OpenRead         0    1    0 5             00 root=1 iDb=0; sqlite_master
   3 Explain          0    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   14    0               00 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s2[t1](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t2[t2](8)
REG[1] =   s2[t1](8)
  13 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s7[numbers](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t2[t2](8)
REG[1] =   s7[numbers](8)
  13 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s2[t2](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t2[t2](8)
REG[1] =   s2[t2](8)
   7 Column           0    0    3               00 r[3]=sqlite_master.type
REG[3] =   s5[index](8)
   8 Ne               4   13    3 (BINARY)      52 if r[4]!=r[3] goto 13
REG[4] =   t5[index](8)
REG[3] =   s5[index](8)
   9 Copy             1    5    0               00 r[5]=r[1]
REG[5] =   s2[t2](8)
  10 Column           0    3    6               00 r[6]=sqlite_master.rootpage
REG[6] =  i:4
  11 Column           0    4    7               00 r[7]=sqlite_master.sql
REG[7] =   s24[CREATE INDEX t2](8)
  12 ResultRow        5    3    0               00 output=r[5..7]
REG[5] =   s2[t2](8)
REG[6] =  i:4
REG[7] =   s24[CREATE INDEX t2](8)
parser: Initialize. Empty stack. State 0
parser: Input 'CREATE'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Shift 'CREATE'
parser: Return. Stack=[explain CREATE]
parser: Input 'INDEX'
parser: Reduce [createkw ::= CREATE], go to state 2.
parser: Shift 'createkw', go to state 107
parser: Reduce [uniqueflag ::=], go to state 107.
parser: Shift 'uniqueflag', go to state 370
parser: Shift 'INDEX', go to state 256
parser: Return. Stack=[explain createkw uniqueflag INDEX]
parser: Input 'ID'
parser: Reduce [ifnotexists ::=], go to state 256.
parser: Shift 'ifnotexists', go to state 180
parser: Shift 'ID'
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists ID]
parser: Input 'ON'
parser: Reduce [nm ::= ID|INDEXED], go to state 180.
parser: Shift 'nm', go to state 255
parser: Reduce [dbnm ::=], go to state 255.
parser: Shift 'dbnm', go to state 369
parser: Shift 'ON', go to state 179
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON ID]
parser: Input 'LP'
parser: Reduce [nm ::= ID|INDEXED], go to state 179.
parser: Shift 'nm', go to state 368
parser: Shift 'LP', go to state 12
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP ID]
parser: Input 'RP'
parser: Reduce [expr ::= ID|INDEXED], go to state 12.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 12.
parser: Shift 'sortlist', go to state 325
parser: Shift 'RP', go to state 254
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP]
parser: Input 'SEMI'
parser: Reduce [where_opt ::=], go to state 254.
parser: Shift 'where_opt'
parser: Reduce [cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
  13 Next             0    5    0               01 
  14 Close            0    0    0               00 
  15 Halt             0    0    0               00 
  32 Expire           0    0    0               00 
  33 Halt             0    0    0               00 
parser: Initialize. Empty stack. State 0
parser: Input 'SEMI'
parser: Shift 'SEMI'
parser: Return. Stack=[SEMI]
parser: Input 'SELECT'
parser: Reduce [ecmd ::= SEMI], go to state 0.
parser: Shift 'ecmd'
parser: Reduce [cmdlist ::= ecmd], go to state 0.
parser: Shift 'cmdlist', go to state 146
parser: Reduce [explain ::=], go to state 146.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[cmdlist explain with SELECT]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct sclp ID]
parser: Input 'LP'
parser: Shift 'LP', go to state 216
parser: Return. Stack=[cmdlist explain with SELECT distinct sclp ID LP]
parser: Input 'STAR'
parser: Shift 'STAR', go to state 393
parser: Return. Stack=[cmdlist explain with SELECT distinct sclp ID LP STAR]
parser: Input 'RP'
parser: Shift 'RP'
parser: Return. Stack=[cmdlist explain with SELECT distinct sclp ID LP STAR RP]
parser: Input 'FROM'
parser: Reduce [expr ::= ID|INDEXED LP STAR RP], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist FROM]
parser: Input 'ID'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'ID'
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'SEMI'
parser: Reduce [nm ::= ID|INDEXED], go to state 165.
parser: Shift 'nm', go to state 287
parser: Reduce [dbnm ::=], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Reduce [where_opt ::=], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Reduce [orderby_opt ::=], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 22.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 2.
parser: Shift 'select'
parser: Reduce [cmd ::= select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[cmdlist explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping cmdlist
parser: Popping $
SQL: [;
SELECT count(*) FROM numbers;]
VDBE Trace:
   0 Init             0    7    0               00 Start at 7
   7 Transaction      0    0    3 1             01 usesStmtJournal=0
   8 TableLock        0    3    0 numbers       00 iDb=0 root=3 write=0
   9 Goto             0    1    0               00 
   1 OpenRead         1    3    0 1             00 root=3 iDb=0
   2 Count            1    1    0               00 r[1]=count()
REG[1] =  i:0
   3 Close            1    0    0               00 
   4 Copy             1    2    0               00 r[2]=r[1]
REG[2] =  i:0
   5 ResultRow        2    1    0               00 output=r[2]
REG[2] =  i:0
   6 Halt             0    0    0               00 
parser: Initialize. Empty stack. State 0
parser: Input 'SEMI'
parser: Shift 'SEMI'
parser: Return. Stack=[SEMI]
parser: Input 'UPDATE'
parser: Reduce [ecmd ::= SEMI], go to state 0.
parser: Shift 'ecmd'
parser: Reduce [cmdlist ::= ecmd], go to state 0.
parser: Shift 'cmdlist', go to state 146
parser: Reduce [explain ::=], go to state 146.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'UPDATE', go to state 242
parser: Return. Stack=[cmdlist explain with UPDATE]
parser: Input 'OR'
parser: Shift 'OR', go to state 121
parser: Return. Stack=[cmdlist explain with UPDATE OR]
parser: Input 'IGNORE'
parser: Shift 'IGNORE'
parser: Return. Stack=[cmdlist explain with UPDATE OR IGNORE]
parser: Input 'ID'
parser: Reduce [resolvetype ::= IGNORE], go to state 121.
parser: Shift 'resolvetype'
parser: Reduce [orconf ::= OR resolvetype], go to state 242.
parser: Shift 'orconf', go to state 129
parser: Shift 'ID'
parser: Return. Stack=[cmdlist explain with UPDATE orconf ID]
parser: Input 'SET'
parser: Reduce [nm ::= ID|INDEXED], go to state 129.
parser: Shift 'nm', go to state 259
parser: Reduce [dbnm ::=], go to state 259.
parser: Shift 'dbnm'
parser: Reduce [fullname ::= nm dbnm], go to state 129.
parser: Shift 'fullname', go to state 219
parser: Reduce [indexed_opt ::=], go to state 219.
parser: Shift 'indexed_opt', go to state 352
parser: Shift 'SET', go to state 128
parser: Return. Stack=[cmdlist explain with UPDATE orconf fullname indexed_opt SET]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[cmdlist explain with UPDATE orconf fullname indexed_opt SET ID]
parser: Input 'EQ'
parser: Reduce [nm ::= ID|INDEXED], go to state 128.
parser: Shift 'nm', go to state 360
parser: Shift 'EQ', go to state 59
parser: Return. Stack=[cmdlist explain with UPDATE orconf fullname indexed_opt SET nm EQ]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with UPDATE orconf fullname indexed_opt SET nm EQ ID]
parser: Input 'STAR'
parser: Reduce [expr ::= ID|INDEXED], go to state 59.
parser: Shift 'expr', go to state 36
parser: Shift 'STAR', go to state 87
parser: Return. Stack=[cmdlist explain with UPDATE orconf fullname indexed_opt SET nm EQ expr STAR]
parser: Input 'INTEGER'
parser: Shift 'INTEGER'
parser: Return. Stack=[cmdlist explain with UPDATE orconf fullname indexed_opt SET nm EQ expr STAR INTEGER]
parser: Input 'SEMI'
parser: Reduce [term ::= INTEGER|FLOAT|BLOB], go to state 87.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 87.
parser: Shift 'expr', go to state 112
parser: Reduce [expr ::= expr STAR|SLASH|REM expr], go to state 59.
parser: Shift 'expr', go to state 36
parser: Reduce [setlist ::= nm EQ expr], go to state 128.
parser: Shift 'setlist', go to state 218
parser: Reduce [where_opt ::=], go to state 218.
parser: Shift 'where_opt'
parser: Reduce [cmd ::= with UPDATE orconf fullname indexed_opt SET setlist where_opt], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[cmdlist explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping cmdlist
parser: Popping $
SQL: [;
UPDATE OR IGNORE t1 SET a=a*2;]
VDBE Trace:
   0 Init             0   37    0               00 Start at 37
  37 Transaction      0    1    3 1             01 usesStmtJournal=0
  38 TableLock        0    2    1 t1            00 iDb=0 root=2 write=1
  39 Integer          2    8    0               00 r[8]=2
REG[8] =  i:2
  40 Goto             0    1    0               00 
   1 Null             0    2    3               00 r[2..3]=NULL
REG[2] =  NULL
   2 OpenRead         0    2    0 0             00 root=2 iDb=0; t1
   3 Explain          0    0    0 SCAN TABLE t1 00 
   4 Rewind           0    8    0               00 
   8 Close            0    0    0               00 
   9 OpenWrite        0    2    0 2             00 root=2 iDb=0; t1
  10 OpenWrite        1    4    0 k(2,,)        00 root=4 iDb=0; t2
  11 RowSetRead       2   34    3               00 r[3]=rowset(2)
REG[2] =  NULL
REG[3] =  NULL
  34 Close            1    0    0               00 
  35 Noop             0    0    0               00 
  36 Halt             0    0    0               00 
parser: Initialize. Empty stack. State 0
parser: Input 'INSERT'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'INSERT', go to state 253
parser: Return. Stack=[explain with INSERT]
parser: Input 'INTO'
parser: Reduce [orconf ::=], go to state 253.
parser: Shift 'orconf'
parser: Reduce [insert_cmd ::= INSERT orconf], go to state 22.
parser: Shift 'insert_cmd', go to state 351
parser: Shift 'INTO', go to state 127
parser: Return. Stack=[explain with insert_cmd INTO]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with insert_cmd INTO ID]
parser: Input 'VALUES'
parser: Reduce [nm ::= ID|INDEXED], go to state 127.
parser: Shift 'nm', go to state 259
parser: Reduce [dbnm ::=], go to state 259.
parser: Shift 'dbnm'
parser: Reduce [fullname ::= nm dbnm], go to state 127.
parser: Shift 'fullname', go to state 241
parser: Reduce [idlist_opt ::=], go to state 241.
parser: Shift 'idlist_opt', go to state 147
parser: Reduce [with ::=], go to state 147.
parser: Shift 'with', go to state 113
parser: Shift 'VALUES', go to state 397
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES]
parser: Input 'LP'
parser: Shift 'LP', go to state 15
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP]
parser: Input 'INTEGER'
parser: Shift 'INTEGER'
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP INTEGER]
parser: Input 'COMMA'
parser: Reduce [term ::= INTEGER|FLOAT|BLOB], go to state 15.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 15.
parser: Shift 'expr', go to state 48
parser: Reduce [nexprlist ::= expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'COMMA', go to state 70
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA STRING]
parser: Input 'RP'
parser: Reduce [term ::= STRING], go to state 70.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 70.
parser: Shift 'expr', go to state 43
parser: Reduce [nexprlist ::= nexprlist COMMA expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'RP'
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist RP]
parser: Input 'SEMI'
parser: Reduce [values ::= VALUES LP nexprlist RP], go to state 113.
parser: Shift 'values', go to state 400
parser: Reduce [oneselect ::= values], go to state 113.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 113.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 147.
parser: Shift 'select'
parser: Reduce [cmd ::= with insert_cmd INTO fullname idlist_opt select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
SQL: [INSERT INTO numbers VALUES(1, 'one');]
VDBE Trace:
   0 Init             0    9    0               00 Start at 9
   9 Transaction      0    1    3 1             01 usesStmtJournal=0
  10 TableLock        0    3    1 numbers       00 iDb=0 root=3 write=1
  11 Goto             0    1    0               00 
   1 OpenWrite        0    3    0 2             00 root=3 iDb=0; numbers
   2 NewRowid         0    1    0               00 r[1]=rowid
REG[1] =  i:1
   3 Integer          1    2    0               00 r[2]=1
REG[2] =  i:1
   4 String8          0    3    0 one           00 r[3]='one'
REG[3] =   t3[one](8)
   5 MakeRecord       2    2    4 DD            00 r[4]=mkrec(r[2..3])
REG[4] =  s6[0309136F6E65...one](8)
   6 Insert           0    4    1 numbers       1B intkey=r[1] data=r[4]
REG[4] =  s6[0309136F6E65...one](8)
REG[1] =  i:1
   7 Noop             0    0    0               00 
   8 Halt             0    0    0               00 
parser: Initialize. Empty stack. State 0
parser: Input 'SELECT'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[explain with SELECT]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'FROM'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[explain with SELECT distinct selcollist FROM]
parser: Input 'ID'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'ID'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ORDER'
parser: Reduce [nm ::= ID|INDEXED], go to state 165.
parser: Shift 'nm', go to state 287
parser: Reduce [dbnm ::=], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Reduce [where_opt ::=], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Shift 'ORDER', go to state 411
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY'
parser: Shift 'BY', go to state 17
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI'
parser: Reduce [expr ::= ID|INDEXED], go to state 17.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 17.
parser: Shift 'sortlist', go to state 410
parser: Reduce [orderby_opt ::= ORDER BY sortlist], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 22.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 2.
parser: Shift 'select'
parser: Reduce [cmd ::= select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
SQL: [SELECT rowid, b, b FROM t1 ORDER BY b
  ;]
VDBE Trace:
   0 Init             0   22    0               00 Start at 22
  22 Transaction      0    0    3 1             01 usesStmtJournal=0
  23 TableLock        0    2    0 t1            00 iDb=0 root=2 write=0
  24 Goto             0    1    0               00 
   1 SorterOpen       1    5    0 k(1,B)        00 
   2 OpenRead         0    2    0 2             00 root=2 iDb=0; t1
   3 Explain          0    0    0 SCAN TABLE t1 00 
   4 Rewind           0   12    0               00 
  12 Close            0    0    0               00 
  13 OpenPseudo       2    6    5               00 5 columns in r[6]
  14 SorterSort       1   21    0               00 
  21 Halt             0    0    0               00 
parser: Initialize. Empty stack. State 0
parser: Input 'PRAGMA'
parser: FALLBACK PRAGMA => ID
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Shift 'PRAGMA', go to state 172
parser: Return. Stack=[explain PRAGMA]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain PRAGMA ID]
parser: Input 'EQ'
parser: Reduce [nm ::= ID|INDEXED], go to state 172.
parser: Shift 'nm', go to state 240
parser: Reduce [dbnm ::=], go to state 240.
parser: Shift 'dbnm', go to state 323
parser: Shift 'EQ', go to state 20
parser: Return. Stack=[explain PRAGMA nm dbnm EQ]
parser: Input 'INTEGER'
parser: Shift 'INTEGER'
parser: Return. Stack=[explain PRAGMA nm dbnm EQ INTEGER]
parser: Input 'SEMI'
parser: Reduce [plus_num ::= INTEGER|FLOAT], go to state 20.
parser: Shift 'plus_num'
parser: Reduce [nmnum ::= plus_num], go to state 20.
parser: Shift 'nmnum'
parser: Reduce [cmd ::= PRAGMA nm dbnm EQ nmnum], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
SQL: [PRAGMA page_size = 1024;]
VDBE Trace:
   0 Init             0    0    0               00 Start at 0
   1 Halt             0    0    0               00 
parser: Initialize. Empty stack. State 0
parser: Input 'SELECT'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[explain with SELECT]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'FROM'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[explain with SELECT distinct selcollist FROM]
parser: Input 'ID'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'ID'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'UNION'
parser: Reduce [nm ::= ID|INDEXED], go to state 165.
parser: Shift 'nm', go to state 287
parser: Reduce [dbnm ::=], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Reduce [where_opt ::=], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Reduce [orderby_opt ::=], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 22.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Shift 'UNION', go to state 396
parser: Return. Stack=[explain with selectnowith UNION]
parser: Input 'ALL'
parser: Shift 'ALL'
parser: Return. Stack=[explain with selectnowith UNION ALL]
parser: Input 'SELECT'
parser: Reduce [multiselect_op ::= UNION ALL], go to state 215.
parser: Shift 'multiselect_op', go to state 150
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[explain with selectnowith multiselect_op SELECT]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with selectnowith multiselect_op SELECT distinct sclp ID]
parser: Input 'LP'
parser: Shift 'LP', go to state 216
parser: Return. Stack=[explain with selectnowith multiselect_op SELECT distinct sclp ID LP]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 216.
parser: Shift 'distinct', go to state 6
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with selectnowith multiselect_op SELECT distinct sclp ID LP distinct ID]
parser: Input 'RP'
parser: Reduce [expr ::= ID|INDEXED], go to state 6.
parser: Shift 'expr', go to state 48
parser: Reduce [nexprlist ::= expr], go to state 6.
parser: Shift 'nexprlist', go to state 412
parser: Reduce [exprlist ::= nexprlist], go to state 6.
parser: Shift 'exprlist', go to state 394
parser: Shift 'RP'
parser: Return. Stack=[explain with selectnowith multiselect_op SELECT distinct sclp ID LP distinct exprlist RP]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED LP distinct exprlist RP], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with selectnowith multiselect_op SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with selectnowith multiselect_op SELECT distinct sclp ID]
parser: Input 'FROM'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[explain with selectnowith multiselect_op SELECT distinct selcollist FROM]
parser: Input 'ID'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'ID'
parser: Return. Stack=[explain with selectnowith multiselect_op SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'SEMI'
parser: Reduce [nm ::= ID|INDEXED], go to state 165.
parser: Shift 'nm', go to state 287
parser: Reduce [dbnm ::=], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Reduce [where_opt ::=], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Reduce [orderby_opt ::=], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 150.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= selectnowith multiselect_op oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 2.
parser: Shift 'select'
parser: Reduce [cmd ::= select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
SQL: [SELECT a, a FROM t1
    UNION ALL
    SELECT abs(a), a FROM t1
  ;]
VDBE Trace:
   0 Init             0   19    0               00 Start at 19
  19 Transaction      0    0    3 1             01 usesStmtJournal=0
  20 TableLock        0    2    0 t1            00 iDb=0 root=2 write=0
  21 Goto             0    1    0               00 
   1 OpenRead         1    2    0 0             00 root=2 iDb=0; t1
   2 Explain          1    0    0 SCAN TABLE t1 00 
   3 Rewind           1    8    0               00 
   8 Close            1    0    0               00 
   9 OpenRead         0    2    0 0             00 root=2 iDb=0; t1
  10 Explain          2    0    0 SCAN TABLE t1 00 
  11 Rewind           0   17    0               00 
  17 Close            0    0    0               00 
  18 Halt             0    0    0               00 
parser: Initialize. Empty stack. State 0
parser: Input 'SEMI'
parser: Shift 'SEMI'
parser: Return. Stack=[SEMI]
parser: Input 'SELECT'
parser: Reduce [ecmd ::= SEMI], go to state 0.
parser: Shift 'ecmd'
parser: Reduce [cmdlist ::= ecmd], go to state 0.
parser: Shift 'cmdlist', go to state 146
parser: Reduce [explain ::=], go to state 146.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[cmdlist explain with SELECT]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct sclp ID]
parser: Input 'FROM'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist FROM]
parser: Input 'STRING'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'STRING'
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist FROM stl_prefix STRING]
parser: Input 'DOT'
parser: Reduce [nm ::= STRING], go to state 165.
parser: Shift 'nm', go to state 287
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Shift 'WHERE', go to state 65
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'AND', go to state 93
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'NE'
parser: Reduce [expr ::= ID|INDEXED], go to state 93.
parser: Shift 'expr', go to state 53
parser: Shift 'NE', go to state 90
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE expr AND expr NE]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE expr AND expr NE STRING]
parser: Input 'ORDER'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 93.
parser: Shift 'expr', go to state 53
parser: Reduce [expr ::= expr AND expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Reduce [where_opt ::= WHERE expr], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Shift 'ORDER', go to state 411
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY'
parser: Shift 'BY', go to state 17
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI'
parser: Reduce [expr ::= ID|INDEXED], go to state 17.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 17.
parser: Shift 'sortlist', go to state 410
parser: Reduce [orderby_opt ::= ORDER BY sortlist], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 22.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 2.
parser: Shift 'select'
parser: Reduce [cmd ::= select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[cmdlist explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping cmdlist
parser: Popping $
SQL: [;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='numbers' AND type!='trigger' ORDER BY rowid;]
VDBE Trace:
   0 Init             0   16    0               00 Start at 16
  16 Transaction      0    0    3 1             01 usesStmtJournal=0
  17 TableLock        0    1    0 sqlite_master 00 iDb=0 root=1 write=0
  18 String8          0    2    0 numbers       00 r[2]='numbers'
REG[2] =   t7[numbers](8)
  19 String8          0    4    0 trigger       00 r[4]='trigger'
REG[4] =   t7[trigger](8)
  20 Goto             0    1    0               00 
   1 Noop             1    5    0               00 
   2 OpenRead         0    1    0 5             00 root=1 iDb=0; sqlite_master
   3 Explain          0    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   14    0               00 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[t1](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t7[numbers](8)
REG[1] =   s2[t1](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s7[numbers](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t7[numbers](8)
REG[1] =   s7[numbers](8)
   7 Column           0    0    3               00 r[3]=sqlite_master.type
REG[3] =   s5[table](8)
   8 Eq               4   13    3 (BINARY)      52 if r[4]==r[3] goto 13
REG[4] =   t7[trigger](8)
REG[3] =   s5[table](8)
   9 Column           0    1    5               00 r[5]=sqlite_master.name
REG[5] =   s7[numbers](8)
  10 Column           0    3    6               00 r[6]=sqlite_master.rootpage
REG[6] =  i:3
  11 Column           0    4    7               00 r[7]=sqlite_master.sql
REG[7] =   s34[CREATE TABLE nu](8)
  12 ResultRow        5    3    0               00 output=r[5..7]
REG[5] =   s7[numbers](8)
REG[6] =  i:3
REG[7] =   s34[CREATE TABLE nu](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[t1](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t7[numbers](8)
REG[1] =   s2[t1](8)
  13 Next             0    5    0               01 
  14 Close            0    0    0               00 
  15 Halt             0    0    0               00 
parser: Initialize. Empty stack. State 0
parser: Input 'SELECT'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[explain with SELECT]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'LP'
parser: Shift 'LP', go to state 216
parser: Return. Stack=[explain with SELECT distinct sclp ID LP]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 216.
parser: Shift 'distinct', go to state 6
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID LP distinct ID]
parser: Input 'RP'
parser: Reduce [expr ::= ID|INDEXED], go to state 6.
parser: Shift 'expr', go to state 48
parser: Reduce [nexprlist ::= expr], go to state 6.
parser: Shift 'nexprlist', go to state 412
parser: Reduce [exprlist ::= nexprlist], go to state 6.
parser: Shift 'exprlist', go to state 394
parser: Shift 'RP'
parser: Return. Stack=[explain with SELECT distinct sclp ID LP distinct exprlist RP]
parser: Input 'FROM'
parser: Reduce [expr ::= ID|INDEXED LP distinct exprlist RP], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[explain with SELECT distinct selcollist FROM]
parser: Input 'ID'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'ID'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'UNION'
parser: Reduce [nm ::= ID|INDEXED], go to state 165.
parser: Shift 'nm', go to state 287
parser: Reduce [dbnm ::=], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Reduce [where_opt ::=], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Reduce [orderby_opt ::=], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 22.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Shift 'UNION', go to state 396
parser: Return. Stack=[explain with selectnowith UNION]
parser: Input 'ALL'
parser: Shift 'ALL'
parser: Return. Stack=[explain with selectnowith UNION ALL]
parser: Input 'SELECT'
parser: Reduce [multiselect_op ::= UNION ALL], go to state 215.
parser: Shift 'multiselect_op', go to state 150
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[explain with selectnowith multiselect_op SELECT]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with selectnowith multiselect_op SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with selectnowith multiselect_op SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with selectnowith multiselect_op SELECT distinct sclp ID]
parser: Input 'FROM'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[explain with selectnowith multiselect_op SELECT distinct selcollist FROM]
parser: Input 'ID'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'ID'
parser: Return. Stack=[explain with selectnowith multiselect_op SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'SEMI'
parser: Reduce [nm ::= ID|INDEXED], go to state 165.
parser: Shift 'nm', go to state 287
parser: Reduce [dbnm ::=], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Reduce [where_opt ::=], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Reduce [orderby_opt ::=], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 150.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= selectnowith multiselect_op oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 2.
parser: Shift 'select'
parser: Reduce [cmd ::= select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
SQL: [SELECT b, abs(b) FROM t1
    UNION ALL
    SELECT b, b FROM t1
  ;]
VDBE Trace:
   0 Init             0   19    0               00 Start at 19
  19 Transaction      0    0    3 1             01 usesStmtJournal=0
  20 TableLock        0    2    0 t1            00 iDb=0 root=2 write=0
  21 Goto             0    1    0               00 
   1 OpenRead         1    2    0 2             00 root=2 iDb=0; t1
   2 Explain          1    0    0 SCAN TABLE t1 00 
   3 Rewind           1    9    0               00 
   9 Close            1    0    0               00 
  10 OpenRead         0    2    0 2             00 root=2 iDb=0; t1
  11 Explain          2    0    0 SCAN TABLE t1 00 
  12 Rewind           0   17    0               00 
  17 Close            0    0    0               00 
  18 Halt             0    0    0               00 
parser: Initialize. Empty stack. State 0
parser: Input 'SELECT'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[explain with SELECT]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'FROM'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[explain with SELECT distinct selcollist FROM]
parser: Input 'ID'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'ID'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'UNION'
parser: Reduce [nm ::= ID|INDEXED], go to state 165.
parser: Shift 'nm', go to state 287
parser: Reduce [dbnm ::=], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Reduce [where_opt ::=], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Reduce [orderby_opt ::=], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 22.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Shift 'UNION', go to state 396
parser: Return. Stack=[explain with selectnowith UNION]
parser: Input 'SELECT'
parser: Reduce [multiselect_op ::= UNION], go to state 215.
parser: Shift 'multiselect_op', go to state 150
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[explain with selectnowith multiselect_op SELECT]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with selectnowith multiselect_op SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with selectnowith multiselect_op SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with selectnowith multiselect_op SELECT distinct sclp ID]
parser: Input 'FROM'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[explain with selectnowith multiselect_op SELECT distinct selcollist FROM]
parser: Input 'ID'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'ID'
parser: Return. Stack=[explain with selectnowith multiselect_op SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ORDER'
parser: Reduce [nm ::= ID|INDEXED], go to state 165.
parser: Shift 'nm', go to state 287
parser: Reduce [dbnm ::=], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Reduce [where_opt ::=], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Shift 'ORDER', go to state 411
parser: Return. Stack=[explain with selectnowith multiselect_op SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY'
parser: Shift 'BY', go to state 17
parser: Return. Stack=[explain with selectnowith multiselect_op SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'INTEGER'
parser: Shift 'INTEGER'
parser: Return. Stack=[explain with selectnowith multiselect_op SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY INTEGER]
parser: Input 'SEMI'
parser: Reduce [term ::= INTEGER|FLOAT|BLOB], go to state 17.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 17.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 17.
parser: Shift 'sortlist', go to state 410
parser: Reduce [orderby_opt ::= ORDER BY sortlist], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 150.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= selectnowith multiselect_op oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 2.
parser: Shift 'select'
parser: Reduce [cmd ::= select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
SQL: [SELECT b, b FROM t1
    UNION 
    SELECT b, b FROM t1
    ORDER BY 1
  ;]
VDBE Trace:
   0 Init             0   85    0               00 Start at 85
  85 Transaction      0    0    3 1             01 usesStmtJournal=0
  86 TableLock        0    2    0 t1            00 iDb=0 root=2 write=0
  87 Goto             0    1    0               00 
   1 Integer          0    1    0               00 r[1]=0
REG[1] =  i:0
   2 InitCoroutine    4   23    3               00 left SELECT
  23 InitCoroutine    5   79   24               00 right SELECT
  79 Yield            4   62    0               00 
REG[4] =  i:2
REG[4] =  i:79
   3 SorterOpen       2    5    0 k(2,B,B)      00 
   4 OpenRead         1    2    0 2             00 root=2 iDb=0; t1
   5 Explain          1    0    0 SCAN TABLE t1 00 
   6 Rewind           1   14    0               00 
  14 Close            1    0    0               00 
  15 OpenPseudo       3   13    5               00 5 columns in r[13]
  16 SorterSort       2   22    0               00 
  22 EndCoroutine     4    0    0               00 
REG[4] =  i:79
  62 Yield            5   84    0               00 
REG[5] =  i:23
REG[5] =  i:62
  24 SorterOpen       4    5    0 k(2,B,B)      00 
  25 OpenRead         0    2    0 2             00 root=2 iDb=0; t1
  26 Explain          2    0    0 SCAN TABLE t1 00 
  27 Rewind           0   35    0               00 
  35 Close            0    0    0               00 
  36 OpenPseudo       5   19    5               00 5 columns in r[19]
  37 SorterSort       4   43    0               00 
  43 EndCoroutine     5    0    0               00 
REG[5] =  i:62
  84 Halt             0    0    0               00 
parser: Initialize. Empty stack. State 0
parser: Input 'SELECT'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[explain with SELECT]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'LP'
parser: Shift 'LP', go to state 216
parser: Return. Stack=[explain with SELECT distinct sclp ID LP]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 216.
parser: Shift 'distinct', go to state 6
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID LP distinct ID]
parser: Input 'RP'
parser: Reduce [expr ::= ID|INDEXED], go to state 6.
parser: Shift 'expr', go to state 48
parser: Reduce [nexprlist ::= expr], go to state 6.
parser: Shift 'nexprlist', go to state 412
parser: Reduce [exprlist ::= nexprlist], go to state 6.
parser: Shift 'exprlist', go to state 394
parser: Shift 'RP'
parser: Return. Stack=[explain with SELECT distinct sclp ID LP distinct exprlist RP]
parser: Input 'FROM'
parser: Reduce [expr ::= ID|INDEXED LP distinct exprlist RP], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[explain with SELECT distinct selcollist FROM]
parser: Input 'ID'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'ID'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'UNION'
parser: Reduce [nm ::= ID|INDEXED], go to state 165.
parser: Shift 'nm', go to state 287
parser: Reduce [dbnm ::=], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Reduce [where_opt ::=], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Reduce [orderby_opt ::=], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 22.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Shift 'UNION', go to state 396
parser: Return. Stack=[explain with selectnowith UNION]
parser: Input 'SELECT'
parser: Reduce [multiselect_op ::= UNION], go to state 215.
parser: Shift 'multiselect_op', go to state 150
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[explain with selectnowith multiselect_op SELECT]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with selectnowith multiselect_op SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with selectnowith multiselect_op SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with selectnowith multiselect_op SELECT distinct sclp ID]
parser: Input 'FROM'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[explain with selectnowith multiselect_op SELECT distinct selcollist FROM]
parser: Input 'ID'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'ID'
parser: Return. Stack=[explain with selectnowith multiselect_op SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ORDER'
parser: Reduce [nm ::= ID|INDEXED], go to state 165.
parser: Shift 'nm', go to state 287
parser: Reduce [dbnm ::=], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Reduce [where_opt ::=], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Shift 'ORDER', go to state 411
parser: Return. Stack=[explain with selectnowith multiselect_op SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY'
parser: Shift 'BY', go to state 17
parser: Return. Stack=[explain with selectnowith multiselect_op SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'INTEGER'
parser: Shift 'INTEGER'
parser: Return. Stack=[explain with selectnowith multiselect_op SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY INTEGER]
parser: Input 'SEMI'
parser: Reduce [term ::= INTEGER|FLOAT|BLOB], go to state 17.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 17.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 17.
parser: Shift 'sortlist', go to state 410
parser: Reduce [orderby_opt ::= ORDER BY sortlist], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 150.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= selectnowith multiselect_op oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 2.
parser: Shift 'select'
parser: Reduce [cmd ::= select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
SQL: [SELECT a, abs(a) FROM t1
    UNION 
    SELECT a, a FROM t1
    ORDER BY 1
  ;]
VDBE Trace:
   0 Init             0   66    0               00 Start at 66
  66 Transaction      0    0    3 1             01 usesStmtJournal=0
  67 TableLock        0    2    0 t1            00 iDb=0 root=2 write=0
  68 Goto             0    1    0               00 
   1 Integer          0    1    0               00 r[1]=0
REG[1] =  i:0
   2 InitCoroutine    4   14    3               00 left SELECT
  14 InitCoroutine    5   60   15               00 right SELECT
  60 Yield            4   43    0               00 
REG[4] =  i:2
REG[4] =  i:60
   3 Noop             2    5    0               00 
   4 OpenRead         1    2    0 0             00 root=2 iDb=0; t1
   5 Explain          1    0    0 SCAN TABLE t1 00 
   6 Rewind           1   12    0               00 
  12 Close            1    0    0               00 
  13 EndCoroutine     4    0    0               00 
REG[4] =  i:60
  43 Yield            5   65    0               00 
REG[5] =  i:14
REG[5] =  i:43
  15 Noop             3    5    0               00 
  16 OpenRead         0    2    0 0             00 root=2 iDb=0; t1
  17 Explain          2    0    0 SCAN TABLE t1 00 
  18 Rewind           0   23    0               00 
  23 Close            0    0    0               00 
  24 EndCoroutine     5    0    0               00 
REG[5] =  i:43
  65 Halt             0    0    0               00 
parser: Initialize. Empty stack. State 0
parser: Input 'SELECT'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[explain with SELECT]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'FROM'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[explain with SELECT distinct selcollist FROM]
parser: Input 'ID'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'ID'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ORDER'
parser: Reduce [nm ::= ID|INDEXED], go to state 165.
parser: Shift 'nm', go to state 287
parser: Reduce [dbnm ::=], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Reduce [where_opt ::=], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Shift 'ORDER', go to state 411
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY'
parser: Shift 'BY', go to state 17
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'DESC'
parser: FALLBACK DESC => ID
parser: Reduce [expr ::= ID|INDEXED], go to state 17.
parser: Shift 'expr', go to state 9
parser: Shift 'DESC'
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY expr DESC]
parser: Input 'SEMI'
parser: Reduce [sortorder ::= DESC], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 17.
parser: Shift 'sortlist', go to state 410
parser: Reduce [orderby_opt ::= ORDER BY sortlist], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 22.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 2.
parser: Shift 'select'
parser: Reduce [cmd ::= select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
SQL: [SELECT b, rowid, b FROM t1 ORDER BY rowid DESC
  ;]
VDBE Trace:
   0 Init             0   12    0               00 Start at 12
  12 Transaction      0    0    3 1             01 usesStmtJournal=0
  13 TableLock        0    2    0 t1            00 iDb=0 root=2 write=0
  14 Goto             0    1    0               00 
   1 Noop             1    5    0               00 
   2 OpenRead         0    2    0 2             00 root=2 iDb=0; t1
   3 Explain          0    0    0 SCAN TABLE t1 00 
   4 Last             0   10    0               00 
  10 Close            0    0    0               00 
  11 Halt             0    0    0               00 
parser: Initialize. Empty stack. State 0
parser: Input 'SELECT'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[explain with SELECT]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'FROM'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[explain with SELECT distinct selcollist FROM]
parser: Input 'ID'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'ID'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ORDER'
parser: Reduce [nm ::= ID|INDEXED], go to state 165.
parser: Shift 'nm', go to state 287
parser: Reduce [dbnm ::=], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Reduce [where_opt ::=], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Shift 'ORDER', go to state 411
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY'
parser: Shift 'BY', go to state 17
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'PLUS'
parser: Shift 'PLUS', go to state 76
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY PLUS]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY PLUS ID]
parser: Input 'DESC'
parser: FALLBACK DESC => ID
parser: Reduce [expr ::= ID|INDEXED], go to state 76.
parser: Shift 'expr', go to state 115
parser: Reduce [expr ::= PLUS expr], go to state 17.
parser: Shift 'expr', go to state 9
parser: Shift 'DESC'
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY expr DESC]
parser: Input 'SEMI'
parser: Reduce [sortorder ::= DESC], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 17.
parser: Shift 'sortlist', go to state 410
parser: Reduce [orderby_opt ::= ORDER BY sortlist], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 22.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 2.
parser: Shift 'select'
parser: Reduce [cmd ::= select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
SQL: [SELECT rowid, a, a FROM t1 ORDER BY +rowid DESC
  ;]
VDBE Trace:
   0 Init             0   22    0               00 Start at 22
  22 Transaction      0    0    3 1             01 usesStmtJournal=0
  23 TableLock        0    2    0 t1            00 iDb=0 root=2 write=0
  24 Goto             0    1    0               00 
   1 SorterOpen       1    5    0 k(1,-B)       00 
   2 OpenRead         0    2    0 0             00 root=2 iDb=0; t1
   3 Explain          0    0    0 SCAN TABLE t1 00 
   4 Rewind           0   12    0               00 
  12 Close            0    0    0               00 
  13 OpenPseudo       2    6    5               00 5 columns in r[6]
  14 SorterSort       1   21    0               00 
  21 Halt             0    0    0               00 
parser: Initialize. Empty stack. State 0
parser: Input 'SEMI'
parser: Shift 'SEMI'
parser: Return. Stack=[SEMI]
parser: Input 'SELECT'
parser: Reduce [ecmd ::= SEMI], go to state 0.
parser: Shift 'ecmd'
parser: Reduce [cmdlist ::= ecmd], go to state 0.
parser: Shift 'cmdlist', go to state 146
parser: Reduce [explain ::=], go to state 146.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[cmdlist explain with SELECT]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct sclp ID]
parser: Input 'FROM'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist FROM]
parser: Input 'ID'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'ID'
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'DOT'
parser: Reduce [nm ::= ID|INDEXED], go to state 165.
parser: Shift 'nm', go to state 287
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'ORDER'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Reduce [where_opt ::=], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Shift 'ORDER', go to state 411
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY'
parser: Shift 'BY', go to state 17
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI'
parser: Reduce [expr ::= ID|INDEXED], go to state 17.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 17.
parser: Shift 'sortlist', go to state 410
parser: Reduce [orderby_opt ::= ORDER BY sortlist], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 22.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 2.
parser: Shift 'select'
parser: Reduce [cmd ::= select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[cmdlist explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping cmdlist
parser: Popping $
SQL: [;
SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;]
VDBE Trace:
   0 Init             0   12    0               00 Start at 12
  12 Transaction      0    0    3 1             01 usesStmtJournal=0
  13 TableLock        0    1    0 sqlite_master 00 iDb=0 root=1 write=0
  14 Goto             0    1    0               00 
   1 Noop             1    5    0               00 
   2 OpenRead         0    1    0 5             00 root=1 iDb=0; sqlite_master
   3 Explain          0    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   10    0               00 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s2[t1](8)
   6 Column           0    3    2               00 r[2]=sqlite_master.rootpage
REG[2] =  i:2
   7 Column           0    4    3               00 r[3]=sqlite_master.sql
REG[3] =   s41[CREATE TABLE t1](8)
   8 ResultRow        1    3    0               00 output=r[1..3]
REG[1] =   s2[t1](8)
REG[2] =  i:2
REG[3] =   s41[CREATE TABLE t1](8)
   9 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s7[numbers](8)
   6 Column           0    3    2               00 r[2]=sqlite_master.rootpage
REG[2] =  i:3
   7 Column           0    4    3               00 r[3]=sqlite_master.sql
REG[3] =   s34[CREATE TABLE nu](8)
   8 ResultRow        1    3    0               00 output=r[1..3]
REG[1] =   s7[numbers](8)
REG[2] =  i:3
REG[3] =   s34[CREATE TABLE nu](8)
   9 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s2[t2](8)
   6 Column           0    3    2               00 r[2]=sqlite_master.rootpage
REG[2] =  i:4
   7 Column           0    4    3               00 r[3]=sqlite_master.sql
REG[3] =   s24[CREATE INDEX t2](8)
   8 ResultRow        1    3    0               00 output=r[1..3]
REG[1] =   s2[t2](8)
REG[2] =  i:4
REG[3] =   s24[CREATE INDEX t2](8)
   9 Next             0    5    0               01 
  10 Close            0    0    0               00 
  11 Halt             0    0    0               00 
parser: Initialize. Empty stack. State 0
parser: Input 'SELECT'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[explain with SELECT]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'PLUS'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Shift 'PLUS', go to state 88
parser: Return. Stack=[explain with SELECT distinct sclp expr PLUS]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp expr PLUS ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 88.
parser: Shift 'expr', go to state 105
parser: Reduce [expr ::= expr PLUS|MINUS expr], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'MINUS'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Shift 'MINUS', go to state 88
parser: Return. Stack=[explain with SELECT distinct sclp expr MINUS]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp expr MINUS ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 88.
parser: Shift 'expr', go to state 105
parser: Reduce [expr ::= expr PLUS|MINUS expr], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'LP'
parser: Shift 'LP', go to state 216
parser: Return. Stack=[explain with SELECT distinct sclp ID LP]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 216.
parser: Shift 'distinct', go to state 6
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID LP distinct ID]
parser: Input 'RP'
parser: Reduce [expr ::= ID|INDEXED], go to state 6.
parser: Shift 'expr', go to state 48
parser: Reduce [nexprlist ::= expr], go to state 6.
parser: Shift 'nexprlist', go to state 412
parser: Reduce [exprlist ::= nexprlist], go to state 6.
parser: Shift 'exprlist', go to state 394
parser: Shift 'RP'
parser: Return. Stack=[explain with SELECT distinct sclp ID LP distinct exprlist RP]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED LP distinct exprlist RP], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'LP'
parser: Shift 'LP', go to state 216
parser: Return. Stack=[explain with SELECT distinct sclp ID LP]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 216.
parser: Shift 'distinct', go to state 6
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID LP distinct ID]
parser: Input 'RP'
parser: Reduce [expr ::= ID|INDEXED], go to state 6.
parser: Shift 'expr', go to state 48
parser: Reduce [nexprlist ::= expr], go to state 6.
parser: Shift 'nexprlist', go to state 412
parser: Reduce [exprlist ::= nexprlist], go to state 6.
parser: Shift 'exprlist', go to state 394
parser: Shift 'RP'
parser: Return. Stack=[explain with SELECT distinct sclp ID LP distinct exprlist RP]
parser: Input 'FROM'
parser: Reduce [expr ::= ID|INDEXED LP distinct exprlist RP], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[explain with SELECT distinct selcollist FROM]
parser: Input 'ID'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'ID'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'UNION'
parser: Reduce [nm ::= ID|INDEXED], go to state 165.
parser: Shift 'nm', go to state 287
parser: Reduce [dbnm ::=], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Reduce [where_opt ::=], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Reduce [orderby_opt ::=], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 22.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Shift 'UNION', go to state 396
parser: Return. Stack=[explain with selectnowith UNION]
parser: Input 'ALL'
parser: Shift 'ALL'
parser: Return. Stack=[explain with selectnowith UNION ALL]
parser: Input 'SELECT'
parser: Reduce [multiselect_op ::= UNION ALL], go to state 215.
parser: Shift 'multiselect_op', go to state 150
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[explain with selectnowith multiselect_op SELECT]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with selectnowith multiselect_op SELECT distinct sclp ID]
parser: Input 'PLUS'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Shift 'PLUS', go to state 88
parser: Return. Stack=[explain with selectnowith multiselect_op SELECT distinct sclp expr PLUS]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with selectnowith multiselect_op SELECT distinct sclp expr PLUS ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 88.
parser: Shift 'expr', go to state 105
parser: Reduce [expr ::= expr PLUS|MINUS expr], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with selectnowith multiselect_op SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with selectnowith multiselect_op SELECT distinct sclp ID]
parser: Input 'MINUS'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Shift 'MINUS', go to state 88
parser: Return. Stack=[explain with selectnowith multiselect_op SELECT distinct sclp expr MINUS]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with selectnowith multiselect_op SELECT distinct sclp expr MINUS ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 88.
parser: Shift 'expr', go to state 105
parser: Reduce [expr ::= expr PLUS|MINUS expr], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with selectnowith multiselect_op SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with selectnowith multiselect_op SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with selectnowith multiselect_op SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with selectnowith multiselect_op SELECT distinct sclp ID]
parser: Input 'FROM'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[explain with selectnowith multiselect_op SELECT distinct selcollist FROM]
parser: Input 'ID'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'ID'
parser: Return. Stack=[explain with selectnowith multiselect_op SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'SEMI'
parser: Reduce [nm ::= ID|INDEXED], go to state 165.
parser: Shift 'nm', go to state 287
parser: Reduce [dbnm ::=], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Reduce [where_opt ::=], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Reduce [orderby_opt ::=], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 150.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= selectnowith multiselect_op oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 2.
parser: Shift 'select'
parser: Reduce [cmd ::= select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
SQL: [SELECT a+b, a-b, abs(a), abs(b) FROM t1
    UNION ALL
    SELECT a+b, a-b, a, b FROM t1
  ;]
VDBE Trace:
   0 Init             0   28    0               00 Start at 28
  28 Transaction      0    0    3 1             01 usesStmtJournal=0
  29 TableLock        0    2    0 t1            00 iDb=0 root=2 write=0
  30 Goto             0    1    0               00 
   1 OpenRead         1    2    0 2             00 root=2 iDb=0; t1
   2 Explain          1    0    0 SCAN TABLE t1 00 
   3 Rewind           1   14    0               00 
  14 Close            1    0    0               00 
  15 OpenRead         0    2    0 2             00 root=2 iDb=0; t1
  16 Explain          2    0    0 SCAN TABLE t1 00 
  17 Rewind           0   26    0               00 
  26 Close            0    0    0               00 
  27 Halt             0    0    0               00 
parser: Initialize. Empty stack. State 0
parser: Input 'INSERT'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'INSERT', go to state 253
parser: Return. Stack=[explain with INSERT]
parser: Input 'INTO'
parser: Reduce [orconf ::=], go to state 253.
parser: Shift 'orconf'
parser: Reduce [insert_cmd ::= INSERT orconf], go to state 22.
parser: Shift 'insert_cmd', go to state 351
parser: Shift 'INTO', go to state 127
parser: Return. Stack=[explain with insert_cmd INTO]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with insert_cmd INTO ID]
parser: Input 'SELECT'
parser: Reduce [nm ::= ID|INDEXED], go to state 127.
parser: Shift 'nm', go to state 259
parser: Reduce [dbnm ::=], go to state 259.
parser: Shift 'dbnm'
parser: Reduce [fullname ::= nm dbnm], go to state 127.
parser: Shift 'fullname', go to state 241
parser: Reduce [idlist_opt ::=], go to state 241.
parser: Shift 'idlist_opt', go to state 147
parser: Reduce [with ::=], go to state 147.
parser: Shift 'with', go to state 113
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with SELECT]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with SELECT distinct sclp ID]
parser: Input 'FROM'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with SELECT distinct selcollist FROM]
parser: Input 'ID'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'ID'
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'SEMI'
parser: Reduce [nm ::= ID|INDEXED], go to state 165.
parser: Shift 'nm', go to state 287
parser: Reduce [dbnm ::=], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Reduce [where_opt ::=], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Reduce [orderby_opt ::=], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 113.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 113.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 147.
parser: Shift 'select'
parser: Reduce [cmd ::= with insert_cmd INTO fullname idlist_opt select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
SQL: [INSERT INTO t1 SELECT a, a FROM t1;]
VDBE Trace:
   0 Init             0   40    0               00 Start at 40
  40 Transaction      0    1    3 1             01 usesStmtJournal=1
  41 TableLock        0    2    1 t1            00 iDb=0 root=2 write=1
  42 Goto             0    1    0               00 
   1 InitCoroutine    4   11    2               00 
  11 OpenEphemeral    1    2    0               00 nColumn=2
  12 Yield            4   17    0               00 
REG[4] =  i:1
REG[4] =  i:12
   2 OpenRead         0    2    0 0             00 root=2 iDb=0; t1
   3 Explain          0    0    0 SCAN TABLE t1 00 
   4 Rewind           0    9    0               00 
   9 Close            0    0    0               00 
  10 EndCoroutine     4    0    0               00 
REG[4] =  i:12
  17 OpenWrite        2    2    0 2             00 root=2 iDb=0; t1
  18 OpenWrite        3    4    0 k(2,,)        00 root=4 iDb=0; t2
  19 Rewind           1   36    0               00 
  36 Close            1    0    0               00 
  37 Close            2    0    0               00 
  38 Noop             3    0    0               00 
  39 Halt             0    0    0               00 
parser: Initialize. Empty stack. State 0
parser: Input 'SELECT'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[explain with SELECT]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'FROM'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[explain with SELECT distinct selcollist FROM]
parser: Input 'ID'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'ID'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'EXCEPT'
parser: Reduce [nm ::= ID|INDEXED], go to state 165.
parser: Shift 'nm', go to state 287
parser: Reduce [dbnm ::=], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Reduce [where_opt ::=], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Reduce [orderby_opt ::=], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 22.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Shift 'EXCEPT'
parser: Return. Stack=[explain with selectnowith EXCEPT]
parser: Input 'SELECT'
parser: Reduce [multiselect_op ::= EXCEPT|INTERSECT], go to state 215.
parser: Shift 'multiselect_op', go to state 150
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[explain with selectnowith multiselect_op SELECT]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with selectnowith multiselect_op SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with selectnowith multiselect_op SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with selectnowith multiselect_op SELECT distinct sclp ID]
parser: Input 'LP'
parser: Shift 'LP', go to state 216
parser: Return. Stack=[explain with selectnowith multiselect_op SELECT distinct sclp ID LP]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 216.
parser: Shift 'distinct', go to state 6
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with selectnowith multiselect_op SELECT distinct sclp ID LP distinct ID]
parser: Input 'RP'
parser: Reduce [expr ::= ID|INDEXED], go to state 6.
parser: Shift 'expr', go to state 48
parser: Reduce [nexprlist ::= expr], go to state 6.
parser: Shift 'nexprlist', go to state 412
parser: Reduce [exprlist ::= nexprlist], go to state 6.
parser: Shift 'exprlist', go to state 394
parser: Shift 'RP'
parser: Return. Stack=[explain with selectnowith multiselect_op SELECT distinct sclp ID LP distinct exprlist RP]
parser: Input 'FROM'
parser: Reduce [expr ::= ID|INDEXED LP distinct exprlist RP], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[explain with selectnowith multiselect_op SELECT distinct selcollist FROM]
parser: Input 'ID'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'ID'
parser: Return. Stack=[explain with selectnowith multiselect_op SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'SEMI'
parser: Reduce [nm ::= ID|INDEXED], go to state 165.
parser: Shift 'nm', go to state 287
parser: Reduce [dbnm ::=], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Reduce [where_opt ::=], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Reduce [orderby_opt ::=], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 150.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= selectnowith multiselect_op oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 2.
parser: Shift 'select'
parser: Reduce [cmd ::= select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
SQL: [SELECT a, a FROM t1
    EXCEPT
    SELECT a, abs(a) FROM t1
  ;]
VDBE Trace:
   0 Init             0   27    0               00 Start at 27
  27 Transaction      0    0    3 1             01 usesStmtJournal=0
  28 TableLock        0    2    0 t1            00 iDb=0 root=2 write=0
  29 Goto             0    1    0               00 
   1 OpenEphemeral    2    2    0 k(2,B,B)      00 nColumn=2
   2 OpenRead         1    2    0 0             00 root=2 iDb=0; t1
   3 Explain          1    0    0 SCAN TABLE t1 00 
   4 Rewind           1   10    0               00 
  10 Close            1    0    0               00 
  11 OpenRead         0    2    0 0             00 root=2 iDb=0; t1
  12 Explain          2    0    0 SCAN TABLE t1 00 
  13 Rewind           0   19    0               00 
  19 Close            0    0    0               00 
  20 Rewind           2   25    0               00 
  25 Noop             2    0    0               00 
  26 Halt             0    0    0               00 
parser: Initialize. Empty stack. State 0
parser: Input 'SEMI'
parser: Shift 'SEMI'
parser: Return. Stack=[SEMI]
parser: Input 'PRAGMA'
parser: Reduce [ecmd ::= SEMI], go to state 0.
parser: Shift 'ecmd'
parser: Reduce [cmdlist ::= ecmd], go to state 0.
parser: Shift 'cmdlist', go to state 146
parser: FALLBACK PRAGMA => ID
parser: Reduce [explain ::=], go to state 146.
parser: Shift 'explain', go to state 2
parser: Shift 'PRAGMA', go to state 172
parser: Return. Stack=[cmdlist explain PRAGMA]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[cmdlist explain PRAGMA ID]
parser: Input 'EQ'
parser: Reduce [nm ::= ID|INDEXED], go to state 172.
parser: Shift 'nm', go to state 240
parser: Reduce [dbnm ::=], go to state 240.
parser: Shift 'dbnm', go to state 323
parser: Shift 'EQ', go to state 20
parser: Return. Stack=[cmdlist explain PRAGMA nm dbnm EQ]
parser: Input 'INTEGER'
parser: Shift 'INTEGER'
parser: Return. Stack=[cmdlist explain PRAGMA nm dbnm EQ INTEGER]
parser: Input 'SEMI'
parser: Reduce [plus_num ::= INTEGER|FLOAT], go to state 20.
parser: Shift 'plus_num'
parser: Reduce [nmnum ::= plus_num], go to state 20.
parser: Shift 'nmnum'
parser: Reduce [cmd ::= PRAGMA nm dbnm EQ nmnum], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[cmdlist explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping cmdlist
parser: Popping $
SQL: [; pragma incremental_vacuum = 1 ;]
VDBE Trace:
   0 Init             0    7    0               00 Start at 7
   7 Transaction      0    1    3 1             01 usesStmtJournal=0
   8 Goto             0    1    0               00 
   1 Integer          1    1    0               00 r[1]=1
REG[1] =  i:1
   2 IncrVacuum       0    6    0               00 
   6 Halt             0    0    0               00 
parser: Initialize. Empty stack. State 0
parser: Input 'SELECT'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[explain with SELECT]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'LP'
parser: Shift 'LP', go to state 216
parser: Return. Stack=[explain with SELECT distinct sclp ID LP]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 216.
parser: Shift 'distinct', go to state 6
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID LP distinct ID]
parser: Input 'RP'
parser: Reduce [expr ::= ID|INDEXED], go to state 6.
parser: Shift 'expr', go to state 48
parser: Reduce [nexprlist ::= expr], go to state 6.
parser: Shift 'nexprlist', go to state 412
parser: Reduce [exprlist ::= nexprlist], go to state 6.
parser: Shift 'exprlist', go to state 394
parser: Shift 'RP'
parser: Return. Stack=[explain with SELECT distinct sclp ID LP distinct exprlist RP]
parser: Input 'FROM'
parser: Reduce [expr ::= ID|INDEXED LP distinct exprlist RP], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[explain with SELECT distinct selcollist FROM]
parser: Input 'ID'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'ID'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'EXCEPT'
parser: Reduce [nm ::= ID|INDEXED], go to state 165.
parser: Shift 'nm', go to state 287
parser: Reduce [dbnm ::=], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Reduce [where_opt ::=], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Reduce [orderby_opt ::=], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 22.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Shift 'EXCEPT'
parser: Return. Stack=[explain with selectnowith EXCEPT]
parser: Input 'SELECT'
parser: Reduce [multiselect_op ::= EXCEPT|INTERSECT], go to state 215.
parser: Shift 'multiselect_op', go to state 150
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[explain with selectnowith multiselect_op SELECT]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with selectnowith multiselect_op SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with selectnowith multiselect_op SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with selectnowith multiselect_op SELECT distinct sclp ID]
parser: Input 'FROM'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[explain with selectnowith multiselect_op SELECT distinct selcollist FROM]
parser: Input 'ID'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'ID'
parser: Return. Stack=[explain with selectnowith multiselect_op SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'SEMI'
parser: Reduce [nm ::= ID|INDEXED], go to state 165.
parser: Shift 'nm', go to state 287
parser: Reduce [dbnm ::=], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Reduce [where_opt ::=], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Reduce [orderby_opt ::=], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 150.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= selectnowith multiselect_op oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 2.
parser: Shift 'select'
parser: Reduce [cmd ::= select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
SQL: [SELECT a, abs(a) FROM t1
    EXCEPT
    SELECT a, a FROM t1
  ;]
VDBE Trace:
   0 Init             0   27    0               00 Start at 27
  27 Transaction      0    0    3 1             01 usesStmtJournal=0
  28 TableLock        0    2    0 t1            00 iDb=0 root=2 write=0
  29 Goto             0    1    0               00 
   1 OpenEphemeral    2    2    0 k(2,B,B)      00 nColumn=2
   2 OpenRead         1    2    0 0             00 root=2 iDb=0; t1
   3 Explain          1    0    0 SCAN TABLE t1 00 
   4 Rewind           1   11    0               00 
  11 Close            1    0    0               00 
  12 OpenRead         0    2    0 0             00 root=2 iDb=0; t1
  13 Explain          2    0    0 SCAN TABLE t1 00 
  14 Rewind           0   19    0               00 
  19 Close            0    0    0               00 
  20 Rewind           2   25    0               00 
  25 Noop             2    0    0               00 
  26 Halt             0    0    0               00 
parser: Initialize. Empty stack. State 0
parser: Input 'SEMI'
parser: Shift 'SEMI'
parser: Return. Stack=[SEMI]
parser: Input 'SELECT'
parser: Reduce [ecmd ::= SEMI], go to state 0.
parser: Shift 'ecmd'
parser: Reduce [cmdlist ::= ecmd], go to state 0.
parser: Shift 'cmdlist', go to state 146
parser: Reduce [explain ::=], go to state 146.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[cmdlist explain with SELECT]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct sclp ID]
parser: Input 'FROM'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist FROM]
parser: Input 'STRING'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'STRING'
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist FROM stl_prefix STRING]
parser: Input 'DOT'
parser: Reduce [nm ::= STRING], go to state 165.
parser: Shift 'nm', go to state 287
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Shift 'WHERE', go to state 65
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'AND', go to state 93
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'NE'
parser: Reduce [expr ::= ID|INDEXED], go to state 93.
parser: Shift 'expr', go to state 53
parser: Shift 'NE', go to state 90
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE expr AND expr NE]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE expr AND expr NE STRING]
parser: Input 'ORDER'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 93.
parser: Shift 'expr', go to state 53
parser: Reduce [expr ::= expr AND expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Reduce [where_opt ::= WHERE expr], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Shift 'ORDER', go to state 411
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY'
parser: Shift 'BY', go to state 17
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI'
parser: Reduce [expr ::= ID|INDEXED], go to state 17.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 17.
parser: Shift 'sortlist', go to state 410
parser: Reduce [orderby_opt ::= ORDER BY sortlist], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 22.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 2.
parser: Shift 'select'
parser: Reduce [cmd ::= select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[cmdlist explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping cmdlist
parser: Popping $
SQL: [;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;]
VDBE Trace:
   0 Init             0   16    0               00 Start at 16
  16 Transaction      0    0    3 1             01 usesStmtJournal=0
  17 TableLock        0    1    0 sqlite_master 00 iDb=0 root=1 write=0
  18 String8          0    2    0 t1            00 r[2]='t1'
REG[2] =   t2[t1](8)
  19 String8          0    4    0 trigger       00 r[4]='trigger'
REG[4] =   t7[trigger](8)
  20 Goto             0    1    0               00 
   1 Noop             1    5    0               00 
   2 OpenRead         0    1    0 5             00 root=1 iDb=0; sqlite_master
   3 Explain          0    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   14    0               00 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[t1](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t2[t1](8)
REG[1] =   s2[t1](8)
   7 Column           0    0    3               00 r[3]=sqlite_master.type
REG[3] =   s5[table](8)
   8 Eq               4   13    3 (BINARY)      52 if r[4]==r[3] goto 13
REG[4] =   t7[trigger](8)
REG[3] =   s5[table](8)
   9 Column           0    1    5               00 r[5]=sqlite_master.name
REG[5] =   s2[t1](8)
  10 Column           0    3    6               00 r[6]=sqlite_master.rootpage
REG[6] =  i:2
  11 Column           0    4    7               00 r[7]=sqlite_master.sql
REG[7] =   s41[CREATE TABLE t1](8)
  12 ResultRow        5    3    0               00 output=r[5..7]
REG[5] =   s2[t1](8)
REG[6] =  i:2
REG[7] =   s41[CREATE TABLE t1](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s7[numbers](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t2[t1](8)
REG[1] =   s7[numbers](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[t1](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t2[t1](8)
REG[1] =   s2[t1](8)
   7 Column           0    0    3               00 r[3]=sqlite_master.type
REG[3] =   s5[index](8)
   8 Eq               4   13    3 (BINARY)      52 if r[4]==r[3] goto 13
REG[4] =   t7[trigger](8)
REG[3] =   s5[index](8)
   9 Column           0    1    5               00 r[5]=sqlite_master.name
REG[5] =   s2[t2](8)
  10 Column           0    3    6               00 r[6]=sqlite_master.rootpage
REG[6] =  i:4
  11 Column           0    4    7               00 r[7]=sqlite_master.sql
REG[7] =   s24[CREATE INDEX t2](8)
  12 ResultRow        5    3    0               00 output=r[5..7]
REG[5] =   s2[t2](8)
REG[6] =  i:4
REG[7] =   s24[CREATE INDEX t2](8)
  13 Next             0    5    0               01 
  14 Close            0    0    0               00 
  15 Halt             0    0    0               00 
parser: Initialize. Empty stack. State 0
parser: Input 'DELETE'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'DELETE', go to state 353
parser: Return. Stack=[explain with DELETE]
parser: Input 'FROM'
parser: Shift 'FROM', go to state 130
parser: Return. Stack=[explain with DELETE FROM]
parser: Input 'STRING'
parser: Shift 'STRING'
parser: Return. Stack=[explain with DELETE FROM STRING]
parser: Input 'SEMI'
parser: Reduce [nm ::= STRING], go to state 130.
parser: Shift 'nm', go to state 259
parser: Reduce [dbnm ::=], go to state 259.
parser: Shift 'dbnm'
parser: Reduce [fullname ::= nm dbnm], go to state 130.
parser: Shift 'fullname', go to state 220
parser: Reduce [indexed_opt ::=], go to state 220.
parser: Shift 'indexed_opt', go to state 243
parser: Reduce [where_opt ::=], go to state 243.
parser: Shift 'where_opt'
parser: Reduce [cmd ::= with DELETE FROM fullname indexed_opt where_opt], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
SQL: [DELETE FROM 'numbers';]
VDBE Trace:
   0 Init             0    3    0               00 Start at 3
   3 Transaction      0    1    3 1             01 usesStmtJournal=0
   4 TableLock        0    3    1 numbers       00 iDb=0 root=3 write=1
   5 Goto             0    1    0               00 
   1 Clear            3    0   -1 numbers       00 
   2 Halt             0    0    0               00 
parser: Initialize. Empty stack. State 0
parser: Input 'CREATE'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Shift 'CREATE'
parser: Return. Stack=[explain CREATE]
parser: Input 'VIEW'
parser: Reduce [createkw ::= CREATE], go to state 2.
parser: Shift 'createkw', go to state 107
parser: FALLBACK VIEW => ID
parser: Reduce [temp ::=], go to state 107.
parser: Shift 'temp', go to state 319
parser: Shift 'VIEW', go to state 264
parser: Return. Stack=[explain createkw temp VIEW]
parser: Input 'ID'
parser: Reduce [ifnotexists ::=], go to state 264.
parser: Shift 'ifnotexists', go to state 182
parser: Shift 'ID'
parser: Return. Stack=[explain createkw temp VIEW ifnotexists ID]
parser: Input 'AS'
parser: Reduce [nm ::= ID|INDEXED], go to state 182.
parser: Shift 'nm', go to state 263
parser: Reduce [dbnm ::=], go to state 263.
parser: Shift 'dbnm', go to state 262
parser: Reduce [eidlist_opt ::=], go to state 262.
parser: Shift 'eidlist_opt', go to state 377
parser: Shift 'AS', go to state 152
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS]
parser: Input 'SELECT'
parser: Reduce [with ::=], go to state 152.
parser: Shift 'with', go to state 113
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp ID]
parser: Input 'ID'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Shift 'ID'
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr ID]
parser: Input 'COMMA'
parser: Reduce [as ::= ID|STRING], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp ID]
parser: Input 'ID'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Shift 'ID'
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr ID]
parser: Input 'COMMA'
parser: Reduce [as ::= ID|STRING], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct selcollist COMMA]
parser: Input 'STRING'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp STRING]
parser: Input 'CONCAT'
parser: Reduce [term ::= STRING], go to state 54.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 54.
parser: Shift 'expr', go to state 8
parser: Shift 'CONCAT', go to state 86
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID]
parser: Input 'LP'
parser: Shift 'LP', go to state 216
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP]
parser: Input 'STRING'
parser: Reduce [distinct ::=], go to state 216.
parser: Shift 'distinct', go to state 6
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP distinct STRING]
parser: Input 'COMMA'
parser: Reduce [term ::= STRING], go to state 6.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 6.
parser: Shift 'expr', go to state 48
parser: Reduce [nexprlist ::= expr], go to state 6.
parser: Shift 'nexprlist', go to state 412
parser: Shift 'COMMA', go to state 70
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP distinct nexprlist COMMA]
parser: Input 'INTEGER'
parser: Shift 'INTEGER'
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP distinct nexprlist COMMA INTEGER]
parser: Input 'PLUS'
parser: Reduce [term ::= INTEGER|FLOAT|BLOB], go to state 70.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 70.
parser: Shift 'expr', go to state 43
parser: Shift 'PLUS', go to state 88
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP distinct nexprlist COMMA expr PLUS]
parser: Input 'LP'
parser: Shift 'LP', go to state 3
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP distinct nexprlist COMMA expr PLUS LP]
parser: Input 'LP'
parser: Shift 'LP', go to state 3
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP distinct nexprlist COMMA expr PLUS LP LP]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP distinct nexprlist COMMA expr PLUS LP LP ID]
parser: Input 'MINUS'
parser: Reduce [expr ::= ID|INDEXED], go to state 3.
parser: Shift 'expr', go to state 30
parser: Shift 'MINUS', go to state 88
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP distinct nexprlist COMMA expr PLUS LP LP expr MINUS]
parser: Input 'INTEGER'
parser: Shift 'INTEGER'
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP distinct nexprlist COMMA expr PLUS LP LP expr MINUS INTEGER]
parser: Input 'RP'
parser: Reduce [term ::= INTEGER|FLOAT|BLOB], go to state 88.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 88.
parser: Shift 'expr', go to state 105
parser: Reduce [expr ::= expr PLUS|MINUS expr], go to state 3.
parser: Shift 'expr', go to state 30
parser: Shift 'RP'
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP distinct nexprlist COMMA expr PLUS LP LP expr RP]
parser: Input 'SLASH'
parser: Reduce [expr ::= LP expr RP], go to state 3.
parser: Shift 'expr', go to state 30
parser: Shift 'SLASH', go to state 87
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP distinct nexprlist COMMA expr PLUS LP expr SLASH]
parser: Input 'INTEGER'
parser: Shift 'INTEGER'
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP distinct nexprlist COMMA expr PLUS LP expr SLASH INTEGER]
parser: Input 'RP'
parser: Reduce [term ::= INTEGER|FLOAT|BLOB], go to state 87.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 87.
parser: Shift 'expr', go to state 112
parser: Reduce [expr ::= expr STAR|SLASH|REM expr], go to state 3.
parser: Shift 'expr', go to state 30
parser: Shift 'RP'
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP distinct nexprlist COMMA expr PLUS LP expr RP]
parser: Input 'COMMA'
parser: Reduce [expr ::= LP expr RP], go to state 88.
parser: Shift 'expr', go to state 105
parser: Reduce [expr ::= expr PLUS|MINUS expr], go to state 70.
parser: Shift 'expr', go to state 43
parser: Reduce [nexprlist ::= nexprlist COMMA expr], go to state 6.
parser: Shift 'nexprlist', go to state 412
parser: Shift 'COMMA', go to state 70
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP distinct nexprlist COMMA]
parser: Input 'INTEGER'
parser: Shift 'INTEGER'
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP distinct nexprlist COMMA INTEGER]
parser: Input 'RP'
parser: Reduce [term ::= INTEGER|FLOAT|BLOB], go to state 70.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 70.
parser: Shift 'expr', go to state 43
parser: Reduce [nexprlist ::= nexprlist COMMA expr], go to state 6.
parser: Shift 'nexprlist', go to state 412
parser: Reduce [exprlist ::= nexprlist], go to state 6.
parser: Shift 'exprlist', go to state 394
parser: Shift 'RP'
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP distinct exprlist RP]
parser: Input 'CONCAT'
parser: Reduce [expr ::= ID|INDEXED LP distinct exprlist RP], go to state 86.
parser: Shift 'expr', go to state 114
parser: Reduce [expr ::= expr CONCAT expr], go to state 54.
parser: Shift 'expr', go to state 8
parser: Shift 'CONCAT', go to state 86
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID]
parser: Input 'LP'
parser: Shift 'LP', go to state 216
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP]
parser: Input 'STRING'
parser: Reduce [distinct ::=], go to state 216.
parser: Shift 'distinct', go to state 6
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP distinct STRING]
parser: Input 'COMMA'
parser: Reduce [term ::= STRING], go to state 6.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 6.
parser: Shift 'expr', go to state 48
parser: Reduce [nexprlist ::= expr], go to state 6.
parser: Shift 'nexprlist', go to state 412
parser: Shift 'COMMA', go to state 70
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP distinct nexprlist COMMA]
parser: Input 'INTEGER'
parser: Shift 'INTEGER'
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP distinct nexprlist COMMA INTEGER]
parser: Input 'PLUS'
parser: Reduce [term ::= INTEGER|FLOAT|BLOB], go to state 70.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 70.
parser: Shift 'expr', go to state 43
parser: Shift 'PLUS', go to state 88
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP distinct nexprlist COMMA expr PLUS]
parser: Input 'LP'
parser: Shift 'LP', go to state 3
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP distinct nexprlist COMMA expr PLUS LP]
parser: Input 'LP'
parser: Shift 'LP', go to state 3
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP distinct nexprlist COMMA expr PLUS LP LP]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP distinct nexprlist COMMA expr PLUS LP LP ID]
parser: Input 'MINUS'
parser: Reduce [expr ::= ID|INDEXED], go to state 3.
parser: Shift 'expr', go to state 30
parser: Shift 'MINUS', go to state 88
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP distinct nexprlist COMMA expr PLUS LP LP expr MINUS]
parser: Input 'INTEGER'
parser: Shift 'INTEGER'
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP distinct nexprlist COMMA expr PLUS LP LP expr MINUS INTEGER]
parser: Input 'RP'
parser: Reduce [term ::= INTEGER|FLOAT|BLOB], go to state 88.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 88.
parser: Shift 'expr', go to state 105
parser: Reduce [expr ::= expr PLUS|MINUS expr], go to state 3.
parser: Shift 'expr', go to state 30
parser: Shift 'RP'
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP distinct nexprlist COMMA expr PLUS LP LP expr RP]
parser: Input 'REM'
parser: Reduce [expr ::= LP expr RP], go to state 3.
parser: Shift 'expr', go to state 30
parser: Shift 'REM', go to state 87
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP distinct nexprlist COMMA expr PLUS LP expr REM]
parser: Input 'INTEGER'
parser: Shift 'INTEGER'
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP distinct nexprlist COMMA expr PLUS LP expr REM INTEGER]
parser: Input 'RP'
parser: Reduce [term ::= INTEGER|FLOAT|BLOB], go to state 87.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 87.
parser: Shift 'expr', go to state 112
parser: Reduce [expr ::= expr STAR|SLASH|REM expr], go to state 3.
parser: Shift 'expr', go to state 30
parser: Shift 'RP'
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP distinct nexprlist COMMA expr PLUS LP expr RP]
parser: Input 'COMMA'
parser: Reduce [expr ::= LP expr RP], go to state 88.
parser: Shift 'expr', go to state 105
parser: Reduce [expr ::= expr PLUS|MINUS expr], go to state 70.
parser: Shift 'expr', go to state 43
parser: Reduce [nexprlist ::= nexprlist COMMA expr], go to state 6.
parser: Shift 'nexprlist', go to state 412
parser: Shift 'COMMA', go to state 70
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP distinct nexprlist COMMA]
parser: Input 'INTEGER'
parser: Shift 'INTEGER'
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP distinct nexprlist COMMA INTEGER]
parser: Input 'RP'
parser: Reduce [term ::= INTEGER|FLOAT|BLOB], go to state 70.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 70.
parser: Shift 'expr', go to state 43
parser: Reduce [nexprlist ::= nexprlist COMMA expr], go to state 6.
parser: Shift 'nexprlist', go to state 412
parser: Reduce [exprlist ::= nexprlist], go to state 6.
parser: Shift 'exprlist', go to state 394
parser: Shift 'RP'
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP distinct exprlist RP]
parser: Input 'ID'
parser: Reduce [expr ::= ID|INDEXED LP distinct exprlist RP], go to state 86.
parser: Shift 'expr', go to state 114
parser: Reduce [expr ::= expr CONCAT expr], go to state 54.
parser: Shift 'expr', go to state 8
parser: Shift 'ID'
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr ID]
parser: Input 'FROM'
parser: Reduce [as ::= ID|STRING], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct selcollist FROM]
parser: Input 'ID'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'ID'
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'WHERE'
parser: Reduce [nm ::= ID|INDEXED], go to state 165.
parser: Shift 'nm', go to state 287
parser: Reduce [dbnm ::=], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Shift 'WHERE', go to state 65
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct selcollist from WHERE]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'SEMI'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Reduce [where_opt ::= WHERE expr], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Reduce [orderby_opt ::=], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 113.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 113.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 152.
parser: Shift 'select'
parser: Reduce [cmd ::= createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS select], go to state 2.
parser: Initialize. Empty stack. State 0
parser: Input 'UPDATE'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'UPDATE', go to state 242
parser: Return. Stack=[explain with UPDATE]
parser: Input 'STRING'
parser: Reduce [orconf ::=], go to state 242.
parser: Shift 'orconf', go to state 129
parser: Shift 'STRING'
parser: Return. Stack=[explain with UPDATE orconf STRING]
parser: Input 'DOT'
parser: Reduce [nm ::= STRING], go to state 129.
parser: Shift 'nm', go to state 259
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[explain with UPDATE orconf nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with UPDATE orconf nm DOT ID]
parser: Input 'SET'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 259.
parser: Shift 'dbnm'
parser: Reduce [fullname ::= nm dbnm], go to state 129.
parser: Shift 'fullname', go to state 219
parser: Reduce [indexed_opt ::=], go to state 219.
parser: Shift 'indexed_opt', go to state 352
parser: Shift 'SET', go to state 128
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET ID]
parser: Input 'EQ'
parser: Reduce [nm ::= ID|INDEXED], go to state 128.
parser: Shift 'nm', go to state 360
parser: Shift 'EQ', go to state 59
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET nm EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET nm EQ STRING]
parser: Input 'COMMA'
parser: Reduce [term ::= STRING], go to state 59.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 59.
parser: Shift 'expr', go to state 36
parser: Reduce [setlist ::= nm EQ expr], go to state 128.
parser: Shift 'setlist', go to state 218
parser: Shift 'COMMA', go to state 176
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist COMMA]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ'
parser: Reduce [nm ::= ID|INDEXED], go to state 176.
parser: Shift 'nm', go to state 361
parser: Shift 'EQ', go to state 60
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'COMMA'
parser: Reduce [term ::= STRING], go to state 60.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 60.
parser: Shift 'expr', go to state 37
parser: Reduce [setlist ::= setlist COMMA nm EQ expr], go to state 128.
parser: Shift 'setlist', go to state 218
parser: Shift 'COMMA', go to state 176
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist COMMA]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ'
parser: Reduce [nm ::= ID|INDEXED], go to state 176.
parser: Shift 'nm', go to state 361
parser: Shift 'EQ', go to state 60
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'COMMA'
parser: Reduce [term ::= STRING], go to state 60.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 60.
parser: Shift 'expr', go to state 37
parser: Reduce [setlist ::= setlist COMMA nm EQ expr], go to state 128.
parser: Shift 'setlist', go to state 218
parser: Shift 'COMMA', go to state 176
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist COMMA]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ'
parser: Reduce [nm ::= ID|INDEXED], go to state 176.
parser: Shift 'nm', go to state 361
parser: Shift 'EQ', go to state 60
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'VARIABLE'
parser: Shift 'VARIABLE'
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist COMMA nm EQ VARIABLE]
parser: Input 'COMMA'
parser: Reduce [expr ::= VARIABLE], go to state 60.
parser: Shift 'expr', go to state 37
parser: Reduce [setlist ::= setlist COMMA nm EQ expr], go to state 128.
parser: Shift 'setlist', go to state 218
parser: Shift 'COMMA', go to state 176
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist COMMA]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ'
parser: Reduce [nm ::= ID|INDEXED], go to state 176.
parser: Shift 'nm', go to state 361
parser: Shift 'EQ', go to state 60
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'WHERE'
parser: Reduce [term ::= STRING], go to state 60.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 60.
parser: Shift 'expr', go to state 37
parser: Reduce [setlist ::= setlist COMMA nm EQ expr], go to state 128.
parser: Shift 'setlist', go to state 218
parser: Shift 'WHERE', go to state 65
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist WHERE]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist WHERE ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist WHERE expr EQ]
parser: Input 'VARIABLE'
parser: Shift 'VARIABLE'
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist WHERE expr EQ VARIABLE]
parser: Input 'SEMI'
parser: Reduce [expr ::= VARIABLE], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Reduce [where_opt ::= WHERE expr], go to state 218.
parser: Shift 'where_opt'
parser: Reduce [cmd ::= with UPDATE orconf fullname indexed_opt SET setlist where_opt], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Input '$'
parser: Reduce [ecmd ::= explain cmdx SEMI], go to state 0.
parser: Shift 'ecmd'
parser: Reduce [cmdlist ::= ecmd], go to state 0.
parser: Shift 'cmdlist', go to state 146
parser: Reduce [input ::= cmdlist], go to state 0.
parser: Accept!
parser: Popping $
parser: Return. Stack=]
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
SQL: [CREATE VIEW t3 as
      select b b, b b, '/dev/cuaD' ||
             substr('01',1+((b-1)/16),1) ||
             substr('0123456789abcdef',1+((b-1)%16),1) b
        from t1 where b='aalp03';]
VDBE Trace:
   0 Init             0   30    0               00 Start at 30
  30 Transaction      0    1    3 1             01 usesStmtJournal=0
  31 TableLock        0    1    1 sqlite_master 00 iDb=0 root=1 write=1
  32 Goto             0    1    0               00 
   1 ReadCookie       0    3    2               00 
REG[3] =  i:4
   2 If               3    5    0               00 
REG[3] =  i:4
   5 Integer          0    2    0               00 r[2]=0
REG[2] =  i:0
   6 OpenWrite        0    1    0 5             00 root=1 iDb=0
   7 NewRowid         0    1    0               00 r[1]=rowid
REG[1] =  i:4
   8 Blob             6    3    0              00 r[3]= (len=6)
REG[3] =  t6[060000000000......](8)
   9 Insert           0    3    1               08 intkey=r[1] data=r[3]
REG[3] =  t6[060000000000......](8)
REG[1] =  i:4
  10 Close            0    0    0               00 
  11 Close            0    0    0               00 
  12 Null             0    4    5               00 r[4..5]=NULL
REG[4] =  NULL
  13 OpenWrite        1    1    0 5             00 root=1 iDb=0; sqlite_master
  14 Explain          0    0    0 SEARCH TABLE sqlite_master USING INTEGER PRIMARY KEY (rowid=?) 00 
  15 MustBeInt        1   18    0               00 
REG[1] =  i:4
  16 NotExists        1   18    1               00 intkey=r[1]; pk
REG[1] =  i:4
  17 Rowid            1    5    0               00 r[5]=rowid
REG[5] =  i:4
  18 IsNull           5   26    0               00 if r[5]==NULL goto 26
REG[5] =  i:4
  19 String8          0    6    0 view          00 r[6]='view'
REG[6] =   t4[view](8)
  20 String8          0    7    0 t3            00 r[7]='t3'
REG[7] =   t2[t3](8)
  21 String8          0    8    0 t3            00 r[8]='t3'
REG[8] =   t2[t3](8)
  22 Copy             2    9    0               00 r[9]=r[2]
REG[9] =  i:0
  23 String8          0   10    0 CREATE VIEW t3 as
      select b b, b b, '/dev/cuaD' ||
             substr('01',1+((b-1)/16),1) ||
             substr('0123456789abcdef',1+((b-1)%16),1) b
        from t1 where b='aalp03' 00 r[10]='CREATE VIEW t3 as
      select b b, b b, '/dev/cuaD' ||
             substr('01',1+((b-1)/16
REG[10] =   t189[CREATE VIEW t3 ](8)
  24 MakeRecord       6    5   11 BBBDB         00 r[11]=mkrec(r[6..10])
REG[11] =  s204[07151111088307766965777433743343.......viewt3t3C](8)
  25 Insert           1   11    5               00 intkey=r[5] data=r[11]
REG[11] =  s204[07151111088307766965777433743343.......viewt3t3C](8)
REG[5] =  i:4
  26 Close            1    0    0               00 
  27 SetCookie        0    1    4               00 
  28 ParseSchema      0    0    0 tbl_name='t3' AND type!='trigger' 00 
parser: Initialize. Empty stack. State 0
parser: Input 'SELECT'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[explain with SELECT]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'FROM'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[explain with SELECT distinct selcollist FROM]
parser: Input 'STRING'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'STRING'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix STRING]
parser: Input 'DOT'
parser: Reduce [nm ::= STRING], go to state 165.
parser: Shift 'nm', go to state 287
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Shift 'WHERE', go to state 65
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'AND', go to state 93
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'NE'
parser: Reduce [expr ::= ID|INDEXED], go to state 93.
parser: Shift 'expr', go to state 53
parser: Shift 'NE', go to state 90
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND expr NE]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND expr NE STRING]
parser: Input 'ORDER'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 93.
parser: Shift 'expr', go to state 53
parser: Reduce [expr ::= expr AND expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Reduce [where_opt ::= WHERE expr], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Shift 'ORDER', go to state 411
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY'
parser: Shift 'BY', go to state 17
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI'
parser: Reduce [expr ::= ID|INDEXED], go to state 17.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 17.
parser: Shift 'sortlist', go to state 410
parser: Reduce [orderby_opt ::= ORDER BY sortlist], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 22.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 2.
parser: Shift 'select'
parser: Reduce [cmd ::= select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
VDBE Trace:
   0 Init             0   16    0               00 Start at 16
  16 Transaction      0    0    4 1             00 usesStmtJournal=0
  17 TableLock        0    1    0 sqlite_master 00 iDb=0 root=1 write=0
  18 String8          0    2    0 t3            00 r[2]='t3'
REG[2] =   t2[t3](8)
  19 String8          0    4    0 trigger       00 r[4]='trigger'
REG[4] =   t7[trigger](8)
  20 Goto             0    1    0               00 
   1 Noop             1    5    0               00 
   2 OpenRead         0    1    0 5             00 root=1 iDb=0; sqlite_master
   3 Explain          0    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   14    0               00 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[t1](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t2[t3](8)
REG[1] =   s2[t1](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s7[numbers](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t2[t3](8)
REG[1] =   s7[numbers](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[t1](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t2[t3](8)
REG[1] =   s2[t1](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[t3](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t2[t3](8)
REG[1] =   s2[t3](8)
   7 Column           0    0    3               00 r[3]=sqlite_master.type
REG[3] =   s4[view](8)
   8 Eq               4   13    3 (BINARY)      52 if r[4]==r[3] goto 13
REG[4] =   t7[trigger](8)
REG[3] =   s4[view](8)
   9 Column           0    1    5               00 r[5]=sqlite_master.name
REG[5] =   s2[t3](8)
  10 Column           0    3    6               00 r[6]=sqlite_master.rootpage
REG[6] =  i:0
  11 Column           0    4    7               00 r[7]=sqlite_master.sql
REG[7] =   s189[CREATE VIEW t3 ](8)
  12 ResultRow        5    3    0               00 output=r[5..7]
REG[5] =   s2[t3](8)
REG[6] =  i:0
REG[7] =   s189[CREATE VIEW t3 ](8)
parser: Initialize. Empty stack. State 0
parser: Input 'CREATE'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Shift 'CREATE'
parser: Return. Stack=[explain CREATE]
parser: Input 'VIEW'
parser: Reduce [createkw ::= CREATE], go to state 2.
parser: Shift 'createkw', go to state 107
parser: FALLBACK VIEW => ID
parser: Reduce [temp ::=], go to state 107.
parser: Shift 'temp', go to state 319
parser: Shift 'VIEW', go to state 264
parser: Return. Stack=[explain createkw temp VIEW]
parser: Input 'ID'
parser: Reduce [ifnotexists ::=], go to state 264.
parser: Shift 'ifnotexists', go to state 182
parser: Shift 'ID'
parser: Return. Stack=[explain createkw temp VIEW ifnotexists ID]
parser: Input 'AS'
parser: Reduce [nm ::= ID|INDEXED], go to state 182.
parser: Shift 'nm', go to state 263
parser: Reduce [dbnm ::=], go to state 263.
parser: Shift 'dbnm', go to state 262
parser: Reduce [eidlist_opt ::=], go to state 262.
parser: Shift 'eidlist_opt', go to state 377
parser: Shift 'AS', go to state 152
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS]
parser: Input 'SELECT'
parser: Reduce [with ::=], go to state 152.
parser: Shift 'with', go to state 113
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp ID]
parser: Input 'ID'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Shift 'ID'
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr ID]
parser: Input 'COMMA'
parser: Reduce [as ::= ID|STRING], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp ID]
parser: Input 'ID'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Shift 'ID'
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr ID]
parser: Input 'COMMA'
parser: Reduce [as ::= ID|STRING], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct selcollist COMMA]
parser: Input 'STRING'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp STRING]
parser: Input 'CONCAT'
parser: Reduce [term ::= STRING], go to state 54.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 54.
parser: Shift 'expr', go to state 8
parser: Shift 'CONCAT', go to state 86
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID]
parser: Input 'LP'
parser: Shift 'LP', go to state 216
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP]
parser: Input 'STRING'
parser: Reduce [distinct ::=], go to state 216.
parser: Shift 'distinct', go to state 6
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP distinct STRING]
parser: Input 'COMMA'
parser: Reduce [term ::= STRING], go to state 6.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 6.
parser: Shift 'expr', go to state 48
parser: Reduce [nexprlist ::= expr], go to state 6.
parser: Shift 'nexprlist', go to state 412
parser: Shift 'COMMA', go to state 70
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP distinct nexprlist COMMA]
parser: Input 'INTEGER'
parser: Shift 'INTEGER'
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP distinct nexprlist COMMA INTEGER]
parser: Input 'PLUS'
parser: Reduce [term ::= INTEGER|FLOAT|BLOB], go to state 70.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 70.
parser: Shift 'expr', go to state 43
parser: Shift 'PLUS', go to state 88
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP distinct nexprlist COMMA expr PLUS]
parser: Input 'LP'
parser: Shift 'LP', go to state 3
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP distinct nexprlist COMMA expr PLUS LP]
parser: Input 'LP'
parser: Shift 'LP', go to state 3
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP distinct nexprlist COMMA expr PLUS LP LP]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP distinct nexprlist COMMA expr PLUS LP LP ID]
parser: Input 'MINUS'
parser: Reduce [expr ::= ID|INDEXED], go to state 3.
parser: Shift 'expr', go to state 30
parser: Shift 'MINUS', go to state 88
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP distinct nexprlist COMMA expr PLUS LP LP expr MINUS]
parser: Input 'INTEGER'
parser: Shift 'INTEGER'
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP distinct nexprlist COMMA expr PLUS LP LP expr MINUS INTEGER]
parser: Input 'RP'
parser: Reduce [term ::= INTEGER|FLOAT|BLOB], go to state 88.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 88.
parser: Shift 'expr', go to state 105
parser: Reduce [expr ::= expr PLUS|MINUS expr], go to state 3.
parser: Shift 'expr', go to state 30
parser: Shift 'RP'
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP distinct nexprlist COMMA expr PLUS LP LP expr RP]
parser: Input 'SLASH'
parser: Reduce [expr ::= LP expr RP], go to state 3.
parser: Shift 'expr', go to state 30
parser: Shift 'SLASH', go to state 87
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP distinct nexprlist COMMA expr PLUS LP expr SLASH]
parser: Input 'INTEGER'
parser: Shift 'INTEGER'
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP distinct nexprlist COMMA expr PLUS LP expr SLASH INTEGER]
parser: Input 'RP'
parser: Reduce [term ::= INTEGER|FLOAT|BLOB], go to state 87.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 87.
parser: Shift 'expr', go to state 112
parser: Reduce [expr ::= expr STAR|SLASH|REM expr], go to state 3.
parser: Shift 'expr', go to state 30
parser: Shift 'RP'
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP distinct nexprlist COMMA expr PLUS LP expr RP]
parser: Input 'COMMA'
parser: Reduce [expr ::= LP expr RP], go to state 88.
parser: Shift 'expr', go to state 105
parser: Reduce [expr ::= expr PLUS|MINUS expr], go to state 70.
parser: Shift 'expr', go to state 43
parser: Reduce [nexprlist ::= nexprlist COMMA expr], go to state 6.
parser: Shift 'nexprlist', go to state 412
parser: Shift 'COMMA', go to state 70
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP distinct nexprlist COMMA]
parser: Input 'INTEGER'
parser: Shift 'INTEGER'
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP distinct nexprlist COMMA INTEGER]
parser: Input 'RP'
parser: Reduce [term ::= INTEGER|FLOAT|BLOB], go to state 70.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 70.
parser: Shift 'expr', go to state 43
parser: Reduce [nexprlist ::= nexprlist COMMA expr], go to state 6.
parser: Shift 'nexprlist', go to state 412
parser: Reduce [exprlist ::= nexprlist], go to state 6.
parser: Shift 'exprlist', go to state 394
parser: Shift 'RP'
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP distinct exprlist RP]
parser: Input 'CONCAT'
parser: Reduce [expr ::= ID|INDEXED LP distinct exprlist RP], go to state 86.
parser: Shift 'expr', go to state 114
parser: Reduce [expr ::= expr CONCAT expr], go to state 54.
parser: Shift 'expr', go to state 8
parser: Shift 'CONCAT', go to state 86
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID]
parser: Input 'LP'
parser: Shift 'LP', go to state 216
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP]
parser: Input 'STRING'
parser: Reduce [distinct ::=], go to state 216.
parser: Shift 'distinct', go to state 6
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP distinct STRING]
parser: Input 'COMMA'
parser: Reduce [term ::= STRING], go to state 6.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 6.
parser: Shift 'expr', go to state 48
parser: Reduce [nexprlist ::= expr], go to state 6.
parser: Shift 'nexprlist', go to state 412
parser: Shift 'COMMA', go to state 70
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP distinct nexprlist COMMA]
parser: Input 'INTEGER'
parser: Shift 'INTEGER'
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP distinct nexprlist COMMA INTEGER]
parser: Input 'PLUS'
parser: Reduce [term ::= INTEGER|FLOAT|BLOB], go to state 70.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 70.
parser: Shift 'expr', go to state 43
parser: Shift 'PLUS', go to state 88
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP distinct nexprlist COMMA expr PLUS]
parser: Input 'LP'
parser: Shift 'LP', go to state 3
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP distinct nexprlist COMMA expr PLUS LP]
parser: Input 'LP'
parser: Shift 'LP', go to state 3
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP distinct nexprlist COMMA expr PLUS LP LP]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP distinct nexprlist COMMA expr PLUS LP LP ID]
parser: Input 'MINUS'
parser: Reduce [expr ::= ID|INDEXED], go to state 3.
parser: Shift 'expr', go to state 30
parser: Shift 'MINUS', go to state 88
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP distinct nexprlist COMMA expr PLUS LP LP expr MINUS]
parser: Input 'INTEGER'
parser: Shift 'INTEGER'
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP distinct nexprlist COMMA expr PLUS LP LP expr MINUS INTEGER]
parser: Input 'RP'
parser: Reduce [term ::= INTEGER|FLOAT|BLOB], go to state 88.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 88.
parser: Shift 'expr', go to state 105
parser: Reduce [expr ::= expr PLUS|MINUS expr], go to state 3.
parser: Shift 'expr', go to state 30
parser: Shift 'RP'
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP distinct nexprlist COMMA expr PLUS LP LP expr RP]
parser: Input 'REM'
parser: Reduce [expr ::= LP expr RP], go to state 3.
parser: Shift 'expr', go to state 30
parser: Shift 'REM', go to state 87
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP distinct nexprlist COMMA expr PLUS LP expr REM]
parser: Input 'INTEGER'
parser: Shift 'INTEGER'
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP distinct nexprlist COMMA expr PLUS LP expr REM INTEGER]
parser: Input 'RP'
parser: Reduce [term ::= INTEGER|FLOAT|BLOB], go to state 87.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 87.
parser: Shift 'expr', go to state 112
parser: Reduce [expr ::= expr STAR|SLASH|REM expr], go to state 3.
parser: Shift 'expr', go to state 30
parser: Shift 'RP'
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP distinct nexprlist COMMA expr PLUS LP expr RP]
parser: Input 'COMMA'
parser: Reduce [expr ::= LP expr RP], go to state 88.
parser: Shift 'expr', go to state 105
parser: Reduce [expr ::= expr PLUS|MINUS expr], go to state 70.
parser: Shift 'expr', go to state 43
parser: Reduce [nexprlist ::= nexprlist COMMA expr], go to state 6.
parser: Shift 'nexprlist', go to state 412
parser: Shift 'COMMA', go to state 70
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP distinct nexprlist COMMA]
parser: Input 'INTEGER'
parser: Shift 'INTEGER'
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP distinct nexprlist COMMA INTEGER]
parser: Input 'RP'
parser: Reduce [term ::= INTEGER|FLOAT|BLOB], go to state 70.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 70.
parser: Shift 'expr', go to state 43
parser: Reduce [nexprlist ::= nexprlist COMMA expr], go to state 6.
parser: Shift 'nexprlist', go to state 412
parser: Reduce [exprlist ::= nexprlist], go to state 6.
parser: Shift 'exprlist', go to state 394
parser: Shift 'RP'
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP distinct exprlist RP]
parser: Input 'ID'
parser: Reduce [expr ::= ID|INDEXED LP distinct exprlist RP], go to state 86.
parser: Shift 'expr', go to state 114
parser: Reduce [expr ::= expr CONCAT expr], go to state 54.
parser: Shift 'expr', go to state 8
parser: Shift 'ID'
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr ID]
parser: Input 'FROM'
parser: Reduce [as ::= ID|STRING], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct selcollist FROM]
parser: Input 'ID'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'ID'
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'WHERE'
parser: Reduce [nm ::= ID|INDEXED], go to state 165.
parser: Shift 'nm', go to state 287
parser: Reduce [dbnm ::=], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Shift 'WHERE', go to state 65
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct selcollist from WHERE]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'SEMI'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Reduce [where_opt ::= WHERE expr], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Reduce [orderby_opt ::=], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 113.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 113.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 152.
parser: Shift 'select'
parser: Reduce [cmd ::= createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
  13 Next             0    5    0               01 
  14 Close            0    0    0               00 
  15 Halt             0    0    0               00 
  29 Halt             0    0    0               00 
parser: Initialize. Empty stack. State 0
parser: Input 'SEMI'
parser: Shift 'SEMI'
parser: Return. Stack=[SEMI]
parser: Input 'SELECT'
parser: Reduce [ecmd ::= SEMI], go to state 0.
parser: Shift 'ecmd'
parser: Reduce [cmdlist ::= ecmd], go to state 0.
parser: Shift 'cmdlist', go to state 146
parser: Reduce [explain ::=], go to state 146.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[cmdlist explain with SELECT]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct sclp ID]
parser: Input 'FROM'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist FROM]
parser: Input 'STRING'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'STRING'
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist FROM stl_prefix STRING]
parser: Input 'DOT'
parser: Reduce [nm ::= STRING], go to state 165.
parser: Shift 'nm', go to state 287
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Shift 'WHERE', go to state 65
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'AND', go to state 93
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'NE'
parser: Reduce [expr ::= ID|INDEXED], go to state 93.
parser: Shift 'expr', go to state 53
parser: Shift 'NE', go to state 90
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE expr AND expr NE]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE expr AND expr NE STRING]
parser: Input 'ORDER'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 93.
parser: Shift 'expr', go to state 53
parser: Reduce [expr ::= expr AND expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Reduce [where_opt ::= WHERE expr], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Shift 'ORDER', go to state 411
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY'
parser: Shift 'BY', go to state 17
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI'
parser: Reduce [expr ::= ID|INDEXED], go to state 17.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 17.
parser: Shift 'sortlist', go to state 410
parser: Reduce [orderby_opt ::= ORDER BY sortlist], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 22.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 2.
parser: Shift 'select'
parser: Reduce [cmd ::= select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[cmdlist explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping cmdlist
parser: Popping $
SQL: [;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t3' AND type!='trigger' ORDER BY rowid;]
VDBE Trace:
   0 Init             0   16    0               00 Start at 16
  16 Transaction      0    0    4 1             01 usesStmtJournal=0
  17 TableLock        0    1    0 sqlite_master 00 iDb=0 root=1 write=0
  18 String8          0    2    0 t3            00 r[2]='t3'
REG[2] =   t2[t3](8)
  19 String8          0    4    0 trigger       00 r[4]='trigger'
REG[4] =   t7[trigger](8)
  20 Goto             0    1    0               00 
   1 Noop             1    5    0               00 
   2 OpenRead         0    1    0 5             00 root=1 iDb=0; sqlite_master
   3 Explain          0    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   14    0               00 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[t1](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t2[t3](8)
REG[1] =   s2[t1](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s7[numbers](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t2[t3](8)
REG[1] =   s7[numbers](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[t1](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t2[t3](8)
REG[1] =   s2[t1](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[t3](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t2[t3](8)
REG[1] =   s2[t3](8)
   7 Column           0    0    3               00 r[3]=sqlite_master.type
REG[3] =   s4[view](8)
   8 Eq               4   13    3 (BINARY)      52 if r[4]==r[3] goto 13
REG[4] =   t7[trigger](8)
REG[3] =   s4[view](8)
   9 Column           0    1    5               00 r[5]=sqlite_master.name
REG[5] =   s2[t3](8)
  10 Column           0    3    6               00 r[6]=sqlite_master.rootpage
REG[6] =  i:0
  11 Column           0    4    7               00 r[7]=sqlite_master.sql
REG[7] =   s189[CREATE VIEW t3 ](8)
  12 ResultRow        5    3    0               00 output=r[5..7]
REG[5] =   s2[t3](8)
REG[6] =  i:0
REG[7] =   s189[CREATE VIEW t3 ](8)
  13 Next             0    5    0               01 
  14 Close            0    0    0               00 
  15 Halt             0    0    0               00 
parser: Initialize. Empty stack. State 0
parser: Input 'SELECT'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[explain with SELECT]
parser: Input 'STAR'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'STAR'
parser: Return. Stack=[explain with SELECT distinct sclp STAR]
parser: Input 'FROM'
parser: Reduce [selcollist ::= sclp STAR], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[explain with SELECT distinct selcollist FROM]
parser: Input 'ID'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'ID'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'SEMI'
parser: Reduce [nm ::= ID|INDEXED], go to state 165.
parser: Shift 'nm', go to state 287
parser: Reduce [dbnm ::=], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Reduce [where_opt ::=], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Reduce [orderby_opt ::=], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 22.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 2.
parser: Shift 'select'
parser: Reduce [cmd ::= select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
SQL: [SELECT * from t3;]
VDBE Trace:
   0 Init             0   22    0               00 Start at 22
  22 Transaction      0    0    4 1             01 usesStmtJournal=0
  23 TableLock        0    2    0 t1            00 iDb=0 root=2 write=0
  24 String8          0    2    0 aalp03        00 r[2]='aalp03'
REG[2] =   t6[aalp03](8)
  25 String8          0    7    0 /dev/cuaD     00 r[7]='/dev/cuaD'
REG[7] =   t9[/dev/cuaD](8)
  26 String8          0    9    0 01            00 r[9]='01'
REG[9] =   t2[01](8)
  27 Integer          1   12    0               00 r[12]=1
REG[12] =  i:1
  28 Integer         16   16    0               00 r[16]=16
REG[16] =  i:16
  29 Integer          1   11    0               00 r[11]=1
REG[11] =  i:1
  30 String8          0   17    0 0123456789abcdef 00 r[17]='0123456789abcdef'
REG[17] =   t16[0123456789abcde](8)
  31 Integer          1   19    0               00 r[19]=1
REG[19] =  i:1
  32 Goto             0    1    0               00 
   1 OpenRead         1    2    0 2             00 root=2 iDb=0; t1
   2 Explain          0    0    0 SCAN TABLE t1 00 
   3 Rewind           1   20    0               00 
  20 Close            1    0    0               00 
  21 Halt             0    0    0               00 
parser: Initialize. Empty stack. State 0
parser: Input 'INSERT'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'INSERT', go to state 253
parser: Return. Stack=[explain with INSERT]
parser: Input 'INTO'
parser: Reduce [orconf ::=], go to state 253.
parser: Shift 'orconf'
parser: Reduce [insert_cmd ::= INSERT orconf], go to state 22.
parser: Shift 'insert_cmd', go to state 351
parser: Shift 'INTO', go to state 127
parser: Return. Stack=[explain with insert_cmd INTO]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with insert_cmd INTO ID]
parser: Input 'VALUES'
parser: Reduce [nm ::= ID|INDEXED], go to state 127.
parser: Shift 'nm', go to state 259
parser: Reduce [dbnm ::=], go to state 259.
parser: Shift 'dbnm'
parser: Reduce [fullname ::= nm dbnm], go to state 127.
parser: Shift 'fullname', go to state 241
parser: Reduce [idlist_opt ::=], go to state 241.
parser: Shift 'idlist_opt', go to state 147
parser: Reduce [with ::=], go to state 147.
parser: Shift 'with', go to state 113
parser: Shift 'VALUES', go to state 397
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES]
parser: Input 'LP'
parser: Shift 'LP', go to state 15
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP]
parser: Input 'INTEGER'
parser: Shift 'INTEGER'
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP INTEGER]
parser: Input 'COMMA'
parser: Reduce [term ::= INTEGER|FLOAT|BLOB], go to state 15.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 15.
parser: Shift 'expr', go to state 48
parser: Reduce [nexprlist ::= expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'COMMA', go to state 70
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA ID]
parser: Input 'LP'
parser: Shift 'LP', go to state 216
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA ID LP]
parser: Input 'INTEGER'
parser: Reduce [distinct ::=], go to state 216.
parser: Shift 'distinct', go to state 6
parser: Shift 'INTEGER'
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA ID LP distinct INTEGER]
parser: Input 'RP'
parser: Reduce [term ::= INTEGER|FLOAT|BLOB], go to state 6.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 6.
parser: Shift 'expr', go to state 48
parser: Reduce [nexprlist ::= expr], go to state 6.
parser: Shift 'nexprlist', go to state 412
parser: Reduce [exprlist ::= nexprlist], go to state 6.
parser: Shift 'exprlist', go to state 394
parser: Shift 'RP'
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA ID LP distinct exprlist RP]
parser: Input 'RP'
parser: Reduce [expr ::= ID|INDEXED LP distinct exprlist RP], go to state 70.
parser: Shift 'expr', go to state 43
parser: Reduce [nexprlist ::= nexprlist COMMA expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'RP'
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist RP]
parser: Input 'SEMI'
parser: Reduce [values ::= VALUES LP nexprlist RP], go to state 113.
parser: Shift 'values', go to state 400
parser: Reduce [oneselect ::= values], go to state 113.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 113.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 147.
parser: Shift 'select'
parser: Reduce [cmd ::= with insert_cmd INTO fullname idlist_opt select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
SQL: [INSERT INTO t1 VALUES(1, randomblob(2500));]
VDBE Trace:
   0 Init             0   21    0               00 Start at 21
  21 Transaction      0    1    4 1             01 usesStmtJournal=0
  22 TableLock        0    2    1 t1            00 iDb=0 root=2 write=1
  23 Integer       2500    5    0               00 r[5]=2500
REG[5] =  i:2500
  24 Goto             0    1    0               00 
   1 OpenWrite        0    2    0 2             00 root=2 iDb=0; t1
   2 OpenWrite        1    4    0 k(2,,)        00 root=4 iDb=0; t2
   3 Integer          1    1    0               00 r[1]=1
REG[1] =  i:1
   4 NotNull          1    6    0               00 if r[1]!=NULL goto 6
REG[1] =  i:1
   6 MustBeInt        1    0    0               00 
REG[1] =  i:1
   7 SoftNull         2    0    0               00 r[2]=NULL
   8 Function0        1    5    3 randomblob(1) 01 r[3]=func(r[5])
REG[5] =  i:2500
REG[3] =  z2500[76B86CD24E6B7FF5C7DA4060EFC8FDA1v.l.Nk....@`....](8)
   9 NotExists        0   11    1               00 intkey=r[1]
REG[1] =  i:1
  11 Affinity         2    1    0 D             00 affinity(r[2])
  12 SCopy            1    6    0               00 r[6]=r[1]; a
REG[6] =  i:1
  13 IntCopy          1    7    0               00 r[7]=r[1]; rowid
REG[7] =  i:1
  14 MakeRecord       6    2    4               00 r[4]=mkrec(r[6..7]); for t2
REG[4] =  s3[030909...](8)
  15 IdxInsert        1    4    0               10 key=r[4]
REG[4] =  s3[030909...](8)
  16 MakeRecord       2    2    8               00 r[8]=mkrec(r[2..3])
REG[8] =  s2504[0400A71476B86CD24E6B7FF5C7DA4060....v.l.Nk....@`](8)
  17 Insert           0    8    1 t1            13 intkey=r[1] data=r[8]
REG[8] =  s2504[0400A71476B86CD24E6B7FF5C7DA4060....v.l.Nk....@`](8)
REG[1] =  i:1
  18 Close            0    0    0               00 
  19 Noop             1    0    0               00 
  20 Halt             0    0    0               00 
parser: Initialize. Empty stack. State 0
parser: Input 'SEMI'
parser: Shift 'SEMI'
parser: Return. Stack=[SEMI]
parser: Input 'SEMI'
parser: Reduce [ecmd ::= SEMI], go to state 0.
parser: Shift 'ecmd'
parser: Reduce [cmdlist ::= ecmd], go to state 0.
parser: Shift 'cmdlist', go to state 146
parser: Shift 'SEMI'
parser: Return. Stack=[cmdlist SEMI]
parser: Input 'SELECT'
parser: Reduce [ecmd ::= SEMI], go to state 146.
parser: Shift 'ecmd'
parser: Reduce [cmdlist ::= cmdlist ecmd], go to state 0.
parser: Shift 'cmdlist', go to state 146
parser: Reduce [explain ::=], go to state 146.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[cmdlist explain with SELECT]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct sclp ID]
parser: Input 'FROM'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist FROM]
parser: Input 'ID'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'ID'
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'SEMI'
parser: Reduce [nm ::= ID|INDEXED], go to state 165.
parser: Shift 'nm', go to state 287
parser: Reduce [dbnm ::=], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Reduce [where_opt ::=], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Reduce [orderby_opt ::=], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 22.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 2.
parser: Shift 'select'
parser: Reduce [cmd ::= select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[cmdlist explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping cmdlist
parser: Popping $
SQL: [;;
SELECT name FROM sqlite_master;]
VDBE Trace:
   0 Init             0    9    0               00 Start at 9
   9 Transaction      0    0    4 1             01 usesStmtJournal=0
  10 TableLock        0    1    0 sqlite_master 00 iDb=0 root=1 write=0
  11 Goto             0    1    0               00 
   1 OpenRead         0    1    0 2             00 root=1 iDb=0; sqlite_master
   2 Explain          0    0    0 SCAN TABLE sqlite_master 00 
   3 Rewind           0    7    0               00 
   4 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s2[t1](8)
   5 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s2[t1](8)
   6 Next             0    4    0               01 
   4 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s7[numbers](8)
   5 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s7[numbers](8)
   6 Next             0    4    0               01 
   4 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s2[t2](8)
   5 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s2[t2](8)
   6 Next             0    4    0               01 
   4 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s2[t3](8)
   5 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s2[t3](8)
   6 Next             0    4    0               01 
   7 Close            0    0    0               00 
   8 Halt             0    0    0               00 
parser: Initialize. Empty stack. State 0
parser: Input 'SEMI'
parser: Shift 'SEMI'
parser: Return. Stack=[SEMI]
parser: Input 'ATTACH'
parser: Reduce [ecmd ::= SEMI], go to state 0.
parser: Shift 'ecmd'
parser: Reduce [cmdlist ::= ecmd], go to state 0.
parser: Shift 'cmdlist', go to state 146
parser: FALLBACK ATTACH => ID
parser: Reduce [explain ::=], go to state 146.
parser: Shift 'explain', go to state 2
parser: Shift 'ATTACH', go to state 239
parser: Return. Stack=[cmdlist explain ATTACH]
parser: Input 'STRING'
parser: Reduce [database_kw_opt ::=], go to state 239.
parser: Shift 'database_kw_opt', go to state 58
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[cmdlist explain ATTACH database_kw_opt STRING]
parser: Input 'AS'
parser: Reduce [term ::= STRING], go to state 58.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 58.
parser: Shift 'expr', go to state 26
parser: Shift 'AS', go to state 57
parser: Return. Stack=[cmdlist explain ATTACH database_kw_opt expr AS]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain ATTACH database_kw_opt expr AS ID]
parser: Input 'SEMI'
parser: Reduce [expr ::= ID|INDEXED], go to state 57.
parser: Shift 'expr', go to state 11
parser: Reduce [key_opt ::=], go to state 11.
parser: Shift 'key_opt'
parser: Reduce [cmd ::= ATTACH database_kw_opt expr AS expr key_opt], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[cmdlist explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping cmdlist
parser: Popping $
SQL: [;
ATTACH 'test.db2' AS aux;]
VDBE Trace:
   0 Init             0    0    0               00 Start at 0
   1 String8          0    1    0 test.db2      00 r[1]='test.db2'
REG[1] =   t8[test.db2](8)
   2 String8          0    2    0 aux           00 r[2]='aux'
REG[2] =   t3[aux](8)
   3 Null             0    3    0               00 r[3]=NULL
REG[3] =  NULL
   4 Function0        0    1    4 sqlite_attach(3) 03 r[4]=func(r[1..3])
REG[1] =   t8[test.db2](8)
REG[2] =   t3[aux](8)
REG[3] =  NULL
parser: Initialize. Empty stack. State 0
parser: Input 'CREATE'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Shift 'CREATE'
parser: Return. Stack=[explain CREATE]
parser: Input 'TABLE'
parser: Reduce [createkw ::= CREATE], go to state 2.
parser: Shift 'createkw', go to state 107
parser: Reduce [temp ::=], go to state 107.
parser: Shift 'temp', go to state 319
parser: Shift 'TABLE', go to state 266
parser: Return. Stack=[explain createkw temp TABLE]
parser: Input 'ID'
parser: Reduce [ifnotexists ::=], go to state 266.
parser: Shift 'ifnotexists', go to state 183
parser: Shift 'ID'
parser: Return. Stack=[explain createkw temp TABLE ifnotexists ID]
parser: Input 'LP'
parser: Reduce [nm ::= ID|INDEXED], go to state 183.
parser: Shift 'nm', go to state 265
parser: Reduce [dbnm ::=], go to state 265.
parser: Shift 'dbnm'
parser: Reduce [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 2.
parser: Shift 'create_table', go to state 234
parser: Shift 'LP', go to state 111
parser: Return. Stack=[explain create_table LP]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP ID]
parser: Input 'ID'
parser: Reduce [nm ::= ID|INDEXED], go to state 111.
parser: Shift 'nm', go to state 148
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP nm ID]
parser: Input 'COMMA'
parser: Reduce [typename ::= ID|STRING], go to state 148.
parser: Shift 'typename', go to state 321
parser: Reduce [typetoken ::= typename], go to state 148.
parser: Shift 'typetoken'
parser: Reduce [columnname ::= nm typetoken], go to state 111.
parser: Shift 'columnname', go to state 311
parser: Reduce [carglist ::=], go to state 311.
parser: Shift 'carglist', go to state 119
parser: Reduce [columnlist ::= columnname carglist], go to state 111.
parser: Shift 'columnlist', go to state 300
parser: Shift 'COMMA', go to state 21
parser: Return. Stack=[explain create_table LP columnlist COMMA]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP columnlist COMMA ID]
parser: Input 'ID'
parser: Reduce [nm ::= ID|INDEXED], go to state 21.
parser: Shift 'nm', go to state 148
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP columnlist COMMA nm ID]
parser: Input 'COMMA'
parser: Reduce [typename ::= ID|STRING], go to state 148.
parser: Shift 'typename', go to state 321
parser: Reduce [typetoken ::= typename], go to state 148.
parser: Shift 'typetoken'
parser: Reduce [columnname ::= nm typetoken], go to state 21.
parser: Shift 'columnname', go to state 314
parser: Reduce [carglist ::=], go to state 314.
parser: Shift 'carglist', go to state 120
parser: Reduce [columnlist ::= columnlist COMMA columnname carglist], go to state 111.
parser: Shift 'columnlist', go to state 300
parser: Shift 'COMMA', go to state 21
parser: Return. Stack=[explain create_table LP columnlist COMMA]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP columnlist COMMA ID]
parser: Input 'ID'
parser: Reduce [nm ::= ID|INDEXED], go to state 21.
parser: Shift 'nm', go to state 148
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP columnlist COMMA nm ID]
parser: Input 'COMMA'
parser: Reduce [typename ::= ID|STRING], go to state 148.
parser: Shift 'typename', go to state 321
parser: Reduce [typetoken ::= typename], go to state 148.
parser: Shift 'typetoken'
parser: Reduce [columnname ::= nm typetoken], go to state 21.
parser: Shift 'columnname', go to state 314
parser: Reduce [carglist ::=], go to state 314.
parser: Shift 'carglist', go to state 120
parser: Reduce [columnlist ::= columnlist COMMA columnname carglist], go to state 111.
parser: Shift 'columnlist', go to state 300
parser: Shift 'COMMA', go to state 21
parser: Return. Stack=[explain create_table LP columnlist COMMA]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP columnlist COMMA ID]
parser: Input 'ID'
parser: Reduce [nm ::= ID|INDEXED], go to state 21.
parser: Shift 'nm', go to state 148
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP columnlist COMMA nm ID]
parser: Input 'COMMA'
parser: Reduce [typename ::= ID|STRING], go to state 148.
parser: Shift 'typename', go to state 321
parser: Reduce [typetoken ::= typename], go to state 148.
parser: Shift 'typetoken'
parser: Reduce [columnname ::= nm typetoken], go to state 21.
parser: Shift 'columnname', go to state 314
parser: Reduce [carglist ::=], go to state 314.
parser: Shift 'carglist', go to state 120
parser: Reduce [columnlist ::= columnlist COMMA columnname carglist], go to state 111.
parser: Shift 'columnlist', go to state 300
parser: Shift 'COMMA', go to state 21
parser: Return. Stack=[explain create_table LP columnlist COMMA]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP columnlist COMMA ID]
parser: Input 'ID'
parser: Reduce [nm ::= ID|INDEXED], go to state 21.
parser: Shift 'nm', go to state 148
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP columnlist COMMA nm ID]
parser: Input 'RP'
parser: Reduce [typename ::= ID|STRING], go to state 148.
parser: Shift 'typename', go to state 321
parser: Reduce [typetoken ::= typename], go to state 148.
parser: Shift 'typetoken'
parser: Reduce [columnname ::= nm typetoken], go to state 21.
parser: Shift 'columnname', go to state 314
parser: Reduce [carglist ::=], go to state 314.
parser: Shift 'carglist', go to state 120
parser: Reduce [columnlist ::= columnlist COMMA columnname carglist], go to state 111.
parser: Shift 'columnlist', go to state 300
parser: Reduce [conslist_opt ::=], go to state 300.
parser: Shift 'conslist_opt', go to state 437
parser: Shift 'RP', go to state 299
parser: Return. Stack=[explain create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI'
parser: Reduce [table_options ::=], go to state 299.
parser: Shift 'table_options'
parser: Reduce [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 234.
parser: Shift 'create_table_args'
parser: Reduce [cmd ::= create_table create_table_args], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'SELECT'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[explain with SELECT]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'FROM'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[explain with SELECT distinct selcollist FROM]
parser: Input 'ID'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'ID'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'DOT'
parser: Reduce [nm ::= ID|INDEXED], go to state 165.
parser: Shift 'nm', go to state 287
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'ORDER'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Reduce [where_opt ::=], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Shift 'ORDER', go to state 411
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY'
parser: Shift 'BY', go to state 17
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI'
parser: Reduce [expr ::= ID|INDEXED], go to state 17.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 17.
parser: Shift 'sortlist', go to state 410
parser: Reduce [orderby_opt ::= ORDER BY sortlist], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 22.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 2.
parser: Shift 'select'
parser: Reduce [cmd ::= select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
VDBE Trace:
   0 Init             0   12    0               00 Start at 12
  12 Transaction      2    0  259 0             00 usesStmtJournal=0
  13 TableLock        2    1    0 sqlite_master 00 iDb=2 root=1 write=0
  14 Goto             0    1    0               00 
   1 Noop             1    5    0               00 
   2 OpenRead         0    1    2 5             00 root=1 iDb=2; sqlite_master
   3 Explain          0    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   10    0               00 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s2[n1](8)
   6 Column           0    3    2               00 r[2]=sqlite_master.rootpage
REG[2] =  i:2
   7 Column           0    4    3               00 r[3]=sqlite_master.sql
REG[3] =   s21[CREATE TABLE n1](8)
   8 ResultRow        1    3    0               00 output=r[1..3]
REG[1] =   s2[n1](8)
REG[2] =  i:2
REG[3] =   s21[CREATE TABLE n1](8)
parser: Initialize. Empty stack. State 0
parser: Input 'CREATE'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Shift 'CREATE'
parser: Return. Stack=[explain CREATE]
parser: Input 'TABLE'
parser: Reduce [createkw ::= CREATE], go to state 2.
parser: Shift 'createkw', go to state 107
parser: Reduce [temp ::=], go to state 107.
parser: Shift 'temp', go to state 319
parser: Shift 'TABLE', go to state 266
parser: Return. Stack=[explain createkw temp TABLE]
parser: Input 'ID'
parser: Reduce [ifnotexists ::=], go to state 266.
parser: Shift 'ifnotexists', go to state 183
parser: Shift 'ID'
parser: Return. Stack=[explain createkw temp TABLE ifnotexists ID]
parser: Input 'LP'
parser: Reduce [nm ::= ID|INDEXED], go to state 183.
parser: Shift 'nm', go to state 265
parser: Reduce [dbnm ::=], go to state 265.
parser: Shift 'dbnm'
parser: Reduce [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 2.
parser: Shift 'create_table', go to state 234
parser: Shift 'LP', go to state 111
parser: Return. Stack=[explain create_table LP]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP ID]
parser: Input 'COMMA'
parser: Reduce [nm ::= ID|INDEXED], go to state 111.
parser: Shift 'nm', go to state 148
parser: Reduce [typetoken ::=], go to state 148.
parser: Shift 'typetoken'
parser: Reduce [columnname ::= nm typetoken], go to state 111.
parser: Shift 'columnname', go to state 311
parser: Reduce [carglist ::=], go to state 311.
parser: Shift 'carglist', go to state 119
parser: Reduce [columnlist ::= columnname carglist], go to state 111.
parser: Shift 'columnlist', go to state 300
parser: Shift 'COMMA', go to state 21
parser: Return. Stack=[explain create_table LP columnlist COMMA]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP columnlist COMMA ID]
parser: Input 'RP'
parser: Reduce [nm ::= ID|INDEXED], go to state 21.
parser: Shift 'nm', go to state 148
parser: Reduce [typetoken ::=], go to state 148.
parser: Shift 'typetoken'
parser: Reduce [columnname ::= nm typetoken], go to state 21.
parser: Shift 'columnname', go to state 314
parser: Reduce [carglist ::=], go to state 314.
parser: Shift 'carglist', go to state 120
parser: Reduce [columnlist ::= columnlist COMMA columnname carglist], go to state 111.
parser: Shift 'columnlist', go to state 300
parser: Reduce [conslist_opt ::=], go to state 300.
parser: Shift 'conslist_opt', go to state 437
parser: Shift 'RP', go to state 299
parser: Return. Stack=[explain create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI'
parser: Reduce [table_options ::=], go to state 299.
parser: Shift 'table_options'
parser: Reduce [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 234.
parser: Shift 'create_table_args'
parser: Reduce [cmd ::= create_table create_table_args], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
   9 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s2[n2](8)
   6 Column           0    3    2               00 r[2]=sqlite_master.rootpage
REG[2] =  i:3
   7 Column           0    4    3               00 r[3]=sqlite_master.sql
REG[3] =   s21[CREATE TABLE n2](8)
   8 ResultRow        1    3    0               00 output=r[1..3]
REG[1] =   s2[n2](8)
REG[2] =  i:3
REG[3] =   s21[CREATE TABLE n2](8)
parser: Initialize. Empty stack. State 0
parser: Input 'CREATE'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Shift 'CREATE'
parser: Return. Stack=[explain CREATE]
parser: Input 'TABLE'
parser: Reduce [createkw ::= CREATE], go to state 2.
parser: Shift 'createkw', go to state 107
parser: Reduce [temp ::=], go to state 107.
parser: Shift 'temp', go to state 319
parser: Shift 'TABLE', go to state 266
parser: Return. Stack=[explain createkw temp TABLE]
parser: Input 'ID'
parser: Reduce [ifnotexists ::=], go to state 266.
parser: Shift 'ifnotexists', go to state 183
parser: Shift 'ID'
parser: Return. Stack=[explain createkw temp TABLE ifnotexists ID]
parser: Input 'LP'
parser: Reduce [nm ::= ID|INDEXED], go to state 183.
parser: Shift 'nm', go to state 265
parser: Reduce [dbnm ::=], go to state 265.
parser: Shift 'dbnm'
parser: Reduce [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 2.
parser: Shift 'create_table', go to state 234
parser: Shift 'LP', go to state 111
parser: Return. Stack=[explain create_table LP]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP ID]
parser: Input 'COMMA'
parser: Reduce [nm ::= ID|INDEXED], go to state 111.
parser: Shift 'nm', go to state 148
parser: Reduce [typetoken ::=], go to state 148.
parser: Shift 'typetoken'
parser: Reduce [columnname ::= nm typetoken], go to state 111.
parser: Shift 'columnname', go to state 311
parser: Reduce [carglist ::=], go to state 311.
parser: Shift 'carglist', go to state 119
parser: Reduce [columnlist ::= columnname carglist], go to state 111.
parser: Shift 'columnlist', go to state 300
parser: Shift 'COMMA', go to state 21
parser: Return. Stack=[explain create_table LP columnlist COMMA]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP columnlist COMMA ID]
parser: Input 'RP'
parser: Reduce [nm ::= ID|INDEXED], go to state 21.
parser: Shift 'nm', go to state 148
parser: Reduce [typetoken ::=], go to state 148.
parser: Shift 'typetoken'
parser: Reduce [columnname ::= nm typetoken], go to state 21.
parser: Shift 'columnname', go to state 314
parser: Reduce [carglist ::=], go to state 314.
parser: Shift 'carglist', go to state 120
parser: Reduce [columnlist ::= columnlist COMMA columnname carglist], go to state 111.
parser: Shift 'columnlist', go to state 300
parser: Reduce [conslist_opt ::=], go to state 300.
parser: Shift 'conslist_opt', go to state 437
parser: Shift 'RP', go to state 299
parser: Return. Stack=[explain create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI'
parser: Reduce [table_options ::=], go to state 299.
parser: Shift 'table_options'
parser: Reduce [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 234.
parser: Shift 'create_table_args'
parser: Reduce [cmd ::= create_table create_table_args], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
   9 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s2[n3](8)
   6 Column           0    3    2               00 r[2]=sqlite_master.rootpage
REG[2] =  i:4
   7 Column           0    4    3               00 r[3]=sqlite_master.sql
REG[3] =   s21[CREATE TABLE n3](8)
   8 ResultRow        1    3    0               00 output=r[1..3]
REG[1] =   s2[n3](8)
REG[2] =  i:4
REG[3] =   s21[CREATE TABLE n3](8)
parser: Initialize. Empty stack. State 0
parser: Input 'CREATE'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Shift 'CREATE'
parser: Return. Stack=[explain CREATE]
parser: Input 'TABLE'
parser: Reduce [createkw ::= CREATE], go to state 2.
parser: Shift 'createkw', go to state 107
parser: Reduce [temp ::=], go to state 107.
parser: Shift 'temp', go to state 319
parser: Shift 'TABLE', go to state 266
parser: Return. Stack=[explain createkw temp TABLE]
parser: Input 'ID'
parser: Reduce [ifnotexists ::=], go to state 266.
parser: Shift 'ifnotexists', go to state 183
parser: Shift 'ID'
parser: Return. Stack=[explain createkw temp TABLE ifnotexists ID]
parser: Input 'LP'
parser: Reduce [nm ::= ID|INDEXED], go to state 183.
parser: Shift 'nm', go to state 265
parser: Reduce [dbnm ::=], go to state 265.
parser: Shift 'dbnm'
parser: Reduce [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 2.
parser: Shift 'create_table', go to state 234
parser: Shift 'LP', go to state 111
parser: Return. Stack=[explain create_table LP]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP ID]
parser: Input 'COMMA'
parser: Reduce [nm ::= ID|INDEXED], go to state 111.
parser: Shift 'nm', go to state 148
parser: Reduce [typetoken ::=], go to state 148.
parser: Shift 'typetoken'
parser: Reduce [columnname ::= nm typetoken], go to state 111.
parser: Shift 'columnname', go to state 311
parser: Reduce [carglist ::=], go to state 311.
parser: Shift 'carglist', go to state 119
parser: Reduce [columnlist ::= columnname carglist], go to state 111.
parser: Shift 'columnlist', go to state 300
parser: Shift 'COMMA', go to state 21
parser: Return. Stack=[explain create_table LP columnlist COMMA]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP columnlist COMMA ID]
parser: Input 'RP'
parser: Reduce [nm ::= ID|INDEXED], go to state 21.
parser: Shift 'nm', go to state 148
parser: Reduce [typetoken ::=], go to state 148.
parser: Shift 'typetoken'
parser: Reduce [columnname ::= nm typetoken], go to state 21.
parser: Shift 'columnname', go to state 314
parser: Reduce [carglist ::=], go to state 314.
parser: Shift 'carglist', go to state 120
parser: Reduce [columnlist ::= columnlist COMMA columnname carglist], go to state 111.
parser: Shift 'columnlist', go to state 300
parser: Reduce [conslist_opt ::=], go to state 300.
parser: Shift 'conslist_opt', go to state 437
parser: Shift 'RP', go to state 299
parser: Return. Stack=[explain create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI'
parser: Reduce [table_options ::=], go to state 299.
parser: Shift 'table_options'
parser: Reduce [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 234.
parser: Shift 'create_table_args'
parser: Reduce [cmd ::= create_table create_table_args], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
   9 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s8[f3_rules](8)
   6 Column           0    3    2               00 r[2]=sqlite_master.rootpage
REG[2] =  i:6
   7 Column           0    4    3               00 r[3]=sqlite_master.sql
REG[3] =   s48[CREATE TABLE f3](8)
   8 ResultRow        1    3    0               00 output=r[1..3]
REG[1] =   s8[f3_rules](8)
REG[2] =  i:6
REG[3] =   s48[CREATE TABLE f3](8)
parser: Initialize. Empty stack. State 0
parser: Input 'CREATE'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Shift 'CREATE'
parser: Return. Stack=[explain CREATE]
parser: Input 'TABLE'
parser: Reduce [createkw ::= CREATE], go to state 2.
parser: Shift 'createkw', go to state 107
parser: Reduce [temp ::=], go to state 107.
parser: Shift 'temp', go to state 319
parser: Shift 'TABLE', go to state 266
parser: Return. Stack=[explain createkw temp TABLE]
parser: Input 'ID'
parser: Reduce [ifnotexists ::=], go to state 266.
parser: Shift 'ifnotexists', go to state 183
parser: Shift 'ID'
parser: Return. Stack=[explain createkw temp TABLE ifnotexists ID]
parser: Input 'LP'
parser: Reduce [nm ::= ID|INDEXED], go to state 183.
parser: Shift 'nm', go to state 265
parser: Reduce [dbnm ::=], go to state 265.
parser: Shift 'dbnm'
parser: Reduce [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 2.
parser: Shift 'create_table', go to state 234
parser: Shift 'LP', go to state 111
parser: Return. Stack=[explain create_table LP]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP ID]
parser: Input 'COMMA'
parser: Reduce [nm ::= ID|INDEXED], go to state 111.
parser: Shift 'nm', go to state 148
parser: Reduce [typetoken ::=], go to state 148.
parser: Shift 'typetoken'
parser: Reduce [columnname ::= nm typetoken], go to state 111.
parser: Shift 'columnname', go to state 311
parser: Reduce [carglist ::=], go to state 311.
parser: Shift 'carglist', go to state 119
parser: Reduce [columnlist ::= columnname carglist], go to state 111.
parser: Shift 'columnlist', go to state 300
parser: Shift 'COMMA', go to state 21
parser: Return. Stack=[explain create_table LP columnlist COMMA]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP columnlist COMMA ID]
parser: Input 'COMMA'
parser: Reduce [nm ::= ID|INDEXED], go to state 21.
parser: Shift 'nm', go to state 148
parser: Reduce [typetoken ::=], go to state 148.
parser: Shift 'typetoken'
parser: Reduce [columnname ::= nm typetoken], go to state 21.
parser: Shift 'columnname', go to state 314
parser: Reduce [carglist ::=], go to state 314.
parser: Shift 'carglist', go to state 120
parser: Reduce [columnlist ::= columnlist COMMA columnname carglist], go to state 111.
parser: Shift 'columnlist', go to state 300
parser: Shift 'COMMA', go to state 21
parser: Return. Stack=[explain create_table LP columnlist COMMA]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP columnlist COMMA ID]
parser: Input 'COMMA'
parser: Reduce [nm ::= ID|INDEXED], go to state 21.
parser: Shift 'nm', go to state 148
parser: Reduce [typetoken ::=], go to state 148.
parser: Shift 'typetoken'
parser: Reduce [columnname ::= nm typetoken], go to state 21.
parser: Shift 'columnname', go to state 314
parser: Reduce [carglist ::=], go to state 314.
parser: Shift 'carglist', go to state 120
parser: Reduce [columnlist ::= columnlist COMMA columnname carglist], go to state 111.
parser: Shift 'columnlist', go to state 300
parser: Shift 'COMMA', go to state 21
parser: Return. Stack=[explain create_table LP columnlist COMMA]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP columnlist COMMA ID]
parser: Input 'RP'
parser: Reduce [nm ::= ID|INDEXED], go to state 21.
parser: Shift 'nm', go to state 148
parser: Reduce [typetoken ::=], go to state 148.
parser: Shift 'typetoken'
parser: Reduce [columnname ::= nm typetoken], go to state 21.
parser: Shift 'columnname', go to state 314
parser: Reduce [carglist ::=], go to state 314.
parser: Shift 'carglist', go to state 120
parser: Reduce [columnlist ::= columnlist COMMA columnname carglist], go to state 111.
parser: Shift 'columnlist', go to state 300
parser: Reduce [conslist_opt ::=], go to state 300.
parser: Shift 'conslist_opt', go to state 437
parser: Shift 'RP', go to state 299
parser: Return. Stack=[explain create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI'
parser: Reduce [table_options ::=], go to state 299.
parser: Shift 'table_options'
parser: Reduce [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 234.
parser: Shift 'create_table_args'
parser: Reduce [cmd ::= create_table create_table_args], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
   9 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s5[files](8)
   6 Column           0    3    2               00 r[2]=sqlite_master.rootpage
REG[2] =  i:7
   7 Column           0    4    3               00 r[3]=sqlite_master.sql
REG[3] =   s30[CREATE TABLE fi](8)
   8 ResultRow        1    3    0               00 output=r[1..3]
REG[1] =   s5[files](8)
REG[2] =  i:7
REG[3] =   s30[CREATE TABLE fi](8)
parser: Initialize. Empty stack. State 0
parser: Input 'CREATE'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Shift 'CREATE'
parser: Return. Stack=[explain CREATE]
parser: Input 'TABLE'
parser: Reduce [createkw ::= CREATE], go to state 2.
parser: Shift 'createkw', go to state 107
parser: Reduce [temp ::=], go to state 107.
parser: Shift 'temp', go to state 319
parser: Shift 'TABLE', go to state 266
parser: Return. Stack=[explain createkw temp TABLE]
parser: Input 'ID'
parser: Reduce [ifnotexists ::=], go to state 266.
parser: Shift 'ifnotexists', go to state 183
parser: Shift 'ID'
parser: Return. Stack=[explain createkw temp TABLE ifnotexists ID]
parser: Input 'LP'
parser: Reduce [nm ::= ID|INDEXED], go to state 183.
parser: Shift 'nm', go to state 265
parser: Reduce [dbnm ::=], go to state 265.
parser: Shift 'dbnm'
parser: Reduce [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 2.
parser: Shift 'create_table', go to state 234
parser: Shift 'LP', go to state 111
parser: Return. Stack=[explain create_table LP]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP ID]
parser: Input 'COMMA'
parser: Reduce [nm ::= ID|INDEXED], go to state 111.
parser: Shift 'nm', go to state 148
parser: Reduce [typetoken ::=], go to state 148.
parser: Shift 'typetoken'
parser: Reduce [columnname ::= nm typetoken], go to state 111.
parser: Shift 'columnname', go to state 311
parser: Reduce [carglist ::=], go to state 311.
parser: Shift 'carglist', go to state 119
parser: Reduce [columnlist ::= columnname carglist], go to state 111.
parser: Shift 'columnlist', go to state 300
parser: Shift 'COMMA', go to state 21
parser: Return. Stack=[explain create_table LP columnlist COMMA]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP columnlist COMMA ID]
parser: Input 'RP'
parser: Reduce [nm ::= ID|INDEXED], go to state 21.
parser: Shift 'nm', go to state 148
parser: Reduce [typetoken ::=], go to state 148.
parser: Shift 'typetoken'
parser: Reduce [columnname ::= nm typetoken], go to state 21.
parser: Shift 'columnname', go to state 314
parser: Reduce [carglist ::=], go to state 314.
parser: Shift 'carglist', go to state 120
parser: Reduce [columnlist ::= columnlist COMMA columnname carglist], go to state 111.
parser: Shift 'columnlist', go to state 300
parser: Reduce [conslist_opt ::=], go to state 300.
parser: Shift 'conslist_opt', go to state 437
parser: Shift 'RP', go to state 299
parser: Return. Stack=[explain create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI'
parser: Reduce [table_options ::=], go to state 299.
parser: Shift 'table_options'
parser: Reduce [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 234.
parser: Shift 'create_table_args'
parser: Reduce [cmd ::= create_table create_table_args], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
   9 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s8[t4...abc](8)
   6 Column           0    3    2               00 r[2]=sqlite_master.rootpage
REG[2] =  i:8
   7 Column           0    4    3               00 r[3]=sqlite_master.sql
REG[3] =   s29[CREATE TABLE "t](8)
   8 ResultRow        1    3    0               00 output=r[1..3]
REG[1] =   s8[t4...abc](8)
REG[2] =  i:8
REG[3] =   s29[CREATE TABLE "t](8)
parser: Initialize. Empty stack. State 0
parser: Input 'CREATE'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Shift 'CREATE'
parser: Return. Stack=[explain CREATE]
parser: Input 'TABLE'
parser: Reduce [createkw ::= CREATE], go to state 2.
parser: Shift 'createkw', go to state 107
parser: Reduce [temp ::=], go to state 107.
parser: Shift 'temp', go to state 319
parser: Shift 'TABLE', go to state 266
parser: Return. Stack=[explain createkw temp TABLE]
parser: Input 'ID'
parser: Reduce [ifnotexists ::=], go to state 266.
parser: Shift 'ifnotexists', go to state 183
parser: Shift 'ID'
parser: Return. Stack=[explain createkw temp TABLE ifnotexists ID]
parser: Input 'LP'
parser: Reduce [nm ::= ID|INDEXED], go to state 183.
parser: Shift 'nm', go to state 265
parser: Reduce [dbnm ::=], go to state 265.
parser: Shift 'dbnm'
parser: Reduce [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 2.
parser: Shift 'create_table', go to state 234
parser: Shift 'LP', go to state 111
parser: Return. Stack=[explain create_table LP]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP ID]
parser: Input 'COMMA'
parser: Reduce [nm ::= ID|INDEXED], go to state 111.
parser: Shift 'nm', go to state 148
parser: Reduce [typetoken ::=], go to state 148.
parser: Shift 'typetoken'
parser: Reduce [columnname ::= nm typetoken], go to state 111.
parser: Shift 'columnname', go to state 311
parser: Reduce [carglist ::=], go to state 311.
parser: Shift 'carglist', go to state 119
parser: Reduce [columnlist ::= columnname carglist], go to state 111.
parser: Shift 'columnlist', go to state 300
parser: Shift 'COMMA', go to state 21
parser: Return. Stack=[explain create_table LP columnlist COMMA]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP columnlist COMMA ID]
parser: Input 'RP'
parser: Reduce [nm ::= ID|INDEXED], go to state 21.
parser: Shift 'nm', go to state 148
parser: Reduce [typetoken ::=], go to state 148.
parser: Shift 'typetoken'
parser: Reduce [columnname ::= nm typetoken], go to state 21.
parser: Shift 'columnname', go to state 314
parser: Reduce [carglist ::=], go to state 314.
parser: Shift 'carglist', go to state 120
parser: Reduce [columnlist ::= columnlist COMMA columnname carglist], go to state 111.
parser: Shift 'columnlist', go to state 300
parser: Reduce [conslist_opt ::=], go to state 300.
parser: Shift 'conslist_opt', go to state 437
parser: Shift 'RP', go to state 299
parser: Return. Stack=[explain create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI'
parser: Reduce [table_options ::=], go to state 299.
parser: Shift 'table_options'
parser: Reduce [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 234.
parser: Shift 'create_table_args'
parser: Reduce [cmd ::= create_table create_table_args], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
   9 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s2[v2](8)
   6 Column           0    3    2               00 r[2]=sqlite_master.rootpage
REG[2] =  i:0
   7 Column           0    4    3               00 r[3]=sqlite_master.sql
REG[3] =   s34[CREATE VIEW v2 ](8)
   8 ResultRow        1    3    0               00 output=r[1..3]
REG[1] =   s2[v2](8)
REG[2] =  i:0
REG[3] =   s34[CREATE VIEW v2 ](8)
parser: Initialize. Empty stack. State 0
parser: Input 'CREATE'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Shift 'CREATE'
parser: Return. Stack=[explain CREATE]
parser: Input 'VIEW'
parser: Reduce [createkw ::= CREATE], go to state 2.
parser: Shift 'createkw', go to state 107
parser: FALLBACK VIEW => ID
parser: Reduce [temp ::=], go to state 107.
parser: Shift 'temp', go to state 319
parser: Shift 'VIEW', go to state 264
parser: Return. Stack=[explain createkw temp VIEW]
parser: Input 'ID'
parser: Reduce [ifnotexists ::=], go to state 264.
parser: Shift 'ifnotexists', go to state 182
parser: Shift 'ID'
parser: Return. Stack=[explain createkw temp VIEW ifnotexists ID]
parser: Input 'AS'
parser: Reduce [nm ::= ID|INDEXED], go to state 182.
parser: Shift 'nm', go to state 263
parser: Reduce [dbnm ::=], go to state 263.
parser: Shift 'dbnm', go to state 262
parser: Reduce [eidlist_opt ::=], go to state 262.
parser: Shift 'eidlist_opt', go to state 377
parser: Shift 'AS', go to state 152
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS]
parser: Input 'SELECT'
parser: Reduce [with ::=], go to state 152.
parser: Shift 'with', go to state 113
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT]
parser: Input 'STAR'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'STAR'
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp STAR]
parser: Input 'FROM'
parser: Reduce [selcollist ::= sclp STAR], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct selcollist FROM]
parser: Input 'ID'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'ID'
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'SEMI'
parser: Reduce [nm ::= ID|INDEXED], go to state 165.
parser: Shift 'nm', go to state 287
parser: Reduce [dbnm ::=], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Reduce [where_opt ::=], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Reduce [orderby_opt ::=], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 113.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 113.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 152.
parser: Shift 'select'
parser: Reduce [cmd ::= createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
   9 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s2[v3](8)
   6 Column           0    3    2               00 r[2]=sqlite_master.rootpage
REG[2] =  i:0
   7 Column           0    4    3               00 r[3]=sqlite_master.sql
REG[3] =   s34[CREATE VIEW v3 ](8)
   8 ResultRow        1    3    0               00 output=r[1..3]
REG[1] =   s2[v3](8)
REG[2] =  i:0
REG[3] =   s34[CREATE VIEW v3 ](8)
parser: Initialize. Empty stack. State 0
parser: Input 'CREATE'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Shift 'CREATE'
parser: Return. Stack=[explain CREATE]
parser: Input 'VIEW'
parser: Reduce [createkw ::= CREATE], go to state 2.
parser: Shift 'createkw', go to state 107
parser: FALLBACK VIEW => ID
parser: Reduce [temp ::=], go to state 107.
parser: Shift 'temp', go to state 319
parser: Shift 'VIEW', go to state 264
parser: Return. Stack=[explain createkw temp VIEW]
parser: Input 'ID'
parser: Reduce [ifnotexists ::=], go to state 264.
parser: Shift 'ifnotexists', go to state 182
parser: Shift 'ID'
parser: Return. Stack=[explain createkw temp VIEW ifnotexists ID]
parser: Input 'AS'
parser: Reduce [nm ::= ID|INDEXED], go to state 182.
parser: Shift 'nm', go to state 263
parser: Reduce [dbnm ::=], go to state 263.
parser: Shift 'dbnm', go to state 262
parser: Reduce [eidlist_opt ::=], go to state 262.
parser: Shift 'eidlist_opt', go to state 377
parser: Shift 'AS', go to state 152
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS]
parser: Input 'SELECT'
parser: Reduce [with ::=], go to state 152.
parser: Shift 'with', go to state 113
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT]
parser: Input 'STAR'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'STAR'
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp STAR]
parser: Input 'FROM'
parser: Reduce [selcollist ::= sclp STAR], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct selcollist FROM]
parser: Input 'ID'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'ID'
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'SEMI'
parser: Reduce [nm ::= ID|INDEXED], go to state 165.
parser: Shift 'nm', go to state 287
parser: Reduce [dbnm ::=], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Reduce [where_opt ::=], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Reduce [orderby_opt ::=], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 113.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 113.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 152.
parser: Shift 'select'
parser: Reduce [cmd ::= createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
   9 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s4[t.2.](8)
   6 Column           0    3    2               00 r[2]=sqlite_master.rootpage
REG[2] =  i:9
   7 Column           0    4    3               00 r[3]=sqlite_master.sql
REG[3] =   s48[C.R.E.A.T.E. .T](8)
   8 ResultRow        1    3    0               00 output=r[1..3]
REG[1] =   s4[t.2.](8)
REG[2] =  i:9
REG[3] =   s48[C.R.E.A.T.E. .T](8)
   9 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s4[v.1.](8)
   6 Column           0    3    2               00 r[2]=sqlite_master.rootpage
REG[2] =  i:0
   7 Column           0    4    3               00 r[3]=sqlite_master.sql
REG[3] =   s68[C.R.E.A.T.E. .V](8)
   8 ResultRow        1    3    0               00 output=r[1..3]
REG[1] =   s4[v.1.](8)
REG[2] =  i:0
REG[3] =   s68[C.R.E.A.T.E. .V](8)
   9 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s12[sqlite_stat1](8)
   6 Column           0    3    2               00 r[2]=sqlite_master.rootpage
REG[2] =  i:5
   7 Column           0    4    3               00 r[3]=sqlite_master.sql
REG[3] =   s39[CREATE TABLE sq](8)
   8 ResultRow        1    3    0               00 output=r[1..3]
REG[1] =   s12[sqlite_stat1](8)
REG[2] =  i:5
REG[3] =   s39[CREATE TABLE sq](8)
parser: Initialize. Empty stack. State 0
parser: Input 'CREATE'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Shift 'CREATE'
parser: Return. Stack=[explain CREATE]
parser: Input 'TABLE'
parser: Reduce [createkw ::= CREATE], go to state 2.
parser: Shift 'createkw', go to state 107
parser: Reduce [temp ::=], go to state 107.
parser: Shift 'temp', go to state 319
parser: Shift 'TABLE', go to state 266
parser: Return. Stack=[explain createkw temp TABLE]
parser: Input 'ID'
parser: Reduce [ifnotexists ::=], go to state 266.
parser: Shift 'ifnotexists', go to state 183
parser: Shift 'ID'
parser: Return. Stack=[explain createkw temp TABLE ifnotexists ID]
parser: Input 'LP'
parser: Reduce [nm ::= ID|INDEXED], go to state 183.
parser: Shift 'nm', go to state 265
parser: Reduce [dbnm ::=], go to state 265.
parser: Shift 'dbnm'
parser: Reduce [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 2.
parser: Shift 'create_table', go to state 234
parser: Shift 'LP', go to state 111
parser: Return. Stack=[explain create_table LP]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP ID]
parser: Input 'COMMA'
parser: Reduce [nm ::= ID|INDEXED], go to state 111.
parser: Shift 'nm', go to state 148
parser: Reduce [typetoken ::=], go to state 148.
parser: Shift 'typetoken'
parser: Reduce [columnname ::= nm typetoken], go to state 111.
parser: Shift 'columnname', go to state 311
parser: Reduce [carglist ::=], go to state 311.
parser: Shift 'carglist', go to state 119
parser: Reduce [columnlist ::= columnname carglist], go to state 111.
parser: Shift 'columnlist', go to state 300
parser: Shift 'COMMA', go to state 21
parser: Return. Stack=[explain create_table LP columnlist COMMA]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP columnlist COMMA ID]
parser: Input 'COMMA'
parser: Reduce [nm ::= ID|INDEXED], go to state 21.
parser: Shift 'nm', go to state 148
parser: Reduce [typetoken ::=], go to state 148.
parser: Shift 'typetoken'
parser: Reduce [columnname ::= nm typetoken], go to state 21.
parser: Shift 'columnname', go to state 314
parser: Reduce [carglist ::=], go to state 314.
parser: Shift 'carglist', go to state 120
parser: Reduce [columnlist ::= columnlist COMMA columnname carglist], go to state 111.
parser: Shift 'columnlist', go to state 300
parser: Shift 'COMMA', go to state 21
parser: Return. Stack=[explain create_table LP columnlist COMMA]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP columnlist COMMA ID]
parser: Input 'RP'
parser: Reduce [nm ::= ID|INDEXED], go to state 21.
parser: Shift 'nm', go to state 148
parser: Reduce [typetoken ::=], go to state 148.
parser: Shift 'typetoken'
parser: Reduce [columnname ::= nm typetoken], go to state 21.
parser: Shift 'columnname', go to state 314
parser: Reduce [carglist ::=], go to state 314.
parser: Shift 'carglist', go to state 120
parser: Reduce [columnlist ::= columnlist COMMA columnname carglist], go to state 111.
parser: Shift 'columnlist', go to state 300
parser: Reduce [conslist_opt ::=], go to state 300.
parser: Shift 'conslist_opt', go to state 437
parser: Shift 'RP', go to state 299
parser: Return. Stack=[explain create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI'
parser: Reduce [table_options ::=], go to state 299.
parser: Shift 'table_options'
parser: Reduce [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 234.
parser: Shift 'create_table_args'
parser: Reduce [cmd ::= create_table create_table_args], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
   9 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s4[.t.2](8)
   6 Column           0    3    2               00 r[2]=sqlite_master.rootpage
REG[2] =  i:10
   7 Column           0    4    3               00 r[3]=sqlite_master.sql
REG[3] =   s48[.C.R.E.A.T.E. .](8)
   8 ResultRow        1    3    0               00 output=r[1..3]
REG[1] =   s4[.t.2](8)
REG[2] =  i:10
REG[3] =   s48[.C.R.E.A.T.E. .](8)
   9 Next             0    5    0               01 
  10 Close            0    0    0               00 
  11 Halt             0    0    0               00 
parser: Initialize. Empty stack. State 0
parser: Input 'SEMI'
parser: Shift 'SEMI'
parser: Return. Stack=[SEMI]
parser: Input 'SEMI'
parser: Reduce [ecmd ::= SEMI], go to state 0.
parser: Shift 'ecmd'
parser: Reduce [cmdlist ::= ecmd], go to state 0.
parser: Shift 'cmdlist', go to state 146
parser: Shift 'SEMI'
parser: Return. Stack=[cmdlist SEMI]
parser: Input 'BEGIN'
parser: Reduce [ecmd ::= SEMI], go to state 146.
parser: Shift 'ecmd'
parser: Reduce [cmdlist ::= cmdlist ecmd], go to state 0.
parser: Shift 'cmdlist', go to state 146
parser: FALLBACK BEGIN => ID
parser: Reduce [explain ::=], go to state 146.
parser: Shift 'explain', go to state 2
parser: Shift 'BEGIN', go to state 217
parser: Return. Stack=[cmdlist explain BEGIN]
parser: Input 'EXCLUSIVE'
parser: Shift 'EXCLUSIVE'
parser: Return. Stack=[cmdlist explain BEGIN EXCLUSIVE]
parser: Input 'SEMI'
parser: Reduce [transtype ::= EXCLUSIVE], go to state 217.
parser: Shift 'transtype', go to state 306
parser: Reduce [trans_opt ::=], go to state 306.
parser: Shift 'trans_opt'
parser: Reduce [cmd ::= BEGIN transtype trans_opt], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[cmdlist explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping cmdlist
parser: Popping $
SQL: [;
; 
          BEGIN EXCLUSIVE;]
VDBE Trace:
   0 Init             0    0    0               00 Start at 0
   1 Transaction      0    2    0               00 
   2 Transaction      1    2    0               00 
   3 AutoCommit       0    0    0               00 
parser: Initialize. Empty stack. State 0
parser: Input 'SEMI'
parser: Shift 'SEMI'
parser: Return. Stack=[SEMI]
parser: Input 'PRAGMA'
parser: Reduce [ecmd ::= SEMI], go to state 0.
parser: Shift 'ecmd'
parser: Reduce [cmdlist ::= ecmd], go to state 0.
parser: Shift 'cmdlist', go to state 146
parser: FALLBACK PRAGMA => ID
parser: Reduce [explain ::=], go to state 146.
parser: Shift 'explain', go to state 2
parser: Shift 'PRAGMA', go to state 172
parser: Return. Stack=[cmdlist explain PRAGMA]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[cmdlist explain PRAGMA ID]
parser: Input 'EQ'
parser: Reduce [nm ::= ID|INDEXED], go to state 172.
parser: Shift 'nm', go to state 240
parser: Reduce [dbnm ::=], go to state 240.
parser: Shift 'dbnm', go to state 323
parser: Shift 'EQ', go to state 20
parser: Return. Stack=[cmdlist explain PRAGMA nm dbnm EQ]
parser: Input 'INTEGER'
parser: Shift 'INTEGER'
parser: Return. Stack=[cmdlist explain PRAGMA nm dbnm EQ INTEGER]
parser: Input 'SEMI'
parser: Reduce [plus_num ::= INTEGER|FLOAT], go to state 20.
parser: Shift 'plus_num'
parser: Reduce [nmnum ::= plus_num], go to state 20.
parser: Shift 'nmnum'
parser: Reduce [cmd ::= PRAGMA nm dbnm EQ nmnum], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[cmdlist explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping cmdlist
parser: Popping $
SQL: [;
PRAGMA page_size = 1024;]
VDBE Trace:
   0 Init             0    0    0               00 Start at 0
   1 Halt             0    0    0               00 
parser: Initialize. Empty stack. State 0
parser: Input 'CREATE'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Shift 'CREATE'
parser: Return. Stack=[explain CREATE]
parser: Input 'INDEX'
parser: Reduce [createkw ::= CREATE], go to state 2.
parser: Shift 'createkw', go to state 107
parser: Reduce [uniqueflag ::=], go to state 107.
parser: Shift 'uniqueflag', go to state 370
parser: Shift 'INDEX', go to state 256
parser: Return. Stack=[explain createkw uniqueflag INDEX]
parser: Input 'ID'
parser: Reduce [ifnotexists ::=], go to state 256.
parser: Shift 'ifnotexists', go to state 180
parser: Shift 'ID'
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists ID]
parser: Input 'ON'
parser: Reduce [nm ::= ID|INDEXED], go to state 180.
parser: Shift 'nm', go to state 255
parser: Reduce [dbnm ::=], go to state 255.
parser: Shift 'dbnm', go to state 369
parser: Shift 'ON', go to state 179
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON ID]
parser: Input 'LP'
parser: Reduce [nm ::= ID|INDEXED], go to state 179.
parser: Shift 'nm', go to state 368
parser: Shift 'LP', go to state 12
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP ID]
parser: Input 'RP'
parser: Reduce [expr ::= ID|INDEXED], go to state 12.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 12.
parser: Shift 'sortlist', go to state 325
parser: Shift 'RP', go to state 254
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP]
parser: Input 'SEMI'
parser: Reduce [where_opt ::=], go to state 254.
parser: Shift 'where_opt'
parser: Reduce [cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt], go to state 2.
parser: Initialize. Empty stack. State 0
parser: Input 'CREATE'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Shift 'CREATE'
parser: Return. Stack=[explain CREATE]
parser: Input 'TABLE'
parser: Reduce [createkw ::= CREATE], go to state 2.
parser: Shift 'createkw', go to state 107
parser: Reduce [temp ::=], go to state 107.
parser: Shift 'temp', go to state 319
parser: Shift 'TABLE', go to state 266
parser: Return. Stack=[explain createkw temp TABLE]
parser: Input 'ID'
parser: Reduce [ifnotexists ::=], go to state 266.
parser: Shift 'ifnotexists', go to state 183
parser: Shift 'ID'
parser: Return. Stack=[explain createkw temp TABLE ifnotexists ID]
parser: Input 'LP'
parser: Reduce [nm ::= ID|INDEXED], go to state 183.
parser: Shift 'nm', go to state 265
parser: Reduce [dbnm ::=], go to state 265.
parser: Shift 'dbnm'
parser: Reduce [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 2.
parser: Shift 'create_table', go to state 234
parser: Shift 'LP', go to state 111
parser: Return. Stack=[explain create_table LP]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP ID]
parser: Input 'ID'
parser: Reduce [nm ::= ID|INDEXED], go to state 111.
parser: Shift 'nm', go to state 148
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP nm ID]
parser: Input 'COMMA'
parser: Reduce [typename ::= ID|STRING], go to state 148.
parser: Shift 'typename', go to state 321
parser: Reduce [typetoken ::= typename], go to state 148.
parser: Shift 'typetoken'
parser: Reduce [columnname ::= nm typetoken], go to state 111.
parser: Shift 'columnname', go to state 311
parser: Reduce [carglist ::=], go to state 311.
parser: Shift 'carglist', go to state 119
parser: Reduce [columnlist ::= columnname carglist], go to state 111.
parser: Shift 'columnlist', go to state 300
parser: Shift 'COMMA', go to state 21
parser: Return. Stack=[explain create_table LP columnlist COMMA]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP columnlist COMMA ID]
parser: Input 'ID'
parser: Reduce [nm ::= ID|INDEXED], go to state 21.
parser: Shift 'nm', go to state 148
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP columnlist COMMA nm ID]
parser: Input 'COMMA'
parser: Reduce [typename ::= ID|STRING], go to state 148.
parser: Shift 'typename', go to state 321
parser: Reduce [typetoken ::= typename], go to state 148.
parser: Shift 'typetoken'
parser: Reduce [columnname ::= nm typetoken], go to state 21.
parser: Shift 'columnname', go to state 314
parser: Reduce [carglist ::=], go to state 314.
parser: Shift 'carglist', go to state 120
parser: Reduce [columnlist ::= columnlist COMMA columnname carglist], go to state 111.
parser: Shift 'columnlist', go to state 300
parser: Shift 'COMMA', go to state 21
parser: Return. Stack=[explain create_table LP columnlist COMMA]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP columnlist COMMA ID]
parser: Input 'ID'
parser: Reduce [nm ::= ID|INDEXED], go to state 21.
parser: Shift 'nm', go to state 148
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP columnlist COMMA nm ID]
parser: Input 'COMMA'
parser: Reduce [typename ::= ID|STRING], go to state 148.
parser: Shift 'typename', go to state 321
parser: Reduce [typetoken ::= typename], go to state 148.
parser: Shift 'typetoken'
parser: Reduce [columnname ::= nm typetoken], go to state 21.
parser: Shift 'columnname', go to state 314
parser: Reduce [carglist ::=], go to state 314.
parser: Shift 'carglist', go to state 120
parser: Reduce [columnlist ::= columnlist COMMA columnname carglist], go to state 111.
parser: Shift 'columnlist', go to state 300
parser: Shift 'COMMA', go to state 21
parser: Return. Stack=[explain create_table LP columnlist COMMA]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP columnlist COMMA ID]
parser: Input 'ID'
parser: Reduce [nm ::= ID|INDEXED], go to state 21.
parser: Shift 'nm', go to state 148
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP columnlist COMMA nm ID]
parser: Input 'COMMA'
parser: Reduce [typename ::= ID|STRING], go to state 148.
parser: Shift 'typename', go to state 321
parser: Reduce [typetoken ::= typename], go to state 148.
parser: Shift 'typetoken'
parser: Reduce [columnname ::= nm typetoken], go to state 21.
parser: Shift 'columnname', go to state 314
parser: Reduce [carglist ::=], go to state 314.
parser: Shift 'carglist', go to state 120
parser: Reduce [columnlist ::= columnlist COMMA columnname carglist], go to state 111.
parser: Shift 'columnlist', go to state 300
parser: Shift 'COMMA', go to state 21
parser: Return. Stack=[explain create_table LP columnlist COMMA]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP columnlist COMMA ID]
parser: Input 'ID'
parser: Reduce [nm ::= ID|INDEXED], go to state 21.
parser: Shift 'nm', go to state 148
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP columnlist COMMA nm ID]
parser: Input 'RP'
parser: Reduce [typename ::= ID|STRING], go to state 148.
parser: Shift 'typename', go to state 321
parser: Reduce [typetoken ::= typename], go to state 148.
parser: Shift 'typetoken'
parser: Reduce [columnname ::= nm typetoken], go to state 21.
parser: Shift 'columnname', go to state 314
parser: Reduce [carglist ::=], go to state 314.
parser: Shift 'carglist', go to state 120
parser: Reduce [columnlist ::= columnlist COMMA columnname carglist], go to state 111.
parser: Shift 'columnlist', go to state 300
parser: Reduce [conslist_opt ::=], go to state 300.
parser: Shift 'conslist_opt', go to state 437
parser: Shift 'RP', go to state 299
parser: Return. Stack=[explain create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI'
parser: Reduce [table_options ::=], go to state 299.
parser: Shift 'table_options'
parser: Reduce [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 234.
parser: Shift 'create_table_args'
parser: Reduce [cmd ::= create_table create_table_args], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'SELECT'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[explain with SELECT]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'FROM'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[explain with SELECT distinct selcollist FROM]
parser: Input 'ID'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'ID'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'DOT'
parser: Reduce [nm ::= ID|INDEXED], go to state 165.
parser: Shift 'nm', go to state 287
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'ORDER'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Reduce [where_opt ::=], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Shift 'ORDER', go to state 411
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY'
parser: Shift 'BY', go to state 17
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI'
parser: Reduce [expr ::= ID|INDEXED], go to state 17.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 17.
parser: Shift 'sortlist', go to state 410
parser: Reduce [orderby_opt ::= ORDER BY sortlist], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 22.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 2.
parser: Shift 'select'
parser: Reduce [cmd ::= select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
VDBE Trace:
   0 Init             0   12    0               00 Start at 12
  12 Transaction      0    0    4 2             00 usesStmtJournal=0
  13 TableLock        0    1    0 sqlite_master 00 iDb=0 root=1 write=0
  14 Goto             0    1    0               00 
   1 Noop             1    5    0               00 
   2 OpenRead         0    1    0 5             00 root=1 iDb=0; sqlite_master
   3 Explain          0    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   10    0               00 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s2[t1](8)
   6 Column           0    3    2               00 r[2]=sqlite_master.rootpage
REG[2] =  i:2
   7 Column           0    4    3               00 r[3]=sqlite_master.sql
REG[3] =   s41[CREATE TABLE t1](8)
   8 ResultRow        1    3    0               00 output=r[1..3]
REG[1] =   s2[t1](8)
REG[2] =  i:2
REG[3] =   s41[CREATE TABLE t1](8)
parser: Initialize. Empty stack. State 0
parser: Input 'CREATE'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Shift 'CREATE'
parser: Return. Stack=[explain CREATE]
parser: Input 'TABLE'
parser: Reduce [createkw ::= CREATE], go to state 2.
parser: Shift 'createkw', go to state 107
parser: Reduce [temp ::=], go to state 107.
parser: Shift 'temp', go to state 319
parser: Shift 'TABLE', go to state 266
parser: Return. Stack=[explain createkw temp TABLE]
parser: Input 'ID'
parser: Reduce [ifnotexists ::=], go to state 266.
parser: Shift 'ifnotexists', go to state 183
parser: Shift 'ID'
parser: Return. Stack=[explain createkw temp TABLE ifnotexists ID]
parser: Input 'LP'
parser: Reduce [nm ::= ID|INDEXED], go to state 183.
parser: Shift 'nm', go to state 265
parser: Reduce [dbnm ::=], go to state 265.
parser: Shift 'dbnm'
parser: Reduce [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 2.
parser: Shift 'create_table', go to state 234
parser: Shift 'LP', go to state 111
parser: Return. Stack=[explain create_table LP]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP ID]
parser: Input 'ID'
parser: Reduce [nm ::= ID|INDEXED], go to state 111.
parser: Shift 'nm', go to state 148
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP nm ID]
parser: Input 'PRIMARY'
parser: Reduce [typename ::= ID|STRING], go to state 148.
parser: Shift 'typename', go to state 321
parser: Reduce [typetoken ::= typename], go to state 148.
parser: Shift 'typetoken'
parser: Reduce [columnname ::= nm typetoken], go to state 111.
parser: Shift 'columnname', go to state 311
parser: Reduce [carglist ::=], go to state 311.
parser: Shift 'carglist', go to state 119
parser: Shift 'PRIMARY', go to state 391
parser: Return. Stack=[explain create_table LP columnname carglist PRIMARY]
parser: Input 'KEY'
parser: Shift 'KEY', go to state 227
parser: Return. Stack=[explain create_table LP columnname carglist PRIMARY KEY]
parser: Input 'COMMA'
parser: Reduce [sortorder ::=], go to state 227.
parser: Shift 'sortorder', go to state 275
parser: Reduce [onconf ::=], go to state 275.
parser: Shift 'onconf', go to state 274
parser: Reduce [autoinc ::=], go to state 274.
parser: Shift 'autoinc'
parser: Reduce [ccons ::= PRIMARY KEY sortorder onconf autoinc], go to state 119.
parser: Shift 'ccons'
parser: Reduce [carglist ::= carglist ccons], go to state 311.
parser: Shift 'carglist', go to state 119
parser: Reduce [columnlist ::= columnname carglist], go to state 111.
parser: Shift 'columnlist', go to state 300
parser: Shift 'COMMA', go to state 21
parser: Return. Stack=[explain create_table LP columnlist COMMA]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP columnlist COMMA ID]
parser: Input 'RP'
parser: Reduce [nm ::= ID|INDEXED], go to state 21.
parser: Shift 'nm', go to state 148
parser: Reduce [typetoken ::=], go to state 148.
parser: Shift 'typetoken'
parser: Reduce [columnname ::= nm typetoken], go to state 21.
parser: Shift 'columnname', go to state 314
parser: Reduce [carglist ::=], go to state 314.
parser: Shift 'carglist', go to state 120
parser: Reduce [columnlist ::= columnlist COMMA columnname carglist], go to state 111.
parser: Shift 'columnlist', go to state 300
parser: Reduce [conslist_opt ::=], go to state 300.
parser: Shift 'conslist_opt', go to state 437
parser: Shift 'RP', go to state 299
parser: Return. Stack=[explain create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI'
parser: Reduce [table_options ::=], go to state 299.
parser: Shift 'table_options'
parser: Reduce [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 234.
parser: Shift 'create_table_args'
parser: Reduce [cmd ::= create_table create_table_args], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
   9 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s7[numbers](8)
   6 Column           0    3    2               00 r[2]=sqlite_master.rootpage
REG[2] =  i:3
   7 Column           0    4    3               00 r[3]=sqlite_master.sql
REG[3] =   s34[CREATE TABLE nu](8)
   8 ResultRow        1    3    0               00 output=r[1..3]
REG[1] =   s7[numbers](8)
REG[2] =  i:3
REG[3] =   s34[CREATE TABLE nu](8)
parser: Initialize. Empty stack. State 0
parser: Input 'CREATE'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Shift 'CREATE'
parser: Return. Stack=[explain CREATE]
parser: Input 'TABLE'
parser: Reduce [createkw ::= CREATE], go to state 2.
parser: Shift 'createkw', go to state 107
parser: Reduce [temp ::=], go to state 107.
parser: Shift 'temp', go to state 319
parser: Shift 'TABLE', go to state 266
parser: Return. Stack=[explain createkw temp TABLE]
parser: Input 'ID'
parser: Reduce [ifnotexists ::=], go to state 266.
parser: Shift 'ifnotexists', go to state 183
parser: Shift 'ID'
parser: Return. Stack=[explain createkw temp TABLE ifnotexists ID]
parser: Input 'LP'
parser: Reduce [nm ::= ID|INDEXED], go to state 183.
parser: Shift 'nm', go to state 265
parser: Reduce [dbnm ::=], go to state 265.
parser: Shift 'dbnm'
parser: Reduce [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 2.
parser: Shift 'create_table', go to state 234
parser: Shift 'LP', go to state 111
parser: Return. Stack=[explain create_table LP]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP ID]
parser: Input 'ID'
parser: Reduce [nm ::= ID|INDEXED], go to state 111.
parser: Shift 'nm', go to state 148
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP nm ID]
parser: Input 'COMMA'
parser: Reduce [typename ::= ID|STRING], go to state 148.
parser: Shift 'typename', go to state 321
parser: Reduce [typetoken ::= typename], go to state 148.
parser: Shift 'typetoken'
parser: Reduce [columnname ::= nm typetoken], go to state 111.
parser: Shift 'columnname', go to state 311
parser: Reduce [carglist ::=], go to state 311.
parser: Shift 'carglist', go to state 119
parser: Reduce [columnlist ::= columnname carglist], go to state 111.
parser: Shift 'columnlist', go to state 300
parser: Shift 'COMMA', go to state 21
parser: Return. Stack=[explain create_table LP columnlist COMMA]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP columnlist COMMA ID]
parser: Input 'ID'
parser: Reduce [nm ::= ID|INDEXED], go to state 21.
parser: Shift 'nm', go to state 148
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP columnlist COMMA nm ID]
parser: Input 'RP'
parser: Reduce [typename ::= ID|STRING], go to state 148.
parser: Shift 'typename', go to state 321
parser: Reduce [typetoken ::= typename], go to state 148.
parser: Shift 'typetoken'
parser: Reduce [columnname ::= nm typetoken], go to state 21.
parser: Shift 'columnname', go to state 314
parser: Reduce [carglist ::=], go to state 314.
parser: Shift 'carglist', go to state 120
parser: Reduce [columnlist ::= columnlist COMMA columnname carglist], go to state 111.
parser: Shift 'columnlist', go to state 300
parser: Reduce [conslist_opt ::=], go to state 300.
parser: Shift 'conslist_opt', go to state 437
parser: Shift 'RP', go to state 299
parser: Return. Stack=[explain create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI'
parser: Reduce [table_options ::=], go to state 299.
parser: Shift 'table_options'
parser: Reduce [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 234.
parser: Shift 'create_table_args'
parser: Reduce [cmd ::= create_table create_table_args], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
   9 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s2[t2](8)
   6 Column           0    3    2               00 r[2]=sqlite_master.rootpage
REG[2] =  i:4
   7 Column           0    4    3               00 r[3]=sqlite_master.sql
REG[3] =   s24[CREATE INDEX t2](8)
   8 ResultRow        1    3    0               00 output=r[1..3]
REG[1] =   s2[t2](8)
REG[2] =  i:4
REG[3] =   s24[CREATE INDEX t2](8)
parser: Initialize. Empty stack. State 0
parser: Input 'CREATE'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Shift 'CREATE'
parser: Return. Stack=[explain CREATE]
parser: Input 'INDEX'
parser: Reduce [createkw ::= CREATE], go to state 2.
parser: Shift 'createkw', go to state 107
parser: Reduce [uniqueflag ::=], go to state 107.
parser: Shift 'uniqueflag', go to state 370
parser: Shift 'INDEX', go to state 256
parser: Return. Stack=[explain createkw uniqueflag INDEX]
parser: Input 'ID'
parser: Reduce [ifnotexists ::=], go to state 256.
parser: Shift 'ifnotexists', go to state 180
parser: Shift 'ID'
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists ID]
parser: Input 'ON'
parser: Reduce [nm ::= ID|INDEXED], go to state 180.
parser: Shift 'nm', go to state 255
parser: Reduce [dbnm ::=], go to state 255.
parser: Shift 'dbnm', go to state 369
parser: Shift 'ON', go to state 179
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON ID]
parser: Input 'LP'
parser: Reduce [nm ::= ID|INDEXED], go to state 179.
parser: Shift 'nm', go to state 368
parser: Shift 'LP', go to state 12
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP ID]
parser: Input 'RP'
parser: Reduce [expr ::= ID|INDEXED], go to state 12.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 12.
parser: Shift 'sortlist', go to state 325
parser: Shift 'RP', go to state 254
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP]
parser: Input 'SEMI'
parser: Reduce [where_opt ::=], go to state 254.
parser: Shift 'where_opt'
parser: Reduce [cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
   9 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s2[t3](8)
   6 Column           0    3    2               00 r[2]=sqlite_master.rootpage
REG[2] =  i:0
   7 Column           0    4    3               00 r[3]=sqlite_master.sql
REG[3] =   s189[CREATE VIEW t3 ](8)
   8 ResultRow        1    3    0               00 output=r[1..3]
REG[1] =   s2[t3](8)
REG[2] =  i:0
REG[3] =   s189[CREATE VIEW t3 ](8)
parser: Initialize. Empty stack. State 0
parser: Input 'CREATE'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Shift 'CREATE'
parser: Return. Stack=[explain CREATE]
parser: Input 'VIEW'
parser: Reduce [createkw ::= CREATE], go to state 2.
parser: Shift 'createkw', go to state 107
parser: FALLBACK VIEW => ID
parser: Reduce [temp ::=], go to state 107.
parser: Shift 'temp', go to state 319
parser: Shift 'VIEW', go to state 264
parser: Return. Stack=[explain createkw temp VIEW]
parser: Input 'ID'
parser: Reduce [ifnotexists ::=], go to state 264.
parser: Shift 'ifnotexists', go to state 182
parser: Shift 'ID'
parser: Return. Stack=[explain createkw temp VIEW ifnotexists ID]
parser: Input 'AS'
parser: Reduce [nm ::= ID|INDEXED], go to state 182.
parser: Shift 'nm', go to state 263
parser: Reduce [dbnm ::=], go to state 263.
parser: Shift 'dbnm', go to state 262
parser: Reduce [eidlist_opt ::=], go to state 262.
parser: Shift 'eidlist_opt', go to state 377
parser: Shift 'AS', go to state 152
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS]
parser: Input 'SELECT'
parser: Reduce [with ::=], go to state 152.
parser: Shift 'with', go to state 113
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp ID]
parser: Input 'ID'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Shift 'ID'
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr ID]
parser: Input 'COMMA'
parser: Reduce [as ::= ID|STRING], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp ID]
parser: Input 'ID'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Shift 'ID'
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr ID]
parser: Input 'COMMA'
parser: Reduce [as ::= ID|STRING], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct selcollist COMMA]
parser: Input 'STRING'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp STRING]
parser: Input 'CONCAT'
parser: Reduce [term ::= STRING], go to state 54.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 54.
parser: Shift 'expr', go to state 8
parser: Shift 'CONCAT', go to state 86
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID]
parser: Input 'LP'
parser: Shift 'LP', go to state 216
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP]
parser: Input 'STRING'
parser: Reduce [distinct ::=], go to state 216.
parser: Shift 'distinct', go to state 6
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP distinct STRING]
parser: Input 'COMMA'
parser: Reduce [term ::= STRING], go to state 6.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 6.
parser: Shift 'expr', go to state 48
parser: Reduce [nexprlist ::= expr], go to state 6.
parser: Shift 'nexprlist', go to state 412
parser: Shift 'COMMA', go to state 70
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP distinct nexprlist COMMA]
parser: Input 'INTEGER'
parser: Shift 'INTEGER'
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP distinct nexprlist COMMA INTEGER]
parser: Input 'PLUS'
parser: Reduce [term ::= INTEGER|FLOAT|BLOB], go to state 70.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 70.
parser: Shift 'expr', go to state 43
parser: Shift 'PLUS', go to state 88
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP distinct nexprlist COMMA expr PLUS]
parser: Input 'LP'
parser: Shift 'LP', go to state 3
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP distinct nexprlist COMMA expr PLUS LP]
parser: Input 'LP'
parser: Shift 'LP', go to state 3
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP distinct nexprlist COMMA expr PLUS LP LP]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP distinct nexprlist COMMA expr PLUS LP LP ID]
parser: Input 'MINUS'
parser: Reduce [expr ::= ID|INDEXED], go to state 3.
parser: Shift 'expr', go to state 30
parser: Shift 'MINUS', go to state 88
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP distinct nexprlist COMMA expr PLUS LP LP expr MINUS]
parser: Input 'INTEGER'
parser: Shift 'INTEGER'
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP distinct nexprlist COMMA expr PLUS LP LP expr MINUS INTEGER]
parser: Input 'RP'
parser: Reduce [term ::= INTEGER|FLOAT|BLOB], go to state 88.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 88.
parser: Shift 'expr', go to state 105
parser: Reduce [expr ::= expr PLUS|MINUS expr], go to state 3.
parser: Shift 'expr', go to state 30
parser: Shift 'RP'
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP distinct nexprlist COMMA expr PLUS LP LP expr RP]
parser: Input 'SLASH'
parser: Reduce [expr ::= LP expr RP], go to state 3.
parser: Shift 'expr', go to state 30
parser: Shift 'SLASH', go to state 87
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP distinct nexprlist COMMA expr PLUS LP expr SLASH]
parser: Input 'INTEGER'
parser: Shift 'INTEGER'
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP distinct nexprlist COMMA expr PLUS LP expr SLASH INTEGER]
parser: Input 'RP'
parser: Reduce [term ::= INTEGER|FLOAT|BLOB], go to state 87.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 87.
parser: Shift 'expr', go to state 112
parser: Reduce [expr ::= expr STAR|SLASH|REM expr], go to state 3.
parser: Shift 'expr', go to state 30
parser: Shift 'RP'
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP distinct nexprlist COMMA expr PLUS LP expr RP]
parser: Input 'COMMA'
parser: Reduce [expr ::= LP expr RP], go to state 88.
parser: Shift 'expr', go to state 105
parser: Reduce [expr ::= expr PLUS|MINUS expr], go to state 70.
parser: Shift 'expr', go to state 43
parser: Reduce [nexprlist ::= nexprlist COMMA expr], go to state 6.
parser: Shift 'nexprlist', go to state 412
parser: Shift 'COMMA', go to state 70
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP distinct nexprlist COMMA]
parser: Input 'INTEGER'
parser: Shift 'INTEGER'
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP distinct nexprlist COMMA INTEGER]
parser: Input 'RP'
parser: Reduce [term ::= INTEGER|FLOAT|BLOB], go to state 70.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 70.
parser: Shift 'expr', go to state 43
parser: Reduce [nexprlist ::= nexprlist COMMA expr], go to state 6.
parser: Shift 'nexprlist', go to state 412
parser: Reduce [exprlist ::= nexprlist], go to state 6.
parser: Shift 'exprlist', go to state 394
parser: Shift 'RP'
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP distinct exprlist RP]
parser: Input 'CONCAT'
parser: Reduce [expr ::= ID|INDEXED LP distinct exprlist RP], go to state 86.
parser: Shift 'expr', go to state 114
parser: Reduce [expr ::= expr CONCAT expr], go to state 54.
parser: Shift 'expr', go to state 8
parser: Shift 'CONCAT', go to state 86
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID]
parser: Input 'LP'
parser: Shift 'LP', go to state 216
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP]
parser: Input 'STRING'
parser: Reduce [distinct ::=], go to state 216.
parser: Shift 'distinct', go to state 6
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP distinct STRING]
parser: Input 'COMMA'
parser: Reduce [term ::= STRING], go to state 6.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 6.
parser: Shift 'expr', go to state 48
parser: Reduce [nexprlist ::= expr], go to state 6.
parser: Shift 'nexprlist', go to state 412
parser: Shift 'COMMA', go to state 70
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP distinct nexprlist COMMA]
parser: Input 'INTEGER'
parser: Shift 'INTEGER'
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP distinct nexprlist COMMA INTEGER]
parser: Input 'PLUS'
parser: Reduce [term ::= INTEGER|FLOAT|BLOB], go to state 70.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 70.
parser: Shift 'expr', go to state 43
parser: Shift 'PLUS', go to state 88
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP distinct nexprlist COMMA expr PLUS]
parser: Input 'LP'
parser: Shift 'LP', go to state 3
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP distinct nexprlist COMMA expr PLUS LP]
parser: Input 'LP'
parser: Shift 'LP', go to state 3
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP distinct nexprlist COMMA expr PLUS LP LP]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP distinct nexprlist COMMA expr PLUS LP LP ID]
parser: Input 'MINUS'
parser: Reduce [expr ::= ID|INDEXED], go to state 3.
parser: Shift 'expr', go to state 30
parser: Shift 'MINUS', go to state 88
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP distinct nexprlist COMMA expr PLUS LP LP expr MINUS]
parser: Input 'INTEGER'
parser: Shift 'INTEGER'
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP distinct nexprlist COMMA expr PLUS LP LP expr MINUS INTEGER]
parser: Input 'RP'
parser: Reduce [term ::= INTEGER|FLOAT|BLOB], go to state 88.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 88.
parser: Shift 'expr', go to state 105
parser: Reduce [expr ::= expr PLUS|MINUS expr], go to state 3.
parser: Shift 'expr', go to state 30
parser: Shift 'RP'
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP distinct nexprlist COMMA expr PLUS LP LP expr RP]
parser: Input 'REM'
parser: Reduce [expr ::= LP expr RP], go to state 3.
parser: Shift 'expr', go to state 30
parser: Shift 'REM', go to state 87
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP distinct nexprlist COMMA expr PLUS LP expr REM]
parser: Input 'INTEGER'
parser: Shift 'INTEGER'
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP distinct nexprlist COMMA expr PLUS LP expr REM INTEGER]
parser: Input 'RP'
parser: Reduce [term ::= INTEGER|FLOAT|BLOB], go to state 87.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 87.
parser: Shift 'expr', go to state 112
parser: Reduce [expr ::= expr STAR|SLASH|REM expr], go to state 3.
parser: Shift 'expr', go to state 30
parser: Shift 'RP'
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP distinct nexprlist COMMA expr PLUS LP expr RP]
parser: Input 'COMMA'
parser: Reduce [expr ::= LP expr RP], go to state 88.
parser: Shift 'expr', go to state 105
parser: Reduce [expr ::= expr PLUS|MINUS expr], go to state 70.
parser: Shift 'expr', go to state 43
parser: Reduce [nexprlist ::= nexprlist COMMA expr], go to state 6.
parser: Shift 'nexprlist', go to state 412
parser: Shift 'COMMA', go to state 70
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP distinct nexprlist COMMA]
parser: Input 'INTEGER'
parser: Shift 'INTEGER'
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP distinct nexprlist COMMA INTEGER]
parser: Input 'RP'
parser: Reduce [term ::= INTEGER|FLOAT|BLOB], go to state 70.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 70.
parser: Shift 'expr', go to state 43
parser: Reduce [nexprlist ::= nexprlist COMMA expr], go to state 6.
parser: Shift 'nexprlist', go to state 412
parser: Reduce [exprlist ::= nexprlist], go to state 6.
parser: Shift 'exprlist', go to state 394
parser: Shift 'RP'
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr CONCAT ID LP distinct exprlist RP]
parser: Input 'ID'
parser: Reduce [expr ::= ID|INDEXED LP distinct exprlist RP], go to state 86.
parser: Shift 'expr', go to state 114
parser: Reduce [expr ::= expr CONCAT expr], go to state 54.
parser: Shift 'expr', go to state 8
parser: Shift 'ID'
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct sclp expr ID]
parser: Input 'FROM'
parser: Reduce [as ::= ID|STRING], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct selcollist FROM]
parser: Input 'ID'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'ID'
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'WHERE'
parser: Reduce [nm ::= ID|INDEXED], go to state 165.
parser: Shift 'nm', go to state 287
parser: Reduce [dbnm ::=], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Shift 'WHERE', go to state 65
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct selcollist from WHERE]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS with SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'SEMI'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Reduce [where_opt ::= WHERE expr], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Reduce [orderby_opt ::=], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 113.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 113.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 152.
parser: Shift 'select'
parser: Reduce [cmd ::= createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
   9 Next             0    5    0               01 
  10 Close            0    0    0               00 
  11 Halt             0    0    0               00 
parser: Initialize. Empty stack. State 0
parser: Input 'CREATE'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Shift 'CREATE'
parser: Return. Stack=[explain CREATE]
parser: Input 'TABLE'
parser: Reduce [createkw ::= CREATE], go to state 2.
parser: Shift 'createkw', go to state 107
parser: Reduce [temp ::=], go to state 107.
parser: Shift 'temp', go to state 319
parser: Shift 'TABLE', go to state 266
parser: Return. Stack=[explain createkw temp TABLE]
parser: Input 'ID'
parser: Reduce [ifnotexists ::=], go to state 266.
parser: Shift 'ifnotexists', go to state 183
parser: Shift 'ID'
parser: Return. Stack=[explain createkw temp TABLE ifnotexists ID]
parser: Input 'LP'
parser: Reduce [nm ::= ID|INDEXED], go to state 183.
parser: Shift 'nm', go to state 265
parser: Reduce [dbnm ::=], go to state 265.
parser: Shift 'dbnm'
parser: Reduce [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 2.
parser: Shift 'create_table', go to state 234
parser: Shift 'LP', go to state 111
parser: Return. Stack=[explain create_table LP]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP ID]
parser: Input 'ID'
parser: Reduce [nm ::= ID|INDEXED], go to state 111.
parser: Shift 'nm', go to state 148
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP nm ID]
parser: Input 'COMMA'
parser: Reduce [typename ::= ID|STRING], go to state 148.
parser: Shift 'typename', go to state 321
parser: Reduce [typetoken ::= typename], go to state 148.
parser: Shift 'typetoken'
parser: Reduce [columnname ::= nm typetoken], go to state 111.
parser: Shift 'columnname', go to state 311
parser: Reduce [carglist ::=], go to state 311.
parser: Shift 'carglist', go to state 119
parser: Reduce [columnlist ::= columnname carglist], go to state 111.
parser: Shift 'columnlist', go to state 300
parser: Shift 'COMMA', go to state 21
parser: Return. Stack=[explain create_table LP columnlist COMMA]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP columnlist COMMA ID]
parser: Input 'ID'
parser: Reduce [nm ::= ID|INDEXED], go to state 21.
parser: Shift 'nm', go to state 148
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP columnlist COMMA nm ID]
parser: Input 'COMMA'
parser: Reduce [typename ::= ID|STRING], go to state 148.
parser: Shift 'typename', go to state 321
parser: Reduce [typetoken ::= typename], go to state 148.
parser: Shift 'typetoken'
parser: Reduce [columnname ::= nm typetoken], go to state 21.
parser: Shift 'columnname', go to state 314
parser: Reduce [carglist ::=], go to state 314.
parser: Shift 'carglist', go to state 120
parser: Reduce [columnlist ::= columnlist COMMA columnname carglist], go to state 111.
parser: Shift 'columnlist', go to state 300
parser: Shift 'COMMA', go to state 21
parser: Return. Stack=[explain create_table LP columnlist COMMA]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP columnlist COMMA ID]
parser: Input 'ID'
parser: Reduce [nm ::= ID|INDEXED], go to state 21.
parser: Shift 'nm', go to state 148
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP columnlist COMMA nm ID]
parser: Input 'COMMA'
parser: Reduce [typename ::= ID|STRING], go to state 148.
parser: Shift 'typename', go to state 321
parser: Reduce [typetoken ::= typename], go to state 148.
parser: Shift 'typetoken'
parser: Reduce [columnname ::= nm typetoken], go to state 21.
parser: Shift 'columnname', go to state 314
parser: Reduce [carglist ::=], go to state 314.
parser: Shift 'carglist', go to state 120
parser: Reduce [columnlist ::= columnlist COMMA columnname carglist], go to state 111.
parser: Shift 'columnlist', go to state 300
parser: Shift 'COMMA', go to state 21
parser: Return. Stack=[explain create_table LP columnlist COMMA]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP columnlist COMMA ID]
parser: Input 'ID'
parser: Reduce [nm ::= ID|INDEXED], go to state 21.
parser: Shift 'nm', go to state 148
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP columnlist COMMA nm ID]
parser: Input 'COMMA'
parser: Reduce [typename ::= ID|STRING], go to state 148.
parser: Shift 'typename', go to state 321
parser: Reduce [typetoken ::= typename], go to state 148.
parser: Shift 'typetoken'
parser: Reduce [columnname ::= nm typetoken], go to state 21.
parser: Shift 'columnname', go to state 314
parser: Reduce [carglist ::=], go to state 314.
parser: Shift 'carglist', go to state 120
parser: Reduce [columnlist ::= columnlist COMMA columnname carglist], go to state 111.
parser: Shift 'columnlist', go to state 300
parser: Shift 'COMMA', go to state 21
parser: Return. Stack=[explain create_table LP columnlist COMMA]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP columnlist COMMA ID]
parser: Input 'ID'
parser: Reduce [nm ::= ID|INDEXED], go to state 21.
parser: Shift 'nm', go to state 148
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP columnlist COMMA nm ID]
parser: Input 'RP'
parser: Reduce [typename ::= ID|STRING], go to state 148.
parser: Shift 'typename', go to state 321
parser: Reduce [typetoken ::= typename], go to state 148.
parser: Shift 'typetoken'
parser: Reduce [columnname ::= nm typetoken], go to state 21.
parser: Shift 'columnname', go to state 314
parser: Reduce [carglist ::=], go to state 314.
parser: Shift 'carglist', go to state 120
parser: Reduce [columnlist ::= columnlist COMMA columnname carglist], go to state 111.
parser: Shift 'columnlist', go to state 300
parser: Reduce [conslist_opt ::=], go to state 300.
parser: Shift 'conslist_opt', go to state 437
parser: Shift 'RP', go to state 299
parser: Return. Stack=[explain create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI'
parser: Reduce [table_options ::=], go to state 299.
parser: Shift 'table_options'
parser: Reduce [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 234.
parser: Shift 'create_table_args'
parser: Reduce [cmd ::= create_table create_table_args], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'INSERT'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'INSERT', go to state 253
parser: Return. Stack=[explain with INSERT]
parser: Input 'INTO'
parser: Reduce [orconf ::=], go to state 253.
parser: Shift 'orconf'
parser: Reduce [insert_cmd ::= INSERT orconf], go to state 22.
parser: Shift 'insert_cmd', go to state 351
parser: Shift 'INTO', go to state 127
parser: Return. Stack=[explain with insert_cmd INTO]
parser: Input 'STRING'
parser: Shift 'STRING'
parser: Return. Stack=[explain with insert_cmd INTO STRING]
parser: Input 'DOT'
parser: Reduce [nm ::= STRING], go to state 127.
parser: Shift 'nm', go to state 259
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[explain with insert_cmd INTO nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with insert_cmd INTO nm DOT ID]
parser: Input 'VALUES'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 259.
parser: Shift 'dbnm'
parser: Reduce [fullname ::= nm dbnm], go to state 127.
parser: Shift 'fullname', go to state 241
parser: Reduce [idlist_opt ::=], go to state 241.
parser: Shift 'idlist_opt', go to state 147
parser: Reduce [with ::=], go to state 147.
parser: Shift 'with', go to state 113
parser: Shift 'VALUES', go to state 397
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES]
parser: Input 'LP'
parser: Shift 'LP', go to state 15
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP STRING]
parser: Input 'COMMA'
parser: Reduce [term ::= STRING], go to state 15.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 15.
parser: Shift 'expr', go to state 48
parser: Reduce [nexprlist ::= expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'COMMA', go to state 70
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA STRING]
parser: Input 'COMMA'
parser: Reduce [term ::= STRING], go to state 70.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 70.
parser: Shift 'expr', go to state 43
parser: Reduce [nexprlist ::= nexprlist COMMA expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'COMMA', go to state 70
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA STRING]
parser: Input 'COMMA'
parser: Reduce [term ::= STRING], go to state 70.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 70.
parser: Shift 'expr', go to state 43
parser: Reduce [nexprlist ::= nexprlist COMMA expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'COMMA', go to state 70
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA]
parser: Input 'VARIABLE'
parser: Shift 'VARIABLE'
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA VARIABLE]
parser: Input 'COMMA'
parser: Reduce [expr ::= VARIABLE], go to state 70.
parser: Shift 'expr', go to state 43
parser: Reduce [nexprlist ::= nexprlist COMMA expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'COMMA', go to state 70
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA STRING]
parser: Input 'RP'
parser: Reduce [term ::= STRING], go to state 70.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 70.
parser: Shift 'expr', go to state 43
parser: Reduce [nexprlist ::= nexprlist COMMA expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'RP'
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist RP]
parser: Input 'SEMI'
parser: Reduce [values ::= VALUES LP nexprlist RP], go to state 113.
parser: Shift 'values', go to state 400
parser: Reduce [oneselect ::= values], go to state 113.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 113.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 147.
parser: Shift 'select'
parser: Reduce [cmd ::= with insert_cmd INTO fullname idlist_opt select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Input '$'
parser: Reduce [ecmd ::= explain cmdx SEMI], go to state 0.
parser: Shift 'ecmd'
parser: Reduce [cmdlist ::= ecmd], go to state 0.
parser: Shift 'cmdlist', go to state 146
parser: Reduce [input ::= cmdlist], go to state 0.
parser: Accept!
parser: Popping $
parser: Return. Stack=]
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
SQL: [CREATE INDEX t4 ON t1(a);]
VDBE Trace:
   0 Init             0   34    0               00 Start at 34
  34 Transaction      0    1    4 2             01 usesStmtJournal=0
  35 TableLock        0    1    1 sqlite_master 00 iDb=0 root=1 write=1
  36 TableLock        0    2    1 t1            00 iDb=0 root=2 write=1
  37 Goto             0    1    0               00 
   1 Noop             0   33    0               00 
   2 CreateIndex      0    1    0               00 r[1]=root iDb=0
REG[1] =  i:5
   3 OpenWrite        0    1    0 5             00 root=1 iDb=0; sqlite_master
   4 NewRowid         0    2    0               00 r[2]=rowid
REG[2] =  i:5
   5 String8          0    3    0 index         00 r[3]='index'
REG[3] =   t5[index](8)
   6 String8          0    4    0 t4            00 r[4]='t4'
REG[4] =   t2[t4](8)
   7 String8          0    5    0 t1            00 r[5]='t1'
REG[5] =   t2[t1](8)
   8 Copy             1    6    0               00 r[6]=r[1]
REG[6] =  i:5
   9 String8          0    7    0 CREATE INDEX t4 ON t1(a) 00 r[7]='CREATE INDEX t4 ON t1(a)'
REG[7] =   t24[CREATE INDEX t4](8)
  10 MakeRecord       3    5    8 BBBDB         00 r[8]=mkrec(r[3..7])
REG[8] =  s40[06171111013D696E6465787434743105.....=indext4t1.](8)
  11 Insert           0    8    2               18 intkey=r[2] data=r[8]
REG[8] =  s40[06171111013D696E6465787434743105.....=indext4t1.](8)
REG[2] =  i:5
  12 Close            0    0    0               00 
  13 SorterOpen       3    0    1 k(2,,)        00 
  14 OpenRead         1    2    0 2             00 root=2 iDb=0; t1
  15 Rewind           1   21    0               00 
  16 Rowid            1   10    0               00 r[10]=rowid; t1.a
REG[10] =  i:1
  17 Rowid            1   11    0               00 r[11]=rowid
REG[11] =  i:1
  18 MakeRecord      10    2    9               00 r[9]=mkrec(r[10..11])
REG[9] =  s3[030909...](8)
  19 SorterInsert     3    9    0               00 
REG[9] =  s3[030909...](8)
  20 Next             1   16    0               00 
  21 OpenWrite        2    1    0 k(2,,)        11 root=1 iDb=0
  22 SorterSort       3   27    0               00 
  23 SorterData       3    9    2               00 r[9]=data
  24 Last             2    0   -1               00 
  25 IdxInsert        2    9    0               10 key=r[9]
REG[9] =  s3[030909...](8)
  26 SorterNext       3   23    0               00 
  27 Close            1    0    0               00 
  28 Close            2    0    0               00 
  29 Close            3    0    0               00 
  30 SetCookie        0    1    5               00 
  31 ParseSchema      0    0    0 name='t4' AND type='index' 00 
parser: Initialize. Empty stack. State 0
parser: Input 'SELECT'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[explain with SELECT]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'FROM'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[explain with SELECT distinct selcollist FROM]
parser: Input 'STRING'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'STRING'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix STRING]
parser: Input 'DOT'
parser: Reduce [nm ::= STRING], go to state 165.
parser: Shift 'nm', go to state 287
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Shift 'WHERE', go to state 65
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'AND', go to state 93
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 93.
parser: Shift 'expr', go to state 53
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND expr EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND expr EQ STRING]
parser: Input 'ORDER'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 93.
parser: Shift 'expr', go to state 53
parser: Reduce [expr ::= expr AND expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Reduce [where_opt ::= WHERE expr], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Shift 'ORDER', go to state 411
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY'
parser: Shift 'BY', go to state 17
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI'
parser: Reduce [expr ::= ID|INDEXED], go to state 17.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 17.
parser: Shift 'sortlist', go to state 410
parser: Reduce [orderby_opt ::= ORDER BY sortlist], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 22.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 2.
parser: Shift 'select'
parser: Reduce [cmd ::= select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
VDBE Trace:
   0 Init             0   16    0               00 Start at 16
  16 Transaction      0    0    5 2             00 usesStmtJournal=0
  17 TableLock        0    1    0 sqlite_master 00 iDb=0 root=1 write=0
  18 String8          0    2    0 t4            00 r[2]='t4'
REG[2] =   t2[t4](8)
  19 String8          0    4    0 index         00 r[4]='index'
REG[4] =   t5[index](8)
  20 Goto             0    1    0               00 
   1 Noop             1    5    0               00 
   2 OpenRead         0    1    0 5             00 root=1 iDb=0; sqlite_master
   3 Explain          0    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   14    0               00 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s2[t1](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t2[t4](8)
REG[1] =   s2[t1](8)
  13 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s7[numbers](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t2[t4](8)
REG[1] =   s7[numbers](8)
  13 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s2[t2](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t2[t4](8)
REG[1] =   s2[t2](8)
  13 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s2[t3](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t2[t4](8)
REG[1] =   s2[t3](8)
  13 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s2[t4](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t2[t4](8)
REG[1] =   s2[t4](8)
   7 Column           0    0    3               00 r[3]=sqlite_master.type
REG[3] =   s5[index](8)
   8 Ne               4   13    3 (BINARY)      52 if r[4]!=r[3] goto 13
REG[4] =   t5[index](8)
REG[3] =   s5[index](8)
   9 Copy             1    5    0               00 r[5]=r[1]
REG[5] =   s2[t4](8)
  10 Column           0    3    6               00 r[6]=sqlite_master.rootpage
REG[6] =  i:5
  11 Column           0    4    7               00 r[7]=sqlite_master.sql
REG[7] =   s24[CREATE INDEX t4](8)
  12 ResultRow        5    3    0               00 output=r[5..7]
REG[5] =   s2[t4](8)
REG[6] =  i:5
REG[7] =   s24[CREATE INDEX t4](8)
parser: Initialize. Empty stack. State 0
parser: Input 'CREATE'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Shift 'CREATE'
parser: Return. Stack=[explain CREATE]
parser: Input 'INDEX'
parser: Reduce [createkw ::= CREATE], go to state 2.
parser: Shift 'createkw', go to state 107
parser: Reduce [uniqueflag ::=], go to state 107.
parser: Shift 'uniqueflag', go to state 370
parser: Shift 'INDEX', go to state 256
parser: Return. Stack=[explain createkw uniqueflag INDEX]
parser: Input 'ID'
parser: Reduce [ifnotexists ::=], go to state 256.
parser: Shift 'ifnotexists', go to state 180
parser: Shift 'ID'
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists ID]
parser: Input 'ON'
parser: Reduce [nm ::= ID|INDEXED], go to state 180.
parser: Shift 'nm', go to state 255
parser: Reduce [dbnm ::=], go to state 255.
parser: Shift 'dbnm', go to state 369
parser: Shift 'ON', go to state 179
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON ID]
parser: Input 'LP'
parser: Reduce [nm ::= ID|INDEXED], go to state 179.
parser: Shift 'nm', go to state 368
parser: Shift 'LP', go to state 12
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP ID]
parser: Input 'RP'
parser: Reduce [expr ::= ID|INDEXED], go to state 12.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 12.
parser: Shift 'sortlist', go to state 325
parser: Shift 'RP', go to state 254
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP]
parser: Input 'SEMI'
parser: Reduce [where_opt ::=], go to state 254.
parser: Shift 'where_opt'
parser: Reduce [cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
  13 Next             0    5    0               01 
  14 Close            0    0    0               00 
  15 Halt             0    0    0               00 
  32 Expire           0    0    0               00 
  33 Halt             0    0    0               00 
parser: Initialize. Empty stack. State 0
parser: Input 'ATTACH'
parser: FALLBACK ATTACH => ID
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Shift 'ATTACH', go to state 239
parser: Return. Stack=[explain ATTACH]
parser: Input 'STRING'
parser: Reduce [database_kw_opt ::=], go to state 239.
parser: Shift 'database_kw_opt', go to state 58
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain ATTACH database_kw_opt STRING]
parser: Input 'AS'
parser: Reduce [term ::= STRING], go to state 58.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 58.
parser: Shift 'expr', go to state 26
parser: Shift 'AS', go to state 57
parser: Return. Stack=[explain ATTACH database_kw_opt expr AS]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain ATTACH database_kw_opt expr AS ID]
parser: Input 'SEMI'
parser: Reduce [expr ::= ID|INDEXED], go to state 57.
parser: Shift 'expr', go to state 11
parser: Reduce [key_opt ::=], go to state 11.
parser: Shift 'key_opt'
parser: Reduce [cmd ::= ATTACH database_kw_opt expr AS expr key_opt], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
SQL: [ATTACH 'test.db3' AS at2;]
VDBE Trace:
   0 Init             0    0    0               00 Start at 0
   1 String8          0    1    0 test.db3      00 r[1]='test.db3'
REG[1] =   t8[test.db3](8)
   2 String8          0    2    0 at2           00 r[2]='at2'
REG[2] =   t3[at2](8)
   3 Null             0    3    0               00 r[3]=NULL
REG[3] =  NULL
   4 Function0        0    1    4 sqlite_attach(3) 03 r[4]=func(r[1..3])
REG[1] =   t8[test.db3](8)
REG[2] =   t3[at2](8)
REG[3] =  NULL
parser: Initialize. Empty stack. State 0
parser: Input 'SEMI'
parser: Shift 'SEMI'
parser: Return. Stack=[SEMI]
parser: Input 'SELECT'
parser: Reduce [ecmd ::= SEMI], go to state 0.
parser: Shift 'ecmd'
parser: Reduce [cmdlist ::= ecmd], go to state 0.
parser: Shift 'cmdlist', go to state 146
parser: Reduce [explain ::=], go to state 146.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[cmdlist explain with SELECT]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct sclp ID]
parser: Input 'FROM'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist FROM]
parser: Input 'ID'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'ID'
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'DOT'
parser: Reduce [nm ::= ID|INDEXED], go to state 165.
parser: Shift 'nm', go to state 287
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'ORDER'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Reduce [where_opt ::=], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Shift 'ORDER', go to state 411
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY'
parser: Shift 'BY', go to state 17
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI'
parser: Reduce [expr ::= ID|INDEXED], go to state 17.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 17.
parser: Shift 'sortlist', go to state 410
parser: Reduce [orderby_opt ::= ORDER BY sortlist], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 22.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 2.
parser: Shift 'select'
parser: Reduce [cmd ::= select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[cmdlist explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping cmdlist
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'SEMI'
parser: Shift 'SEMI'
parser: Return. Stack=[SEMI]
parser: Input 'SEMI'
parser: Reduce [ecmd ::= SEMI], go to state 0.
parser: Shift 'ecmd'
parser: Reduce [cmdlist ::= ecmd], go to state 0.
parser: Shift 'cmdlist', go to state 146
parser: Shift 'SEMI'
parser: Return. Stack=[cmdlist SEMI]
parser: Input 'SELECT'
parser: Reduce [ecmd ::= SEMI], go to state 146.
parser: Shift 'ecmd'
parser: Reduce [cmdlist ::= cmdlist ecmd], go to state 0.
parser: Shift 'cmdlist', go to state 146
parser: Reduce [explain ::=], go to state 146.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[cmdlist explain with SELECT]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct sclp ID]
parser: Input 'FROM'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist FROM]
parser: Input 'STRING'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'STRING'
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist FROM stl_prefix STRING]
parser: Input 'DOT'
parser: Reduce [nm ::= STRING], go to state 165.
parser: Shift 'nm', go to state 287
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Shift 'WHERE', go to state 65
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'AND', go to state 93
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'NE'
parser: Reduce [expr ::= ID|INDEXED], go to state 93.
parser: Shift 'expr', go to state 53
parser: Shift 'NE', go to state 90
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE expr AND expr NE]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE expr AND expr NE STRING]
parser: Input 'ORDER'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 93.
parser: Shift 'expr', go to state 53
parser: Reduce [expr ::= expr AND expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Reduce [where_opt ::= WHERE expr], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Shift 'ORDER', go to state 411
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY'
parser: Shift 'BY', go to state 17
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI'
parser: Reduce [expr ::= ID|INDEXED], go to state 17.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 17.
parser: Shift 'sortlist', go to state 410
parser: Reduce [orderby_opt ::= ORDER BY sortlist], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 22.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 2.
parser: Shift 'select'
parser: Reduce [cmd ::= select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[cmdlist explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping cmdlist
parser: Popping $
SQL: [;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='numbers' AND type!='trigger' ORDER BY rowid;]
VDBE Trace:
   0 Init             0   16    0               00 Start at 16
  16 Transaction      0    0    5 2             01 usesStmtJournal=0
  17 TableLock        0    1    0 sqlite_master 00 iDb=0 root=1 write=0
  18 String8          0    2    0 numbers       00 r[2]='numbers'
REG[2] =   t7[numbers](8)
  19 String8          0    4    0 trigger       00 r[4]='trigger'
REG[4] =   t7[trigger](8)
  20 Goto             0    1    0               00 
   1 Noop             1    5    0               00 
   2 OpenRead         0    1    0 5             00 root=1 iDb=0; sqlite_master
   3 Explain          0    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   14    0               00 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[t1](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t7[numbers](8)
REG[1] =   s2[t1](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s7[numbers](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t7[numbers](8)
REG[1] =   s7[numbers](8)
   7 Column           0    0    3               00 r[3]=sqlite_master.type
REG[3] =   s5[table](8)
   8 Eq               4   13    3 (BINARY)      52 if r[4]==r[3] goto 13
REG[4] =   t7[trigger](8)
REG[3] =   s5[table](8)
   9 Column           0    1    5               00 r[5]=sqlite_master.name
REG[5] =   s7[numbers](8)
  10 Column           0    3    6               00 r[6]=sqlite_master.rootpage
REG[6] =  i:3
  11 Column           0    4    7               00 r[7]=sqlite_master.sql
REG[7] =   s34[CREATE TABLE nu](8)
  12 ResultRow        5    3    0               00 output=r[5..7]
REG[5] =   s7[numbers](8)
REG[6] =  i:3
REG[7] =   s34[CREATE TABLE nu](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[t1](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t7[numbers](8)
REG[1] =   s2[t1](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[t3](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t7[numbers](8)
REG[1] =   s2[t3](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[t1](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t7[numbers](8)
REG[1] =   s2[t1](8)
  13 Next             0    5    0               01 
  14 Close            0    0    0               00 
  15 Halt             0    0    0               00 
parser: Initialize. Empty stack. State 0
parser: Input 'CREATE'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Shift 'CREATE'
parser: Return. Stack=[explain CREATE]
parser: Input 'TRIGGER'
parser: Reduce [createkw ::= CREATE], go to state 2.
parser: Shift 'createkw', go to state 107
parser: FALLBACK TRIGGER => ID
parser: Reduce [temp ::=], go to state 107.
parser: Shift 'temp', go to state 319
parser: Shift 'TRIGGER', go to state 261
parser: Return. Stack=[explain createkw temp TRIGGER]
parser: Input 'ID'
parser: Reduce [ifnotexists ::=], go to state 261.
parser: Shift 'ifnotexists', go to state 181
parser: Shift 'ID'
parser: Return. Stack=[explain createkw temp TRIGGER ifnotexists ID]
parser: Input 'DOT'
parser: Reduce [nm ::= ID|INDEXED], go to state 181.
parser: Shift 'nm', go to state 260
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[explain createkw temp TRIGGER ifnotexists nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain createkw temp TRIGGER ifnotexists nm DOT ID]
parser: Input 'BEFORE'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 260.
parser: Shift 'dbnm', go to state 210
parser: Shift 'BEFORE'
parser: Return. Stack=[explain createkw temp TRIGGER ifnotexists nm dbnm BEFORE]
parser: Input 'INSERT'
parser: Reduce [trigger_time ::= BEFORE], go to state 210.
parser: Shift 'trigger_time', go to state 209
parser: Shift 'INSERT'
parser: Return. Stack=[explain createkw temp TRIGGER ifnotexists nm dbnm trigger_time INSERT]
parser: Input 'ON'
parser: Reduce [trigger_event ::= DELETE|INSERT], go to state 209.
parser: Shift 'trigger_event', go to state 376
parser: Shift 'ON', go to state 141
parser: Return. Stack=[explain createkw temp TRIGGER ifnotexists nm dbnm trigger_time trigger_event ON]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain createkw temp TRIGGER ifnotexists nm dbnm trigger_time trigger_event ON ID]
parser: Input 'BEGIN'
parser: Reduce [nm ::= ID|INDEXED], go to state 141.
parser: Shift 'nm', go to state 259
parser: FALLBACK BEGIN => ID
parser: Reduce [dbnm ::=], go to state 259.
parser: Shift 'dbnm'
parser: Reduce [fullname ::= nm dbnm], go to state 141.
parser: Shift 'fullname', go to state 258
parser: FALLBACK BEGIN => ID
parser: Reduce [foreach_clause ::=], go to state 258.
parser: Shift 'foreach_clause', go to state 257
parser: FALLBACK BEGIN => ID
parser: Reduce [when_clause ::=], go to state 257.
parser: Shift 'when_clause'
parser: Reduce [trigger_decl ::= temp TRIGGER ifnotexists nm dbnm trigger_time trigger_event ON fullname foreach_clause when_clause], go to state 107.
parser: Shift 'trigger_decl', go to state 367
parser: Shift 'BEGIN', go to state 7
parser: Return. Stack=[explain createkw trigger_decl BEGIN]
parser: Input 'SELECT'
parser: Reduce [with ::=], go to state 7.
parser: Shift 'with', go to state 113
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[explain createkw trigger_decl BEGIN with SELECT]
parser: Input 'INTEGER'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'INTEGER'
parser: Return. Stack=[explain createkw trigger_decl BEGIN with SELECT distinct sclp INTEGER]
parser: Input 'SEMI'
parser: Reduce [term ::= INTEGER|FLOAT|BLOB], go to state 54.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Reduce [from ::=], go to state 232.
parser: Shift 'from', go to state 298
parser: Reduce [where_opt ::=], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Reduce [orderby_opt ::=], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 113.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 113.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 7.
parser: Shift 'select'
parser: Reduce [trigger_cmd ::= select], go to state 7.
parser: Shift 'trigger_cmd', go to state 357
parser: Shift 'SEMI'
parser: Return. Stack=[explain createkw trigger_decl BEGIN trigger_cmd SEMI]
parser: Input 'END'
parser: Reduce [trigger_cmd_list ::= trigger_cmd SEMI], go to state 7.
parser: Shift 'trigger_cmd_list', go to state 23
parser: Shift 'END'
parser: Return. Stack=[explain createkw trigger_decl BEGIN trigger_cmd_list END]
parser: Input 'SEMI'
parser: Reduce [cmd ::= createkw trigger_decl BEGIN trigger_cmd_list END], go to state 2.
parser: Initialize. Empty stack. State 0
parser: Input 'INSERT'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'INSERT', go to state 253
parser: Return. Stack=[explain with INSERT]
parser: Input 'INTO'
parser: Reduce [orconf ::=], go to state 253.
parser: Shift 'orconf'
parser: Reduce [insert_cmd ::= INSERT orconf], go to state 22.
parser: Shift 'insert_cmd', go to state 351
parser: Shift 'INTO', go to state 127
parser: Return. Stack=[explain with insert_cmd INTO]
parser: Input 'STRING'
parser: Shift 'STRING'
parser: Return. Stack=[explain with insert_cmd INTO STRING]
parser: Input 'DOT'
parser: Reduce [nm ::= STRING], go to state 127.
parser: Shift 'nm', go to state 259
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[explain with insert_cmd INTO nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with insert_cmd INTO nm DOT ID]
parser: Input 'VALUES'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 259.
parser: Shift 'dbnm'
parser: Reduce [fullname ::= nm dbnm], go to state 127.
parser: Shift 'fullname', go to state 241
parser: Reduce [idlist_opt ::=], go to state 241.
parser: Shift 'idlist_opt', go to state 147
parser: Reduce [with ::=], go to state 147.
parser: Shift 'with', go to state 113
parser: Shift 'VALUES', go to state 397
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES]
parser: Input 'LP'
parser: Shift 'LP', go to state 15
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP STRING]
parser: Input 'COMMA'
parser: Reduce [term ::= STRING], go to state 15.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 15.
parser: Shift 'expr', go to state 48
parser: Reduce [nexprlist ::= expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'COMMA', go to state 70
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA STRING]
parser: Input 'COMMA'
parser: Reduce [term ::= STRING], go to state 70.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 70.
parser: Shift 'expr', go to state 43
parser: Reduce [nexprlist ::= nexprlist COMMA expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'COMMA', go to state 70
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA STRING]
parser: Input 'COMMA'
parser: Reduce [term ::= STRING], go to state 70.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 70.
parser: Shift 'expr', go to state 43
parser: Reduce [nexprlist ::= nexprlist COMMA expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'COMMA', go to state 70
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA]
parser: Input 'INTEGER'
parser: Shift 'INTEGER'
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA INTEGER]
parser: Input 'COMMA'
parser: Reduce [term ::= INTEGER|FLOAT|BLOB], go to state 70.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 70.
parser: Shift 'expr', go to state 43
parser: Reduce [nexprlist ::= nexprlist COMMA expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'COMMA', go to state 70
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA STRING]
parser: Input 'RP'
parser: Reduce [term ::= STRING], go to state 70.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 70.
parser: Shift 'expr', go to state 43
parser: Reduce [nexprlist ::= nexprlist COMMA expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'RP'
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist RP]
parser: Input 'SEMI'
parser: Reduce [values ::= VALUES LP nexprlist RP], go to state 113.
parser: Shift 'values', go to state 400
parser: Reduce [oneselect ::= values], go to state 113.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 113.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 147.
parser: Shift 'select'
parser: Reduce [cmd ::= with insert_cmd INTO fullname idlist_opt select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Input '$'
parser: Reduce [ecmd ::= explain cmdx SEMI], go to state 0.
parser: Shift 'ecmd'
parser: Reduce [cmdlist ::= ecmd], go to state 0.
parser: Shift 'cmdlist', go to state 146
parser: Reduce [input ::= cmdlist], go to state 0.
parser: Accept!
parser: Popping $
parser: Return. Stack=]
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
SQL: [CREATE TRIGGER main.t5 BEFORE INSERT ON numbers BEGIN SELECT 1; END;]
VDBE Trace:
   0 Init             0   14    0               00 Start at 14
  14 Transaction      0    1    5 2             01 usesStmtJournal=0
  15 TableLock        0    1    1 sqlite_master 00 iDb=0 root=1 write=1
  16 Goto             0    1    0               00 
   1 OpenWrite        0    1    0 5             00 root=1 iDb=0; sqlite_master
   2 NewRowid         0    1    0               00 r[1]=rowid
REG[1] =  i:6
   3 String8          0    2    0 trigger       00 r[2]='trigger'
REG[2] =   t7[trigger](8)
   4 String8          0    3    0 t5            00 r[3]='t5'
REG[3] =   t2[t5](8)
   5 String8          0    4    0 numbers       00 r[4]='numbers'
REG[4] =   t7[numbers](8)
   6 Integer          0    5    0               00 r[5]=0
REG[5] =  i:0
   7 String8          0    6    0 CREATE TRIGGER t5 BEFORE INSERT ON numbers BEGIN SELECT 1; END 00 r[6]='CREATE TRIGGER t5 BEFORE INSERT ON numbers BEGIN SELECT 1; END'
REG[6] =   t62[CREATE TRIGGER ](8)
   8 MakeRecord       2    5    7 BBBDB         00 r[7]=mkrec(r[2..6])
REG[7] =  s85[071B111B088109747269676765727435.......triggert5](8)
   9 Insert           0    7    1               18 intkey=r[1] data=r[7]
REG[7] =  s85[071B111B088109747269676765727435.......triggert5](8)
REG[1] =  i:6
  10 Close            0    0    0               00 
  11 SetCookie        0    1    6               00 
  12 ParseSchema      0    0    0 type='trigger' AND name='t5' 00 
parser: Initialize. Empty stack. State 0
parser: Input 'SELECT'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[explain with SELECT]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'FROM'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[explain with SELECT distinct selcollist FROM]
parser: Input 'STRING'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'STRING'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix STRING]
parser: Input 'DOT'
parser: Reduce [nm ::= STRING], go to state 165.
parser: Shift 'nm', go to state 287
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Shift 'WHERE', go to state 65
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'AND', go to state 93
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 93.
parser: Shift 'expr', go to state 53
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND expr EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND expr EQ STRING]
parser: Input 'ORDER'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 93.
parser: Shift 'expr', go to state 53
parser: Reduce [expr ::= expr AND expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Reduce [where_opt ::= WHERE expr], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Shift 'ORDER', go to state 411
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY'
parser: Shift 'BY', go to state 17
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI'
parser: Reduce [expr ::= ID|INDEXED], go to state 17.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 17.
parser: Shift 'sortlist', go to state 410
parser: Reduce [orderby_opt ::= ORDER BY sortlist], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 22.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 2.
parser: Shift 'select'
parser: Reduce [cmd ::= select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
VDBE Trace:
   0 Init             0   16    0               00 Start at 16
  16 Transaction      0    0    6 2             00 usesStmtJournal=0
  17 TableLock        0    1    0 sqlite_master 00 iDb=0 root=1 write=0
  18 String8          0    2    0 trigger       00 r[2]='trigger'
REG[2] =   t7[trigger](8)
  19 String8          0    4    0 t5            00 r[4]='t5'
REG[4] =   t2[t5](8)
  20 Goto             0    1    0               00 
   1 Noop             1    5    0               00 
   2 OpenRead         0    1    0 5             00 root=1 iDb=0; sqlite_master
   3 Explain          0    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   14    0               00 
   5 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[table](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t7[trigger](8)
REG[1] =   s5[table](8)
  13 Next             0    5    0               01 
   5 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[table](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t7[trigger](8)
REG[1] =   s5[table](8)
  13 Next             0    5    0               01 
   5 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[index](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t7[trigger](8)
REG[1] =   s5[index](8)
  13 Next             0    5    0               01 
   5 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s4[view](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t7[trigger](8)
REG[1] =   s4[view](8)
  13 Next             0    5    0               01 
   5 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[index](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t7[trigger](8)
REG[1] =   s5[index](8)
  13 Next             0    5    0               01 
   5 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s7[trigger](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t7[trigger](8)
REG[1] =   s7[trigger](8)
   7 Column           0    1    3               00 r[3]=sqlite_master.name
REG[3] =   s2[t5](8)
   8 Ne               4   13    3 (BINARY)      52 if r[4]!=r[3] goto 13
REG[4] =   t2[t5](8)
REG[3] =   s2[t5](8)
   9 Copy             3    5    0               00 r[5]=r[3]
REG[5] =   s2[t5](8)
  10 Column           0    3    6               00 r[6]=sqlite_master.rootpage
REG[6] =  i:0
  11 Column           0    4    7               00 r[7]=sqlite_master.sql
REG[7] =   s62[CREATE TRIGGER ](8)
  12 ResultRow        5    3    0               00 output=r[5..7]
REG[5] =   s2[t5](8)
REG[6] =  i:0
REG[7] =   s62[CREATE TRIGGER ](8)
parser: Initialize. Empty stack. State 0
parser: Input 'CREATE'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Shift 'CREATE'
parser: Return. Stack=[explain CREATE]
parser: Input 'TRIGGER'
parser: Reduce [createkw ::= CREATE], go to state 2.
parser: Shift 'createkw', go to state 107
parser: FALLBACK TRIGGER => ID
parser: Reduce [temp ::=], go to state 107.
parser: Shift 'temp', go to state 319
parser: Shift 'TRIGGER', go to state 261
parser: Return. Stack=[explain createkw temp TRIGGER]
parser: Input 'ID'
parser: Reduce [ifnotexists ::=], go to state 261.
parser: Shift 'ifnotexists', go to state 181
parser: Shift 'ID'
parser: Return. Stack=[explain createkw temp TRIGGER ifnotexists ID]
parser: Input 'BEFORE'
parser: Reduce [nm ::= ID|INDEXED], go to state 181.
parser: Shift 'nm', go to state 260
parser: FALLBACK BEFORE => ID
parser: Reduce [dbnm ::=], go to state 260.
parser: Shift 'dbnm', go to state 210
parser: Shift 'BEFORE'
parser: Return. Stack=[explain createkw temp TRIGGER ifnotexists nm dbnm BEFORE]
parser: Input 'INSERT'
parser: Reduce [trigger_time ::= BEFORE], go to state 210.
parser: Shift 'trigger_time', go to state 209
parser: Shift 'INSERT'
parser: Return. Stack=[explain createkw temp TRIGGER ifnotexists nm dbnm trigger_time INSERT]
parser: Input 'ON'
parser: Reduce [trigger_event ::= DELETE|INSERT], go to state 209.
parser: Shift 'trigger_event', go to state 376
parser: Shift 'ON', go to state 141
parser: Return. Stack=[explain createkw temp TRIGGER ifnotexists nm dbnm trigger_time trigger_event ON]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain createkw temp TRIGGER ifnotexists nm dbnm trigger_time trigger_event ON ID]
parser: Input 'BEGIN'
parser: Reduce [nm ::= ID|INDEXED], go to state 141.
parser: Shift 'nm', go to state 259
parser: FALLBACK BEGIN => ID
parser: Reduce [dbnm ::=], go to state 259.
parser: Shift 'dbnm'
parser: Reduce [fullname ::= nm dbnm], go to state 141.
parser: Shift 'fullname', go to state 258
parser: FALLBACK BEGIN => ID
parser: Reduce [foreach_clause ::=], go to state 258.
parser: Shift 'foreach_clause', go to state 257
parser: FALLBACK BEGIN => ID
parser: Reduce [when_clause ::=], go to state 257.
parser: Shift 'when_clause'
parser: Reduce [trigger_decl ::= temp TRIGGER ifnotexists nm dbnm trigger_time trigger_event ON fullname foreach_clause when_clause], go to state 107.
parser: Shift 'trigger_decl', go to state 367
parser: Shift 'BEGIN', go to state 7
parser: Return. Stack=[explain createkw trigger_decl BEGIN]
parser: Input 'SELECT'
parser: Reduce [with ::=], go to state 7.
parser: Shift 'with', go to state 113
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[explain createkw trigger_decl BEGIN with SELECT]
parser: Input 'INTEGER'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'INTEGER'
parser: Return. Stack=[explain createkw trigger_decl BEGIN with SELECT distinct sclp INTEGER]
parser: Input 'SEMI'
parser: Reduce [term ::= INTEGER|FLOAT|BLOB], go to state 54.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Reduce [from ::=], go to state 232.
parser: Shift 'from', go to state 298
parser: Reduce [where_opt ::=], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Reduce [orderby_opt ::=], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 113.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 113.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 7.
parser: Shift 'select'
parser: Reduce [trigger_cmd ::= select], go to state 7.
parser: Shift 'trigger_cmd', go to state 357
parser: Shift 'SEMI'
parser: Return. Stack=[explain createkw trigger_decl BEGIN trigger_cmd SEMI]
parser: Input 'END'
parser: Reduce [trigger_cmd_list ::= trigger_cmd SEMI], go to state 7.
parser: Shift 'trigger_cmd_list', go to state 23
parser: Shift 'END'
parser: Return. Stack=[explain createkw trigger_decl BEGIN trigger_cmd_list END]
parser: Input 'SEMI'
parser: Reduce [cmd ::= createkw trigger_decl BEGIN trigger_cmd_list END], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
  13 Next             0    5    0               01 
  14 Close            0    0    0               00 
  15 Halt             0    0    0               00 
  13 Halt             0    0    0               00 
parser: Initialize. Empty stack. State 0
parser: Input 'SELECT'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[explain with SELECT]
parser: Input 'INTEGER'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'INTEGER'
parser: Return. Stack=[explain with SELECT distinct sclp INTEGER]
parser: Input 'SEMI'
parser: Reduce [term ::= INTEGER|FLOAT|BLOB], go to state 54.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Reduce [from ::=], go to state 232.
parser: Shift 'from', go to state 298
parser: Reduce [where_opt ::=], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Reduce [orderby_opt ::=], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 22.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 2.
parser: Shift 'select'
parser: Reduce [cmd ::= select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
SQL: [SELECT 1;]
VDBE Trace:
   0 Init             0    0    0               00 Start at 0
   1 Integer          1    1    0               00 r[1]=1
REG[1] =  i:1
   2 ResultRow        1    1    0               00 output=r[1]
REG[1] =  i:1
   3 Halt             0    0    0               00 
parser: Initialize. Empty stack. State 0
parser: Input 'CREATE'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Shift 'CREATE'
parser: Return. Stack=[explain CREATE]
parser: Input 'TABLE'
parser: Reduce [createkw ::= CREATE], go to state 2.
parser: Shift 'createkw', go to state 107
parser: Reduce [temp ::=], go to state 107.
parser: Shift 'temp', go to state 319
parser: Shift 'TABLE', go to state 266
parser: Return. Stack=[explain createkw temp TABLE]
parser: Input 'ID'
parser: Reduce [ifnotexists ::=], go to state 266.
parser: Shift 'ifnotexists', go to state 183
parser: Shift 'ID'
parser: Return. Stack=[explain createkw temp TABLE ifnotexists ID]
parser: Input 'LP'
parser: Reduce [nm ::= ID|INDEXED], go to state 183.
parser: Shift 'nm', go to state 265
parser: Reduce [dbnm ::=], go to state 265.
parser: Shift 'dbnm'
parser: Reduce [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 2.
parser: Shift 'create_table', go to state 234
parser: Shift 'LP', go to state 111
parser: Return. Stack=[explain create_table LP]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP ID]
parser: Input 'COMMA'
parser: Reduce [nm ::= ID|INDEXED], go to state 111.
parser: Shift 'nm', go to state 148
parser: Reduce [typetoken ::=], go to state 148.
parser: Shift 'typetoken'
parser: Reduce [columnname ::= nm typetoken], go to state 111.
parser: Shift 'columnname', go to state 311
parser: Reduce [carglist ::=], go to state 311.
parser: Shift 'carglist', go to state 119
parser: Reduce [columnlist ::= columnname carglist], go to state 111.
parser: Shift 'columnlist', go to state 300
parser: Shift 'COMMA', go to state 21
parser: Return. Stack=[explain create_table LP columnlist COMMA]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP columnlist COMMA ID]
parser: Input 'COMMA'
parser: Reduce [nm ::= ID|INDEXED], go to state 21.
parser: Shift 'nm', go to state 148
parser: Reduce [typetoken ::=], go to state 148.
parser: Shift 'typetoken'
parser: Reduce [columnname ::= nm typetoken], go to state 21.
parser: Shift 'columnname', go to state 314
parser: Reduce [carglist ::=], go to state 314.
parser: Shift 'carglist', go to state 120
parser: Reduce [columnlist ::= columnlist COMMA columnname carglist], go to state 111.
parser: Shift 'columnlist', go to state 300
parser: Shift 'COMMA', go to state 21
parser: Return. Stack=[explain create_table LP columnlist COMMA]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP columnlist COMMA ID]
parser: Input 'RP'
parser: Reduce [nm ::= ID|INDEXED], go to state 21.
parser: Shift 'nm', go to state 148
parser: Reduce [typetoken ::=], go to state 148.
parser: Shift 'typetoken'
parser: Reduce [columnname ::= nm typetoken], go to state 21.
parser: Shift 'columnname', go to state 314
parser: Reduce [carglist ::=], go to state 314.
parser: Shift 'carglist', go to state 120
parser: Reduce [columnlist ::= columnlist COMMA columnname carglist], go to state 111.
parser: Shift 'columnlist', go to state 300
parser: Reduce [conslist_opt ::=], go to state 300.
parser: Shift 'conslist_opt', go to state 437
parser: Shift 'RP', go to state 299
parser: Return. Stack=[explain create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI'
parser: Reduce [table_options ::=], go to state 299.
parser: Shift 'table_options'
parser: Reduce [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 234.
parser: Initialize. Empty stack. State 0
parser: Input 'UPDATE'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'UPDATE', go to state 242
parser: Return. Stack=[explain with UPDATE]
parser: Input 'STRING'
parser: Reduce [orconf ::=], go to state 242.
parser: Shift 'orconf', go to state 129
parser: Shift 'STRING'
parser: Return. Stack=[explain with UPDATE orconf STRING]
parser: Input 'DOT'
parser: Reduce [nm ::= STRING], go to state 129.
parser: Shift 'nm', go to state 259
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[explain with UPDATE orconf nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with UPDATE orconf nm DOT ID]
parser: Input 'SET'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 259.
parser: Shift 'dbnm'
parser: Reduce [fullname ::= nm dbnm], go to state 129.
parser: Shift 'fullname', go to state 219
parser: Reduce [indexed_opt ::=], go to state 219.
parser: Shift 'indexed_opt', go to state 352
parser: Shift 'SET', go to state 128
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET ID]
parser: Input 'EQ'
parser: Reduce [nm ::= ID|INDEXED], go to state 128.
parser: Shift 'nm', go to state 360
parser: Shift 'EQ', go to state 59
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET nm EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET nm EQ STRING]
parser: Input 'COMMA'
parser: Reduce [term ::= STRING], go to state 59.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 59.
parser: Shift 'expr', go to state 36
parser: Reduce [setlist ::= nm EQ expr], go to state 128.
parser: Shift 'setlist', go to state 218
parser: Shift 'COMMA', go to state 176
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist COMMA]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ'
parser: Reduce [nm ::= ID|INDEXED], go to state 176.
parser: Shift 'nm', go to state 361
parser: Shift 'EQ', go to state 60
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'COMMA'
parser: Reduce [term ::= STRING], go to state 60.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 60.
parser: Shift 'expr', go to state 37
parser: Reduce [setlist ::= setlist COMMA nm EQ expr], go to state 128.
parser: Shift 'setlist', go to state 218
parser: Shift 'COMMA', go to state 176
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist COMMA]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ'
parser: Reduce [nm ::= ID|INDEXED], go to state 176.
parser: Shift 'nm', go to state 361
parser: Shift 'EQ', go to state 60
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'COMMA'
parser: Reduce [term ::= STRING], go to state 60.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 60.
parser: Shift 'expr', go to state 37
parser: Reduce [setlist ::= setlist COMMA nm EQ expr], go to state 128.
parser: Shift 'setlist', go to state 218
parser: Shift 'COMMA', go to state 176
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist COMMA]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ'
parser: Reduce [nm ::= ID|INDEXED], go to state 176.
parser: Shift 'nm', go to state 361
parser: Shift 'EQ', go to state 60
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'VARIABLE'
parser: Shift 'VARIABLE'
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist COMMA nm EQ VARIABLE]
parser: Input 'COMMA'
parser: Reduce [expr ::= VARIABLE], go to state 60.
parser: Shift 'expr', go to state 37
parser: Reduce [setlist ::= setlist COMMA nm EQ expr], go to state 128.
parser: Shift 'setlist', go to state 218
parser: Shift 'COMMA', go to state 176
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist COMMA]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ'
parser: Reduce [nm ::= ID|INDEXED], go to state 176.
parser: Shift 'nm', go to state 361
parser: Shift 'EQ', go to state 60
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'WHERE'
parser: Reduce [term ::= STRING], go to state 60.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 60.
parser: Shift 'expr', go to state 37
parser: Reduce [setlist ::= setlist COMMA nm EQ expr], go to state 128.
parser: Shift 'setlist', go to state 218
parser: Shift 'WHERE', go to state 65
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist WHERE]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist WHERE ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist WHERE expr EQ]
parser: Input 'VARIABLE'
parser: Shift 'VARIABLE'
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist WHERE expr EQ VARIABLE]
parser: Input 'SEMI'
parser: Reduce [expr ::= VARIABLE], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Reduce [where_opt ::= WHERE expr], go to state 218.
parser: Shift 'where_opt'
parser: Reduce [cmd ::= with UPDATE orconf fullname indexed_opt SET setlist where_opt], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Input '$'
parser: Reduce [ecmd ::= explain cmdx SEMI], go to state 0.
parser: Shift 'ecmd'
parser: Reduce [cmdlist ::= ecmd], go to state 0.
parser: Shift 'cmdlist', go to state 146
parser: Reduce [input ::= cmdlist], go to state 0.
parser: Accept!
parser: Popping $
parser: Return. Stack=]
parser: Shift 'create_table_args'
parser: Reduce [cmd ::= create_table create_table_args], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
SQL: [CREATE TABLE t6(t7, t8, t9);]
VDBE Trace:
   0 Init             0   30    0               00 Start at 30
  30 Transaction      0    1    6 2             01 usesStmtJournal=0
  31 TableLock        0    1    1 sqlite_master 00 iDb=0 root=1 write=1
  32 Goto             0    1    0               00 
   1 ReadCookie       0    3    2               00 
REG[3] =  i:4
   2 If               3    5    0               00 
REG[3] =  i:4
   5 CreateTable      0    2    0               00 r[2]=root iDb=0
REG[2] =  i:6
   6 OpenWrite        0    1    0 5             00 root=1 iDb=0
   7 NewRowid         0    1    0               00 r[1]=rowid
REG[1] =  i:7
   8 Blob             6    3    0              00 r[3]= (len=6)
REG[3] =  t6[060000000000......](8)
   9 Insert           0    3    1               08 intkey=r[1] data=r[3]
REG[3] =  t6[060000000000......](8)
REG[1] =  i:7
  10 Close            0    0    0               00 
  11 Close            0    0    0               00 
  12 Null             0    4    5               00 r[4..5]=NULL
REG[4] =  NULL
  13 OpenWrite        1    1    0 5             00 root=1 iDb=0; sqlite_master
  14 Explain          0    0    0 SEARCH TABLE sqlite_master USING INTEGER PRIMARY KEY (rowid=?) 00 
  15 MustBeInt        1   18    0               00 
REG[1] =  i:7
  16 NotExists        1   18    1               00 intkey=r[1]; pk
REG[1] =  i:7
  17 Rowid            1    5    0               00 r[5]=rowid
REG[5] =  i:7
  18 IsNull           5   26    0               00 if r[5]==NULL goto 26
REG[5] =  i:7
  19 String8          0    6    0 table         00 r[6]='table'
REG[6] =   t5[table](8)
  20 String8          0    7    0 t6            00 r[7]='t6'
REG[7] =   t2[t6](8)
  21 String8          0    8    0 t6            00 r[8]='t6'
REG[8] =   t2[t6](8)
  22 Copy             2    9    0               00 r[9]=r[2]
REG[9] =  i:6
  23 String8          0   10    0 CREATE TABLE t6(t7, t8, t9) 00 r[10]='CREATE TABLE t6(t7, t8, t9)'
REG[10] =   t27[CREATE TABLE t6](8)
  24 MakeRecord       6    5   11 BBBDB         00 r[11]=mkrec(r[6..10])
REG[11] =  s43[0617111101437461626C657436743606.....Ctablet6t6.](8)
  25 Insert           1   11    5               00 intkey=r[5] data=r[11]
REG[11] =  s43[0617111101437461626C657436743606.....Ctablet6t6.](8)
REG[5] =  i:7
  26 Close            1    0    0               00 
  27 SetCookie        0    1    7               00 
  28 ParseSchema      0    0    0 tbl_name='t6' AND type!='trigger' 00 
parser: Initialize. Empty stack. State 0
parser: Input 'SELECT'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[explain with SELECT]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'FROM'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[explain with SELECT distinct selcollist FROM]
parser: Input 'STRING'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'STRING'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix STRING]
parser: Input 'DOT'
parser: Reduce [nm ::= STRING], go to state 165.
parser: Shift 'nm', go to state 287
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Shift 'WHERE', go to state 65
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'AND', go to state 93
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'NE'
parser: Reduce [expr ::= ID|INDEXED], go to state 93.
parser: Shift 'expr', go to state 53
parser: Shift 'NE', go to state 90
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND expr NE]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND expr NE STRING]
parser: Input 'ORDER'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 93.
parser: Shift 'expr', go to state 53
parser: Reduce [expr ::= expr AND expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Reduce [where_opt ::= WHERE expr], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Shift 'ORDER', go to state 411
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY'
parser: Shift 'BY', go to state 17
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI'
parser: Reduce [expr ::= ID|INDEXED], go to state 17.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 17.
parser: Shift 'sortlist', go to state 410
parser: Reduce [orderby_opt ::= ORDER BY sortlist], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 22.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 2.
parser: Shift 'select'
parser: Reduce [cmd ::= select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
VDBE Trace:
   0 Init             0   16    0               00 Start at 16
  16 Transaction      0    0    7 2             00 usesStmtJournal=0
  17 TableLock        0    1    0 sqlite_master 00 iDb=0 root=1 write=0
  18 String8          0    2    0 t6            00 r[2]='t6'
REG[2] =   t2[t6](8)
  19 String8          0    4    0 trigger       00 r[4]='trigger'
REG[4] =   t7[trigger](8)
  20 Goto             0    1    0               00 
   1 Noop             1    5    0               00 
   2 OpenRead         0    1    0 5             00 root=1 iDb=0; sqlite_master
   3 Explain          0    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   14    0               00 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[t1](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t2[t6](8)
REG[1] =   s2[t1](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s7[numbers](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t2[t6](8)
REG[1] =   s7[numbers](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[t1](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t2[t6](8)
REG[1] =   s2[t1](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[t3](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t2[t6](8)
REG[1] =   s2[t3](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[t1](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t2[t6](8)
REG[1] =   s2[t1](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s7[numbers](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t2[t6](8)
REG[1] =   s7[numbers](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[t6](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t2[t6](8)
REG[1] =   s2[t6](8)
   7 Column           0    0    3               00 r[3]=sqlite_master.type
REG[3] =   s5[table](8)
   8 Eq               4   13    3 (BINARY)      52 if r[4]==r[3] goto 13
REG[4] =   t7[trigger](8)
REG[3] =   s5[table](8)
   9 Column           0    1    5               00 r[5]=sqlite_master.name
REG[5] =   s2[t6](8)
  10 Column           0    3    6               00 r[6]=sqlite_master.rootpage
REG[6] =  i:6
  11 Column           0    4    7               00 r[7]=sqlite_master.sql
REG[7] =   s27[CREATE TABLE t6](8)
  12 ResultRow        5    3    0               00 output=r[5..7]
REG[5] =   s2[t6](8)
REG[6] =  i:6
REG[7] =   s27[CREATE TABLE t6](8)
parser: Initialize. Empty stack. State 0
parser: Input 'CREATE'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Shift 'CREATE'
parser: Return. Stack=[explain CREATE]
parser: Input 'TABLE'
parser: Reduce [createkw ::= CREATE], go to state 2.
parser: Shift 'createkw', go to state 107
parser: Reduce [temp ::=], go to state 107.
parser: Shift 'temp', go to state 319
parser: Shift 'TABLE', go to state 266
parser: Return. Stack=[explain createkw temp TABLE]
parser: Input 'ID'
parser: Reduce [ifnotexists ::=], go to state 266.
parser: Shift 'ifnotexists', go to state 183
parser: Shift 'ID'
parser: Return. Stack=[explain createkw temp TABLE ifnotexists ID]
parser: Input 'LP'
parser: Reduce [nm ::= ID|INDEXED], go to state 183.
parser: Shift 'nm', go to state 265
parser: Reduce [dbnm ::=], go to state 265.
parser: Shift 'dbnm'
parser: Reduce [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 2.
parser: Shift 'create_table', go to state 234
parser: Shift 'LP', go to state 111
parser: Return. Stack=[explain create_table LP]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP ID]
parser: Input 'COMMA'
parser: Reduce [nm ::= ID|INDEXED], go to state 111.
parser: Shift 'nm', go to state 148
parser: Reduce [typetoken ::=], go to state 148.
parser: Shift 'typetoken'
parser: Reduce [columnname ::= nm typetoken], go to state 111.
parser: Shift 'columnname', go to state 311
parser: Reduce [carglist ::=], go to state 311.
parser: Shift 'carglist', go to state 119
parser: Reduce [columnlist ::= columnname carglist], go to state 111.
parser: Shift 'columnlist', go to state 300
parser: Shift 'COMMA', go to state 21
parser: Return. Stack=[explain create_table LP columnlist COMMA]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP columnlist COMMA ID]
parser: Input 'COMMA'
parser: Reduce [nm ::= ID|INDEXED], go to state 21.
parser: Shift 'nm', go to state 148
parser: Reduce [typetoken ::=], go to state 148.
parser: Shift 'typetoken'
parser: Reduce [columnname ::= nm typetoken], go to state 21.
parser: Shift 'columnname', go to state 314
parser: Reduce [carglist ::=], go to state 314.
parser: Shift 'carglist', go to state 120
parser: Reduce [columnlist ::= columnlist COMMA columnname carglist], go to state 111.
parser: Shift 'columnlist', go to state 300
parser: Shift 'COMMA', go to state 21
parser: Return. Stack=[explain create_table LP columnlist COMMA]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP columnlist COMMA ID]
parser: Input 'RP'
parser: Reduce [nm ::= ID|INDEXED], go to state 21.
parser: Shift 'nm', go to state 148
parser: Reduce [typetoken ::=], go to state 148.
parser: Shift 'typetoken'
parser: Reduce [columnname ::= nm typetoken], go to state 21.
parser: Shift 'columnname', go to state 314
parser: Reduce [carglist ::=], go to state 314.
parser: Shift 'carglist', go to state 120
parser: Reduce [columnlist ::= columnlist COMMA columnname carglist], go to state 111.
parser: Shift 'columnlist', go to state 300
parser: Reduce [conslist_opt ::=], go to state 300.
parser: Shift 'conslist_opt', go to state 437
parser: Shift 'RP', go to state 299
parser: Return. Stack=[explain create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI'
parser: Reduce [table_options ::=], go to state 299.
parser: Shift 'table_options'
parser: Reduce [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 234.
parser: Shift 'create_table_args'
parser: Reduce [cmd ::= create_table create_table_args], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
  13 Next             0    5    0               01 
  14 Close            0    0    0               00 
  15 Halt             0    0    0               00 
  29 Halt             0    0    0               00 
parser: Initialize. Empty stack. State 0
parser: Input 'ATTACH'
parser: FALLBACK ATTACH => ID
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Shift 'ATTACH', go to state 239
parser: Return. Stack=[explain ATTACH]
parser: Input 'STRING'
parser: Reduce [database_kw_opt ::=], go to state 239.
parser: Shift 'database_kw_opt', go to state 58
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain ATTACH database_kw_opt STRING]
parser: Input 'AS'
parser: Reduce [term ::= STRING], go to state 58.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 58.
parser: Shift 'expr', go to state 26
parser: Shift 'AS', go to state 57
parser: Return. Stack=[explain ATTACH database_kw_opt expr AS]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain ATTACH database_kw_opt expr AS ID]
parser: Input 'SEMI'
parser: Reduce [expr ::= ID|INDEXED], go to state 57.
parser: Shift 'expr', go to state 11
parser: Reduce [key_opt ::=], go to state 11.
parser: Shift 'key_opt'
parser: Reduce [cmd ::= ATTACH database_kw_opt expr AS expr key_opt], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
SQL: [ATTACH 'test.db3' AS at2;]
VDBE Trace:
   0 Init             0    0    0               00 Start at 0
   1 String8          0    1    0 test.db3      00 r[1]='test.db3'
REG[1] =   t8[test.db3](8)
   2 String8          0    2    0 at2           00 r[2]='at2'
REG[2] =   t3[at2](8)
   3 Null             0    3    0               00 r[3]=NULL
REG[3] =  NULL
   4 Function0        0    1    4 sqlite_attach(3) 03 r[4]=func(r[1..3])
REG[1] =   t8[test.db3](8)
REG[2] =   t3[at2](8)
REG[3] =  NULL
parser: Initialize. Empty stack. State 0
parser: Input 'SEMI'
parser: Shift 'SEMI'
parser: Return. Stack=[SEMI]
parser: Input 'SELECT'
parser: Reduce [ecmd ::= SEMI], go to state 0.
parser: Shift 'ecmd'
parser: Reduce [cmdlist ::= ecmd], go to state 0.
parser: Shift 'cmdlist', go to state 146
parser: Reduce [explain ::=], go to state 146.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[cmdlist explain with SELECT]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct sclp ID]
parser: Input 'FROM'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist FROM]
parser: Input 'STRING'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'STRING'
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist FROM stl_prefix STRING]
parser: Input 'DOT'
parser: Reduce [nm ::= STRING], go to state 165.
parser: Shift 'nm', go to state 287
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Shift 'WHERE', go to state 65
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'AND', go to state 93
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'NE'
parser: Reduce [expr ::= ID|INDEXED], go to state 93.
parser: Shift 'expr', go to state 53
parser: Shift 'NE', go to state 90
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE expr AND expr NE]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE expr AND expr NE STRING]
parser: Input 'ORDER'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 93.
parser: Shift 'expr', go to state 53
parser: Reduce [expr ::= expr AND expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Reduce [where_opt ::= WHERE expr], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Shift 'ORDER', go to state 411
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY'
parser: Shift 'BY', go to state 17
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI'
parser: Reduce [expr ::= ID|INDEXED], go to state 17.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 17.
parser: Shift 'sortlist', go to state 410
parser: Reduce [orderby_opt ::= ORDER BY sortlist], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 22.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 2.
parser: Shift 'select'
parser: Reduce [cmd ::= select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[cmdlist explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping cmdlist
parser: Popping $
SQL: [;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t6' AND type!='trigger' ORDER BY rowid;]
VDBE Trace:
   0 Init             0   16    0               00 Start at 16
  16 Transaction      0    0    7 2             01 usesStmtJournal=0
  17 TableLock        0    1    0 sqlite_master 00 iDb=0 root=1 write=0
  18 String8          0    2    0 t6            00 r[2]='t6'
REG[2] =   t2[t6](8)
  19 String8          0    4    0 trigger       00 r[4]='trigger'
REG[4] =   t7[trigger](8)
  20 Goto             0    1    0               00 
   1 Noop             1    5    0               00 
   2 OpenRead         0    1    0 5             00 root=1 iDb=0; sqlite_master
   3 Explain          0    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   14    0               00 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[t1](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t2[t6](8)
REG[1] =   s2[t1](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s7[numbers](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t2[t6](8)
REG[1] =   s7[numbers](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[t1](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t2[t6](8)
REG[1] =   s2[t1](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[t3](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t2[t6](8)
REG[1] =   s2[t3](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[t1](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t2[t6](8)
REG[1] =   s2[t1](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s7[numbers](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t2[t6](8)
REG[1] =   s7[numbers](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[t6](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t2[t6](8)
REG[1] =   s2[t6](8)
   7 Column           0    0    3               00 r[3]=sqlite_master.type
REG[3] =   s5[table](8)
   8 Eq               4   13    3 (BINARY)      52 if r[4]==r[3] goto 13
REG[4] =   t7[trigger](8)
REG[3] =   s5[table](8)
   9 Column           0    1    5               00 r[5]=sqlite_master.name
REG[5] =   s2[t6](8)
  10 Column           0    3    6               00 r[6]=sqlite_master.rootpage
REG[6] =  i:6
  11 Column           0    4    7               00 r[7]=sqlite_master.sql
REG[7] =   s27[CREATE TABLE t6](8)
  12 ResultRow        5    3    0               00 output=r[5..7]
REG[5] =   s2[t6](8)
REG[6] =  i:6
REG[7] =   s27[CREATE TABLE t6](8)
  13 Next             0    5    0               01 
  14 Close            0    0    0               00 
  15 Halt             0    0    0               00 
parser: Initialize. Empty stack. State 0
parser: Input 'SEMI'
parser: Shift 'SEMI'
parser: Return. Stack=[SEMI]
parser: Input 'SEMI'
parser: Reduce [ecmd ::= SEMI], go to state 0.
parser: Shift 'ecmd'
parser: Reduce [cmdlist ::= ecmd], go to state 0.
parser: Shift 'cmdlist', go to state 146
parser: Shift 'SEMI'
parser: Return. Stack=[cmdlist SEMI]
parser: Input 'SELECT'
parser: Reduce [ecmd ::= SEMI], go to state 146.
parser: Shift 'ecmd'
parser: Reduce [cmdlist ::= cmdlist ecmd], go to state 0.
parser: Shift 'cmdlist', go to state 146
parser: Reduce [explain ::=], go to state 146.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[cmdlist explain with SELECT]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct sclp ID]
parser: Input 'FROM'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist FROM]
parser: Input 'STRING'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'STRING'
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist FROM stl_prefix STRING]
parser: Input 'DOT'
parser: Reduce [nm ::= STRING], go to state 165.
parser: Shift 'nm', go to state 287
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Shift 'WHERE', go to state 65
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'AND', go to state 93
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'NE'
parser: Reduce [expr ::= ID|INDEXED], go to state 93.
parser: Shift 'expr', go to state 53
parser: Shift 'NE', go to state 90
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE expr AND expr NE]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE expr AND expr NE STRING]
parser: Input 'ORDER'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 93.
parser: Shift 'expr', go to state 53
parser: Reduce [expr ::= expr AND expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Reduce [where_opt ::= WHERE expr], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Shift 'ORDER', go to state 411
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY'
parser: Shift 'BY', go to state 17
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI'
parser: Reduce [expr ::= ID|INDEXED], go to state 17.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 17.
parser: Shift 'sortlist', go to state 410
parser: Reduce [orderby_opt ::= ORDER BY sortlist], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 22.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 2.
parser: Shift 'select'
parser: Reduce [cmd ::= select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[cmdlist explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping cmdlist
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'SEMI'
parser: Shift 'SEMI'
parser: Return. Stack=[SEMI]
parser: Input 'SELECT'
parser: Reduce [ecmd ::= SEMI], go to state 0.
parser: Shift 'ecmd'
parser: Reduce [cmdlist ::= ecmd], go to state 0.
parser: Shift 'cmdlist', go to state 146
parser: Reduce [explain ::=], go to state 146.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[cmdlist explain with SELECT]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct sclp ID]
parser: Input 'FROM'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist FROM]
parser: Input 'STRING'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'STRING'
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist FROM stl_prefix STRING]
parser: Input 'DOT'
parser: Reduce [nm ::= STRING], go to state 165.
parser: Shift 'nm', go to state 287
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Shift 'WHERE', go to state 65
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'AND', go to state 93
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'NE'
parser: Reduce [expr ::= ID|INDEXED], go to state 93.
parser: Shift 'expr', go to state 53
parser: Shift 'NE', go to state 90
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE expr AND expr NE]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE expr AND expr NE STRING]
parser: Input 'ORDER'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 93.
parser: Shift 'expr', go to state 53
parser: Reduce [expr ::= expr AND expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Reduce [where_opt ::= WHERE expr], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Shift 'ORDER', go to state 411
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY'
parser: Shift 'BY', go to state 17
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI'
parser: Reduce [expr ::= ID|INDEXED], go to state 17.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 17.
parser: Shift 'sortlist', go to state 410
parser: Reduce [orderby_opt ::= ORDER BY sortlist], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 22.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 2.
parser: Shift 'select'
parser: Reduce [cmd ::= select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[cmdlist explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping cmdlist
parser: Popping $
SQL: [;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t6' AND type!='trigger' ORDER BY rowid;]
VDBE Trace:
   0 Init             0   16    0               00 Start at 16
  16 Transaction      0    0    7 2             01 usesStmtJournal=0
  17 TableLock        0    1    0 sqlite_master 00 iDb=0 root=1 write=0
  18 String8          0    2    0 t6            00 r[2]='t6'
REG[2] =   t2[t6](8)
  19 String8          0    4    0 trigger       00 r[4]='trigger'
REG[4] =   t7[trigger](8)
  20 Goto             0    1    0               00 
   1 Noop             1    5    0               00 
   2 OpenRead         0    1    0 5             00 root=1 iDb=0; sqlite_master
   3 Explain          0    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   14    0               00 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[t1](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t2[t6](8)
REG[1] =   s2[t1](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s7[numbers](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t2[t6](8)
REG[1] =   s7[numbers](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[t1](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t2[t6](8)
REG[1] =   s2[t1](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[t3](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t2[t6](8)
REG[1] =   s2[t3](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[t1](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t2[t6](8)
REG[1] =   s2[t1](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s7[numbers](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t2[t6](8)
REG[1] =   s7[numbers](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[t6](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t2[t6](8)
REG[1] =   s2[t6](8)
   7 Column           0    0    3               00 r[3]=sqlite_master.type
REG[3] =   s5[table](8)
   8 Eq               4   13    3 (BINARY)      52 if r[4]==r[3] goto 13
REG[4] =   t7[trigger](8)
REG[3] =   s5[table](8)
   9 Column           0    1    5               00 r[5]=sqlite_master.name
REG[5] =   s2[t6](8)
  10 Column           0    3    6               00 r[6]=sqlite_master.rootpage
REG[6] =  i:6
  11 Column           0    4    7               00 r[7]=sqlite_master.sql
REG[7] =   s27[CREATE TABLE t6](8)
  12 ResultRow        5    3    0               00 output=r[5..7]
REG[5] =   s2[t6](8)
REG[6] =  i:6
REG[7] =   s27[CREATE TABLE t6](8)
  13 Next             0    5    0               01 
  14 Close            0    0    0               00 
  15 Halt             0    0    0               00 
parser: Initialize. Empty stack. State 0
parser: Input 'SEMI'
parser: Shift 'SEMI'
parser: Return. Stack=[SEMI]
parser: Input 'SELECT'
parser: Reduce [ecmd ::= SEMI], go to state 0.
parser: Shift 'ecmd'
parser: Reduce [cmdlist ::= ecmd], go to state 0.
parser: Shift 'cmdlist', go to state 146
parser: Reduce [explain ::=], go to state 146.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[cmdlist explain with SELECT]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct sclp ID]
parser: Input 'FROM'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist FROM]
parser: Input 'STRING'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'STRING'
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist FROM stl_prefix STRING]
parser: Input 'DOT'
parser: Reduce [nm ::= STRING], go to state 165.
parser: Shift 'nm', go to state 287
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Shift 'WHERE', go to state 65
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'AND', go to state 93
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'NE'
parser: Reduce [expr ::= ID|INDEXED], go to state 93.
parser: Shift 'expr', go to state 53
parser: Shift 'NE', go to state 90
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE expr AND expr NE]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE expr AND expr NE STRING]
parser: Input 'ORDER'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 93.
parser: Shift 'expr', go to state 53
parser: Reduce [expr ::= expr AND expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Reduce [where_opt ::= WHERE expr], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Shift 'ORDER', go to state 411
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY'
parser: Shift 'BY', go to state 17
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI'
parser: Reduce [expr ::= ID|INDEXED], go to state 17.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 17.
parser: Shift 'sortlist', go to state 410
parser: Reduce [orderby_opt ::= ORDER BY sortlist], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 22.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 2.
parser: Shift 'select'
parser: Reduce [cmd ::= select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[cmdlist explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping cmdlist
parser: Popping $
SQL: [;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='numbers' AND type!='trigger' ORDER BY rowid;]
VDBE Trace:
   0 Init             0   16    0               00 Start at 16
  16 Transaction      0    0    7 2             01 usesStmtJournal=0
  17 TableLock        0    1    0 sqlite_master 00 iDb=0 root=1 write=0
  18 String8          0    2    0 numbers       00 r[2]='numbers'
REG[2] =   t7[numbers](8)
  19 String8          0    4    0 trigger       00 r[4]='trigger'
REG[4] =   t7[trigger](8)
  20 Goto             0    1    0               00 
   1 Noop             1    5    0               00 
   2 OpenRead         0    1    0 5             00 root=1 iDb=0; sqlite_master
   3 Explain          0    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   14    0               00 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[t1](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t7[numbers](8)
REG[1] =   s2[t1](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s7[numbers](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t7[numbers](8)
REG[1] =   s7[numbers](8)
   7 Column           0    0    3               00 r[3]=sqlite_master.type
REG[3] =   s5[table](8)
   8 Eq               4   13    3 (BINARY)      52 if r[4]==r[3] goto 13
REG[4] =   t7[trigger](8)
REG[3] =   s5[table](8)
   9 Column           0    1    5               00 r[5]=sqlite_master.name
REG[5] =   s7[numbers](8)
  10 Column           0    3    6               00 r[6]=sqlite_master.rootpage
REG[6] =  i:3
  11 Column           0    4    7               00 r[7]=sqlite_master.sql
REG[7] =   s34[CREATE TABLE nu](8)
  12 ResultRow        5    3    0               00 output=r[5..7]
REG[5] =   s7[numbers](8)
REG[6] =  i:3
REG[7] =   s34[CREATE TABLE nu](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[t1](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t7[numbers](8)
REG[1] =   s2[t1](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[t3](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t7[numbers](8)
REG[1] =   s2[t3](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[t1](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t7[numbers](8)
REG[1] =   s2[t1](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s7[numbers](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t7[numbers](8)
REG[1] =   s7[numbers](8)
   7 Column           0    0    3               00 r[3]=sqlite_master.type
REG[3] =   s7[trigger](8)
   8 Eq               4   13    3 (BINARY)      52 if r[4]==r[3] goto 13
REG[4] =   t7[trigger](8)
REG[3] =   s7[trigger](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[t6](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t7[numbers](8)
REG[1] =   s2[t6](8)
  13 Next             0    5    0               01 
  14 Close            0    0    0               00 
  15 Halt             0    0    0               00 
parser: Initialize. Empty stack. State 0
parser: Input 'SEMI'
parser: Shift 'SEMI'
parser: Return. Stack=[SEMI]
parser: Input 'SELECT'
parser: Reduce [ecmd ::= SEMI], go to state 0.
parser: Shift 'ecmd'
parser: Reduce [cmdlist ::= ecmd], go to state 0.
parser: Shift 'cmdlist', go to state 146
parser: Reduce [explain ::=], go to state 146.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[cmdlist explain with SELECT]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct sclp ID]
parser: Input 'FROM'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist FROM]
parser: Input 'STRING'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'STRING'
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist FROM stl_prefix STRING]
parser: Input 'DOT'
parser: Reduce [nm ::= STRING], go to state 165.
parser: Shift 'nm', go to state 287
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Shift 'WHERE', go to state 65
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'AND', go to state 93
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 93.
parser: Shift 'expr', go to state 53
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE expr AND expr EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE expr AND expr EQ STRING]
parser: Input 'ORDER'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 93.
parser: Shift 'expr', go to state 53
parser: Reduce [expr ::= expr AND expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Reduce [where_opt ::= WHERE expr], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Shift 'ORDER', go to state 411
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY'
parser: Shift 'BY', go to state 17
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI'
parser: Reduce [expr ::= ID|INDEXED], go to state 17.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 17.
parser: Shift 'sortlist', go to state 410
parser: Reduce [orderby_opt ::= ORDER BY sortlist], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 22.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 2.
parser: Shift 'select'
parser: Reduce [cmd ::= select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[cmdlist explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping cmdlist
parser: Popping $
SQL: [;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE type='trigger' AND name='t5' ORDER BY rowid;]
VDBE Trace:
   0 Init             0   16    0               00 Start at 16
  16 Transaction      0    0    7 2             01 usesStmtJournal=0
  17 TableLock        0    1    0 sqlite_master 00 iDb=0 root=1 write=0
  18 String8          0    2    0 trigger       00 r[2]='trigger'
REG[2] =   t7[trigger](8)
  19 String8          0    4    0 t5            00 r[4]='t5'
REG[4] =   t2[t5](8)
  20 Goto             0    1    0               00 
   1 Noop             1    5    0               00 
   2 OpenRead         0    1    0 5             00 root=1 iDb=0; sqlite_master
   3 Explain          0    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   14    0               00 
   5 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[table](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t7[trigger](8)
REG[1] =   s5[table](8)
  13 Next             0    5    0               01 
   5 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[table](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t7[trigger](8)
REG[1] =   s5[table](8)
  13 Next             0    5    0               01 
   5 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[index](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t7[trigger](8)
REG[1] =   s5[index](8)
  13 Next             0    5    0               01 
   5 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s4[view](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t7[trigger](8)
REG[1] =   s4[view](8)
  13 Next             0    5    0               01 
   5 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[index](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t7[trigger](8)
REG[1] =   s5[index](8)
  13 Next             0    5    0               01 
   5 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s7[trigger](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t7[trigger](8)
REG[1] =   s7[trigger](8)
   7 Column           0    1    3               00 r[3]=sqlite_master.name
REG[3] =   s2[t5](8)
   8 Ne               4   13    3 (BINARY)      52 if r[4]!=r[3] goto 13
REG[4] =   t2[t5](8)
REG[3] =   s2[t5](8)
   9 Copy             3    5    0               00 r[5]=r[3]
REG[5] =   s2[t5](8)
  10 Column           0    3    6               00 r[6]=sqlite_master.rootpage
REG[6] =  i:0
  11 Column           0    4    7               00 r[7]=sqlite_master.sql
REG[7] =   s62[CREATE TRIGGER ](8)
  12 ResultRow        5    3    0               00 output=r[5..7]
REG[5] =   s2[t5](8)
REG[6] =  i:0
REG[7] =   s62[CREATE TRIGGER ](8)
  13 Next             0    5    0               01 
   5 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[table](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t7[trigger](8)
REG[1] =   s5[table](8)
  13 Next             0    5    0               01 
  14 Close            0    0    0               00 
  15 Halt             0    0    0               00 
parser: Initialize. Empty stack. State 0
parser: Input 'CREATE'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Shift 'CREATE'
parser: Return. Stack=[explain CREATE]
parser: Input 'TABLE'
parser: Reduce [createkw ::= CREATE], go to state 2.
parser: Shift 'createkw', go to state 107
parser: Reduce [temp ::=], go to state 107.
parser: Shift 'temp', go to state 319
parser: Shift 'TABLE', go to state 266
parser: Return. Stack=[explain createkw temp TABLE]
parser: Input 'ID'
parser: Reduce [ifnotexists ::=], go to state 266.
parser: Shift 'ifnotexists', go to state 183
parser: Shift 'ID'
parser: Return. Stack=[explain createkw temp TABLE ifnotexists ID]
parser: Input 'LP'
parser: Reduce [nm ::= ID|INDEXED], go to state 183.
parser: Shift 'nm', go to state 265
parser: Reduce [dbnm ::=], go to state 265.
parser: Shift 'dbnm'
parser: Reduce [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 2.
parser: Shift 'create_table', go to state 234
parser: Shift 'LP', go to state 111
parser: Return. Stack=[explain create_table LP]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP ID]
parser: Input 'COMMA'
parser: Reduce [nm ::= ID|INDEXED], go to state 111.
parser: Shift 'nm', go to state 148
parser: Reduce [typetoken ::=], go to state 148.
parser: Shift 'typetoken'
parser: Reduce [columnname ::= nm typetoken], go to state 111.
parser: Shift 'columnname', go to state 311
parser: Reduce [carglist ::=], go to state 311.
parser: Shift 'carglist', go to state 119
parser: Reduce [columnlist ::= columnname carglist], go to state 111.
parser: Shift 'columnlist', go to state 300
parser: Shift 'COMMA', go to state 21
parser: Return. Stack=[explain create_table LP columnlist COMMA]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP columnlist COMMA ID]
parser: Input 'COMMA'
parser: Reduce [nm ::= ID|INDEXED], go to state 21.
parser: Shift 'nm', go to state 148
parser: Reduce [typetoken ::=], go to state 148.
parser: Shift 'typetoken'
parser: Reduce [columnname ::= nm typetoken], go to state 21.
parser: Shift 'columnname', go to state 314
parser: Reduce [carglist ::=], go to state 314.
parser: Shift 'carglist', go to state 120
parser: Reduce [columnlist ::= columnlist COMMA columnname carglist], go to state 111.
parser: Shift 'columnlist', go to state 300
parser: Shift 'COMMA', go to state 21
parser: Return. Stack=[explain create_table LP columnlist COMMA]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP columnlist COMMA ID]
parser: Input 'RP'
parser: Reduce [nm ::= ID|INDEXED], go to state 21.
parser: Shift 'nm', go to state 148
parser: Reduce [typetoken ::=], go to state 148.
parser: Shift 'typetoken'
parser: Reduce [columnname ::= nm typetoken], go to state 21.
parser: Shift 'columnname', go to state 314
parser: Reduce [carglist ::=], go to state 314.
parser: Shift 'carglist', go to state 120
parser: Reduce [columnlist ::= columnlist COMMA columnname carglist], go to state 111.
parser: Shift 'columnlist', go to state 300
parser: Reduce [conslist_opt ::=], go to state 300.
parser: Shift 'conslist_opt', go to state 437
parser: Shift 'RP', go to state 299
parser: Return. Stack=[explain create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI'
parser: Reduce [table_options ::=], go to state 299.
parser: Shift 'table_options'
parser: Reduce [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 234.
parser: Initialize. Empty stack. State 0
parser: Input 'UPDATE'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'UPDATE', go to state 242
parser: Return. Stack=[explain with UPDATE]
parser: Input 'STRING'
parser: Reduce [orconf ::=], go to state 242.
parser: Shift 'orconf', go to state 129
parser: Shift 'STRING'
parser: Return. Stack=[explain with UPDATE orconf STRING]
parser: Input 'DOT'
parser: Reduce [nm ::= STRING], go to state 129.
parser: Shift 'nm', go to state 259
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[explain with UPDATE orconf nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with UPDATE orconf nm DOT ID]
parser: Input 'SET'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 259.
parser: Shift 'dbnm'
parser: Reduce [fullname ::= nm dbnm], go to state 129.
parser: Shift 'fullname', go to state 219
parser: Reduce [indexed_opt ::=], go to state 219.
parser: Shift 'indexed_opt', go to state 352
parser: Shift 'SET', go to state 128
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET ID]
parser: Input 'EQ'
parser: Reduce [nm ::= ID|INDEXED], go to state 128.
parser: Shift 'nm', go to state 360
parser: Shift 'EQ', go to state 59
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET nm EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET nm EQ STRING]
parser: Input 'COMMA'
parser: Reduce [term ::= STRING], go to state 59.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 59.
parser: Shift 'expr', go to state 36
parser: Reduce [setlist ::= nm EQ expr], go to state 128.
parser: Shift 'setlist', go to state 218
parser: Shift 'COMMA', go to state 176
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist COMMA]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ'
parser: Reduce [nm ::= ID|INDEXED], go to state 176.
parser: Shift 'nm', go to state 361
parser: Shift 'EQ', go to state 60
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'COMMA'
parser: Reduce [term ::= STRING], go to state 60.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 60.
parser: Shift 'expr', go to state 37
parser: Reduce [setlist ::= setlist COMMA nm EQ expr], go to state 128.
parser: Shift 'setlist', go to state 218
parser: Shift 'COMMA', go to state 176
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist COMMA]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ'
parser: Reduce [nm ::= ID|INDEXED], go to state 176.
parser: Shift 'nm', go to state 361
parser: Shift 'EQ', go to state 60
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'COMMA'
parser: Reduce [term ::= STRING], go to state 60.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 60.
parser: Shift 'expr', go to state 37
parser: Reduce [setlist ::= setlist COMMA nm EQ expr], go to state 128.
parser: Shift 'setlist', go to state 218
parser: Shift 'COMMA', go to state 176
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist COMMA]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ'
parser: Reduce [nm ::= ID|INDEXED], go to state 176.
parser: Shift 'nm', go to state 361
parser: Shift 'EQ', go to state 60
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'VARIABLE'
parser: Shift 'VARIABLE'
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist COMMA nm EQ VARIABLE]
parser: Input 'COMMA'
parser: Reduce [expr ::= VARIABLE], go to state 60.
parser: Shift 'expr', go to state 37
parser: Reduce [setlist ::= setlist COMMA nm EQ expr], go to state 128.
parser: Shift 'setlist', go to state 218
parser: Shift 'COMMA', go to state 176
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist COMMA]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ'
parser: Reduce [nm ::= ID|INDEXED], go to state 176.
parser: Shift 'nm', go to state 361
parser: Shift 'EQ', go to state 60
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'WHERE'
parser: Reduce [term ::= STRING], go to state 60.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 60.
parser: Shift 'expr', go to state 37
parser: Reduce [setlist ::= setlist COMMA nm EQ expr], go to state 128.
parser: Shift 'setlist', go to state 218
parser: Shift 'WHERE', go to state 65
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist WHERE]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist WHERE ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist WHERE expr EQ]
parser: Input 'VARIABLE'
parser: Shift 'VARIABLE'
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist WHERE expr EQ VARIABLE]
parser: Input 'SEMI'
parser: Reduce [expr ::= VARIABLE], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Reduce [where_opt ::= WHERE expr], go to state 218.
parser: Shift 'where_opt'
parser: Reduce [cmd ::= with UPDATE orconf fullname indexed_opt SET setlist where_opt], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Input '$'
parser: Reduce [ecmd ::= explain cmdx SEMI], go to state 0.
parser: Shift 'ecmd'
parser: Reduce [cmdlist ::= ecmd], go to state 0.
parser: Shift 'cmdlist', go to state 146
parser: Reduce [input ::= cmdlist], go to state 0.
parser: Accept!
parser: Popping $
parser: Return. Stack=]
parser: Shift 'create_table_args'
parser: Reduce [cmd ::= create_table create_table_args], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
SQL: [CREATE TABLE t10(t11, t12, t13);]
VDBE Trace:
   0 Init             0   30    0               00 Start at 30
  30 Transaction      0    1    7 2             01 usesStmtJournal=0
  31 TableLock        0    1    1 sqlite_master 00 iDb=0 root=1 write=1
  32 Goto             0    1    0               00 
   1 ReadCookie       0    3    2               00 
REG[3] =  i:4
   2 If               3    5    0               00 
REG[3] =  i:4
   5 CreateTable      0    2    0               00 r[2]=root iDb=0
REG[2] =  i:7
   6 OpenWrite        0    1    0 5             00 root=1 iDb=0
   7 NewRowid         0    1    0               00 r[1]=rowid
REG[1] =  i:8
   8 Blob             6    3    0              00 r[3]= (len=6)
REG[3] =  t6[060000000000......](8)
   9 Insert           0    3    1               08 intkey=r[1] data=r[3]
REG[3] =  t6[060000000000......](8)
REG[1] =  i:8
  10 Close            0    0    0               00 
  11 Close            0    0    0               00 
  12 Null             0    4    5               00 r[4..5]=NULL
REG[4] =  NULL
  13 OpenWrite        1    1    0 5             00 root=1 iDb=0; sqlite_master
  14 Explain          0    0    0 SEARCH TABLE sqlite_master USING INTEGER PRIMARY KEY (rowid=?) 00 
  15 MustBeInt        1   18    0               00 
REG[1] =  i:8
  16 NotExists        1   18    1               00 intkey=r[1]; pk
REG[1] =  i:8
  17 Rowid            1    5    0               00 r[5]=rowid
REG[5] =  i:8
  18 IsNull           5   26    0               00 if r[5]==NULL goto 26
REG[5] =  i:8
  19 String8          0    6    0 table         00 r[6]='table'
REG[6] =   t5[table](8)
  20 String8          0    7    0 t10           00 r[7]='t10'
REG[7] =   t3[t10](8)
  21 String8          0    8    0 t10           00 r[8]='t10'
REG[8] =   t3[t10](8)
  22 Copy             2    9    0               00 r[9]=r[2]
REG[9] =  i:7
  23 String8          0   10    0 CREATE TABLE t10(t11, t12, t13) 00 r[10]='CREATE TABLE t10(t11, t12, t13)'
REG[10] =   t31[CREATE TABLE t1](8)
  24 MakeRecord       6    5   11 BBBDB         00 r[11]=mkrec(r[6..10])
REG[11] =  s49[06171313014B7461626C657431307431.....Ktablet10t1](8)
  25 Insert           1   11    5               00 intkey=r[5] data=r[11]
REG[11] =  s49[06171313014B7461626C657431307431.....Ktablet10t1](8)
REG[5] =  i:8
  26 Close            1    0    0               00 
  27 SetCookie        0    1    8               00 
  28 ParseSchema      0    0    0 tbl_name='t10' AND type!='trigger' 00 
parser: Initialize. Empty stack. State 0
parser: Input 'SELECT'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[explain with SELECT]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'FROM'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[explain with SELECT distinct selcollist FROM]
parser: Input 'STRING'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'STRING'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix STRING]
parser: Input 'DOT'
parser: Reduce [nm ::= STRING], go to state 165.
parser: Shift 'nm', go to state 287
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Shift 'WHERE', go to state 65
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'AND', go to state 93
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'NE'
parser: Reduce [expr ::= ID|INDEXED], go to state 93.
parser: Shift 'expr', go to state 53
parser: Shift 'NE', go to state 90
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND expr NE]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND expr NE STRING]
parser: Input 'ORDER'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 93.
parser: Shift 'expr', go to state 53
parser: Reduce [expr ::= expr AND expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Reduce [where_opt ::= WHERE expr], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Shift 'ORDER', go to state 411
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY'
parser: Shift 'BY', go to state 17
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI'
parser: Reduce [expr ::= ID|INDEXED], go to state 17.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 17.
parser: Shift 'sortlist', go to state 410
parser: Reduce [orderby_opt ::= ORDER BY sortlist], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 22.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 2.
parser: Shift 'select'
parser: Reduce [cmd ::= select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
VDBE Trace:
   0 Init             0   16    0               00 Start at 16
  16 Transaction      0    0    8 2             00 usesStmtJournal=0
  17 TableLock        0    1    0 sqlite_master 00 iDb=0 root=1 write=0
  18 String8          0    2    0 t10           00 r[2]='t10'
REG[2] =   t3[t10](8)
  19 String8          0    4    0 trigger       00 r[4]='trigger'
REG[4] =   t7[trigger](8)
  20 Goto             0    1    0               00 
   1 Noop             1    5    0               00 
   2 OpenRead         0    1    0 5             00 root=1 iDb=0; sqlite_master
   3 Explain          0    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   14    0               00 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[t1](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t3[t10](8)
REG[1] =   s2[t1](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s7[numbers](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t3[t10](8)
REG[1] =   s7[numbers](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[t1](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t3[t10](8)
REG[1] =   s2[t1](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[t3](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t3[t10](8)
REG[1] =   s2[t3](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[t1](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t3[t10](8)
REG[1] =   s2[t1](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s7[numbers](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t3[t10](8)
REG[1] =   s7[numbers](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[t6](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t3[t10](8)
REG[1] =   s2[t6](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s3[t10](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t3[t10](8)
REG[1] =   s3[t10](8)
   7 Column           0    0    3               00 r[3]=sqlite_master.type
REG[3] =   s5[table](8)
   8 Eq               4   13    3 (BINARY)      52 if r[4]==r[3] goto 13
REG[4] =   t7[trigger](8)
REG[3] =   s5[table](8)
   9 Column           0    1    5               00 r[5]=sqlite_master.name
REG[5] =   s3[t10](8)
  10 Column           0    3    6               00 r[6]=sqlite_master.rootpage
REG[6] =  i:7
  11 Column           0    4    7               00 r[7]=sqlite_master.sql
REG[7] =   s31[CREATE TABLE t1](8)
  12 ResultRow        5    3    0               00 output=r[5..7]
REG[5] =   s3[t10](8)
REG[6] =  i:7
REG[7] =   s31[CREATE TABLE t1](8)
parser: Initialize. Empty stack. State 0
parser: Input 'CREATE'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Shift 'CREATE'
parser: Return. Stack=[explain CREATE]
parser: Input 'TABLE'
parser: Reduce [createkw ::= CREATE], go to state 2.
parser: Shift 'createkw', go to state 107
parser: Reduce [temp ::=], go to state 107.
parser: Shift 'temp', go to state 319
parser: Shift 'TABLE', go to state 266
parser: Return. Stack=[explain createkw temp TABLE]
parser: Input 'ID'
parser: Reduce [ifnotexists ::=], go to state 266.
parser: Shift 'ifnotexists', go to state 183
parser: Shift 'ID'
parser: Return. Stack=[explain createkw temp TABLE ifnotexists ID]
parser: Input 'LP'
parser: Reduce [nm ::= ID|INDEXED], go to state 183.
parser: Shift 'nm', go to state 265
parser: Reduce [dbnm ::=], go to state 265.
parser: Shift 'dbnm'
parser: Reduce [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 2.
parser: Shift 'create_table', go to state 234
parser: Shift 'LP', go to state 111
parser: Return. Stack=[explain create_table LP]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP ID]
parser: Input 'COMMA'
parser: Reduce [nm ::= ID|INDEXED], go to state 111.
parser: Shift 'nm', go to state 148
parser: Reduce [typetoken ::=], go to state 148.
parser: Shift 'typetoken'
parser: Reduce [columnname ::= nm typetoken], go to state 111.
parser: Shift 'columnname', go to state 311
parser: Reduce [carglist ::=], go to state 311.
parser: Shift 'carglist', go to state 119
parser: Reduce [columnlist ::= columnname carglist], go to state 111.
parser: Shift 'columnlist', go to state 300
parser: Shift 'COMMA', go to state 21
parser: Return. Stack=[explain create_table LP columnlist COMMA]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP columnlist COMMA ID]
parser: Input 'COMMA'
parser: Reduce [nm ::= ID|INDEXED], go to state 21.
parser: Shift 'nm', go to state 148
parser: Reduce [typetoken ::=], go to state 148.
parser: Shift 'typetoken'
parser: Reduce [columnname ::= nm typetoken], go to state 21.
parser: Shift 'columnname', go to state 314
parser: Reduce [carglist ::=], go to state 314.
parser: Shift 'carglist', go to state 120
parser: Reduce [columnlist ::= columnlist COMMA columnname carglist], go to state 111.
parser: Shift 'columnlist', go to state 300
parser: Shift 'COMMA', go to state 21
parser: Return. Stack=[explain create_table LP columnlist COMMA]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP columnlist COMMA ID]
parser: Input 'RP'
parser: Reduce [nm ::= ID|INDEXED], go to state 21.
parser: Shift 'nm', go to state 148
parser: Reduce [typetoken ::=], go to state 148.
parser: Shift 'typetoken'
parser: Reduce [columnname ::= nm typetoken], go to state 21.
parser: Shift 'columnname', go to state 314
parser: Reduce [carglist ::=], go to state 314.
parser: Shift 'carglist', go to state 120
parser: Reduce [columnlist ::= columnlist COMMA columnname carglist], go to state 111.
parser: Shift 'columnlist', go to state 300
parser: Reduce [conslist_opt ::=], go to state 300.
parser: Shift 'conslist_opt', go to state 437
parser: Shift 'RP', go to state 299
parser: Return. Stack=[explain create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI'
parser: Reduce [table_options ::=], go to state 299.
parser: Shift 'table_options'
parser: Reduce [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 234.
parser: Shift 'create_table_args'
parser: Reduce [cmd ::= create_table create_table_args], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
  13 Next             0    5    0               01 
  14 Close            0    0    0               00 
  15 Halt             0    0    0               00 
  29 Halt             0    0    0               00 
parser: Initialize. Empty stack. State 0
parser: Input 'SELECT'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[explain with SELECT]
parser: Input 'INTEGER'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'INTEGER'
parser: Return. Stack=[explain with SELECT distinct sclp INTEGER]
parser: Input 'SEMI'
parser: Reduce [term ::= INTEGER|FLOAT|BLOB], go to state 54.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Reduce [from ::=], go to state 232.
parser: Shift 'from', go to state 298
parser: Reduce [where_opt ::=], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Reduce [orderby_opt ::=], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 22.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 2.
parser: Shift 'select'
parser: Reduce [cmd ::= select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
SQL: [SELECT 1;]
VDBE Trace:
   0 Init             0    0    0               00 Start at 0
   1 Integer          1    1    0               00 r[1]=1
REG[1] =  i:1
   2 ResultRow        1    1    0               00 output=r[1]
REG[1] =  i:1
   3 Halt             0    0    0               00 
parser: Initialize. Empty stack. State 0
parser: Input 'SELECT'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[explain with SELECT]
parser: Input 'DISTINCT'
parser: Shift 'DISTINCT'
parser: Return. Stack=[explain with SELECT DISTINCT]
parser: Input 'ID'
parser: Reduce [distinct ::= DISTINCT], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'CONCAT'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Shift 'CONCAT', go to state 86
parser: Return. Stack=[explain with SELECT distinct sclp expr CONCAT]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp expr CONCAT ID]
parser: Input 'FROM'
parser: Reduce [expr ::= ID|INDEXED], go to state 86.
parser: Shift 'expr', go to state 114
parser: Reduce [expr ::= expr CONCAT expr], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[explain with SELECT distinct selcollist FROM]
parser: Input 'ID'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'ID'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'SEMI'
parser: Reduce [nm ::= ID|INDEXED], go to state 165.
parser: Shift 'nm', go to state 287
parser: Reduce [dbnm ::=], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Reduce [where_opt ::=], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Reduce [orderby_opt ::=], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 22.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 2.
parser: Shift 'select'
parser: Reduce [cmd ::= select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
SQL: [SELECT DISTINCT t9, t7, t9||t7 FROM t6 ;]
VDBE Trace:
   0 Init             0   15    0               00 Start at 15
  15 Transaction      0    0    8 2             01 usesStmtJournal=0
  16 TableLock        0    6    0 t6            00 iDb=0 root=6 write=0
  17 Goto             0    1    0               00 
   1 OpenEphemeral    1    0    0 k(3,B,B,B)    08 nColumn=0
   2 OpenRead         0    6    0 3             00 root=6 iDb=0; t6
   3 Explain          0    0    0 SCAN TABLE t6 00 
   4 Rewind           0   13    0               00 
  13 Close            0    0    0               00 
  14 Halt             0    0    0               00 
parser: Initialize. Empty stack. State 0
parser: Input 'SELECT'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[explain with SELECT]
parser: Input 'INTEGER'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'INTEGER'
parser: Return. Stack=[explain with SELECT distinct sclp INTEGER]
parser: Input 'COMMA'
parser: Reduce [term ::= INTEGER|FLOAT|BLOB], go to state 54.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'INTEGER'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'INTEGER'
parser: Return. Stack=[explain with SELECT distinct sclp INTEGER]
parser: Input 'COMMA'
parser: Reduce [term ::= INTEGER|FLOAT|BLOB], go to state 54.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'INTEGER'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'INTEGER'
parser: Return. Stack=[explain with SELECT distinct sclp INTEGER]
parser: Input 'WHERE'
parser: Reduce [term ::= INTEGER|FLOAT|BLOB], go to state 54.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Reduce [from ::=], go to state 232.
parser: Shift 'from', go to state 298
parser: Shift 'WHERE', go to state 65
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE]
parser: Input 'INTEGER'
parser: Shift 'INTEGER'
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE INTEGER]
parser: Input 'SEMI'
parser: Reduce [term ::= INTEGER|FLOAT|BLOB], go to state 65.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 65.
parser: Shift 'expr', go to state 40
parser: Reduce [where_opt ::= WHERE expr], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Reduce [orderby_opt ::=], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 22.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 2.
parser: Shift 'select'
parser: Reduce [cmd ::= select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
SQL: [SELECT 1, 2, 3 WHERE 1 ;]
VDBE Trace:
   0 Init             0    0    0               00 Start at 0
   1 Integer          1    1    0               00 r[1]=1
REG[1] =  i:1
   2 Integer          2    2    0               00 r[2]=2
REG[2] =  i:2
   3 Integer          3    3    0               00 r[3]=3
REG[3] =  i:3
   4 ResultRow        1    3    0               00 output=r[1..3]
REG[1] =  i:1
REG[2] =  i:2
REG[3] =  i:3
   5 Halt             0    0    0               00 
parser: Initialize. Empty stack. State 0
parser: Input 'CREATE'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Shift 'CREATE'
parser: Return. Stack=[explain CREATE]
parser: Input 'TABLE'
parser: Reduce [createkw ::= CREATE], go to state 2.
parser: Shift 'createkw', go to state 107
parser: Reduce [temp ::=], go to state 107.
parser: Shift 'temp', go to state 319
parser: Shift 'TABLE', go to state 266
parser: Return. Stack=[explain createkw temp TABLE]
parser: Input 'ID'
parser: Reduce [ifnotexists ::=], go to state 266.
parser: Shift 'ifnotexists', go to state 183
parser: Shift 'ID'
parser: Return. Stack=[explain createkw temp TABLE ifnotexists ID]
parser: Input 'LP'
parser: Reduce [nm ::= ID|INDEXED], go to state 183.
parser: Shift 'nm', go to state 265
parser: Reduce [dbnm ::=], go to state 265.
parser: Shift 'dbnm'
parser: Reduce [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 2.
parser: Shift 'create_table', go to state 234
parser: Shift 'LP', go to state 111
parser: Return. Stack=[explain create_table LP]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP ID]
parser: Input 'COMMA'
parser: Reduce [nm ::= ID|INDEXED], go to state 111.
parser: Shift 'nm', go to state 148
parser: Reduce [typetoken ::=], go to state 148.
parser: Shift 'typetoken'
parser: Reduce [columnname ::= nm typetoken], go to state 111.
parser: Shift 'columnname', go to state 311
parser: Reduce [carglist ::=], go to state 311.
parser: Shift 'carglist', go to state 119
parser: Reduce [columnlist ::= columnname carglist], go to state 111.
parser: Shift 'columnlist', go to state 300
parser: Shift 'COMMA', go to state 21
parser: Return. Stack=[explain create_table LP columnlist COMMA]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP columnlist COMMA ID]
parser: Input 'COMMA'
parser: Reduce [nm ::= ID|INDEXED], go to state 21.
parser: Shift 'nm', go to state 148
parser: Reduce [typetoken ::=], go to state 148.
parser: Shift 'typetoken'
parser: Reduce [columnname ::= nm typetoken], go to state 21.
parser: Shift 'columnname', go to state 314
parser: Reduce [carglist ::=], go to state 314.
parser: Shift 'carglist', go to state 120
parser: Reduce [columnlist ::= columnlist COMMA columnname carglist], go to state 111.
parser: Shift 'columnlist', go to state 300
parser: Shift 'COMMA', go to state 21
parser: Return. Stack=[explain create_table LP columnlist COMMA]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP columnlist COMMA ID]
parser: Input 'RP'
parser: Reduce [nm ::= ID|INDEXED], go to state 21.
parser: Shift 'nm', go to state 148
parser: Reduce [typetoken ::=], go to state 148.
parser: Shift 'typetoken'
parser: Reduce [columnname ::= nm typetoken], go to state 21.
parser: Shift 'columnname', go to state 314
parser: Reduce [carglist ::=], go to state 314.
parser: Shift 'carglist', go to state 120
parser: Reduce [columnlist ::= columnlist COMMA columnname carglist], go to state 111.
parser: Shift 'columnlist', go to state 300
parser: Reduce [conslist_opt ::=], go to state 300.
parser: Shift 'conslist_opt', go to state 437
parser: Shift 'RP', go to state 299
parser: Return. Stack=[explain create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI'
parser: Reduce [table_options ::=], go to state 299.
parser: Shift 'table_options'
parser: Reduce [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 234.
parser: Initialize. Empty stack. State 0
parser: Input 'UPDATE'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'UPDATE', go to state 242
parser: Return. Stack=[explain with UPDATE]
parser: Input 'STRING'
parser: Reduce [orconf ::=], go to state 242.
parser: Shift 'orconf', go to state 129
parser: Shift 'STRING'
parser: Return. Stack=[explain with UPDATE orconf STRING]
parser: Input 'DOT'
parser: Reduce [nm ::= STRING], go to state 129.
parser: Shift 'nm', go to state 259
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[explain with UPDATE orconf nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with UPDATE orconf nm DOT ID]
parser: Input 'SET'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 259.
parser: Shift 'dbnm'
parser: Reduce [fullname ::= nm dbnm], go to state 129.
parser: Shift 'fullname', go to state 219
parser: Reduce [indexed_opt ::=], go to state 219.
parser: Shift 'indexed_opt', go to state 352
parser: Shift 'SET', go to state 128
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET ID]
parser: Input 'EQ'
parser: Reduce [nm ::= ID|INDEXED], go to state 128.
parser: Shift 'nm', go to state 360
parser: Shift 'EQ', go to state 59
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET nm EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET nm EQ STRING]
parser: Input 'COMMA'
parser: Reduce [term ::= STRING], go to state 59.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 59.
parser: Shift 'expr', go to state 36
parser: Reduce [setlist ::= nm EQ expr], go to state 128.
parser: Shift 'setlist', go to state 218
parser: Shift 'COMMA', go to state 176
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist COMMA]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ'
parser: Reduce [nm ::= ID|INDEXED], go to state 176.
parser: Shift 'nm', go to state 361
parser: Shift 'EQ', go to state 60
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'COMMA'
parser: Reduce [term ::= STRING], go to state 60.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 60.
parser: Shift 'expr', go to state 37
parser: Reduce [setlist ::= setlist COMMA nm EQ expr], go to state 128.
parser: Shift 'setlist', go to state 218
parser: Shift 'COMMA', go to state 176
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist COMMA]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ'
parser: Reduce [nm ::= ID|INDEXED], go to state 176.
parser: Shift 'nm', go to state 361
parser: Shift 'EQ', go to state 60
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'COMMA'
parser: Reduce [term ::= STRING], go to state 60.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 60.
parser: Shift 'expr', go to state 37
parser: Reduce [setlist ::= setlist COMMA nm EQ expr], go to state 128.
parser: Shift 'setlist', go to state 218
parser: Shift 'COMMA', go to state 176
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist COMMA]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ'
parser: Reduce [nm ::= ID|INDEXED], go to state 176.
parser: Shift 'nm', go to state 361
parser: Shift 'EQ', go to state 60
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'VARIABLE'
parser: Shift 'VARIABLE'
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist COMMA nm EQ VARIABLE]
parser: Input 'COMMA'
parser: Reduce [expr ::= VARIABLE], go to state 60.
parser: Shift 'expr', go to state 37
parser: Reduce [setlist ::= setlist COMMA nm EQ expr], go to state 128.
parser: Shift 'setlist', go to state 218
parser: Shift 'COMMA', go to state 176
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist COMMA]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ'
parser: Reduce [nm ::= ID|INDEXED], go to state 176.
parser: Shift 'nm', go to state 361
parser: Shift 'EQ', go to state 60
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'WHERE'
parser: Reduce [term ::= STRING], go to state 60.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 60.
parser: Shift 'expr', go to state 37
parser: Reduce [setlist ::= setlist COMMA nm EQ expr], go to state 128.
parser: Shift 'setlist', go to state 218
parser: Shift 'WHERE', go to state 65
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist WHERE]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist WHERE ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist WHERE expr EQ]
parser: Input 'VARIABLE'
parser: Shift 'VARIABLE'
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist WHERE expr EQ VARIABLE]
parser: Input 'SEMI'
parser: Reduce [expr ::= VARIABLE], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Reduce [where_opt ::= WHERE expr], go to state 218.
parser: Shift 'where_opt'
parser: Reduce [cmd ::= with UPDATE orconf fullname indexed_opt SET setlist where_opt], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Input '$'
parser: Reduce [ecmd ::= explain cmdx SEMI], go to state 0.
parser: Shift 'ecmd'
parser: Reduce [cmdlist ::= ecmd], go to state 0.
parser: Shift 'cmdlist', go to state 146
parser: Reduce [input ::= cmdlist], go to state 0.
parser: Accept!
parser: Popping $
parser: Return. Stack=]
parser: Shift 'create_table_args'
parser: Reduce [cmd ::= create_table create_table_args], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
SQL: [CREATE TABLE t14(t15, m, rins);]
VDBE Trace:
   0 Init             0   30    0               00 Start at 30
  30 Transaction      0    1    8 2             01 usesStmtJournal=0
  31 TableLock        0    1    1 sqlite_master 00 iDb=0 root=1 write=1
  32 Goto             0    1    0               00 
   1 ReadCookie       0    3    2               00 
REG[3] =  i:4
   2 If               3    5    0               00 
REG[3] =  i:4
   5 CreateTable      0    2    0               00 r[2]=root iDb=0
REG[2] =  i:8
   6 OpenWrite        0    1    0 5             00 root=1 iDb=0
   7 NewRowid         0    1    0               00 r[1]=rowid
REG[1] =  i:9
   8 Blob             6    3    0              00 r[3]= (len=6)
REG[3] =  t6[060000000000......](8)
   9 Insert           0    3    1               08 intkey=r[1] data=r[3]
REG[3] =  t6[060000000000......](8)
REG[1] =  i:9
  10 Close            0    0    0               00 
  11 Close            0    0    0               00 
  12 Null             0    4    5               00 r[4..5]=NULL
REG[4] =  NULL
  13 OpenWrite        1    1    0 5             00 root=1 iDb=0; sqlite_master
  14 Explain          0    0    0 SEARCH TABLE sqlite_master USING INTEGER PRIMARY KEY (rowid=?) 00 
  15 MustBeInt        1   18    0               00 
REG[1] =  i:9
  16 NotExists        1   18    1               00 intkey=r[1]; pk
REG[1] =  i:9
  17 Rowid            1    5    0               00 r[5]=rowid
REG[5] =  i:9
  18 IsNull           5   26    0               00 if r[5]==NULL goto 26
REG[5] =  i:9
  19 String8          0    6    0 table         00 r[6]='table'
REG[6] =   t5[table](8)
  20 String8          0    7    0 t14           00 r[7]='t14'
REG[7] =   t3[t14](8)
  21 String8          0    8    0 t14           00 r[8]='t14'
REG[8] =   t3[t14](8)
  22 Copy             2    9    0               00 r[9]=r[2]
REG[9] =  i:8
  23 String8          0   10    0 CREATE TABLE t14(t15, m, rins) 00 r[10]='CREATE TABLE t14(t15, m, rins)'
REG[10] =   t30[CREATE TABLE t1](8)
  24 MakeRecord       6    5   11 BBBDB         00 r[11]=mkrec(r[6..10])
REG[11] =  s48[0617131301497461626C657431347431.....Itablet14t1](8)
  25 Insert           1   11    5               00 intkey=r[5] data=r[11]
REG[11] =  s48[0617131301497461626C657431347431.....Itablet14t1](8)
REG[5] =  i:9
  26 Close            1    0    0               00 
  27 SetCookie        0    1    9               00 
  28 ParseSchema      0    0    0 tbl_name='t14' AND type!='trigger' 00 
parser: Initialize. Empty stack. State 0
parser: Input 'SELECT'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[explain with SELECT]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'FROM'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[explain with SELECT distinct selcollist FROM]
parser: Input 'STRING'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'STRING'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix STRING]
parser: Input 'DOT'
parser: Reduce [nm ::= STRING], go to state 165.
parser: Shift 'nm', go to state 287
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Shift 'WHERE', go to state 65
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'AND', go to state 93
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'NE'
parser: Reduce [expr ::= ID|INDEXED], go to state 93.
parser: Shift 'expr', go to state 53
parser: Shift 'NE', go to state 90
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND expr NE]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND expr NE STRING]
parser: Input 'ORDER'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 93.
parser: Shift 'expr', go to state 53
parser: Reduce [expr ::= expr AND expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Reduce [where_opt ::= WHERE expr], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Shift 'ORDER', go to state 411
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY'
parser: Shift 'BY', go to state 17
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI'
parser: Reduce [expr ::= ID|INDEXED], go to state 17.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 17.
parser: Shift 'sortlist', go to state 410
parser: Reduce [orderby_opt ::= ORDER BY sortlist], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 22.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 2.
parser: Shift 'select'
parser: Reduce [cmd ::= select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
VDBE Trace:
   0 Init             0   16    0               00 Start at 16
  16 Transaction      0    0    9 2             00 usesStmtJournal=0
  17 TableLock        0    1    0 sqlite_master 00 iDb=0 root=1 write=0
  18 String8          0    2    0 t14           00 r[2]='t14'
REG[2] =   t3[t14](8)
  19 String8          0    4    0 trigger       00 r[4]='trigger'
REG[4] =   t7[trigger](8)
  20 Goto             0    1    0               00 
   1 Noop             1    5    0               00 
   2 OpenRead         0    1    0 5             00 root=1 iDb=0; sqlite_master
   3 Explain          0    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   14    0               00 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[t1](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t3[t14](8)
REG[1] =   s2[t1](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s7[numbers](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t3[t14](8)
REG[1] =   s7[numbers](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[t1](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t3[t14](8)
REG[1] =   s2[t1](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[t3](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t3[t14](8)
REG[1] =   s2[t3](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[t1](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t3[t14](8)
REG[1] =   s2[t1](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s7[numbers](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t3[t14](8)
REG[1] =   s7[numbers](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[t6](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t3[t14](8)
REG[1] =   s2[t6](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s3[t10](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t3[t14](8)
REG[1] =   s3[t10](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s3[t14](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t3[t14](8)
REG[1] =   s3[t14](8)
   7 Column           0    0    3               00 r[3]=sqlite_master.type
REG[3] =   s5[table](8)
   8 Eq               4   13    3 (BINARY)      52 if r[4]==r[3] goto 13
REG[4] =   t7[trigger](8)
REG[3] =   s5[table](8)
   9 Column           0    1    5               00 r[5]=sqlite_master.name
REG[5] =   s3[t14](8)
  10 Column           0    3    6               00 r[6]=sqlite_master.rootpage
REG[6] =  i:8
  11 Column           0    4    7               00 r[7]=sqlite_master.sql
REG[7] =   s30[CREATE TABLE t1](8)
  12 ResultRow        5    3    0               00 output=r[5..7]
REG[5] =   s3[t14](8)
REG[6] =  i:8
REG[7] =   s30[CREATE TABLE t1](8)
parser: Initialize. Empty stack. State 0
parser: Input 'CREATE'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Shift 'CREATE'
parser: Return. Stack=[explain CREATE]
parser: Input 'TABLE'
parser: Reduce [createkw ::= CREATE], go to state 2.
parser: Shift 'createkw', go to state 107
parser: Reduce [temp ::=], go to state 107.
parser: Shift 'temp', go to state 319
parser: Shift 'TABLE', go to state 266
parser: Return. Stack=[explain createkw temp TABLE]
parser: Input 'ID'
parser: Reduce [ifnotexists ::=], go to state 266.
parser: Shift 'ifnotexists', go to state 183
parser: Shift 'ID'
parser: Return. Stack=[explain createkw temp TABLE ifnotexists ID]
parser: Input 'LP'
parser: Reduce [nm ::= ID|INDEXED], go to state 183.
parser: Shift 'nm', go to state 265
parser: Reduce [dbnm ::=], go to state 265.
parser: Shift 'dbnm'
parser: Reduce [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 2.
parser: Shift 'create_table', go to state 234
parser: Shift 'LP', go to state 111
parser: Return. Stack=[explain create_table LP]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP ID]
parser: Input 'COMMA'
parser: Reduce [nm ::= ID|INDEXED], go to state 111.
parser: Shift 'nm', go to state 148
parser: Reduce [typetoken ::=], go to state 148.
parser: Shift 'typetoken'
parser: Reduce [columnname ::= nm typetoken], go to state 111.
parser: Shift 'columnname', go to state 311
parser: Reduce [carglist ::=], go to state 311.
parser: Shift 'carglist', go to state 119
parser: Reduce [columnlist ::= columnname carglist], go to state 111.
parser: Shift 'columnlist', go to state 300
parser: Shift 'COMMA', go to state 21
parser: Return. Stack=[explain create_table LP columnlist COMMA]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP columnlist COMMA ID]
parser: Input 'COMMA'
parser: Reduce [nm ::= ID|INDEXED], go to state 21.
parser: Shift 'nm', go to state 148
parser: Reduce [typetoken ::=], go to state 148.
parser: Shift 'typetoken'
parser: Reduce [columnname ::= nm typetoken], go to state 21.
parser: Shift 'columnname', go to state 314
parser: Reduce [carglist ::=], go to state 314.
parser: Shift 'carglist', go to state 120
parser: Reduce [columnlist ::= columnlist COMMA columnname carglist], go to state 111.
parser: Shift 'columnlist', go to state 300
parser: Shift 'COMMA', go to state 21
parser: Return. Stack=[explain create_table LP columnlist COMMA]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP columnlist COMMA ID]
parser: Input 'RP'
parser: Reduce [nm ::= ID|INDEXED], go to state 21.
parser: Shift 'nm', go to state 148
parser: Reduce [typetoken ::=], go to state 148.
parser: Shift 'typetoken'
parser: Reduce [columnname ::= nm typetoken], go to state 21.
parser: Shift 'columnname', go to state 314
parser: Reduce [carglist ::=], go to state 314.
parser: Shift 'carglist', go to state 120
parser: Reduce [columnlist ::= columnlist COMMA columnname carglist], go to state 111.
parser: Shift 'columnlist', go to state 300
parser: Reduce [conslist_opt ::=], go to state 300.
parser: Shift 'conslist_opt', go to state 437
parser: Shift 'RP', go to state 299
parser: Return. Stack=[explain create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI'
parser: Reduce [table_options ::=], go to state 299.
parser: Shift 'table_options'
parser: Reduce [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 234.
parser: Shift 'create_table_args'
parser: Reduce [cmd ::= create_table create_table_args], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
  13 Next             0    5    0               01 
  14 Close            0    0    0               00 
  15 Halt             0    0    0               00 
  29 Halt             0    0    0               00 
parser: Initialize. Empty stack. State 0
parser: Input 'SELECT'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[explain with SELECT]
parser: Input 'DISTINCT'
parser: Shift 'DISTINCT'
parser: Return. Stack=[explain with SELECT DISTINCT]
parser: Input 'INTEGER'
parser: Reduce [distinct ::= DISTINCT], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'INTEGER'
parser: Return. Stack=[explain with SELECT distinct sclp INTEGER]
parser: Input 'COMMA'
parser: Reduce [term ::= INTEGER|FLOAT|BLOB], go to state 54.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'INTEGER'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'INTEGER'
parser: Return. Stack=[explain with SELECT distinct sclp INTEGER]
parser: Input 'COMMA'
parser: Reduce [term ::= INTEGER|FLOAT|BLOB], go to state 54.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'INTEGER'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'INTEGER'
parser: Return. Stack=[explain with SELECT distinct sclp INTEGER]
parser: Input 'GROUP'
parser: Reduce [term ::= INTEGER|FLOAT|BLOB], go to state 54.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Reduce [from ::=], go to state 232.
parser: Shift 'from', go to state 298
parser: Reduce [where_opt ::=], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Shift 'GROUP', go to state 409
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt GROUP]
parser: Input 'BY'
parser: Shift 'BY', go to state 16
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt GROUP BY]
parser: Input 'INTEGER'
parser: Shift 'INTEGER'
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt GROUP BY INTEGER]
parser: Input 'HAVING'
parser: Reduce [term ::= INTEGER|FLOAT|BLOB], go to state 16.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 16.
parser: Shift 'expr', go to state 48
parser: Reduce [nexprlist ::= expr], go to state 16.
parser: Shift 'nexprlist', go to state 408
parser: Reduce [groupby_opt ::= GROUP BY nexprlist], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Shift 'HAVING', go to state 66
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt HAVING]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt HAVING ID]
parser: Input 'LP'
parser: Shift 'LP', go to state 216
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt HAVING ID LP]
parser: Input 'STAR'
parser: Shift 'STAR', go to state 393
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt HAVING ID LP STAR]
parser: Input 'RP'
parser: Shift 'RP'
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt HAVING ID LP STAR RP]
parser: Input 'GT'
parser: Reduce [expr ::= ID|INDEXED LP STAR RP], go to state 66.
parser: Shift 'expr', go to state 41
parser: Shift 'GT', go to state 91
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt HAVING expr GT]
parser: Input 'INTEGER'
parser: Shift 'INTEGER'
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt HAVING expr GT INTEGER]
parser: Input 'SEMI'
parser: Reduce [term ::= INTEGER|FLOAT|BLOB], go to state 91.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 91.
parser: Shift 'expr', go to state 103
parser: Reduce [expr ::= expr LT|GT|GE|LE expr], go to state 66.
parser: Shift 'expr', go to state 41
parser: Reduce [having_opt ::= HAVING expr], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Reduce [orderby_opt ::=], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 22.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 2.
parser: Shift 'select'
parser: Reduce [cmd ::= select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
SQL: [SELECT DISTINCT 1, 2, 3 GROUP BY 2 HAVING count(*)>1;]
VDBE Trace:
   0 Init             0   35    0               00 Start at 35
  35 Integer          1    9    0               00 r[9]=1
REG[9] =  i:1
  36 Goto             0    1    0               00 
   1 OpenEphemeral    0    0    0 k(3,B,B,B)    08 nColumn=0
   2 Noop             1    1    0               00 
   3 Integer          0    3    0               00 r[3]=0; clear abort flag
REG[3] =  i:0
   4 Integer          0    2    0               00 r[2]=0; indicate accumulator empty
REG[2] =  i:0
   5 Null             0    6    6               00 r[6..6]=NULL
REG[6] =  NULL
   6 Gosub            5   32    0               00 
REG[5] =  i:6
  32 Null             0    1    1               00 r[1..1]=NULL
REG[1] =  NULL
  33 Return           5    0    0               00 
REG[5] =  i:6
   7 Integer          2    7    0               00 r[7]=2
REG[7] =  i:2
   8 Compare          6    7    1 k(1,B)        00 r[6] <-> r[7]
REG[6] =  NULL
REG[7] =  i:2
   9 Jump            10   14   10               00 
  10 Move             7    6    1               00 r[6]=r[7]
REG[6] =  i:2
  11 Gosub            4   20    0               00 output one row
REG[4] =  i:11
  20 IfPos            2   22    0               00 if r[2]>0 then r[2]-=0, goto 22; Groupby result generator entry point
REG[2] =  i:0
  21 Return           4    0    0               00 
REG[4] =  i:11
  12 IfPos            3   34    0               00 if r[3]>0 then r[3]-=0, goto 34; check abort flag
REG[3] =  i:0
  13 Gosub            5   32    0               00 reset accumulator
REG[5] =  i:13
  32 Null             0    1    1               00 r[1..1]=NULL
REG[1] =  NULL
  33 Return           5    0    0               00 
REG[5] =  i:13
  14 AggStep0         0    0    1 count(0)      00 accum=r[1] step(r[0])
  15 Integer          1    2    0               00 r[2]=1; indicate data in accumulator
REG[2] =  i:1
  16 Gosub            4   20    0               00 output final row
REG[4] =  i:16
  20 IfPos            2   22    0               00 if r[2]>0 then r[2]-=0, goto 22; Groupby result generator entry point
REG[2] =  i:1
  22 AggFinal         1    0    0 count(0)      00 accum=r[1] N=0
  23 Le               9   21    1               51 if r[9]<=r[1] goto 21
REG[9] =  i:1
REG[1] =  i:1
  21 Return           4    0    0               00 
REG[4] =  i:16
  17 Goto             0   34    0               00 
  34 Halt             0    0    0               00 
parser: Initialize. Empty stack. State 0
parser: Input 'SELECT'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[explain with SELECT]
parser: Input 'INTEGER'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'INTEGER'
parser: Return. Stack=[explain with SELECT distinct sclp INTEGER]
parser: Input 'COMMA'
parser: Reduce [term ::= INTEGER|FLOAT|BLOB], go to state 54.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'INTEGER'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'INTEGER'
parser: Return. Stack=[explain with SELECT distinct sclp INTEGER]
parser: Input 'COMMA'
parser: Reduce [term ::= INTEGER|FLOAT|BLOB], go to state 54.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'INTEGER'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'INTEGER'
parser: Return. Stack=[explain with SELECT distinct sclp INTEGER]
parser: Input 'WHERE'
parser: Reduce [term ::= INTEGER|FLOAT|BLOB], go to state 54.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Reduce [from ::=], go to state 232.
parser: Shift 'from', go to state 298
parser: Shift 'WHERE', go to state 65
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE]
parser: Input 'INTEGER'
parser: Shift 'INTEGER'
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE INTEGER]
parser: Input 'GROUP'
parser: Reduce [term ::= INTEGER|FLOAT|BLOB], go to state 65.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 65.
parser: Shift 'expr', go to state 40
parser: Reduce [where_opt ::= WHERE expr], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Shift 'GROUP', go to state 409
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt GROUP]
parser: Input 'BY'
parser: Shift 'BY', go to state 16
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt GROUP BY]
parser: Input 'INTEGER'
parser: Shift 'INTEGER'
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt GROUP BY INTEGER]
parser: Input 'HAVING'
parser: Reduce [term ::= INTEGER|FLOAT|BLOB], go to state 16.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 16.
parser: Shift 'expr', go to state 48
parser: Reduce [nexprlist ::= expr], go to state 16.
parser: Shift 'nexprlist', go to state 408
parser: Reduce [groupby_opt ::= GROUP BY nexprlist], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Shift 'HAVING', go to state 66
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt HAVING]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt HAVING ID]
parser: Input 'LP'
parser: Shift 'LP', go to state 216
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt HAVING ID LP]
parser: Input 'STAR'
parser: Shift 'STAR', go to state 393
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt HAVING ID LP STAR]
parser: Input 'RP'
parser: Shift 'RP'
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt HAVING ID LP STAR RP]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED LP STAR RP], go to state 66.
parser: Shift 'expr', go to state 41
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt HAVING expr EQ]
parser: Input 'INTEGER'
parser: Shift 'INTEGER'
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt HAVING expr EQ INTEGER]
parser: Input 'SEMI'
parser: Reduce [term ::= INTEGER|FLOAT|BLOB], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 66.
parser: Shift 'expr', go to state 41
parser: Reduce [having_opt ::= HAVING expr], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Reduce [orderby_opt ::=], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 22.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 2.
parser: Shift 'select'
parser: Reduce [cmd ::= select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
SQL: [SELECT 1, 2, 3 WHERE 0 GROUP BY 2 HAVING count(*)=1;]
VDBE Trace:
   0 Init             0   32    0               00 Start at 32
  32 Integer          1    9    0               00 r[9]=1
REG[9] =  i:1
  33 Goto             0    1    0               00 
   1 Noop             0    1    0               00 
   2 Integer          0    3    0               00 r[3]=0; clear abort flag
REG[3] =  i:0
   3 Integer          0    2    0               00 r[2]=0; indicate accumulator empty
REG[2] =  i:0
   4 Null             0    6    6               00 r[6..6]=NULL
REG[6] =  NULL
   5 Gosub            5   29    0               00 
REG[5] =  i:5
  29 Null             0    1    1               00 r[1..1]=NULL
REG[1] =  NULL
  30 Return           5    0    0               00 
REG[5] =  i:5
   6 Goto             0   16    0               00 
  16 Gosub            4   20    0               00 output final row
REG[4] =  i:16
  20 IfPos            2   22    0               00 if r[2]>0 then r[2]-=0, goto 22; Groupby result generator entry point
REG[2] =  i:0
  21 Return           4    0    0               00 
REG[4] =  i:16
  17 Goto             0   31    0               00 
  31 Halt             0    0    0               00 
parser: Initialize. Empty stack. State 0
parser: Input 'SELECT'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[explain with SELECT]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'LP'
parser: Shift 'LP', go to state 216
parser: Return. Stack=[explain with SELECT distinct sclp ID LP]
parser: Input 'STAR'
parser: Shift 'STAR', go to state 393
parser: Return. Stack=[explain with SELECT distinct sclp ID LP STAR]
parser: Input 'RP'
parser: Shift 'RP'
parser: Return. Stack=[explain with SELECT distinct sclp ID LP STAR RP]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED LP STAR RP], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'LP'
parser: Shift 'LP', go to state 216
parser: Return. Stack=[explain with SELECT distinct sclp ID LP]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 216.
parser: Shift 'distinct', go to state 6
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID LP distinct ID]
parser: Input 'RP'
parser: Reduce [expr ::= ID|INDEXED], go to state 6.
parser: Shift 'expr', go to state 48
parser: Reduce [nexprlist ::= expr], go to state 6.
parser: Shift 'nexprlist', go to state 412
parser: Reduce [exprlist ::= nexprlist], go to state 6.
parser: Shift 'exprlist', go to state 394
parser: Shift 'RP'
parser: Return. Stack=[explain with SELECT distinct sclp ID LP distinct exprlist RP]
parser: Input 'FROM'
parser: Reduce [expr ::= ID|INDEXED LP distinct exprlist RP], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[explain with SELECT distinct selcollist FROM]
parser: Input 'ID'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'ID'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'WHERE'
parser: Reduce [nm ::= ID|INDEXED], go to state 165.
parser: Shift 'nm', go to state 287
parser: Reduce [dbnm ::=], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Shift 'WHERE', go to state 65
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'GROUP'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Reduce [where_opt ::= WHERE expr], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Shift 'GROUP', go to state 409
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt GROUP]
parser: Input 'BY'
parser: Shift 'BY', go to state 16
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt GROUP BY]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt GROUP BY ID]
parser: Input 'SEMI'
parser: Reduce [expr ::= ID|INDEXED], go to state 16.
parser: Shift 'expr', go to state 48
parser: Reduce [nexprlist ::= expr], go to state 16.
parser: Shift 'nexprlist', go to state 408
parser: Reduce [groupby_opt ::= GROUP BY nexprlist], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Reduce [orderby_opt ::=], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 22.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 2.
parser: Shift 'select'
parser: Reduce [cmd ::= select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
SQL: [SELECT count(*), max(x) FROM numbers WHERE x='x' GROUP BY y;]
VDBE Trace:
   0 Init             0   47    0               00 Start at 47
  47 Transaction      0    0    9 2             01 usesStmtJournal=0
  48 TableLock        0    3    0 numbers       00 iDb=0 root=3 write=0
  49 String8          0   11    0 x             00 r[11]='x'
REG[11] =   t1[x](8)
  50 Goto             0    1    0               00 
   1 SorterOpen       1    2    0 k(1,B)        00 
   2 Integer          0    5    0               00 r[5]=0; clear abort flag
REG[5] =  i:0
   3 Integer          0    4    0               00 r[4]=0; indicate accumulator empty
REG[4] =  i:0
   4 Null             0    8    8               00 r[8..8]=NULL
REG[8] =  NULL
   5 Gosub            7   44    0               00 
REG[7] =  i:5
  44 Null             0    1    3               00 r[1..3]=NULL
REG[1] =  NULL
  45 Return           7    0    0               00 
REG[7] =  i:5
   6 OpenRead         0    3    0 2             00 root=3 iDb=0; numbers
   7 Explain          0    0    0 SCAN TABLE numbers 00 
   8 Rewind           0   16    0               00 
  16 Close            0    0    0               00 
  17 OpenPseudo       2   10    2               00 2 columns in r[10]
  18 SorterSort       1   46    0               00 GROUP BY sort
  46 Halt             0    0    0               00 
parser: Initialize. Empty stack. State 0
parser: Input 'SEMI'
parser: Shift 'SEMI'
parser: Return. Stack=[SEMI]
parser: Input 'SEMI'
parser: Reduce [ecmd ::= SEMI], go to state 0.
parser: Shift 'ecmd'
parser: Reduce [cmdlist ::= ecmd], go to state 0.
parser: Shift 'cmdlist', go to state 146
parser: Shift 'SEMI'
parser: Return. Stack=[cmdlist SEMI]
parser: Input 'SELECT'
parser: Reduce [ecmd ::= SEMI], go to state 146.
parser: Shift 'ecmd'
parser: Reduce [cmdlist ::= cmdlist ecmd], go to state 0.
parser: Shift 'cmdlist', go to state 146
parser: Reduce [explain ::=], go to state 146.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[cmdlist explain with SELECT]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct sclp ID]
parser: Input 'FROM'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist FROM]
parser: Input 'STRING'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'STRING'
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist FROM stl_prefix STRING]
parser: Input 'DOT'
parser: Reduce [nm ::= STRING], go to state 165.
parser: Shift 'nm', go to state 287
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Shift 'WHERE', go to state 65
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'AND', go to state 93
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'NE'
parser: Reduce [expr ::= ID|INDEXED], go to state 93.
parser: Shift 'expr', go to state 53
parser: Shift 'NE', go to state 90
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE expr AND expr NE]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE expr AND expr NE STRING]
parser: Input 'ORDER'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 93.
parser: Shift 'expr', go to state 53
parser: Reduce [expr ::= expr AND expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Reduce [where_opt ::= WHERE expr], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Shift 'ORDER', go to state 411
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY'
parser: Shift 'BY', go to state 17
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI'
parser: Reduce [expr ::= ID|INDEXED], go to state 17.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 17.
parser: Shift 'sortlist', go to state 410
parser: Reduce [orderby_opt ::= ORDER BY sortlist], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 22.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 2.
parser: Shift 'select'
parser: Reduce [cmd ::= select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[cmdlist explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping cmdlist
parser: Popping $
SQL: [;;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t1' AND type!='trigger' ORDER BY rowid;]
VDBE Trace:
   0 Init             0   16    0               00 Start at 16
  16 Transaction      0    0    9 2             01 usesStmtJournal=0
  17 TableLock        0    1    0 sqlite_master 00 iDb=0 root=1 write=0
  18 String8          0    2    0 t1            00 r[2]='t1'
REG[2] =   t2[t1](8)
  19 String8          0    4    0 trigger       00 r[4]='trigger'
REG[4] =   t7[trigger](8)
  20 Goto             0    1    0               00 
   1 Noop             1    5    0               00 
   2 OpenRead         0    1    0 5             00 root=1 iDb=0; sqlite_master
   3 Explain          0    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   14    0               00 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[t1](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t2[t1](8)
REG[1] =   s2[t1](8)
   7 Column           0    0    3               00 r[3]=sqlite_master.type
REG[3] =   s5[table](8)
   8 Eq               4   13    3 (BINARY)      52 if r[4]==r[3] goto 13
REG[4] =   t7[trigger](8)
REG[3] =   s5[table](8)
   9 Column           0    1    5               00 r[5]=sqlite_master.name
REG[5] =   s2[t1](8)
  10 Column           0    3    6               00 r[6]=sqlite_master.rootpage
REG[6] =  i:2
  11 Column           0    4    7               00 r[7]=sqlite_master.sql
REG[7] =   s41[CREATE TABLE t1](8)
  12 ResultRow        5    3    0               00 output=r[5..7]
REG[5] =   s2[t1](8)
REG[6] =  i:2
REG[7] =   s41[CREATE TABLE t1](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s7[numbers](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t2[t1](8)
REG[1] =   s7[numbers](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[t1](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t2[t1](8)
REG[1] =   s2[t1](8)
   7 Column           0    0    3               00 r[3]=sqlite_master.type
REG[3] =   s5[index](8)
   8 Eq               4   13    3 (BINARY)      52 if r[4]==r[3] goto 13
REG[4] =   t7[trigger](8)
REG[3] =   s5[index](8)
   9 Column           0    1    5               00 r[5]=sqlite_master.name
REG[5] =   s2[t2](8)
  10 Column           0    3    6               00 r[6]=sqlite_master.rootpage
REG[6] =  i:4
  11 Column           0    4    7               00 r[7]=sqlite_master.sql
REG[7] =   s24[CREATE INDEX t2](8)
  12 ResultRow        5    3    0               00 output=r[5..7]
REG[5] =   s2[t2](8)
REG[6] =  i:4
REG[7] =   s24[CREATE INDEX t2](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[t3](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t2[t1](8)
REG[1] =   s2[t3](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[t1](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t2[t1](8)
REG[1] =   s2[t1](8)
   7 Column           0    0    3               00 r[3]=sqlite_master.type
REG[3] =   s5[index](8)
   8 Eq               4   13    3 (BINARY)      52 if r[4]==r[3] goto 13
REG[4] =   t7[trigger](8)
REG[3] =   s5[index](8)
   9 Column           0    1    5               00 r[5]=sqlite_master.name
REG[5] =   s2[t4](8)
  10 Column           0    3    6               00 r[6]=sqlite_master.rootpage
REG[6] =  i:5
  11 Column           0    4    7               00 r[7]=sqlite_master.sql
REG[7] =   s24[CREATE INDEX t4](8)
  12 ResultRow        5    3    0               00 output=r[5..7]
REG[5] =   s2[t4](8)
REG[6] =  i:5
REG[7] =   s24[CREATE INDEX t4](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s7[numbers](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t2[t1](8)
REG[1] =   s7[numbers](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[t6](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t2[t1](8)
REG[1] =   s2[t6](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s3[t10](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t2[t1](8)
REG[1] =   s3[t10](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s3[t14](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t2[t1](8)
REG[1] =   s3[t14](8)
  13 Next             0    5    0               01 
  14 Close            0    0    0               00 
  15 Halt             0    0    0               00 
parser: Initialize. Empty stack. State 0
parser: Input 'SEMI'
parser: Shift 'SEMI'
parser: Return. Stack=[SEMI]
parser: Input 'SEMI'
parser: Reduce [ecmd ::= SEMI], go to state 0.
parser: Shift 'ecmd'
parser: Reduce [cmdlist ::= ecmd], go to state 0.
parser: Shift 'cmdlist', go to state 146
parser: Shift 'SEMI'
parser: Return. Stack=[cmdlist SEMI]
parser: Input 'SELECT'
parser: Reduce [ecmd ::= SEMI], go to state 146.
parser: Shift 'ecmd'
parser: Reduce [cmdlist ::= cmdlist ecmd], go to state 0.
parser: Shift 'cmdlist', go to state 146
parser: Reduce [explain ::=], go to state 146.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[cmdlist explain with SELECT]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct sclp ID]
parser: Input 'FROM'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist FROM]
parser: Input 'ID'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'ID'
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'DOT'
parser: Reduce [nm ::= ID|INDEXED], go to state 165.
parser: Shift 'nm', go to state 287
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'ORDER'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Reduce [where_opt ::=], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Shift 'ORDER', go to state 411
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY'
parser: Shift 'BY', go to state 17
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI'
parser: Reduce [expr ::= ID|INDEXED], go to state 17.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 17.
parser: Shift 'sortlist', go to state 410
parser: Reduce [orderby_opt ::= ORDER BY sortlist], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 22.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 2.
parser: Shift 'select'
parser: Reduce [cmd ::= select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[cmdlist explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping cmdlist
parser: Popping $
SQL: [;;
SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;]
VDBE Trace:
   0 Init             0   12    0               00 Start at 12
  12 Transaction      0    0    9 2             01 usesStmtJournal=0
  13 TableLock        0    1    0 sqlite_master 00 iDb=0 root=1 write=0
  14 Goto             0    1    0               00 
   1 Noop             1    5    0               00 
   2 OpenRead         0    1    0 5             00 root=1 iDb=0; sqlite_master
   3 Explain          0    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   10    0               00 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s2[t1](8)
   6 Column           0    3    2               00 r[2]=sqlite_master.rootpage
REG[2] =  i:2
   7 Column           0    4    3               00 r[3]=sqlite_master.sql
REG[3] =   s41[CREATE TABLE t1](8)
   8 ResultRow        1    3    0               00 output=r[1..3]
REG[1] =   s2[t1](8)
REG[2] =  i:2
REG[3] =   s41[CREATE TABLE t1](8)
   9 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s7[numbers](8)
   6 Column           0    3    2               00 r[2]=sqlite_master.rootpage
REG[2] =  i:3
   7 Column           0    4    3               00 r[3]=sqlite_master.sql
REG[3] =   s34[CREATE TABLE nu](8)
   8 ResultRow        1    3    0               00 output=r[1..3]
REG[1] =   s7[numbers](8)
REG[2] =  i:3
REG[3] =   s34[CREATE TABLE nu](8)
   9 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s2[t2](8)
   6 Column           0    3    2               00 r[2]=sqlite_master.rootpage
REG[2] =  i:4
   7 Column           0    4    3               00 r[3]=sqlite_master.sql
REG[3] =   s24[CREATE INDEX t2](8)
   8 ResultRow        1    3    0               00 output=r[1..3]
REG[1] =   s2[t2](8)
REG[2] =  i:4
REG[3] =   s24[CREATE INDEX t2](8)
   9 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s2[t3](8)
   6 Column           0    3    2               00 r[2]=sqlite_master.rootpage
REG[2] =  i:0
   7 Column           0    4    3               00 r[3]=sqlite_master.sql
REG[3] =   s189[CREATE VIEW t3 ](8)
   8 ResultRow        1    3    0               00 output=r[1..3]
REG[1] =   s2[t3](8)
REG[2] =  i:0
REG[3] =   s189[CREATE VIEW t3 ](8)
   9 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s2[t4](8)
   6 Column           0    3    2               00 r[2]=sqlite_master.rootpage
REG[2] =  i:5
   7 Column           0    4    3               00 r[3]=sqlite_master.sql
REG[3] =   s24[CREATE INDEX t4](8)
   8 ResultRow        1    3    0               00 output=r[1..3]
REG[1] =   s2[t4](8)
REG[2] =  i:5
REG[3] =   s24[CREATE INDEX t4](8)
   9 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s2[t5](8)
   6 Column           0    3    2               00 r[2]=sqlite_master.rootpage
REG[2] =  i:0
   7 Column           0    4    3               00 r[3]=sqlite_master.sql
REG[3] =   s62[CREATE TRIGGER ](8)
   8 ResultRow        1    3    0               00 output=r[1..3]
REG[1] =   s2[t5](8)
REG[2] =  i:0
REG[3] =   s62[CREATE TRIGGER ](8)
   9 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s2[t6](8)
   6 Column           0    3    2               00 r[2]=sqlite_master.rootpage
REG[2] =  i:6
   7 Column           0    4    3               00 r[3]=sqlite_master.sql
REG[3] =   s27[CREATE TABLE t6](8)
   8 ResultRow        1    3    0               00 output=r[1..3]
REG[1] =   s2[t6](8)
REG[2] =  i:6
REG[3] =   s27[CREATE TABLE t6](8)
   9 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s3[t10](8)
   6 Column           0    3    2               00 r[2]=sqlite_master.rootpage
REG[2] =  i:7
   7 Column           0    4    3               00 r[3]=sqlite_master.sql
REG[3] =   s31[CREATE TABLE t1](8)
   8 ResultRow        1    3    0               00 output=r[1..3]
REG[1] =   s3[t10](8)
REG[2] =  i:7
REG[3] =   s31[CREATE TABLE t1](8)
   9 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s3[t14](8)
   6 Column           0    3    2               00 r[2]=sqlite_master.rootpage
REG[2] =  i:8
   7 Column           0    4    3               00 r[3]=sqlite_master.sql
REG[3] =   s30[CREATE TABLE t1](8)
   8 ResultRow        1    3    0               00 output=r[1..3]
REG[1] =   s3[t14](8)
REG[2] =  i:8
REG[3] =   s30[CREATE TABLE t1](8)
   9 Next             0    5    0               01 
  10 Close            0    0    0               00 
  11 Halt             0    0    0               00 
parser: Initialize. Empty stack. State 0
parser: Input 'SEMI'
parser: Shift 'SEMI'
parser: Return. Stack=[SEMI]
parser: Input 'SEMI'
parser: Reduce [ecmd ::= SEMI], go to state 0.
parser: Shift 'ecmd'
parser: Reduce [cmdlist ::= ecmd], go to state 0.
parser: Shift 'cmdlist', go to state 146
parser: Shift 'SEMI'
parser: Return. Stack=[cmdlist SEMI]
parser: Input 'SELECT'
parser: Reduce [ecmd ::= SEMI], go to state 146.
parser: Shift 'ecmd'
parser: Reduce [cmdlist ::= cmdlist ecmd], go to state 0.
parser: Shift 'cmdlist', go to state 146
parser: Reduce [explain ::=], go to state 146.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[cmdlist explain with SELECT]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct sclp ID]
parser: Input 'FROM'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist FROM]
parser: Input 'ID'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'ID'
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'DOT'
parser: Reduce [nm ::= ID|INDEXED], go to state 165.
parser: Shift 'nm', go to state 287
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'ORDER'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Reduce [where_opt ::=], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Shift 'ORDER', go to state 411
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY'
parser: Shift 'BY', go to state 17
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI'
parser: Reduce [expr ::= ID|INDEXED], go to state 17.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 17.
parser: Shift 'sortlist', go to state 410
parser: Reduce [orderby_opt ::= ORDER BY sortlist], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 22.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 2.
parser: Shift 'select'
parser: Reduce [cmd ::= select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[cmdlist explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping cmdlist
parser: Popping $
SQL: [;;
SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;]
VDBE Trace:
   0 Init             0   12    0               00 Start at 12
  12 Transaction      0    0    9 2             01 usesStmtJournal=0
  13 TableLock        0    1    0 sqlite_master 00 iDb=0 root=1 write=0
  14 Goto             0    1    0               00 
   1 Noop             1    5    0               00 
   2 OpenRead         0    1    0 5             00 root=1 iDb=0; sqlite_master
   3 Explain          0    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   10    0               00 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s2[t1](8)
   6 Column           0    3    2               00 r[2]=sqlite_master.rootpage
REG[2] =  i:2
   7 Column           0    4    3               00 r[3]=sqlite_master.sql
REG[3] =   s41[CREATE TABLE t1](8)
   8 ResultRow        1    3    0               00 output=r[1..3]
REG[1] =   s2[t1](8)
REG[2] =  i:2
REG[3] =   s41[CREATE TABLE t1](8)
   9 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s7[numbers](8)
   6 Column           0    3    2               00 r[2]=sqlite_master.rootpage
REG[2] =  i:3
   7 Column           0    4    3               00 r[3]=sqlite_master.sql
REG[3] =   s34[CREATE TABLE nu](8)
   8 ResultRow        1    3    0               00 output=r[1..3]
REG[1] =   s7[numbers](8)
REG[2] =  i:3
REG[3] =   s34[CREATE TABLE nu](8)
   9 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s2[t2](8)
   6 Column           0    3    2               00 r[2]=sqlite_master.rootpage
REG[2] =  i:4
   7 Column           0    4    3               00 r[3]=sqlite_master.sql
REG[3] =   s24[CREATE INDEX t2](8)
   8 ResultRow        1    3    0               00 output=r[1..3]
REG[1] =   s2[t2](8)
REG[2] =  i:4
REG[3] =   s24[CREATE INDEX t2](8)
   9 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s2[t3](8)
   6 Column           0    3    2               00 r[2]=sqlite_master.rootpage
REG[2] =  i:0
   7 Column           0    4    3               00 r[3]=sqlite_master.sql
REG[3] =   s189[CREATE VIEW t3 ](8)
   8 ResultRow        1    3    0               00 output=r[1..3]
REG[1] =   s2[t3](8)
REG[2] =  i:0
REG[3] =   s189[CREATE VIEW t3 ](8)
   9 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s2[t4](8)
   6 Column           0    3    2               00 r[2]=sqlite_master.rootpage
REG[2] =  i:5
   7 Column           0    4    3               00 r[3]=sqlite_master.sql
REG[3] =   s24[CREATE INDEX t4](8)
   8 ResultRow        1    3    0               00 output=r[1..3]
REG[1] =   s2[t4](8)
REG[2] =  i:5
REG[3] =   s24[CREATE INDEX t4](8)
   9 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s2[t5](8)
   6 Column           0    3    2               00 r[2]=sqlite_master.rootpage
REG[2] =  i:0
   7 Column           0    4    3               00 r[3]=sqlite_master.sql
REG[3] =   s62[CREATE TRIGGER ](8)
   8 ResultRow        1    3    0               00 output=r[1..3]
REG[1] =   s2[t5](8)
REG[2] =  i:0
REG[3] =   s62[CREATE TRIGGER ](8)
   9 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s2[t6](8)
   6 Column           0    3    2               00 r[2]=sqlite_master.rootpage
REG[2] =  i:6
   7 Column           0    4    3               00 r[3]=sqlite_master.sql
REG[3] =   s27[CREATE TABLE t6](8)
   8 ResultRow        1    3    0               00 output=r[1..3]
REG[1] =   s2[t6](8)
REG[2] =  i:6
REG[3] =   s27[CREATE TABLE t6](8)
   9 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s3[t10](8)
   6 Column           0    3    2               00 r[2]=sqlite_master.rootpage
REG[2] =  i:7
   7 Column           0    4    3               00 r[3]=sqlite_master.sql
REG[3] =   s31[CREATE TABLE t1](8)
   8 ResultRow        1    3    0               00 output=r[1..3]
REG[1] =   s3[t10](8)
REG[2] =  i:7
REG[3] =   s31[CREATE TABLE t1](8)
   9 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s3[t14](8)
   6 Column           0    3    2               00 r[2]=sqlite_master.rootpage
REG[2] =  i:8
   7 Column           0    4    3               00 r[3]=sqlite_master.sql
REG[3] =   s30[CREATE TABLE t1](8)
   8 ResultRow        1    3    0               00 output=r[1..3]
REG[1] =   s3[t14](8)
REG[2] =  i:8
REG[3] =   s30[CREATE TABLE t1](8)
   9 Next             0    5    0               01 
  10 Close            0    0    0               00 
  11 Halt             0    0    0               00 
parser: Initialize. Empty stack. State 0
parser: Input 'DELETE'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'DELETE', go to state 353
parser: Return. Stack=[explain with DELETE]
parser: Input 'FROM'
parser: Shift 'FROM', go to state 130
parser: Return. Stack=[explain with DELETE FROM]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with DELETE FROM ID]
parser: Input 'WHERE'
parser: Reduce [nm ::= ID|INDEXED], go to state 130.
parser: Shift 'nm', go to state 259
parser: Reduce [dbnm ::=], go to state 259.
parser: Shift 'dbnm'
parser: Reduce [fullname ::= nm dbnm], go to state 130.
parser: Shift 'fullname', go to state 220
parser: Reduce [indexed_opt ::=], go to state 220.
parser: Shift 'indexed_opt', go to state 243
parser: Shift 'WHERE', go to state 65
parser: Return. Stack=[explain with DELETE FROM fullname indexed_opt WHERE]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with DELETE FROM fullname indexed_opt WHERE ID]
parser: Input 'LT'
parser: Reduce [expr ::= ID|INDEXED], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'LT', go to state 91
parser: Return. Stack=[explain with DELETE FROM fullname indexed_opt WHERE expr LT]
parser: Input 'INTEGER'
parser: Shift 'INTEGER'
parser: Return. Stack=[explain with DELETE FROM fullname indexed_opt WHERE expr LT INTEGER]
parser: Input 'SEMI'
parser: Reduce [term ::= INTEGER|FLOAT|BLOB], go to state 91.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 91.
parser: Shift 'expr', go to state 103
parser: Reduce [expr ::= expr LT|GT|GE|LE expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Reduce [where_opt ::= WHERE expr], go to state 243.
parser: Shift 'where_opt'
parser: Reduce [cmd ::= with DELETE FROM fullname indexed_opt where_opt], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
SQL: [DELETE FROM t6 WHERE rowid < 30;]
VDBE Trace:
   0 Init             0   13    0               00 Start at 13
  13 Transaction      0    1    9 2             01 usesStmtJournal=0
  14 TableLock        0    6    1 t6            00 iDb=0 root=6 write=1
  15 Goto             0    1    0               00 
   1 Null             0    1    0               00 r[1]=NULL
REG[1] =  NULL
   2 OpenWrite        0    6    0 3             00 root=6 iDb=0; t6
   3 Explain          0    0    0 SEARCH TABLE t6 USING INTEGER PRIMARY KEY (rowid<?) 00 
   4 Rewind           0   11    0               00 
  11 Noop             0    0    0               00 
  12 Halt             0    0    0               00 
parser: Initialize. Empty stack. State 0
parser: Input 'SELECT'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[explain with SELECT]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'LP'
parser: Shift 'LP', go to state 216
parser: Return. Stack=[explain with SELECT distinct sclp ID LP]
parser: Input 'STAR'
parser: Shift 'STAR', go to state 393
parser: Return. Stack=[explain with SELECT distinct sclp ID LP STAR]
parser: Input 'RP'
parser: Shift 'RP'
parser: Return. Stack=[explain with SELECT distinct sclp ID LP STAR RP]
parser: Input 'FROM'
parser: Reduce [expr ::= ID|INDEXED LP STAR RP], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[explain with SELECT distinct selcollist FROM]
parser: Input 'ID'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'ID'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'COMMA'
parser: Reduce [nm ::= ID|INDEXED], go to state 165.
parser: Shift 'nm', go to state 287
parser: Reduce [dbnm ::=], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM seltablist COMMA]
parser: Input 'ID'
parser: Reduce [joinop ::= COMMA|JOIN], go to state 214.
parser: Shift 'joinop'
parser: Reduce [stl_prefix ::= seltablist joinop], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'ID'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'SEMI'
parser: Reduce [nm ::= ID|INDEXED], go to state 165.
parser: Shift 'nm', go to state 287
parser: Reduce [dbnm ::=], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Reduce [where_opt ::=], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Reduce [orderby_opt ::=], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 22.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 2.
parser: Shift 'select'
parser: Reduce [cmd ::= select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
SQL: [SELECT count(*) FROM t10 , t10 
;]
VDBE Trace:
   0 Init             0   17    0               00 Start at 17
  17 Transaction      0    0    9 2             01 usesStmtJournal=0
  18 TableLock        0    7    0 t10           00 iDb=0 root=7 write=0
  19 Goto             0    1    0               00 
   1 Null             0    1    1               00 r[1..1]=NULL
REG[1] =  NULL
   2 OpenRead         0    7    0 0             00 root=7 iDb=0; t10
   3 OpenRead         1    7    0 0             00 root=7 iDb=0; t10
   4 Explain          0    0    0 SCAN TABLE t10 00 
   5 Rewind           0   11    0               00 
  11 Close            0    0    0               00 
  12 Close            1    0    0               00 
  13 AggFinal         1    0    0 count(0)      00 accum=r[1] N=0
  14 Copy             1    2    0               00 r[2]=r[1]
REG[2] =  i:0
  15 ResultRow        2    1    0               00 output=r[2]
REG[2] =  i:0
  16 Halt             0    0    0               00 
parser: Initialize. Empty stack. State 0
parser: Input 'SEMI'
parser: Shift 'SEMI'
parser: Return. Stack=[SEMI]
parser: Input 'SELECT'
parser: Reduce [ecmd ::= SEMI], go to state 0.
parser: Shift 'ecmd'
parser: Reduce [cmdlist ::= ecmd], go to state 0.
parser: Shift 'cmdlist', go to state 146
parser: Reduce [explain ::=], go to state 146.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[cmdlist explain with SELECT]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct sclp ID]
parser: Input 'FROM'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist FROM]
parser: Input 'ID'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'ID'
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'DOT'
parser: Reduce [nm ::= ID|INDEXED], go to state 165.
parser: Shift 'nm', go to state 287
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'ORDER'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Reduce [where_opt ::=], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Shift 'ORDER', go to state 411
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY'
parser: Shift 'BY', go to state 17
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI'
parser: Reduce [expr ::= ID|INDEXED], go to state 17.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 17.
parser: Shift 'sortlist', go to state 410
parser: Reduce [orderby_opt ::= ORDER BY sortlist], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 22.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 2.
parser: Shift 'select'
parser: Reduce [cmd ::= select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[cmdlist explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping cmdlist
parser: Popping $
SQL: [;
SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid;]
VDBE Trace:
   0 Init             0   12    0               00 Start at 12
  12 Transaction      0    0    9 2             01 usesStmtJournal=0
  13 TableLock        0    1    0 sqlite_master 00 iDb=0 root=1 write=0
  14 Goto             0    1    0               00 
   1 Noop             1    5    0               00 
   2 OpenRead         0    1    0 5             00 root=1 iDb=0; sqlite_master
   3 Explain          0    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   10    0               00 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s2[t1](8)
   6 Column           0    3    2               00 r[2]=sqlite_master.rootpage
REG[2] =  i:2
   7 Column           0    4    3               00 r[3]=sqlite_master.sql
REG[3] =   s41[CREATE TABLE t1](8)
   8 ResultRow        1    3    0               00 output=r[1..3]
REG[1] =   s2[t1](8)
REG[2] =  i:2
REG[3] =   s41[CREATE TABLE t1](8)
   9 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s7[numbers](8)
   6 Column           0    3    2               00 r[2]=sqlite_master.rootpage
REG[2] =  i:3
   7 Column           0    4    3               00 r[3]=sqlite_master.sql
REG[3] =   s34[CREATE TABLE nu](8)
   8 ResultRow        1    3    0               00 output=r[1..3]
REG[1] =   s7[numbers](8)
REG[2] =  i:3
REG[3] =   s34[CREATE TABLE nu](8)
   9 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s2[t2](8)
   6 Column           0    3    2               00 r[2]=sqlite_master.rootpage
REG[2] =  i:4
   7 Column           0    4    3               00 r[3]=sqlite_master.sql
REG[3] =   s24[CREATE INDEX t2](8)
   8 ResultRow        1    3    0               00 output=r[1..3]
REG[1] =   s2[t2](8)
REG[2] =  i:4
REG[3] =   s24[CREATE INDEX t2](8)
   9 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s2[t3](8)
   6 Column           0    3    2               00 r[2]=sqlite_master.rootpage
REG[2] =  i:0
   7 Column           0    4    3               00 r[3]=sqlite_master.sql
REG[3] =   s189[CREATE VIEW t3 ](8)
   8 ResultRow        1    3    0               00 output=r[1..3]
REG[1] =   s2[t3](8)
REG[2] =  i:0
REG[3] =   s189[CREATE VIEW t3 ](8)
   9 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s2[t4](8)
   6 Column           0    3    2               00 r[2]=sqlite_master.rootpage
REG[2] =  i:5
   7 Column           0    4    3               00 r[3]=sqlite_master.sql
REG[3] =   s24[CREATE INDEX t4](8)
   8 ResultRow        1    3    0               00 output=r[1..3]
REG[1] =   s2[t4](8)
REG[2] =  i:5
REG[3] =   s24[CREATE INDEX t4](8)
   9 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s2[t5](8)
   6 Column           0    3    2               00 r[2]=sqlite_master.rootpage
REG[2] =  i:0
   7 Column           0    4    3               00 r[3]=sqlite_master.sql
REG[3] =   s62[CREATE TRIGGER ](8)
   8 ResultRow        1    3    0               00 output=r[1..3]
REG[1] =   s2[t5](8)
REG[2] =  i:0
REG[3] =   s62[CREATE TRIGGER ](8)
   9 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s2[t6](8)
   6 Column           0    3    2               00 r[2]=sqlite_master.rootpage
REG[2] =  i:6
   7 Column           0    4    3               00 r[3]=sqlite_master.sql
REG[3] =   s27[CREATE TABLE t6](8)
   8 ResultRow        1    3    0               00 output=r[1..3]
REG[1] =   s2[t6](8)
REG[2] =  i:6
REG[3] =   s27[CREATE TABLE t6](8)
   9 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s3[t10](8)
   6 Column           0    3    2               00 r[2]=sqlite_master.rootpage
REG[2] =  i:7
   7 Column           0    4    3               00 r[3]=sqlite_master.sql
REG[3] =   s31[CREATE TABLE t1](8)
   8 ResultRow        1    3    0               00 output=r[1..3]
REG[1] =   s3[t10](8)
REG[2] =  i:7
REG[3] =   s31[CREATE TABLE t1](8)
   9 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s3[t14](8)
   6 Column           0    3    2               00 r[2]=sqlite_master.rootpage
REG[2] =  i:8
   7 Column           0    4    3               00 r[3]=sqlite_master.sql
REG[3] =   s30[CREATE TABLE t1](8)
   8 ResultRow        1    3    0               00 output=r[1..3]
REG[1] =   s3[t14](8)
REG[2] =  i:8
REG[3] =   s30[CREATE TABLE t1](8)
   9 Next             0    5    0               01 
  10 Close            0    0    0               00 
  11 Halt             0    0    0               00 
parser: Initialize. Empty stack. State 0
parser: Input 'SEMI'
parser: Shift 'SEMI'
parser: Return. Stack=[SEMI]
parser: Input 'SELECT'
parser: Reduce [ecmd ::= SEMI], go to state 0.
parser: Shift 'ecmd'
parser: Reduce [cmdlist ::= ecmd], go to state 0.
parser: Shift 'cmdlist', go to state 146
parser: Reduce [explain ::=], go to state 146.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[cmdlist explain with SELECT]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct sclp ID]
parser: Input 'FROM'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist FROM]
parser: Input 'STRING'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'STRING'
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist FROM stl_prefix STRING]
parser: Input 'DOT'
parser: Reduce [nm ::= STRING], go to state 165.
parser: Shift 'nm', go to state 287
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Shift 'WHERE', go to state 65
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'AND', go to state 93
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'NE'
parser: Reduce [expr ::= ID|INDEXED], go to state 93.
parser: Shift 'expr', go to state 53
parser: Shift 'NE', go to state 90
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE expr AND expr NE]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE expr AND expr NE STRING]
parser: Input 'ORDER'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 93.
parser: Shift 'expr', go to state 53
parser: Reduce [expr ::= expr AND expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Reduce [where_opt ::= WHERE expr], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Shift 'ORDER', go to state 411
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY'
parser: Shift 'BY', go to state 17
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI'
parser: Reduce [expr ::= ID|INDEXED], go to state 17.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 17.
parser: Shift 'sortlist', go to state 410
parser: Reduce [orderby_opt ::= ORDER BY sortlist], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 22.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 2.
parser: Shift 'select'
parser: Reduce [cmd ::= select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[cmdlist explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping cmdlist
parser: Popping $
SQL: [;
SELECT name, rootpage, sql FROM 'main'.sqlite_master WHERE tbl_name='t6' AND type!='trigger' ORDER BY rowid;]
VDBE Trace:
   0 Init             0   16    0               00 Start at 16
  16 Transaction      0    0    9 2             01 usesStmtJournal=0
  17 TableLock        0    1    0 sqlite_master 00 iDb=0 root=1 write=0
  18 String8          0    2    0 t6            00 r[2]='t6'
REG[2] =   t2[t6](8)
  19 String8          0    4    0 trigger       00 r[4]='trigger'
REG[4] =   t7[trigger](8)
  20 Goto             0    1    0               00 
   1 Noop             1    5    0               00 
   2 OpenRead         0    1    0 5             00 root=1 iDb=0; sqlite_master
   3 Explain          0    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   14    0               00 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[t1](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t2[t6](8)
REG[1] =   s2[t1](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s7[numbers](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t2[t6](8)
REG[1] =   s7[numbers](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[t1](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t2[t6](8)
REG[1] =   s2[t1](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[t3](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t2[t6](8)
REG[1] =   s2[t3](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[t1](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t2[t6](8)
REG[1] =   s2[t1](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s7[numbers](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t2[t6](8)
REG[1] =   s7[numbers](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[t6](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t2[t6](8)
REG[1] =   s2[t6](8)
   7 Column           0    0    3               00 r[3]=sqlite_master.type
REG[3] =   s5[table](8)
   8 Eq               4   13    3 (BINARY)      52 if r[4]==r[3] goto 13
REG[4] =   t7[trigger](8)
REG[3] =   s5[table](8)
   9 Column           0    1    5               00 r[5]=sqlite_master.name
REG[5] =   s2[t6](8)
  10 Column           0    3    6               00 r[6]=sqlite_master.rootpage
REG[6] =  i:6
  11 Column           0    4    7               00 r[7]=sqlite_master.sql
REG[7] =   s27[CREATE TABLE t6](8)
  12 ResultRow        5    3    0               00 output=r[5..7]
REG[5] =   s2[t6](8)
REG[6] =  i:6
REG[7] =   s27[CREATE TABLE t6](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s3[t10](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t2[t6](8)
REG[1] =   s3[t10](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s3[t14](8)
   6 Ne               2   13    1 (BINARY)      52 if r[2]!=r[1] goto 13
REG[2] =   t2[t6](8)
REG[1] =   s3[t14](8)
  13 Next             0    5    0               01 
  14 Close            0    0    0               00 
  15 Halt             0    0    0               00 
parser: Initialize. Empty stack. State 0
parser: Input 'SELECT'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[explain with SELECT]
parser: Input 'STAR'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'STAR'
parser: Return. Stack=[explain with SELECT distinct sclp STAR]
parser: Input 'FROM'
parser: Reduce [selcollist ::= sclp STAR], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[explain with SELECT distinct selcollist FROM]
parser: Input 'LP'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'LP', go to state 24
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix LP]
parser: Input 'SELECT'
parser: Reduce [with ::=], go to state 24.
parser: Shift 'with', go to state 113
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix LP with SELECT]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix LP with SELECT distinct sclp ID]
parser: Input 'COLLATE'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Shift 'COLLATE', go to state 339
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix LP with SELECT distinct sclp expr COLLATE]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix LP with SELECT distinct sclp expr COLLATE ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= expr COLLATE ID|STRING], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix LP with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix LP with SELECT distinct sclp ID]
parser: Input 'FROM'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix LP with SELECT distinct selcollist FROM]
parser: Input 'ID'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'ID'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix LP with SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'RP'
parser: Reduce [nm ::= ID|INDEXED], go to state 165.
parser: Shift 'nm', go to state 287
parser: Reduce [dbnm ::=], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Reduce [where_opt ::=], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Reduce [orderby_opt ::=], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 113.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 113.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 24.
parser: Shift 'select', go to state 402
parser: Shift 'RP', go to state 211
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix LP select RP]
parser: Input 'JOIN_KW'
parser: Reduce [as ::=], go to state 211.
parser: Shift 'as', go to state 280
parser: Reduce [on_opt ::=], go to state 280.
parser: Shift 'on_opt', go to state 279
parser: Reduce [using_opt ::=], go to state 279.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix LP select RP as on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Shift 'JOIN_KW', go to state 167
parser: Return. Stack=[explain with SELECT distinct selcollist FROM seltablist JOIN_KW]
parser: Input 'JOIN'
parser: Shift 'JOIN'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM seltablist JOIN_KW JOIN]
parser: Input 'ID'
parser: Reduce [joinop ::= JOIN_KW JOIN], go to state 214.
parser: Shift 'joinop'
parser: Reduce [stl_prefix ::= seltablist joinop], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'ID'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'USING'
parser: Reduce [nm ::= ID|INDEXED], go to state 165.
parser: Shift 'nm', go to state 287
parser: Reduce [dbnm ::=], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Shift 'USING', go to state 406
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix nm dbnm as indexed_opt on_opt USING]
parser: Input 'LP'
parser: Shift 'LP', go to state 143
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix nm dbnm as indexed_opt on_opt USING LP]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix nm dbnm as indexed_opt on_opt USING LP ID]
parser: Input 'RP'
parser: Reduce [nm ::= ID|INDEXED], go to state 143.
parser: Shift 'nm'
parser: Reduce [idlist ::= nm], go to state 143.
parser: Shift 'idlist', go to state 333
parser: Shift 'RP'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix nm dbnm as indexed_opt on_opt USING LP idlist RP]
parser: Input 'SEMI'
parser: Reduce [using_opt ::= USING LP idlist RP], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Reduce [where_opt ::=], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Reduce [orderby_opt ::=], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [l
Program received signal SIGABRT, Aborted.
__GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:50
(gdb) #0  __GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:50
#1  0x00007fcb4b05d859 in __GI_abort () at abort.c:79
#2  0x00007fcb4b05d729 in __assert_fail_base (fmt=0x7fcb4b1f3588 "%s%s%s:%u: %s%sAssertion `%s' failed.\n%n", assertion=0x212bb5 "0", file=0x222c23 "sqlite3.c", line=125392, function=<optimized out>) at assert.c:92
#3  0x00007fcb4b06efd6 in __GI___assert_fail (assertion=0x212bb5 "0", file=0x222c23 "sqlite3.c", line=125392, function=0x2266f4 "int termIsEquivalence(Parse *, Expr *)") at assert.c:101
#4  0x0000000000398c39 in exprAnalyze (pSrc=<optimized out>, pWC=<optimized out>, idxTerm=<optimized out>) at sqlite3.c:125392
#5  0x000000000038c95f in sqlite3WhereBegin (pParse=<optimized out>, pTabList=<optimized out>, pWhere=<optimized out>, pOrderBy=<optimized out>, pDistinctSet=0x8b2ee0, wctrlFlags=0, iAuxArg=320) at sqlite3.c:125921
#6  0x0000000000328d02 in sqlite3Select (pParse=<optimized out>, p=<optimized out>, pDest=<optimized out>) at sqlite3.c:118028
#7  0x00000000003034ae in yy_reduce (yypParser=0x8c5f50, yyruleno=<optimized out>) at sqlite3.c:133175
#8  0x00000000002fef8e in sqlite3Parser (yyp=0x8c5f50, yymajor=<optimized out>, yyminor=..., pParse=<optimized out>) at sqlite3.c:134258
#9  0x00000000002fc544 in sqlite3RunParser (pParse=0x8a1910, 
    zSql=0x8c1450 "SELECT * FROM (SELECT a COLLATE nocase, a FROM t1) CROSS JOIN t1 USING (a) ;;\nPRAGMA freelist_count;;\nSELECT name, rootpage, sql FROM \"main\".sqlite_master ORDER BY rowid;;;\nSELECT name, rootpage, sql "..., pzErrMsg=0x7ffe463693e8) at sqlite3.c:135186
#10 0x00000000002fac4e in sqlite3Prepare (db=0x8a0750, 
    zSql=0x8a2c71 "SELECT * FROM (SELECT a COLLATE nocase, a FROM t1) CROSS JOIN t1 USING (a) ;;\nPRAGMA freelist_count;;\nSELECT name, rootpage, sql FROM \"main\".sqlite_master ORDER BY rowid;;;\nSELECT name, rootpage, sql "..., nBytes=<optimized out>, saveSqlFlag=1, pReprepare=<optimized out>, ppStmt=0x7ffe46369518, pzTail=0x7ffe46369500) at sqlite3.c:112589
#11 0x00000000002fa0f4 in sqlite3LockAndPrepare (db=0x8a0750, 
    zSql=0x8a2c71 "SELECT * FROM (SELECT a COLLATE nocase, a FROM t1) CROSS JOIN t1 USING (a) ;;\nPRAGMA freelist_count;;\nSELECT name, rootpage, sql FROM \"main\".sqlite_master ORDER BY rowid;;;\nSELECT name, rootpage, sql "..., nBytes=2060, saveSqlFlag=1, pOld=0x0, ppStmt=<optimized out>, pzTail=0x7ffe46369500) at sqlite3.c:112688
#12 0x000000000028f38c in sqlite3_prepare_v2 (db=0x2, zSql=0x7ffe463689d0 "", nBytes=0, ppStmt=0x7ffe46369518, pzTail=<optimized out>) at sqlite3.c:112764
#13 0x000000000024b100 in main (argc=1, argv=0x7ffe463696c8) at target.cc:106
(gdb) quit
A debugging session is active.

	Inferior 1 [process 9645] will be killed.

Quit anyway? (y or n) [answered Y; input not from terminal]
