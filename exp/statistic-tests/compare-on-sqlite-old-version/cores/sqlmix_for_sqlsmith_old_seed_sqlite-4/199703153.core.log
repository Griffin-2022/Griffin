GNU gdb (Ubuntu 9.2-0ubuntu1~20.04.1) 9.2
Copyright (C) 2020 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type "show copying" and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
    <http://www.gnu.org/software/gdb/documentation/>.

For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from /root/sqlite_driver_fast...
(gdb) Starting program: /root/sqlite_driver_fast < "/root/out/default/crashes/id:000301,sig:06,src:004523+006077,time:11040137,execs:1089883,op:merge.so,pos:0"
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[cmdlist explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping cmdlist
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'SELECT'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[explain with SELECT]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'FROM'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[explain with SELECT distinct selcollist FROM]
parser: Input 'STRING'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'STRING'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix STRING]
parser: Input 'DOT'
parser: Reduce [nm ::= STRING], go to state 165.
parser: Shift 'nm', go to state 287
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Shift 'WHERE', go to state 65
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'AND', go to state 93
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 93.
parser: Shift 'expr', go to state 53
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND expr EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND expr EQ STRING]
parser: Input 'ORDER'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 93.
parser: Shift 'expr', go to state 53
parser: Reduce [expr ::= expr AND expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Reduce [where_opt ::= WHERE expr], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Shift 'ORDER', go to state 411
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY'
parser: Shift 'BY', go to state 17
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI'
parser: Reduce [expr ::= ID|INDEXED], go to state 17.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 17.
parser: Shift 'sortlist', go to state 410
parser: Reduce [orderby_opt ::= ORDER BY sortlist], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 22.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 2.
parser: Shift 'select'
parser: Reduce [cmd ::= select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'CREATE'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Shift 'CREATE'
parser: Return. Stack=[explain CREATE]
parser: Input 'INDEX'
parser: Reduce [createkw ::= CREATE], go to state 2.
parser: Shift 'createkw', go to state 107
parser: Reduce [uniqueflag ::=], go to state 107.
parser: Shift 'uniqueflag', go to state 370
parser: Shift 'INDEX', go to state 256
parser: Return. Stack=[explain createkw uniqueflag INDEX]
parser: Input 'ID'
parser: Reduce [ifnotexists ::=], go to state 256.
parser: Shift 'ifnotexists', go to state 180
parser: Shift 'ID'
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists ID]
parser: Input 'ON'
parser: Reduce [nm ::= ID|INDEXED], go to state 180.
parser: Shift 'nm', go to state 255
parser: Reduce [dbnm ::=], go to state 255.
parser: Shift 'dbnm', go to state 369
parser: Shift 'ON', go to state 179
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON ID]
parser: Input 'LP'
parser: Reduce [nm ::= ID|INDEXED], go to state 179.
parser: Shift 'nm', go to state 368
parser: Shift 'LP', go to state 12
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP ID]
parser: Input 'RP'
parser: Reduce [expr ::= ID|INDEXED], go to state 12.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 12.
parser: Shift 'sortlist', go to state 325
parser: Shift 'RP', go to state 254
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP]
parser: Input 'SEMI'
parser: Reduce [where_opt ::=], go to state 254.
parser: Shift 'where_opt'
parser: Reduce [cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt], go to state 2.
parser: Initialize. Empty stack. State 0
parser: Input 'INSERT'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'INSERT', go to state 253
parser: Return. Stack=[explain with INSERT]
parser: Input 'INTO'
parser: Reduce [orconf ::=], go to state 253.
parser: Shift 'orconf'
parser: Reduce [insert_cmd ::= INSERT orconf], go to state 22.
parser: Shift 'insert_cmd', go to state 351
parser: Shift 'INTO', go to state 127
parser: Return. Stack=[explain with insert_cmd INTO]
parser: Input 'STRING'
parser: Shift 'STRING'
parser: Return. Stack=[explain with insert_cmd INTO STRING]
parser: Input 'DOT'
parser: Reduce [nm ::= STRING], go to state 127.
parser: Shift 'nm', go to state 259
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[explain with insert_cmd INTO nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with insert_cmd INTO nm DOT ID]
parser: Input 'VALUES'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 259.
parser: Shift 'dbnm'
parser: Reduce [fullname ::= nm dbnm], go to state 127.
parser: Shift 'fullname', go to state 241
parser: Reduce [idlist_opt ::=], go to state 241.
parser: Shift 'idlist_opt', go to state 147
parser: Reduce [with ::=], go to state 147.
parser: Shift 'with', go to state 113
parser: Shift 'VALUES', go to state 397
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES]
parser: Input 'LP'
parser: Shift 'LP', go to state 15
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP STRING]
parser: Input 'COMMA'
parser: Reduce [term ::= STRING], go to state 15.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 15.
parser: Shift 'expr', go to state 48
parser: Reduce [nexprlist ::= expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'COMMA', go to state 70
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA STRING]
parser: Input 'COMMA'
parser: Reduce [term ::= STRING], go to state 70.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 70.
parser: Shift 'expr', go to state 43
parser: Reduce [nexprlist ::= nexprlist COMMA expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'COMMA', go to state 70
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA STRING]
parser: Input 'COMMA'
parser: Reduce [term ::= STRING], go to state 70.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 70.
parser: Shift 'expr', go to state 43
parser: Reduce [nexprlist ::= nexprlist COMMA expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'COMMA', go to state 70
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA]
parser: Input 'VARIABLE'
parser: Shift 'VARIABLE'
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA VARIABLE]
parser: Input 'COMMA'
parser: Reduce [expr ::= VARIABLE], go to state 70.
parser: Shift 'expr', go to state 43
parser: Reduce [nexprlist ::= nexprlist COMMA expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'COMMA', go to state 70
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA STRING]
parser: Input 'RP'
parser: Reduce [term ::= STRING], go to state 70.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 70.
parser: Shift 'expr', go to state 43
parser: Reduce [nexprlist ::= nexprlist COMMA expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'RP'
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist RP]
parser: Input 'SEMI'
parser: Reduce [values ::= VALUES LP nexprlist RP], go to state 113.
parser: Shift 'values', go to state 400
parser: Reduce [oneselect ::= values], go to state 113.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 113.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 147.
parser: Shift 'select'
parser: Reduce [cmd ::= with insert_cmd INTO fullname idlist_opt select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Input '$'
parser: Reduce [ecmd ::= explain cmdx SEMI], go to state 0.
parser: Shift 'ecmd'
parser: Reduce [cmdlist ::= ecmd], go to state 0.
parser: Shift 'cmdlist', go to state 146
parser: Reduce [input ::= cmdlist], go to state 0.
parser: Accept!
parser: Popping $
parser: Return. Stack=]
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'SELECT'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[explain with SELECT]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'FROM'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[explain with SELECT distinct selcollist FROM]
parser: Input 'STRING'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'STRING'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix STRING]
parser: Input 'DOT'
parser: Reduce [nm ::= STRING], go to state 165.
parser: Shift 'nm', go to state 287
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Shift 'WHERE', go to state 65
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'AND', go to state 93
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 93.
parser: Shift 'expr', go to state 53
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND expr EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND expr EQ STRING]
parser: Input 'ORDER'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 93.
parser: Shift 'expr', go to state 53
parser: Reduce [expr ::= expr AND expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Reduce [where_opt ::= WHERE expr], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Shift 'ORDER', go to state 411
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY'
parser: Shift 'BY', go to state 17
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI'
parser: Reduce [expr ::= ID|INDEXED], go to state 17.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 17.
parser: Shift 'sortlist', go to state 410
parser: Reduce [orderby_opt ::= ORDER BY sortlist], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 22.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 2.
parser: Shift 'select'
parser: Reduce [cmd ::= select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'CREATE'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Shift 'CREATE'
parser: Return. Stack=[explain CREATE]
parser: Input 'INDEX'
parser: Reduce [createkw ::= CREATE], go to state 2.
parser: Shift 'createkw', go to state 107
parser: Reduce [uniqueflag ::=], go to state 107.
parser: Shift 'uniqueflag', go to state 370
parser: Shift 'INDEX', go to state 256
parser: Return. Stack=[explain createkw uniqueflag INDEX]
parser: Input 'ID'
parser: Reduce [ifnotexists ::=], go to state 256.
parser: Shift 'ifnotexists', go to state 180
parser: Shift 'ID'
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists ID]
parser: Input 'ON'
parser: Reduce [nm ::= ID|INDEXED], go to state 180.
parser: Shift 'nm', go to state 255
parser: Reduce [dbnm ::=], go to state 255.
parser: Shift 'dbnm', go to state 369
parser: Shift 'ON', go to state 179
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON ID]
parser: Input 'LP'
parser: Reduce [nm ::= ID|INDEXED], go to state 179.
parser: Shift 'nm', go to state 368
parser: Shift 'LP', go to state 12
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP ID]
parser: Input 'RP'
parser: Reduce [expr ::= ID|INDEXED], go to state 12.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 12.
parser: Shift 'sortlist', go to state 325
parser: Shift 'RP', go to state 254
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP]
parser: Input 'SEMI'
parser: Reduce [where_opt ::=], go to state 254.
parser: Shift 'where_opt'
parser: Reduce [cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'SELECT'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[explain with SELECT]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'FROM'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[explain with SELECT distinct selcollist FROM]
parser: Input 'STRING'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'STRING'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix STRING]
parser: Input 'DOT'
parser: Reduce [nm ::= STRING], go to state 165.
parser: Shift 'nm', go to state 287
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Shift 'WHERE', go to state 65
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'AND', go to state 93
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 93.
parser: Shift 'expr', go to state 53
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND expr EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND expr EQ STRING]
parser: Input 'ORDER'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 93.
parser: Shift 'expr', go to state 53
parser: Reduce [expr ::= expr AND expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Reduce [where_opt ::= WHERE expr], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Shift 'ORDER', go to state 411
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY'
parser: Shift 'BY', go to state 17
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI'
parser: Reduce [expr ::= ID|INDEXED], go to state 17.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 17.
parser: Shift 'sortlist', go to state 410
parser: Reduce [orderby_opt ::= ORDER BY sortlist], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 22.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 2.
parser: Shift 'select'
parser: Reduce [cmd ::= select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'SELECT'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[explain with SELECT]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'FROM'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[explain with SELECT distinct selcollist FROM]
parser: Input 'STRING'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'STRING'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix STRING]
parser: Input 'DOT'
parser: Reduce [nm ::= STRING], go to state 165.
parser: Shift 'nm', go to state 287
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Shift 'WHERE', go to state 65
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'AND', go to state 93
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 93.
parser: Shift 'expr', go to state 53
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND expr EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND expr EQ STRING]
parser: Input 'ORDER'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 93.
parser: Shift 'expr', go to state 53
parser: Reduce [expr ::= expr AND expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Reduce [where_opt ::= WHERE expr], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Shift 'ORDER', go to state 411
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY'
parser: Shift 'BY', go to state 17
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI'
parser: Reduce [expr ::= ID|INDEXED], go to state 17.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 17.
parser: Shift 'sortlist', go to state 410
parser: Reduce [orderby_opt ::= ORDER BY sortlist], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 22.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 2.
parser: Shift 'select'
parser: Reduce [cmd ::= select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'CREATE'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Shift 'CREATE'
parser: Return. Stack=[explain CREATE]
parser: Input 'INDEX'
parser: Reduce [createkw ::= CREATE], go to state 2.
parser: Shift 'createkw', go to state 107
parser: Reduce [uniqueflag ::=], go to state 107.
parser: Shift 'uniqueflag', go to state 370
parser: Shift 'INDEX', go to state 256
parser: Return. Stack=[explain createkw uniqueflag INDEX]
parser: Input 'ID'
parser: Reduce [ifnotexists ::=], go to state 256.
parser: Shift 'ifnotexists', go to state 180
parser: Shift 'ID'
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists ID]
parser: Input 'ON'
parser: Reduce [nm ::= ID|INDEXED], go to state 180.
parser: Shift 'nm', go to state 255
parser: Reduce [dbnm ::=], go to state 255.
parser: Shift 'dbnm', go to state 369
parser: Shift 'ON', go to state 179
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON ID]
parser: Input 'LP'
parser: Reduce [nm ::= ID|INDEXED], go to state 179.
parser: Shift 'nm', go to state 368
parser: Shift 'LP', go to state 12
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP ID]
parser: Input 'RP'
parser: Reduce [expr ::= ID|INDEXED], go to state 12.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 12.
parser: Shift 'sortlist', go to state 325
parser: Shift 'RP', go to state 254
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP]
parser: Input 'SEMI'
parser: Reduce [where_opt ::=], go to state 254.
parser: Shift 'where_opt'
parser: Reduce [cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt], go to state 2.
parser: Initialize. Empty stack. State 0
parser: Input 'INSERT'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'INSERT', go to state 253
parser: Return. Stack=[explain with INSERT]
parser: Input 'INTO'
parser: Reduce [orconf ::=], go to state 253.
parser: Shift 'orconf'
parser: Reduce [insert_cmd ::= INSERT orconf], go to state 22.
parser: Shift 'insert_cmd', go to state 351
parser: Shift 'INTO', go to state 127
parser: Return. Stack=[explain with insert_cmd INTO]
parser: Input 'STRING'
parser: Shift 'STRING'
parser: Return. Stack=[explain with insert_cmd INTO STRING]
parser: Input 'DOT'
parser: Reduce [nm ::= STRING], go to state 127.
parser: Shift 'nm', go to state 259
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[explain with insert_cmd INTO nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with insert_cmd INTO nm DOT ID]
parser: Input 'VALUES'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 259.
parser: Shift 'dbnm'
parser: Reduce [fullname ::= nm dbnm], go to state 127.
parser: Shift 'fullname', go to state 241
parser: Reduce [idlist_opt ::=], go to state 241.
parser: Shift 'idlist_opt', go to state 147
parser: Reduce [with ::=], go to state 147.
parser: Shift 'with', go to state 113
parser: Shift 'VALUES', go to state 397
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES]
parser: Input 'LP'
parser: Shift 'LP', go to state 15
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP STRING]
parser: Input 'COMMA'
parser: Reduce [term ::= STRING], go to state 15.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 15.
parser: Shift 'expr', go to state 48
parser: Reduce [nexprlist ::= expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'COMMA', go to state 70
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA STRING]
parser: Input 'COMMA'
parser: Reduce [term ::= STRING], go to state 70.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 70.
parser: Shift 'expr', go to state 43
parser: Reduce [nexprlist ::= nexprlist COMMA expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'COMMA', go to state 70
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA STRING]
parser: Input 'COMMA'
parser: Reduce [term ::= STRING], go to state 70.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 70.
parser: Shift 'expr', go to state 43
parser: Reduce [nexprlist ::= nexprlist COMMA expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'COMMA', go to state 70
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA]
parser: Input 'VARIABLE'
parser: Shift 'VARIABLE'
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA VARIABLE]
parser: Input 'COMMA'
parser: Reduce [expr ::= VARIABLE], go to state 70.
parser: Shift 'expr', go to state 43
parser: Reduce [nexprlist ::= nexprlist COMMA expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'COMMA', go to state 70
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA STRING]
parser: Input 'RP'
parser: Reduce [term ::= STRING], go to state 70.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 70.
parser: Shift 'expr', go to state 43
parser: Reduce [nexprlist ::= nexprlist COMMA expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'RP'
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist RP]
parser: Input 'SEMI'
parser: Reduce [values ::= VALUES LP nexprlist RP], go to state 113.
parser: Shift 'values', go to state 400
parser: Reduce [oneselect ::= values], go to state 113.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 113.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 147.
parser: Shift 'select'
parser: Reduce [cmd ::= with insert_cmd INTO fullname idlist_opt select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Input '$'
parser: Reduce [ecmd ::= explain cmdx SEMI], go to state 0.
parser: Shift 'ecmd'
parser: Reduce [cmdlist ::= ecmd], go to state 0.
parser: Shift 'cmdlist', go to state 146
parser: Reduce [input ::= cmdlist], go to state 0.
parser: Accept!
parser: Popping $
parser: Return. Stack=]
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'SELECT'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[explain with SELECT]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'FROM'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[explain with SELECT distinct selcollist FROM]
parser: Input 'STRING'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'STRING'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix STRING]
parser: Input 'DOT'
parser: Reduce [nm ::= STRING], go to state 165.
parser: Shift 'nm', go to state 287
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Shift 'WHERE', go to state 65
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'AND', go to state 93
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 93.
parser: Shift 'expr', go to state 53
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND expr EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND expr EQ STRING]
parser: Input 'ORDER'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 93.
parser: Shift 'expr', go to state 53
parser: Reduce [expr ::= expr AND expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Reduce [where_opt ::= WHERE expr], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Shift 'ORDER', go to state 411
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY'
parser: Shift 'BY', go to state 17
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI'
parser: Reduce [expr ::= ID|INDEXED], go to state 17.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 17.
parser: Shift 'sortlist', go to state 410
parser: Reduce [orderby_opt ::= ORDER BY sortlist], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 22.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 2.
parser: Shift 'select'
parser: Reduce [cmd ::= select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'CREATE'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Shift 'CREATE'
parser: Return. Stack=[explain CREATE]
parser: Input 'INDEX'
parser: Reduce [createkw ::= CREATE], go to state 2.
parser: Shift 'createkw', go to state 107
parser: Reduce [uniqueflag ::=], go to state 107.
parser: Shift 'uniqueflag', go to state 370
parser: Shift 'INDEX', go to state 256
parser: Return. Stack=[explain createkw uniqueflag INDEX]
parser: Input 'ID'
parser: Reduce [ifnotexists ::=], go to state 256.
parser: Shift 'ifnotexists', go to state 180
parser: Shift 'ID'
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists ID]
parser: Input 'ON'
parser: Reduce [nm ::= ID|INDEXED], go to state 180.
parser: Shift 'nm', go to state 255
parser: Reduce [dbnm ::=], go to state 255.
parser: Shift 'dbnm', go to state 369
parser: Shift 'ON', go to state 179
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON ID]
parser: Input 'LP'
parser: Reduce [nm ::= ID|INDEXED], go to state 179.
parser: Shift 'nm', go to state 368
parser: Shift 'LP', go to state 12
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP ID]
parser: Input 'RP'
parser: Reduce [expr ::= ID|INDEXED], go to state 12.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 12.
parser: Shift 'sortlist', go to state 325
parser: Shift 'RP', go to state 254
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP]
parser: Input 'SEMI'
parser: Reduce [where_opt ::=], go to state 254.
parser: Shift 'where_opt'
parser: Reduce [cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'CREATE'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Shift 'CREATE'
parser: Return. Stack=[explain CREATE]
parser: Input 'INDEX'
parser: Reduce [createkw ::= CREATE], go to state 2.
parser: Shift 'createkw', go to state 107
parser: Reduce [uniqueflag ::=], go to state 107.
parser: Shift 'uniqueflag', go to state 370
parser: Shift 'INDEX', go to state 256
parser: Return. Stack=[explain createkw uniqueflag INDEX]
parser: Input 'ID'
parser: Reduce [ifnotexists ::=], go to state 256.
parser: Shift 'ifnotexists', go to state 180
parser: Shift 'ID'
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists ID]
parser: Input 'ON'
parser: Reduce [nm ::= ID|INDEXED], go to state 180.
parser: Shift 'nm', go to state 255
parser: Reduce [dbnm ::=], go to state 255.
parser: Shift 'dbnm', go to state 369
parser: Shift 'ON', go to state 179
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON ID]
parser: Input 'LP'
parser: Reduce [nm ::= ID|INDEXED], go to state 179.
parser: Shift 'nm', go to state 368
parser: Shift 'LP', go to state 12
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP ID]
parser: Input 'RP'
parser: Reduce [expr ::= ID|INDEXED], go to state 12.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 12.
parser: Shift 'sortlist', go to state 325
parser: Shift 'RP', go to state 254
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP]
parser: Input 'SEMI'
parser: Reduce [where_opt ::=], go to state 254.
parser: Shift 'where_opt'
parser: Reduce [cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt], go to state 2.
parser: Initialize. Empty stack. State 0
parser: Input 'INSERT'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'INSERT', go to state 253
parser: Return. Stack=[explain with INSERT]
parser: Input 'INTO'
parser: Reduce [orconf ::=], go to state 253.
parser: Shift 'orconf'
parser: Reduce [insert_cmd ::= INSERT orconf], go to state 22.
parser: Shift 'insert_cmd', go to state 351
parser: Shift 'INTO', go to state 127
parser: Return. Stack=[explain with insert_cmd INTO]
parser: Input 'STRING'
parser: Shift 'STRING'
parser: Return. Stack=[explain with insert_cmd INTO STRING]
parser: Input 'DOT'
parser: Reduce [nm ::= STRING], go to state 127.
parser: Shift 'nm', go to state 259
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[explain with insert_cmd INTO nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with insert_cmd INTO nm DOT ID]
parser: Input 'VALUES'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 259.
parser: Shift 'dbnm'
parser: Reduce [fullname ::= nm dbnm], go to state 127.
parser: Shift 'fullname', go to state 241
parser: Reduce [idlist_opt ::=], go to state 241.
parser: Shift 'idlist_opt', go to state 147
parser: Reduce [with ::=], go to state 147.
parser: Shift 'with', go to state 113
parser: Shift 'VALUES', go to state 397
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES]
parser: Input 'LP'
parser: Shift 'LP', go to state 15
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP STRING]
parser: Input 'COMMA'
parser: Reduce [term ::= STRING], go to state 15.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 15.
parser: Shift 'expr', go to state 48
parser: Reduce [nexprlist ::= expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'COMMA', go to state 70
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA STRING]
parser: Input 'COMMA'
parser: Reduce [term ::= STRING], go to state 70.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 70.
parser: Shift 'expr', go to state 43
parser: Reduce [nexprlist ::= nexprlist COMMA expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'COMMA', go to state 70
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA STRING]
parser: Input 'COMMA'
parser: Reduce [term ::= STRING], go to state 70.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 70.
parser: Shift 'expr', go to state 43
parser: Reduce [nexprlist ::= nexprlist COMMA expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'COMMA', go to state 70
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA]
parser: Input 'VARIABLE'
parser: Shift 'VARIABLE'
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA VARIABLE]
parser: Input 'COMMA'
parser: Reduce [expr ::= VARIABLE], go to state 70.
parser: Shift 'expr', go to state 43
parser: Reduce [nexprlist ::= nexprlist COMMA expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'COMMA', go to state 70
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA STRING]
parser: Input 'RP'
parser: Reduce [term ::= STRING], go to state 70.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 70.
parser: Shift 'expr', go to state 43
parser: Reduce [nexprlist ::= nexprlist COMMA expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'RP'
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist RP]
parser: Input 'SEMI'
parser: Reduce [values ::= VALUES LP nexprlist RP], go to state 113.
parser: Shift 'values', go to state 400
parser: Reduce [oneselect ::= values], go to state 113.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 113.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 147.
parser: Shift 'select'
parser: Reduce [cmd ::= with insert_cmd INTO fullname idlist_opt select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Input '$'
parser: Reduce [ecmd ::= explain cmdx SEMI], go to state 0.
parser: Shift 'ecmd'
parser: Reduce [cmdlist ::= ecmd], go to state 0.
parser: Shift 'cmdlist', go to state 146
parser: Reduce [input ::= cmdlist], go to state 0.
parser: Accept!
parser: Popping $
parser: Return. Stack=]
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'SELECT'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[explain with SELECT]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'FROM'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[explain with SELECT distinct selcollist FROM]
parser: Input 'STRING'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'STRING'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix STRING]
parser: Input 'DOT'
parser: Reduce [nm ::= STRING], go to state 165.
parser: Shift 'nm', go to state 287
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Shift 'WHERE', go to state 65
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'AND', go to state 93
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 93.
parser: Shift 'expr', go to state 53
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND expr EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND expr EQ STRING]
parser: Input 'ORDER'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 93.
parser: Shift 'expr', go to state 53
parser: Reduce [expr ::= expr AND expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Reduce [where_opt ::= WHERE expr], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Shift 'ORDER', go to state 411
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY'
parser: Shift 'BY', go to state 17
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI'
parser: Reduce [expr ::= ID|INDEXED], go to state 17.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 17.
parser: Shift 'sortlist', go to state 410
parser: Reduce [orderby_opt ::= ORDER BY sortlist], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 22.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 2.
parser: Shift 'select'
parser: Reduce [cmd ::= select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'CREATE'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Shift 'CREATE'
parser: Return. Stack=[explain CREATE]
parser: Input 'INDEX'
parser: Reduce [createkw ::= CREATE], go to state 2.
parser: Shift 'createkw', go to state 107
parser: Reduce [uniqueflag ::=], go to state 107.
parser: Shift 'uniqueflag', go to state 370
parser: Shift 'INDEX', go to state 256
parser: Return. Stack=[explain createkw uniqueflag INDEX]
parser: Input 'ID'
parser: Reduce [ifnotexists ::=], go to state 256.
parser: Shift 'ifnotexists', go to state 180
parser: Shift 'ID'
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists ID]
parser: Input 'ON'
parser: Reduce [nm ::= ID|INDEXED], go to state 180.
parser: Shift 'nm', go to state 255
parser: Reduce [dbnm ::=], go to state 255.
parser: Shift 'dbnm', go to state 369
parser: Shift 'ON', go to state 179
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON ID]
parser: Input 'LP'
parser: Reduce [nm ::= ID|INDEXED], go to state 179.
parser: Shift 'nm', go to state 368
parser: Shift 'LP', go to state 12
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP ID]
parser: Input 'RP'
parser: Reduce [expr ::= ID|INDEXED], go to state 12.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 12.
parser: Shift 'sortlist', go to state 325
parser: Shift 'RP', go to state 254
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP]
parser: Input 'SEMI'
parser: Reduce [where_opt ::=], go to state 254.
parser: Shift 'where_opt'
parser: Reduce [cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'CREATE'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Shift 'CREATE'
parser: Return. Stack=[explain CREATE]
parser: Input 'INDEX'
parser: Reduce [createkw ::= CREATE], go to state 2.
parser: Shift 'createkw', go to state 107
parser: Reduce [uniqueflag ::=], go to state 107.
parser: Shift 'uniqueflag', go to state 370
parser: Shift 'INDEX', go to state 256
parser: Return. Stack=[explain createkw uniqueflag INDEX]
parser: Input 'ID'
parser: Reduce [ifnotexists ::=], go to state 256.
parser: Shift 'ifnotexists', go to state 180
parser: Shift 'ID'
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists ID]
parser: Input 'ON'
parser: Reduce [nm ::= ID|INDEXED], go to state 180.
parser: Shift 'nm', go to state 255
parser: Reduce [dbnm ::=], go to state 255.
parser: Shift 'dbnm', go to state 369
parser: Shift 'ON', go to state 179
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON ID]
parser: Input 'LP'
parser: Reduce [nm ::= ID|INDEXED], go to state 179.
parser: Shift 'nm', go to state 368
parser: Shift 'LP', go to state 12
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP ID]
parser: Input 'RP'
parser: Reduce [expr ::= ID|INDEXED], go to state 12.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 12.
parser: Shift 'sortlist', go to state 325
parser: Shift 'RP', go to state 254
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP]
parser: Input 'SEMI'
parser: Reduce [where_opt ::=], go to state 254.
parser: Shift 'where_opt'
parser: Reduce [cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt], go to state 2.
parser: Initialize. Empty stack. State 0
parser: Input 'INSERT'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'INSERT', go to state 253
parser: Return. Stack=[explain with INSERT]
parser: Input 'INTO'
parser: Reduce [orconf ::=], go to state 253.
parser: Shift 'orconf'
parser: Reduce [insert_cmd ::= INSERT orconf], go to state 22.
parser: Shift 'insert_cmd', go to state 351
parser: Shift 'INTO', go to state 127
parser: Return. Stack=[explain with insert_cmd INTO]
parser: Input 'STRING'
parser: Shift 'STRING'
parser: Return. Stack=[explain with insert_cmd INTO STRING]
parser: Input 'DOT'
parser: Reduce [nm ::= STRING], go to state 127.
parser: Shift 'nm', go to state 259
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[explain with insert_cmd INTO nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with insert_cmd INTO nm DOT ID]
parser: Input 'VALUES'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 259.
parser: Shift 'dbnm'
parser: Reduce [fullname ::= nm dbnm], go to state 127.
parser: Shift 'fullname', go to state 241
parser: Reduce [idlist_opt ::=], go to state 241.
parser: Shift 'idlist_opt', go to state 147
parser: Reduce [with ::=], go to state 147.
parser: Shift 'with', go to state 113
parser: Shift 'VALUES', go to state 397
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES]
parser: Input 'LP'
parser: Shift 'LP', go to state 15
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP STRING]
parser: Input 'COMMA'
parser: Reduce [term ::= STRING], go to state 15.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 15.
parser: Shift 'expr', go to state 48
parser: Reduce [nexprlist ::= expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'COMMA', go to state 70
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA STRING]
parser: Input 'COMMA'
parser: Reduce [term ::= STRING], go to state 70.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 70.
parser: Shift 'expr', go to state 43
parser: Reduce [nexprlist ::= nexprlist COMMA expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'COMMA', go to state 70
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA STRING]
parser: Input 'COMMA'
parser: Reduce [term ::= STRING], go to state 70.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 70.
parser: Shift 'expr', go to state 43
parser: Reduce [nexprlist ::= nexprlist COMMA expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'COMMA', go to state 70
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA]
parser: Input 'VARIABLE'
parser: Shift 'VARIABLE'
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA VARIABLE]
parser: Input 'COMMA'
parser: Reduce [expr ::= VARIABLE], go to state 70.
parser: Shift 'expr', go to state 43
parser: Reduce [nexprlist ::= nexprlist COMMA expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'COMMA', go to state 70
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA STRING]
parser: Input 'RP'
parser: Reduce [term ::= STRING], go to state 70.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 70.
parser: Shift 'expr', go to state 43
parser: Reduce [nexprlist ::= nexprlist COMMA expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'RP'
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist RP]
parser: Input 'SEMI'
parser: Reduce [values ::= VALUES LP nexprlist RP], go to state 113.
parser: Shift 'values', go to state 400
parser: Reduce [oneselect ::= values], go to state 113.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 113.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 147.
parser: Shift 'select'
parser: Reduce [cmd ::= with insert_cmd INTO fullname idlist_opt select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Input '$'
parser: Reduce [ecmd ::= explain cmdx SEMI], go to state 0.
parser: Shift 'ecmd'
parser: Reduce [cmdlist ::= ecmd], go to state 0.
parser: Shift 'cmdlist', go to state 146
parser: Reduce [input ::= cmdlist], go to state 0.
parser: Accept!
parser: Popping $
parser: Return. Stack=]
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'SELECT'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[explain with SELECT]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'FROM'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[explain with SELECT distinct selcollist FROM]
parser: Input 'STRING'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'STRING'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix STRING]
parser: Input 'DOT'
parser: Reduce [nm ::= STRING], go to state 165.
parser: Shift 'nm', go to state 287
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Shift 'WHERE', go to state 65
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'AND', go to state 93
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 93.
parser: Shift 'expr', go to state 53
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND expr EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND expr EQ STRING]
parser: Input 'ORDER'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 93.
parser: Shift 'expr', go to state 53
parser: Reduce [expr ::= expr AND expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Reduce [where_opt ::= WHERE expr], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Shift 'ORDER', go to state 411
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY'
parser: Shift 'BY', go to state 17
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI'
parser: Reduce [expr ::= ID|INDEXED], go to state 17.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 17.
parser: Shift 'sortlist', go to state 410
parser: Reduce [orderby_opt ::= ORDER BY sortlist], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 22.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 2.
parser: Shift 'select'
parser: Reduce [cmd ::= select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'CREATE'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Shift 'CREATE'
parser: Return. Stack=[explain CREATE]
parser: Input 'INDEX'
parser: Reduce [createkw ::= CREATE], go to state 2.
parser: Shift 'createkw', go to state 107
parser: Reduce [uniqueflag ::=], go to state 107.
parser: Shift 'uniqueflag', go to state 370
parser: Shift 'INDEX', go to state 256
parser: Return. Stack=[explain createkw uniqueflag INDEX]
parser: Input 'ID'
parser: Reduce [ifnotexists ::=], go to state 256.
parser: Shift 'ifnotexists', go to state 180
parser: Shift 'ID'
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists ID]
parser: Input 'ON'
parser: Reduce [nm ::= ID|INDEXED], go to state 180.
parser: Shift 'nm', go to state 255
parser: Reduce [dbnm ::=], go to state 255.
parser: Shift 'dbnm', go to state 369
parser: Shift 'ON', go to state 179
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON ID]
parser: Input 'LP'
parser: Reduce [nm ::= ID|INDEXED], go to state 179.
parser: Shift 'nm', go to state 368
parser: Shift 'LP', go to state 12
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP ID]
parser: Input 'RP'
parser: Reduce [expr ::= ID|INDEXED], go to state 12.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 12.
parser: Shift 'sortlist', go to state 325
parser: Shift 'RP', go to state 254
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP]
parser: Input 'SEMI'
parser: Reduce [where_opt ::=], go to state 254.
parser: Shift 'where_opt'
parser: Reduce [cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'PRAGMA'
parser: FALLBACK PRAGMA => ID
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Shift 'PRAGMA', go to state 172
parser: Return. Stack=[explain PRAGMA]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain PRAGMA ID]
parser: Input 'EQ'
parser: Reduce [nm ::= ID|INDEXED], go to state 172.
parser: Shift 'nm', go to state 240
parser: Reduce [dbnm ::=], go to state 240.
parser: Shift 'dbnm', go to state 323
parser: Shift 'EQ', go to state 20
parser: Return. Stack=[explain PRAGMA nm dbnm EQ]
parser: Input 'INTEGER'
parser: Shift 'INTEGER'
parser: Return. Stack=[explain PRAGMA nm dbnm EQ INTEGER]
parser: Input 'SEMI'
parser: Reduce [plus_num ::= INTEGER|FLOAT], go to state 20.
parser: Shift 'plus_num'
parser: Reduce [nmnum ::= plus_num], go to state 20.
parser: Shift 'nmnum'
parser: Reduce [cmd ::= PRAGMA nm dbnm EQ nmnum], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'PRAGMA'
parser: FALLBACK PRAGMA => ID
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Shift 'PRAGMA', go to state 172
parser: Return. Stack=[explain PRAGMA]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain PRAGMA ID]
parser: Input 'LP'
parser: Reduce [nm ::= ID|INDEXED], go to state 172.
parser: Shift 'nm', go to state 240
parser: Reduce [dbnm ::=], go to state 240.
parser: Shift 'dbnm', go to state 323
parser: Shift 'LP', go to state 19
parser: Return. Stack=[explain PRAGMA nm dbnm LP]
parser: Input 'INTEGER'
parser: Shift 'INTEGER'
parser: Return. Stack=[explain PRAGMA nm dbnm LP INTEGER]
parser: Input 'RP'
parser: Reduce [plus_num ::= INTEGER|FLOAT], go to state 19.
parser: Shift 'plus_num'
parser: Reduce [nmnum ::= plus_num], go to state 19.
parser: Shift 'nmnum', go to state 349
parser: Shift 'RP'
parser: Return. Stack=[explain PRAGMA nm dbnm LP nmnum RP]
parser: Input 'SEMI'
parser: Reduce [cmd ::= PRAGMA nm dbnm LP nmnum RP], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'SEMI'
parser: Shift 'SEMI'
parser: Return. Stack=[SEMI]
parser: Input 'SELECT'
parser: Reduce [ecmd ::= SEMI], go to state 0.
parser: Shift 'ecmd'
parser: Reduce [cmdlist ::= ecmd], go to state 0.
parser: Shift 'cmdlist', go to state 146
parser: Reduce [explain ::=], go to state 146.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[cmdlist explain with SELECT]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct sclp ID]
parser: Input 'FROM'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist FROM]
parser: Input 'STRING'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'STRING'
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist FROM stl_prefix STRING]
parser: Input 'DOT'
parser: Reduce [nm ::= STRING], go to state 165.
parser: Shift 'nm', go to state 287
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Shift 'WHERE', go to state 65
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'AND', go to state 93
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 93.
parser: Shift 'expr', go to state 53
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE expr AND expr EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE expr AND expr EQ STRING]
parser: Input 'ORDER'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 93.
parser: Shift 'expr', go to state 53
parser: Reduce [expr ::= expr AND expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Reduce [where_opt ::= WHERE expr], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Shift 'ORDER', go to state 411
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY'
parser: Shift 'BY', go to state 17
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI'
parser: Reduce [expr ::= ID|INDEXED], go to state 17.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 17.
parser: Shift 'sortlist', go to state 410
parser: Reduce [orderby_opt ::= ORDER BY sortlist], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 22.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 2.
parser: Shift 'select'
parser: Reduce [cmd ::= select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[cmdlist explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping cmdlist
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'SEMI'
parser: Shift 'SEMI'
parser: Return. Stack=[SEMI]
parser: Input 'PRAGMA'
parser: Reduce [ecmd ::= SEMI], go to state 0.
parser: Shift 'ecmd'
parser: Reduce [cmdlist ::= ecmd], go to state 0.
parser: Shift 'cmdlist', go to state 146
parser: FALLBACK PRAGMA => ID
parser: Reduce [explain ::=], go to state 146.
parser: Shift 'explain', go to state 2
parser: Shift 'PRAGMA', go to state 172
parser: Return. Stack=[cmdlist explain PRAGMA]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[cmdlist explain PRAGMA ID]
parser: Input 'EQ'
parser: Reduce [nm ::= ID|INDEXED], go to state 172.
parser: Shift 'nm', go to state 240
parser: Reduce [dbnm ::=], go to state 240.
parser: Shift 'dbnm', go to state 323
parser: Shift 'EQ', go to state 20
parser: Return. Stack=[cmdlist explain PRAGMA nm dbnm EQ]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[cmdlist explain PRAGMA nm dbnm EQ ID]
parser: Input 'SEMI'
parser: Reduce [nm ::= ID|INDEXED], go to state 20.
parser: Shift 'nm'
parser: Reduce [nmnum ::= nm], go to state 20.
parser: Shift 'nmnum'
parser: Reduce [cmd ::= PRAGMA nm dbnm EQ nmnum], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[cmdlist explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping cmdlist
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'SELECT'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[explain with SELECT]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'FROM'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[explain with SELECT distinct selcollist FROM]
parser: Input 'STRING'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'STRING'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix STRING]
parser: Input 'DOT'
parser: Reduce [nm ::= STRING], go to state 165.
parser: Shift 'nm', go to state 287
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Shift 'WHERE', go to state 65
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'AND', go to state 93
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 93.
parser: Shift 'expr', go to state 53
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND expr EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND expr EQ STRING]
parser: Input 'ORDER'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 93.
parser: Shift 'expr', go to state 53
parser: Reduce [expr ::= expr AND expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Reduce [where_opt ::= WHERE expr], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Shift 'ORDER', go to state 411
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY'
parser: Shift 'BY', go to state 17
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI'
parser: Reduce [expr ::= ID|INDEXED], go to state 17.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 17.
parser: Shift 'sortlist', go to state 410
parser: Reduce [orderby_opt ::= ORDER BY sortlist], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 22.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 2.
parser: Shift 'select'
parser: Reduce [cmd ::= select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'SEMI'
parser: Shift 'SEMI'
parser: Return. Stack=[SEMI]
parser: Input 'SELECT'
parser: Reduce [ecmd ::= SEMI], go to state 0.
parser: Shift 'ecmd'
parser: Reduce [cmdlist ::= ecmd], go to state 0.
parser: Shift 'cmdlist', go to state 146
parser: Reduce [explain ::=], go to state 146.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[cmdlist explain with SELECT]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct sclp ID]
parser: Input 'FROM'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist FROM]
parser: Input 'STRING'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'STRING'
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist FROM stl_prefix STRING]
parser: Input 'DOT'
parser: Reduce [nm ::= STRING], go to state 165.
parser: Shift 'nm', go to state 287
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Shift 'WHERE', go to state 65
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'AND', go to state 93
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 93.
parser: Shift 'expr', go to state 53
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE expr AND expr EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE expr AND expr EQ STRING]
parser: Input 'ORDER'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 93.
parser: Shift 'expr', go to state 53
parser: Reduce [expr ::= expr AND expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Reduce [where_opt ::= WHERE expr], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Shift 'ORDER', go to state 411
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY'
parser: Shift 'BY', go to state 17
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI'
parser: Reduce [expr ::= ID|INDEXED], go to state 17.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 17.
parser: Shift 'sortlist', go to state 410
parser: Reduce [orderby_opt ::= ORDER BY sortlist], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 22.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 2.
parser: Shift 'select'
parser: Reduce [cmd ::= select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[cmdlist explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping cmdlist
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'ATTACH'
parser: FALLBACK ATTACH => ID
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Shift 'ATTACH', go to state 239
parser: Return. Stack=[explain ATTACH]
parser: Input 'STRING'
parser: Reduce [database_kw_opt ::=], go to state 239.
parser: Shift 'database_kw_opt', go to state 58
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain ATTACH database_kw_opt STRING]
parser: Input 'AS'
parser: Reduce [term ::= STRING], go to state 58.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 58.
parser: Shift 'expr', go to state 26
parser: Shift 'AS', go to state 57
parser: Return. Stack=[explain ATTACH database_kw_opt expr AS]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain ATTACH database_kw_opt expr AS ID]
parser: Input 'SEMI'
parser: Reduce [expr ::= ID|INDEXED], go to state 57.
parser: Shift 'expr', go to state 11
parser: Reduce [key_opt ::=], go to state 11.
parser: Shift 'key_opt'
parser: Reduce [cmd ::= ATTACH database_kw_opt expr AS expr key_opt], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'SELECT'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[explain with SELECT]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'FROM'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[explain with SELECT distinct selcollist FROM]
parser: Input 'STRING'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'STRING'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix STRING]
parser: Input 'DOT'
parser: Reduce [nm ::= STRING], go to state 165.
parser: Shift 'nm', go to state 287
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Shift 'WHERE', go to state 65
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'AND', go to state 93
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 93.
parser: Shift 'expr', go to state 53
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND expr EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND expr EQ STRING]
parser: Input 'ORDER'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 93.
parser: Shift 'expr', go to state 53
parser: Reduce [expr ::= expr AND expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Reduce [where_opt ::= WHERE expr], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Shift 'ORDER', go to state 411
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY'
parser: Shift 'BY', go to state 17
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI'
parser: Reduce [expr ::= ID|INDEXED], go to state 17.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 17.
parser: Shift 'sortlist', go to state 410
parser: Reduce [orderby_opt ::= ORDER BY sortlist], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 22.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 2.
parser: Shift 'select'
parser: Reduce [cmd ::= select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'PRAGMA'
parser: FALLBACK PRAGMA => ID
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Shift 'PRAGMA', go to state 172
parser: Return. Stack=[explain PRAGMA]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain PRAGMA ID]
parser: Input 'LP'
parser: Reduce [nm ::= ID|INDEXED], go to state 172.
parser: Shift 'nm', go to state 240
parser: Reduce [dbnm ::=], go to state 240.
parser: Shift 'dbnm', go to state 323
parser: Shift 'LP', go to state 19
parser: Return. Stack=[explain PRAGMA nm dbnm LP]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain PRAGMA nm dbnm LP ID]
parser: Input 'RP'
parser: Reduce [nm ::= ID|INDEXED], go to state 19.
parser: Shift 'nm'
parser: Reduce [nmnum ::= nm], go to state 19.
parser: Shift 'nmnum', go to state 349
parser: Shift 'RP'
parser: Return. Stack=[explain PRAGMA nm dbnm LP nmnum RP]
parser: Input 'SEMI'
parser: Reduce [cmd ::= PRAGMA nm dbnm LP nmnum RP], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'SELECT'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[explain with SELECT]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'FROM'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[explain with SELECT distinct selcollist FROM]
parser: Input 'STRING'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'STRING'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix STRING]
parser: Input 'DOT'
parser: Reduce [nm ::= STRING], go to state 165.
parser: Shift 'nm', go to state 287
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Shift 'WHERE', go to state 65
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'AND', go to state 93
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 93.
parser: Shift 'expr', go to state 53
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND expr EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND expr EQ STRING]
parser: Input 'ORDER'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 93.
parser: Shift 'expr', go to state 53
parser: Reduce [expr ::= expr AND expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Reduce [where_opt ::= WHERE expr], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Shift 'ORDER', go to state 411
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY'
parser: Shift 'BY', go to state 17
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI'
parser: Reduce [expr ::= ID|INDEXED], go to state 17.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 17.
parser: Shift 'sortlist', go to state 410
parser: Reduce [orderby_opt ::= ORDER BY sortlist], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 22.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 2.
parser: Shift 'select'
parser: Reduce [cmd ::= select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'SELECT'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[explain with SELECT]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'FROM'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[explain with SELECT distinct selcollist FROM]
parser: Input 'STRING'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'STRING'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix STRING]
parser: Input 'DOT'
parser: Reduce [nm ::= STRING], go to state 165.
parser: Shift 'nm', go to state 287
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Shift 'WHERE', go to state 65
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'AND', go to state 93
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 93.
parser: Shift 'expr', go to state 53
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND expr EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND expr EQ STRING]
parser: Input 'ORDER'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 93.
parser: Shift 'expr', go to state 53
parser: Reduce [expr ::= expr AND expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Reduce [where_opt ::= WHERE expr], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Shift 'ORDER', go to state 411
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY'
parser: Shift 'BY', go to state 17
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI'
parser: Reduce [expr ::= ID|INDEXED], go to state 17.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 17.
parser: Shift 'sortlist', go to state 410
parser: Reduce [orderby_opt ::= ORDER BY sortlist], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 22.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 2.
parser: Shift 'select'
parser: Reduce [cmd ::= select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'CREATE'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Shift 'CREATE'
parser: Return. Stack=[explain CREATE]
parser: Input 'INDEX'
parser: Reduce [createkw ::= CREATE], go to state 2.
parser: Shift 'createkw', go to state 107
parser: Reduce [uniqueflag ::=], go to state 107.
parser: Shift 'uniqueflag', go to state 370
parser: Shift 'INDEX', go to state 256
parser: Return. Stack=[explain createkw uniqueflag INDEX]
parser: Input 'ID'
parser: Reduce [ifnotexists ::=], go to state 256.
parser: Shift 'ifnotexists', go to state 180
parser: Shift 'ID'
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists ID]
parser: Input 'ON'
parser: Reduce [nm ::= ID|INDEXED], go to state 180.
parser: Shift 'nm', go to state 255
parser: Reduce [dbnm ::=], go to state 255.
parser: Shift 'dbnm', go to state 369
parser: Shift 'ON', go to state 179
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON ID]
parser: Input 'LP'
parser: Reduce [nm ::= ID|INDEXED], go to state 179.
parser: Shift 'nm', go to state 368
parser: Shift 'LP', go to state 12
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP ID]
parser: Input 'RP'
parser: Reduce [expr ::= ID|INDEXED], go to state 12.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 12.
parser: Shift 'sortlist', go to state 325
parser: Shift 'RP', go to state 254
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP]
parser: Input 'SEMI'
parser: Reduce [where_opt ::=], go to state 254.
parser: Shift 'where_opt'
parser: Reduce [cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt], go to state 2.
parser: Initialize. Empty stack. State 0
parser: Input 'INSERT'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'INSERT', go to state 253
parser: Return. Stack=[explain with INSERT]
parser: Input 'INTO'
parser: Reduce [orconf ::=], go to state 253.
parser: Shift 'orconf'
parser: Reduce [insert_cmd ::= INSERT orconf], go to state 22.
parser: Shift 'insert_cmd', go to state 351
parser: Shift 'INTO', go to state 127
parser: Return. Stack=[explain with insert_cmd INTO]
parser: Input 'STRING'
parser: Shift 'STRING'
parser: Return. Stack=[explain with insert_cmd INTO STRING]
parser: Input 'DOT'
parser: Reduce [nm ::= STRING], go to state 127.
parser: Shift 'nm', go to state 259
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[explain with insert_cmd INTO nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with insert_cmd INTO nm DOT ID]
parser: Input 'VALUES'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 259.
parser: Shift 'dbnm'
parser: Reduce [fullname ::= nm dbnm], go to state 127.
parser: Shift 'fullname', go to state 241
parser: Reduce [idlist_opt ::=], go to state 241.
parser: Shift 'idlist_opt', go to state 147
parser: Reduce [with ::=], go to state 147.
parser: Shift 'with', go to state 113
parser: Shift 'VALUES', go to state 397
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES]
parser: Input 'LP'
parser: Shift 'LP', go to state 15
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP STRING]
parser: Input 'COMMA'
parser: Reduce [term ::= STRING], go to state 15.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 15.
parser: Shift 'expr', go to state 48
parser: Reduce [nexprlist ::= expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'COMMA', go to state 70
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA STRING]
parser: Input 'COMMA'
parser: Reduce [term ::= STRING], go to state 70.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 70.
parser: Shift 'expr', go to state 43
parser: Reduce [nexprlist ::= nexprlist COMMA expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'COMMA', go to state 70
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA STRING]
parser: Input 'COMMA'
parser: Reduce [term ::= STRING], go to state 70.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 70.
parser: Shift 'expr', go to state 43
parser: Reduce [nexprlist ::= nexprlist COMMA expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'COMMA', go to state 70
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA]
parser: Input 'VARIABLE'
parser: Shift 'VARIABLE'
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA VARIABLE]
parser: Input 'COMMA'
parser: Reduce [expr ::= VARIABLE], go to state 70.
parser: Shift 'expr', go to state 43
parser: Reduce [nexprlist ::= nexprlist COMMA expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'COMMA', go to state 70
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA STRING]
parser: Input 'RP'
parser: Reduce [term ::= STRING], go to state 70.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 70.
parser: Shift 'expr', go to state 43
parser: Reduce [nexprlist ::= nexprlist COMMA expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'RP'
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist RP]
parser: Input 'SEMI'
parser: Reduce [values ::= VALUES LP nexprlist RP], go to state 113.
parser: Shift 'values', go to state 400
parser: Reduce [oneselect ::= values], go to state 113.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 113.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 147.
parser: Shift 'select'
parser: Reduce [cmd ::= with insert_cmd INTO fullname idlist_opt select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Input '$'
parser: Reduce [ecmd ::= explain cmdx SEMI], go to state 0.
parser: Shift 'ecmd'
parser: Reduce [cmdlist ::= ecmd], go to state 0.
parser: Shift 'cmdlist', go to state 146
parser: Reduce [input ::= cmdlist], go to state 0.
parser: Accept!
parser: Popping $
parser: Return. Stack=]
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'SELECT'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[explain with SELECT]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'FROM'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[explain with SELECT distinct selcollist FROM]
parser: Input 'STRING'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'STRING'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix STRING]
parser: Input 'DOT'
parser: Reduce [nm ::= STRING], go to state 165.
parser: Shift 'nm', go to state 287
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Shift 'WHERE', go to state 65
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'AND', go to state 93
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 93.
parser: Shift 'expr', go to state 53
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND expr EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND expr EQ STRING]
parser: Input 'ORDER'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 93.
parser: Shift 'expr', go to state 53
parser: Reduce [expr ::= expr AND expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Reduce [where_opt ::= WHERE expr], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Shift 'ORDER', go to state 411
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY'
parser: Shift 'BY', go to state 17
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI'
parser: Reduce [expr ::= ID|INDEXED], go to state 17.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 17.
parser: Shift 'sortlist', go to state 410
parser: Reduce [orderby_opt ::= ORDER BY sortlist], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 22.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 2.
parser: Shift 'select'
parser: Reduce [cmd ::= select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'CREATE'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Shift 'CREATE'
parser: Return. Stack=[explain CREATE]
parser: Input 'INDEX'
parser: Reduce [createkw ::= CREATE], go to state 2.
parser: Shift 'createkw', go to state 107
parser: Reduce [uniqueflag ::=], go to state 107.
parser: Shift 'uniqueflag', go to state 370
parser: Shift 'INDEX', go to state 256
parser: Return. Stack=[explain createkw uniqueflag INDEX]
parser: Input 'ID'
parser: Reduce [ifnotexists ::=], go to state 256.
parser: Shift 'ifnotexists', go to state 180
parser: Shift 'ID'
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists ID]
parser: Input 'ON'
parser: Reduce [nm ::= ID|INDEXED], go to state 180.
parser: Shift 'nm', go to state 255
parser: Reduce [dbnm ::=], go to state 255.
parser: Shift 'dbnm', go to state 369
parser: Shift 'ON', go to state 179
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON ID]
parser: Input 'LP'
parser: Reduce [nm ::= ID|INDEXED], go to state 179.
parser: Shift 'nm', go to state 368
parser: Shift 'LP', go to state 12
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP ID]
parser: Input 'RP'
parser: Reduce [expr ::= ID|INDEXED], go to state 12.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 12.
parser: Shift 'sortlist', go to state 325
parser: Shift 'RP', go to state 254
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP]
parser: Input 'SEMI'
parser: Reduce [where_opt ::=], go to state 254.
parser: Shift 'where_opt'
parser: Reduce [cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'SELECT'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[explain with SELECT]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'FROM'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[explain with SELECT distinct selcollist FROM]
parser: Input 'STRING'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'STRING'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix STRING]
parser: Input 'DOT'
parser: Reduce [nm ::= STRING], go to state 165.
parser: Shift 'nm', go to state 287
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Shift 'WHERE', go to state 65
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'AND', go to state 93
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 93.
parser: Shift 'expr', go to state 53
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND expr EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND expr EQ STRING]
parser: Input 'ORDER'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 93.
parser: Shift 'expr', go to state 53
parser: Reduce [expr ::= expr AND expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Reduce [where_opt ::= WHERE expr], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Shift 'ORDER', go to state 411
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY'
parser: Shift 'BY', go to state 17
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI'
parser: Reduce [expr ::= ID|INDEXED], go to state 17.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 17.
parser: Shift 'sortlist', go to state 410
parser: Reduce [orderby_opt ::= ORDER BY sortlist], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 22.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 2.
parser: Shift 'select'
parser: Reduce [cmd ::= select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'SELECT'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[explain with SELECT]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'FROM'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[explain with SELECT distinct selcollist FROM]
parser: Input 'STRING'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'STRING'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix STRING]
parser: Input 'DOT'
parser: Reduce [nm ::= STRING], go to state 165.
parser: Shift 'nm', go to state 287
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Shift 'WHERE', go to state 65
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'AND', go to state 93
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 93.
parser: Shift 'expr', go to state 53
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND expr EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND expr EQ STRING]
parser: Input 'ORDER'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 93.
parser: Shift 'expr', go to state 53
parser: Reduce [expr ::= expr AND expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Reduce [where_opt ::= WHERE expr], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Shift 'ORDER', go to state 411
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY'
parser: Shift 'BY', go to state 17
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI'
parser: Reduce [expr ::= ID|INDEXED], go to state 17.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 17.
parser: Shift 'sortlist', go to state 410
parser: Reduce [orderby_opt ::= ORDER BY sortlist], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 22.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 2.
parser: Shift 'select'
parser: Reduce [cmd ::= select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'SEMI'
parser: Shift 'SEMI'
parser: Return. Stack=[SEMI]
parser: Input 'PRAGMA'
parser: Reduce [ecmd ::= SEMI], go to state 0.
parser: Shift 'ecmd'
parser: Reduce [cmdlist ::= ecmd], go to state 0.
parser: Shift 'cmdlist', go to state 146
parser: FALLBACK PRAGMA => ID
parser: Reduce [explain ::=], go to state 146.
parser: Shift 'explain', go to state 2
parser: Shift 'PRAGMA', go to state 172
parser: Return. Stack=[cmdlist explain PRAGMA]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[cmdlist explain PRAGMA ID]
parser: Input 'LP'
parser: Reduce [nm ::= ID|INDEXED], go to state 172.
parser: Shift 'nm', go to state 240
parser: Reduce [dbnm ::=], go to state 240.
parser: Shift 'dbnm', go to state 323
parser: Shift 'LP', go to state 19
parser: Return. Stack=[cmdlist explain PRAGMA nm dbnm LP]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[cmdlist explain PRAGMA nm dbnm LP ID]
parser: Input 'RP'
parser: Reduce [nm ::= ID|INDEXED], go to state 19.
parser: Shift 'nm'
parser: Reduce [nmnum ::= nm], go to state 19.
parser: Shift 'nmnum', go to state 349
parser: Shift 'RP'
parser: Return. Stack=[cmdlist explain PRAGMA nm dbnm LP nmnum RP]
parser: Input 'SEMI'
parser: Reduce [cmd ::= PRAGMA nm dbnm LP nmnum RP], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[cmdlist explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping cmdlist
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'SEMI'
parser: Shift 'SEMI'
parser: Return. Stack=[SEMI]
parser: Input 'PRAGMA'
parser: Reduce [ecmd ::= SEMI], go to state 0.
parser: Shift 'ecmd'
parser: Reduce [cmdlist ::= ecmd], go to state 0.
parser: Shift 'cmdlist', go to state 146
parser: FALLBACK PRAGMA => ID
parser: Reduce [explain ::=], go to state 146.
parser: Shift 'explain', go to state 2
parser: Shift 'PRAGMA', go to state 172
parser: Return. Stack=[cmdlist explain PRAGMA]
parser: Input 'TEMP'
parser: FALLBACK TEMP => ID
parser: Shift 'TEMP'
parser: Return. Stack=[cmdlist explain PRAGMA TEMP]
parser: Input 'DOT'
parser: Reduce [nm ::= ID|INDEXED], go to state 172.
parser: Shift 'nm', go to state 240
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[cmdlist explain PRAGMA nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[cmdlist explain PRAGMA nm DOT ID]
parser: Input 'LP'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 240.
parser: Shift 'dbnm', go to state 323
parser: Shift 'LP', go to state 19
parser: Return. Stack=[cmdlist explain PRAGMA nm dbnm LP]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[cmdlist explain PRAGMA nm dbnm LP ID]
parser: Input 'RP'
parser: Reduce [nm ::= ID|INDEXED], go to state 19.
parser: Shift 'nm'
parser: Reduce [nmnum ::= nm], go to state 19.
parser: Shift 'nmnum', go to state 349
parser: Shift 'RP'
parser: Return. Stack=[cmdlist explain PRAGMA nm dbnm LP nmnum RP]
parser: Input 'SEMI'
parser: Reduce [cmd ::= PRAGMA nm dbnm LP nmnum RP], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[cmdlist explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping cmdlist
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'CREATE'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Shift 'CREATE'
parser: Return. Stack=[explain CREATE]
parser: Input 'INDEX'
parser: Reduce [createkw ::= CREATE], go to state 2.
parser: Shift 'createkw', go to state 107
parser: Reduce [uniqueflag ::=], go to state 107.
parser: Shift 'uniqueflag', go to state 370
parser: Shift 'INDEX', go to state 256
parser: Return. Stack=[explain createkw uniqueflag INDEX]
parser: Input 'ID'
parser: Reduce [ifnotexists ::=], go to state 256.
parser: Shift 'ifnotexists', go to state 180
parser: Shift 'ID'
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists ID]
parser: Input 'ON'
parser: Reduce [nm ::= ID|INDEXED], go to state 180.
parser: Shift 'nm', go to state 255
parser: Reduce [dbnm ::=], go to state 255.
parser: Shift 'dbnm', go to state 369
parser: Shift 'ON', go to state 179
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON ID]
parser: Input 'LP'
parser: Reduce [nm ::= ID|INDEXED], go to state 179.
parser: Shift 'nm', go to state 368
parser: Shift 'LP', go to state 12
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP ID]
parser: Input 'RP'
parser: Reduce [expr ::= ID|INDEXED], go to state 12.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 12.
parser: Shift 'sortlist', go to state 325
parser: Shift 'RP', go to state 254
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP]
parser: Input 'SEMI'
parser: Reduce [where_opt ::=], go to state 254.
parser: Shift 'where_opt'
parser: Reduce [cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt], go to state 2.
parser: Initialize. Empty stack. State 0
parser: Input 'INSERT'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'INSERT', go to state 253
parser: Return. Stack=[explain with INSERT]
parser: Input 'INTO'
parser: Reduce [orconf ::=], go to state 253.
parser: Shift 'orconf'
parser: Reduce [insert_cmd ::= INSERT orconf], go to state 22.
parser: Shift 'insert_cmd', go to state 351
parser: Shift 'INTO', go to state 127
parser: Return. Stack=[explain with insert_cmd INTO]
parser: Input 'STRING'
parser: Shift 'STRING'
parser: Return. Stack=[explain with insert_cmd INTO STRING]
parser: Input 'DOT'
parser: Reduce [nm ::= STRING], go to state 127.
parser: Shift 'nm', go to state 259
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[explain with insert_cmd INTO nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with insert_cmd INTO nm DOT ID]
parser: Input 'VALUES'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 259.
parser: Shift 'dbnm'
parser: Reduce [fullname ::= nm dbnm], go to state 127.
parser: Shift 'fullname', go to state 241
parser: Reduce [idlist_opt ::=], go to state 241.
parser: Shift 'idlist_opt', go to state 147
parser: Reduce [with ::=], go to state 147.
parser: Shift 'with', go to state 113
parser: Shift 'VALUES', go to state 397
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES]
parser: Input 'LP'
parser: Shift 'LP', go to state 15
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP STRING]
parser: Input 'COMMA'
parser: Reduce [term ::= STRING], go to state 15.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 15.
parser: Shift 'expr', go to state 48
parser: Reduce [nexprlist ::= expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'COMMA', go to state 70
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA STRING]
parser: Input 'COMMA'
parser: Reduce [term ::= STRING], go to state 70.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 70.
parser: Shift 'expr', go to state 43
parser: Reduce [nexprlist ::= nexprlist COMMA expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'COMMA', go to state 70
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA STRING]
parser: Input 'COMMA'
parser: Reduce [term ::= STRING], go to state 70.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 70.
parser: Shift 'expr', go to state 43
parser: Reduce [nexprlist ::= nexprlist COMMA expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'COMMA', go to state 70
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA]
parser: Input 'VARIABLE'
parser: Shift 'VARIABLE'
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA VARIABLE]
parser: Input 'COMMA'
parser: Reduce [expr ::= VARIABLE], go to state 70.
parser: Shift 'expr', go to state 43
parser: Reduce [nexprlist ::= nexprlist COMMA expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'COMMA', go to state 70
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA STRING]
parser: Input 'RP'
parser: Reduce [term ::= STRING], go to state 70.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 70.
parser: Shift 'expr', go to state 43
parser: Reduce [nexprlist ::= nexprlist COMMA expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'RP'
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist RP]
parser: Input 'SEMI'
parser: Reduce [values ::= VALUES LP nexprlist RP], go to state 113.
parser: Shift 'values', go to state 400
parser: Reduce [oneselect ::= values], go to state 113.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 113.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 147.
parser: Shift 'select'
parser: Reduce [cmd ::= with insert_cmd INTO fullname idlist_opt select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Input '$'
parser: Reduce [ecmd ::= explain cmdx SEMI], go to state 0.
parser: Shift 'ecmd'
parser: Reduce [cmdlist ::= ecmd], go to state 0.
parser: Shift 'cmdlist', go to state 146
parser: Reduce [input ::= cmdlist], go to state 0.
parser: Accept!
parser: Popping $
parser: Return. Stack=]
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'SELECT'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[explain with SELECT]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'FROM'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[explain with SELECT distinct selcollist FROM]
parser: Input 'STRING'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'STRING'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix STRING]
parser: Input 'DOT'
parser: Reduce [nm ::= STRING], go to state 165.
parser: Shift 'nm', go to state 287
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Shift 'WHERE', go to state 65
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'AND', go to state 93
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 93.
parser: Shift 'expr', go to state 53
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND expr EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND expr EQ STRING]
parser: Input 'ORDER'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 93.
parser: Shift 'expr', go to state 53
parser: Reduce [expr ::= expr AND expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Reduce [where_opt ::= WHERE expr], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Shift 'ORDER', go to state 411
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY'
parser: Shift 'BY', go to state 17
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI'
parser: Reduce [expr ::= ID|INDEXED], go to state 17.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 17.
parser: Shift 'sortlist', go to state 410
parser: Reduce [orderby_opt ::= ORDER BY sortlist], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 22.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 2.
parser: Shift 'select'
parser: Reduce [cmd ::= select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'CREATE'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Shift 'CREATE'
parser: Return. Stack=[explain CREATE]
parser: Input 'INDEX'
parser: Reduce [createkw ::= CREATE], go to state 2.
parser: Shift 'createkw', go to state 107
parser: Reduce [uniqueflag ::=], go to state 107.
parser: Shift 'uniqueflag', go to state 370
parser: Shift 'INDEX', go to state 256
parser: Return. Stack=[explain createkw uniqueflag INDEX]
parser: Input 'ID'
parser: Reduce [ifnotexists ::=], go to state 256.
parser: Shift 'ifnotexists', go to state 180
parser: Shift 'ID'
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists ID]
parser: Input 'ON'
parser: Reduce [nm ::= ID|INDEXED], go to state 180.
parser: Shift 'nm', go to state 255
parser: Reduce [dbnm ::=], go to state 255.
parser: Shift 'dbnm', go to state 369
parser: Shift 'ON', go to state 179
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON ID]
parser: Input 'LP'
parser: Reduce [nm ::= ID|INDEXED], go to state 179.
parser: Shift 'nm', go to state 368
parser: Shift 'LP', go to state 12
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP ID]
parser: Input 'RP'
parser: Reduce [expr ::= ID|INDEXED], go to state 12.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 12.
parser: Shift 'sortlist', go to state 325
parser: Shift 'RP', go to state 254
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP]
parser: Input 'SEMI'
parser: Reduce [where_opt ::=], go to state 254.
parser: Shift 'where_opt'
parser: Reduce [cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'CREATE'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Shift 'CREATE'
parser: Return. Stack=[explain CREATE]
parser: Input 'INDEX'
parser: Reduce [createkw ::= CREATE], go to state 2.
parser: Shift 'createkw', go to state 107
parser: Reduce [uniqueflag ::=], go to state 107.
parser: Shift 'uniqueflag', go to state 370
parser: Shift 'INDEX', go to state 256
parser: Return. Stack=[explain createkw uniqueflag INDEX]
parser: Input 'ID'
parser: Reduce [ifnotexists ::=], go to state 256.
parser: Shift 'ifnotexists', go to state 180
parser: Shift 'ID'
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists ID]
parser: Input 'ON'
parser: Reduce [nm ::= ID|INDEXED], go to state 180.
parser: Shift 'nm', go to state 255
parser: Reduce [dbnm ::=], go to state 255.
parser: Shift 'dbnm', go to state 369
parser: Shift 'ON', go to state 179
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON ID]
parser: Input 'LP'
parser: Reduce [nm ::= ID|INDEXED], go to state 179.
parser: Shift 'nm', go to state 368
parser: Shift 'LP', go to state 12
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP ID]
parser: Input 'RP'
parser: Reduce [expr ::= ID|INDEXED], go to state 12.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 12.
parser: Shift 'sortlist', go to state 325
parser: Shift 'RP', go to state 254
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP]
parser: Input 'SEMI'
parser: Reduce [where_opt ::=], go to state 254.
parser: Shift 'where_opt'
parser: Reduce [cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt], go to state 2.
parser: Initialize. Empty stack. State 0
parser: Input 'INSERT'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'INSERT', go to state 253
parser: Return. Stack=[explain with INSERT]
parser: Input 'INTO'
parser: Reduce [orconf ::=], go to state 253.
parser: Shift 'orconf'
parser: Reduce [insert_cmd ::= INSERT orconf], go to state 22.
parser: Shift 'insert_cmd', go to state 351
parser: Shift 'INTO', go to state 127
parser: Return. Stack=[explain with insert_cmd INTO]
parser: Input 'STRING'
parser: Shift 'STRING'
parser: Return. Stack=[explain with insert_cmd INTO STRING]
parser: Input 'DOT'
parser: Reduce [nm ::= STRING], go to state 127.
parser: Shift 'nm', go to state 259
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[explain with insert_cmd INTO nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with insert_cmd INTO nm DOT ID]
parser: Input 'VALUES'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 259.
parser: Shift 'dbnm'
parser: Reduce [fullname ::= nm dbnm], go to state 127.
parser: Shift 'fullname', go to state 241
parser: Reduce [idlist_opt ::=], go to state 241.
parser: Shift 'idlist_opt', go to state 147
parser: Reduce [with ::=], go to state 147.
parser: Shift 'with', go to state 113
parser: Shift 'VALUES', go to state 397
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES]
parser: Input 'LP'
parser: Shift 'LP', go to state 15
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP STRING]
parser: Input 'COMMA'
parser: Reduce [term ::= STRING], go to state 15.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 15.
parser: Shift 'expr', go to state 48
parser: Reduce [nexprlist ::= expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'COMMA', go to state 70
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA STRING]
parser: Input 'COMMA'
parser: Reduce [term ::= STRING], go to state 70.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 70.
parser: Shift 'expr', go to state 43
parser: Reduce [nexprlist ::= nexprlist COMMA expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'COMMA', go to state 70
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA STRING]
parser: Input 'COMMA'
parser: Reduce [term ::= STRING], go to state 70.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 70.
parser: Shift 'expr', go to state 43
parser: Reduce [nexprlist ::= nexprlist COMMA expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'COMMA', go to state 70
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA]
parser: Input 'VARIABLE'
parser: Shift 'VARIABLE'
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA VARIABLE]
parser: Input 'COMMA'
parser: Reduce [expr ::= VARIABLE], go to state 70.
parser: Shift 'expr', go to state 43
parser: Reduce [nexprlist ::= nexprlist COMMA expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'COMMA', go to state 70
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA STRING]
parser: Input 'RP'
parser: Reduce [term ::= STRING], go to state 70.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 70.
parser: Shift 'expr', go to state 43
parser: Reduce [nexprlist ::= nexprlist COMMA expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'RP'
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist RP]
parser: Input 'SEMI'
parser: Reduce [values ::= VALUES LP nexprlist RP], go to state 113.
parser: Shift 'values', go to state 400
parser: Reduce [oneselect ::= values], go to state 113.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 113.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 147.
parser: Shift 'select'
parser: Reduce [cmd ::= with insert_cmd INTO fullname idlist_opt select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Input '$'
parser: Reduce [ecmd ::= explain cmdx SEMI], go to state 0.
parser: Shift 'ecmd'
parser: Reduce [cmdlist ::= ecmd], go to state 0.
parser: Shift 'cmdlist', go to state 146
parser: Reduce [input ::= cmdlist], go to state 0.
parser: Accept!
parser: Popping $
parser: Return. Stack=]
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'SELECT'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[explain with SELECT]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'FROM'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[explain with SELECT distinct selcollist FROM]
parser: Input 'STRING'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'STRING'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix STRING]
parser: Input 'DOT'
parser: Reduce [nm ::= STRING], go to state 165.
parser: Shift 'nm', go to state 287
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Shift 'WHERE', go to state 65
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'AND', go to state 93
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 93.
parser: Shift 'expr', go to state 53
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND expr EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND expr EQ STRING]
parser: Input 'ORDER'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 93.
parser: Shift 'expr', go to state 53
parser: Reduce [expr ::= expr AND expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Reduce [where_opt ::= WHERE expr], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Shift 'ORDER', go to state 411
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY'
parser: Shift 'BY', go to state 17
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI'
parser: Reduce [expr ::= ID|INDEXED], go to state 17.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 17.
parser: Shift 'sortlist', go to state 410
parser: Reduce [orderby_opt ::= ORDER BY sortlist], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 22.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 2.
parser: Shift 'select'
parser: Reduce [cmd ::= select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'CREATE'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Shift 'CREATE'
parser: Return. Stack=[explain CREATE]
parser: Input 'INDEX'
parser: Reduce [createkw ::= CREATE], go to state 2.
parser: Shift 'createkw', go to state 107
parser: Reduce [uniqueflag ::=], go to state 107.
parser: Shift 'uniqueflag', go to state 370
parser: Shift 'INDEX', go to state 256
parser: Return. Stack=[explain createkw uniqueflag INDEX]
parser: Input 'ID'
parser: Reduce [ifnotexists ::=], go to state 256.
parser: Shift 'ifnotexists', go to state 180
parser: Shift 'ID'
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists ID]
parser: Input 'ON'
parser: Reduce [nm ::= ID|INDEXED], go to state 180.
parser: Shift 'nm', go to state 255
parser: Reduce [dbnm ::=], go to state 255.
parser: Shift 'dbnm', go to state 369
parser: Shift 'ON', go to state 179
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON ID]
parser: Input 'LP'
parser: Reduce [nm ::= ID|INDEXED], go to state 179.
parser: Shift 'nm', go to state 368
parser: Shift 'LP', go to state 12
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP ID]
parser: Input 'RP'
parser: Reduce [expr ::= ID|INDEXED], go to state 12.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 12.
parser: Shift 'sortlist', go to state 325
parser: Shift 'RP', go to state 254
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP]
parser: Input 'SEMI'
parser: Reduce [where_opt ::=], go to state 254.
parser: Shift 'where_opt'
parser: Reduce [cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'CREATE'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Shift 'CREATE'
parser: Return. Stack=[explain CREATE]
parser: Input 'INDEX'
parser: Reduce [createkw ::= CREATE], go to state 2.
parser: Shift 'createkw', go to state 107
parser: Reduce [uniqueflag ::=], go to state 107.
parser: Shift 'uniqueflag', go to state 370
parser: Shift 'INDEX', go to state 256
parser: Return. Stack=[explain createkw uniqueflag INDEX]
parser: Input 'ID'
parser: Reduce [ifnotexists ::=], go to state 256.
parser: Shift 'ifnotexists', go to state 180
parser: Shift 'ID'
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists ID]
parser: Input 'ON'
parser: Reduce [nm ::= ID|INDEXED], go to state 180.
parser: Shift 'nm', go to state 255
parser: Reduce [dbnm ::=], go to state 255.
parser: Shift 'dbnm', go to state 369
parser: Shift 'ON', go to state 179
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON ID]
parser: Input 'LP'
parser: Reduce [nm ::= ID|INDEXED], go to state 179.
parser: Shift 'nm', go to state 368
parser: Shift 'LP', go to state 12
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP ID]
parser: Input 'RP'
parser: Reduce [expr ::= ID|INDEXED], go to state 12.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 12.
parser: Shift 'sortlist', go to state 325
parser: Shift 'RP', go to state 254
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP]
parser: Input 'SEMI'
parser: Reduce [where_opt ::=], go to state 254.
parser: Shift 'where_opt'
parser: Reduce [cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt], go to state 2.
parser: Initialize. Empty stack. State 0
parser: Input 'INSERT'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'INSERT', go to state 253
parser: Return. Stack=[explain with INSERT]
parser: Input 'INTO'
parser: Reduce [orconf ::=], go to state 253.
parser: Shift 'orconf'
parser: Reduce [insert_cmd ::= INSERT orconf], go to state 22.
parser: Shift 'insert_cmd', go to state 351
parser: Shift 'INTO', go to state 127
parser: Return. Stack=[explain with insert_cmd INTO]
parser: Input 'STRING'
parser: Shift 'STRING'
parser: Return. Stack=[explain with insert_cmd INTO STRING]
parser: Input 'DOT'
parser: Reduce [nm ::= STRING], go to state 127.
parser: Shift 'nm', go to state 259
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[explain with insert_cmd INTO nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with insert_cmd INTO nm DOT ID]
parser: Input 'VALUES'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 259.
parser: Shift 'dbnm'
parser: Reduce [fullname ::= nm dbnm], go to state 127.
parser: Shift 'fullname', go to state 241
parser: Reduce [idlist_opt ::=], go to state 241.
parser: Shift 'idlist_opt', go to state 147
parser: Reduce [with ::=], go to state 147.
parser: Shift 'with', go to state 113
parser: Shift 'VALUES', go to state 397
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES]
parser: Input 'LP'
parser: Shift 'LP', go to state 15
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP STRING]
parser: Input 'COMMA'
parser: Reduce [term ::= STRING], go to state 15.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 15.
parser: Shift 'expr', go to state 48
parser: Reduce [nexprlist ::= expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'COMMA', go to state 70
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA STRING]
parser: Input 'COMMA'
parser: Reduce [term ::= STRING], go to state 70.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 70.
parser: Shift 'expr', go to state 43
parser: Reduce [nexprlist ::= nexprlist COMMA expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'COMMA', go to state 70
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA STRING]
parser: Input 'COMMA'
parser: Reduce [term ::= STRING], go to state 70.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 70.
parser: Shift 'expr', go to state 43
parser: Reduce [nexprlist ::= nexprlist COMMA expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'COMMA', go to state 70
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA]
parser: Input 'VARIABLE'
parser: Shift 'VARIABLE'
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA VARIABLE]
parser: Input 'COMMA'
parser: Reduce [expr ::= VARIABLE], go to state 70.
parser: Shift 'expr', go to state 43
parser: Reduce [nexprlist ::= nexprlist COMMA expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'COMMA', go to state 70
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA STRING]
parser: Input 'RP'
parser: Reduce [term ::= STRING], go to state 70.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 70.
parser: Shift 'expr', go to state 43
parser: Reduce [nexprlist ::= nexprlist COMMA expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'RP'
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist RP]
parser: Input 'SEMI'
parser: Reduce [values ::= VALUES LP nexprlist RP], go to state 113.
parser: Shift 'values', go to state 400
parser: Reduce [oneselect ::= values], go to state 113.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 113.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 147.
parser: Shift 'select'
parser: Reduce [cmd ::= with insert_cmd INTO fullname idlist_opt select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Input '$'
parser: Reduce [ecmd ::= explain cmdx SEMI], go to state 0.
parser: Shift 'ecmd'
parser: Reduce [cmdlist ::= ecmd], go to state 0.
parser: Shift 'cmdlist', go to state 146
parser: Reduce [input ::= cmdlist], go to state 0.
parser: Accept!
parser: Popping $
parser: Return. Stack=]
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'SELECT'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[explain with SELECT]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'FROM'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[explain with SELECT distinct selcollist FROM]
parser: Input 'STRING'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'STRING'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix STRING]
parser: Input 'DOT'
parser: Reduce [nm ::= STRING], go to state 165.
parser: Shift 'nm', go to state 287
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Shift 'WHERE', go to state 65
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'AND', go to state 93
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 93.
parser: Shift 'expr', go to state 53
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND expr EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND expr EQ STRING]
parser: Input 'ORDER'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 93.
parser: Shift 'expr', go to state 53
parser: Reduce [expr ::= expr AND expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Reduce [where_opt ::= WHERE expr], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Shift 'ORDER', go to state 411
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY'
parser: Shift 'BY', go to state 17
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI'
parser: Reduce [expr ::= ID|INDEXED], go to state 17.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 17.
parser: Shift 'sortlist', go to state 410
parser: Reduce [orderby_opt ::= ORDER BY sortlist], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 22.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 2.
parser: Shift 'select'
parser: Reduce [cmd ::= select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'CREATE'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Shift 'CREATE'
parser: Return. Stack=[explain CREATE]
parser: Input 'INDEX'
parser: Reduce [createkw ::= CREATE], go to state 2.
parser: Shift 'createkw', go to state 107
parser: Reduce [uniqueflag ::=], go to state 107.
parser: Shift 'uniqueflag', go to state 370
parser: Shift 'INDEX', go to state 256
parser: Return. Stack=[explain createkw uniqueflag INDEX]
parser: Input 'ID'
parser: Reduce [ifnotexists ::=], go to state 256.
parser: Shift 'ifnotexists', go to state 180
parser: Shift 'ID'
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists ID]
parser: Input 'ON'
parser: Reduce [nm ::= ID|INDEXED], go to state 180.
parser: Shift 'nm', go to state 255
parser: Reduce [dbnm ::=], go to state 255.
parser: Shift 'dbnm', go to state 369
parser: Shift 'ON', go to state 179
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON ID]
parser: Input 'LP'
parser: Reduce [nm ::= ID|INDEXED], go to state 179.
parser: Shift 'nm', go to state 368
parser: Shift 'LP', go to state 12
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP ID]
parser: Input 'RP'
parser: Reduce [expr ::= ID|INDEXED], go to state 12.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 12.
parser: Shift 'sortlist', go to state 325
parser: Shift 'RP', go to state 254
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP]
parser: Input 'SEMI'
parser: Reduce [where_opt ::=], go to state 254.
parser: Shift 'where_opt'
parser: Reduce [cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'SELECT'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[explain with SELECT]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'FROM'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[explain with SELECT distinct selcollist FROM]
parser: Input 'STRING'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'STRING'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix STRING]
parser: Input 'DOT'
parser: Reduce [nm ::= STRING], go to state 165.
parser: Shift 'nm', go to state 287
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Shift 'WHERE', go to state 65
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'AND', go to state 93
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 93.
parser: Shift 'expr', go to state 53
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND expr EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND expr EQ STRING]
parser: Input 'ORDER'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 93.
parser: Shift 'expr', go to state 53
parser: Reduce [expr ::= expr AND expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Reduce [where_opt ::= WHERE expr], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Shift 'ORDER', go to state 411
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY'
parser: Shift 'BY', go to state 17
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI'
parser: Reduce [expr ::= ID|INDEXED], go to state 17.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 17.
parser: Shift 'sortlist', go to state 410
parser: Reduce [orderby_opt ::= ORDER BY sortlist], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 22.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 2.
parser: Shift 'select'
parser: Reduce [cmd ::= select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'SELECT'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[explain with SELECT]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'FROM'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[explain with SELECT distinct selcollist FROM]
parser: Input 'STRING'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'STRING'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix STRING]
parser: Input 'DOT'
parser: Reduce [nm ::= STRING], go to state 165.
parser: Shift 'nm', go to state 287
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Shift 'WHERE', go to state 65
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'AND', go to state 93
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 93.
parser: Shift 'expr', go to state 53
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND expr EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND expr EQ STRING]
parser: Input 'ORDER'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 93.
parser: Shift 'expr', go to state 53
parser: Reduce [expr ::= expr AND expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Reduce [where_opt ::= WHERE expr], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Shift 'ORDER', go to state 411
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY'
parser: Shift 'BY', go to state 17
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI'
parser: Reduce [expr ::= ID|INDEXED], go to state 17.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 17.
parser: Shift 'sortlist', go to state 410
parser: Reduce [orderby_opt ::= ORDER BY sortlist], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 22.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 2.
parser: Shift 'select'
parser: Reduce [cmd ::= select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'PRAGMA'
parser: FALLBACK PRAGMA => ID
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Shift 'PRAGMA', go to state 172
parser: Return. Stack=[explain PRAGMA]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain PRAGMA ID]
parser: Input 'LP'
parser: Reduce [nm ::= ID|INDEXED], go to state 172.
parser: Shift 'nm', go to state 240
parser: Reduce [dbnm ::=], go to state 240.
parser: Shift 'dbnm', go to state 323
parser: Shift 'LP', go to state 19
parser: Return. Stack=[explain PRAGMA nm dbnm LP]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain PRAGMA nm dbnm LP ID]
parser: Input 'RP'
parser: Reduce [nm ::= ID|INDEXED], go to state 19.
parser: Shift 'nm'
parser: Reduce [nmnum ::= nm], go to state 19.
parser: Shift 'nmnum', go to state 349
parser: Shift 'RP'
parser: Return. Stack=[explain PRAGMA nm dbnm LP nmnum RP]
parser: Input 'SEMI'
parser: Reduce [cmd ::= PRAGMA nm dbnm LP nmnum RP], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'SEMI'
parser: Shift 'SEMI'
parser: Return. Stack=[SEMI]
parser: Input 'PRAGMA'
parser: Reduce [ecmd ::= SEMI], go to state 0.
parser: Shift 'ecmd'
parser: Reduce [cmdlist ::= ecmd], go to state 0.
parser: Shift 'cmdlist', go to state 146
parser: FALLBACK PRAGMA => ID
parser: Reduce [explain ::=], go to state 146.
parser: Shift 'explain', go to state 2
parser: Shift 'PRAGMA', go to state 172
parser: Return. Stack=[cmdlist explain PRAGMA]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[cmdlist explain PRAGMA ID]
parser: Input 'LP'
parser: Reduce [nm ::= ID|INDEXED], go to state 172.
parser: Shift 'nm', go to state 240
parser: Reduce [dbnm ::=], go to state 240.
parser: Shift 'dbnm', go to state 323
parser: Shift 'LP', go to state 19
parser: Return. Stack=[cmdlist explain PRAGMA nm dbnm LP]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[cmdlist explain PRAGMA nm dbnm LP ID]
parser: Input 'RP'
parser: Reduce [nm ::= ID|INDEXED], go to state 19.
parser: Shift 'nm'
parser: Reduce [nmnum ::= nm], go to state 19.
parser: Shift 'nmnum', go to state 349
parser: Shift 'RP'
parser: Return. Stack=[cmdlist explain PRAGMA nm dbnm LP nmnum RP]
parser: Input 'SEMI'
parser: Reduce [cmd ::= PRAGMA nm dbnm LP nmnum RP], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[cmdlist explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping cmdlist
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'SELECT'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[explain with SELECT]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'FROM'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[explain with SELECT distinct selcollist FROM]
parser: Input 'STRING'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'STRING'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix STRING]
parser: Input 'DOT'
parser: Reduce [nm ::= STRING], go to state 165.
parser: Shift 'nm', go to state 287
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Shift 'WHERE', go to state 65
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'AND', go to state 93
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 93.
parser: Shift 'expr', go to state 53
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND expr EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND expr EQ STRING]
parser: Input 'ORDER'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 93.
parser: Shift 'expr', go to state 53
parser: Reduce [expr ::= expr AND expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Reduce [where_opt ::= WHERE expr], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Shift 'ORDER', go to state 411
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY'
parser: Shift 'BY', go to state 17
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI'
parser: Reduce [expr ::= ID|INDEXED], go to state 17.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 17.
parser: Shift 'sortlist', go to state 410
parser: Reduce [orderby_opt ::= ORDER BY sortlist], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 22.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 2.
parser: Shift 'select'
parser: Reduce [cmd ::= select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'PRAGMA'
parser: FALLBACK PRAGMA => ID
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Shift 'PRAGMA', go to state 172
parser: Return. Stack=[explain PRAGMA]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain PRAGMA ID]
parser: Input 'LP'
parser: Reduce [nm ::= ID|INDEXED], go to state 172.
parser: Shift 'nm', go to state 240
parser: Reduce [dbnm ::=], go to state 240.
parser: Shift 'dbnm', go to state 323
parser: Shift 'LP', go to state 19
parser: Return. Stack=[explain PRAGMA nm dbnm LP]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain PRAGMA nm dbnm LP ID]
parser: Input 'RP'
parser: Reduce [nm ::= ID|INDEXED], go to state 19.
parser: Shift 'nm'
parser: Reduce [nmnum ::= nm], go to state 19.
parser: Shift 'nmnum', go to state 349
parser: Shift 'RP'
parser: Return. Stack=[explain PRAGMA nm dbnm LP nmnum RP]
parser: Input 'SEMI'
parser: Reduce [cmd ::= PRAGMA nm dbnm LP nmnum RP], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'SELECT'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[explain with SELECT]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'FROM'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[explain with SELECT distinct selcollist FROM]
parser: Input 'STRING'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'STRING'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix STRING]
parser: Input 'DOT'
parser: Reduce [nm ::= STRING], go to state 165.
parser: Shift 'nm', go to state 287
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Shift 'WHERE', go to state 65
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'AND', go to state 93
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 93.
parser: Shift 'expr', go to state 53
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND expr EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND expr EQ STRING]
parser: Input 'ORDER'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 93.
parser: Shift 'expr', go to state 53
parser: Reduce [expr ::= expr AND expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Reduce [where_opt ::= WHERE expr], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Shift 'ORDER', go to state 411
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY'
parser: Shift 'BY', go to state 17
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI'
parser: Reduce [expr ::= ID|INDEXED], go to state 17.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 17.
parser: Shift 'sortlist', go to state 410
parser: Reduce [orderby_opt ::= ORDER BY sortlist], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 22.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 2.
parser: Shift 'select'
parser: Reduce [cmd ::= select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'REINDEX'
parser: FALLBACK REINDEX => ID
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Shift 'REINDEX', go to state 171
parser: Return. Stack=[explain REINDEX]
parser: Input 'SEMI'
parser: Reduce [cmd ::= REINDEX], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'INSERT'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'INSERT', go to state 253
parser: Return. Stack=[explain with INSERT]
parser: Input 'INTO'
parser: Reduce [orconf ::=], go to state 253.
parser: Shift 'orconf'
parser: Reduce [insert_cmd ::= INSERT orconf], go to state 22.
parser: Shift 'insert_cmd', go to state 351
parser: Shift 'INTO', go to state 127
parser: Return. Stack=[explain with insert_cmd INTO]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with insert_cmd INTO ID]
parser: Input 'VALUES'
parser: Reduce [nm ::= ID|INDEXED], go to state 127.
parser: Shift 'nm', go to state 259
parser: Reduce [dbnm ::=], go to state 259.
parser: Shift 'dbnm'
parser: Reduce [fullname ::= nm dbnm], go to state 127.
parser: Shift 'fullname', go to state 241
parser: Reduce [idlist_opt ::=], go to state 241.
parser: Shift 'idlist_opt', go to state 147
parser: Reduce [with ::=], go to state 147.
parser: Shift 'with', go to state 113
parser: Shift 'VALUES', go to state 397
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES]
parser: Input 'LP'
parser: Shift 'LP', go to state 15
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP]
parser: Input 'INTEGER'
parser: Shift 'INTEGER'
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP INTEGER]
parser: Input 'COMMA'
parser: Reduce [term ::= INTEGER|FLOAT|BLOB], go to state 15.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 15.
parser: Shift 'expr', go to state 48
parser: Reduce [nexprlist ::= expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'COMMA', go to state 70
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA]
parser: Input 'INTEGER'
parser: Shift 'INTEGER'
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA INTEGER]
parser: Input 'RP'
parser: Reduce [term ::= INTEGER|FLOAT|BLOB], go to state 70.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 70.
parser: Shift 'expr', go to state 43
parser: Reduce [nexprlist ::= nexprlist COMMA expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'RP'
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist RP]
parser: Input 'SEMI'
parser: Reduce [values ::= VALUES LP nexprlist RP], go to state 113.
parser: Shift 'values', go to state 400
parser: Reduce [oneselect ::= values], go to state 113.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 113.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 147.
parser: Shift 'select'
parser: Reduce [cmd ::= with insert_cmd INTO fullname idlist_opt select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'INSERT'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'INSERT', go to state 253
parser: Return. Stack=[explain with INSERT]
parser: Input 'INTO'
parser: Reduce [orconf ::=], go to state 253.
parser: Shift 'orconf'
parser: Reduce [insert_cmd ::= INSERT orconf], go to state 22.
parser: Shift 'insert_cmd', go to state 351
parser: Shift 'INTO', go to state 127
parser: Return. Stack=[explain with insert_cmd INTO]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with insert_cmd INTO ID]
parser: Input 'VALUES'
parser: Reduce [nm ::= ID|INDEXED], go to state 127.
parser: Shift 'nm', go to state 259
parser: Reduce [dbnm ::=], go to state 259.
parser: Shift 'dbnm'
parser: Reduce [fullname ::= nm dbnm], go to state 127.
parser: Shift 'fullname', go to state 241
parser: Reduce [idlist_opt ::=], go to state 241.
parser: Shift 'idlist_opt', go to state 147
parser: Reduce [with ::=], go to state 147.
parser: Shift 'with', go to state 113
parser: Shift 'VALUES', go to state 397
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES]
parser: Input 'LP'
parser: Shift 'LP', go to state 15
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP]
parser: Input 'INTEGER'
parser: Shift 'INTEGER'
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP INTEGER]
parser: Input 'COMMA'
parser: Reduce [term ::= INTEGER|FLOAT|BLOB], go to state 15.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 15.
parser: Shift 'expr', go to state 48
parser: Reduce [nexprlist ::= expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'COMMA', go to state 70
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA]
parser: Input 'INTEGER'
parser: Shift 'INTEGER'
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA INTEGER]
parser: Input 'RP'
parser: Reduce [term ::= INTEGER|FLOAT|BLOB], go to state 70.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 70.
parser: Shift 'expr', go to state 43
parser: Reduce [nexprlist ::= nexprlist COMMA expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'RP'
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist RP]
parser: Input 'SEMI'
parser: Reduce [values ::= VALUES LP nexprlist RP], go to state 113.
parser: Shift 'values', go to state 400
parser: Reduce [oneselect ::= values], go to state 113.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 113.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 147.
parser: Shift 'select'
parser: Reduce [cmd ::= with insert_cmd INTO fullname idlist_opt select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'SELECT'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[explain with SELECT]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'FROM'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[explain with SELECT distinct selcollist FROM]
parser: Input 'STRING'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'STRING'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix STRING]
parser: Input 'DOT'
parser: Reduce [nm ::= STRING], go to state 165.
parser: Shift 'nm', go to state 287
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Shift 'WHERE', go to state 65
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'AND', go to state 93
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 93.
parser: Shift 'expr', go to state 53
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND expr EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND expr EQ STRING]
parser: Input 'ORDER'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 93.
parser: Shift 'expr', go to state 53
parser: Reduce [expr ::= expr AND expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Reduce [where_opt ::= WHERE expr], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Shift 'ORDER', go to state 411
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY'
parser: Shift 'BY', go to state 17
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI'
parser: Reduce [expr ::= ID|INDEXED], go to state 17.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 17.
parser: Shift 'sortlist', go to state 410
parser: Reduce [orderby_opt ::= ORDER BY sortlist], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 22.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 2.
parser: Shift 'select'
parser: Reduce [cmd ::= select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'CREATE'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Shift 'CREATE'
parser: Return. Stack=[explain CREATE]
parser: Input 'INDEX'
parser: Reduce [createkw ::= CREATE], go to state 2.
parser: Shift 'createkw', go to state 107
parser: Reduce [uniqueflag ::=], go to state 107.
parser: Shift 'uniqueflag', go to state 370
parser: Shift 'INDEX', go to state 256
parser: Return. Stack=[explain createkw uniqueflag INDEX]
parser: Input 'ID'
parser: Reduce [ifnotexists ::=], go to state 256.
parser: Shift 'ifnotexists', go to state 180
parser: Shift 'ID'
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists ID]
parser: Input 'ON'
parser: Reduce [nm ::= ID|INDEXED], go to state 180.
parser: Shift 'nm', go to state 255
parser: Reduce [dbnm ::=], go to state 255.
parser: Shift 'dbnm', go to state 369
parser: Shift 'ON', go to state 179
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON ID]
parser: Input 'LP'
parser: Reduce [nm ::= ID|INDEXED], go to state 179.
parser: Shift 'nm', go to state 368
parser: Shift 'LP', go to state 12
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP ID]
parser: Input 'RP'
parser: Reduce [expr ::= ID|INDEXED], go to state 12.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 12.
parser: Shift 'sortlist', go to state 325
parser: Shift 'RP', go to state 254
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP]
parser: Input 'SEMI'
parser: Reduce [where_opt ::=], go to state 254.
parser: Shift 'where_opt'
parser: Reduce [cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt], go to state 2.
parser: Initialize. Empty stack. State 0
parser: Input 'INSERT'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'INSERT', go to state 253
parser: Return. Stack=[explain with INSERT]
parser: Input 'INTO'
parser: Reduce [orconf ::=], go to state 253.
parser: Shift 'orconf'
parser: Reduce [insert_cmd ::= INSERT orconf], go to state 22.
parser: Shift 'insert_cmd', go to state 351
parser: Shift 'INTO', go to state 127
parser: Return. Stack=[explain with insert_cmd INTO]
parser: Input 'STRING'
parser: Shift 'STRING'
parser: Return. Stack=[explain with insert_cmd INTO STRING]
parser: Input 'DOT'
parser: Reduce [nm ::= STRING], go to state 127.
parser: Shift 'nm', go to state 259
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[explain with insert_cmd INTO nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with insert_cmd INTO nm DOT ID]
parser: Input 'VALUES'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 259.
parser: Shift 'dbnm'
parser: Reduce [fullname ::= nm dbnm], go to state 127.
parser: Shift 'fullname', go to state 241
parser: Reduce [idlist_opt ::=], go to state 241.
parser: Shift 'idlist_opt', go to state 147
parser: Reduce [with ::=], go to state 147.
parser: Shift 'with', go to state 113
parser: Shift 'VALUES', go to state 397
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES]
parser: Input 'LP'
parser: Shift 'LP', go to state 15
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP STRING]
parser: Input 'COMMA'
parser: Reduce [term ::= STRING], go to state 15.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 15.
parser: Shift 'expr', go to state 48
parser: Reduce [nexprlist ::= expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'COMMA', go to state 70
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA STRING]
parser: Input 'COMMA'
parser: Reduce [term ::= STRING], go to state 70.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 70.
parser: Shift 'expr', go to state 43
parser: Reduce [nexprlist ::= nexprlist COMMA expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'COMMA', go to state 70
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA STRING]
parser: Input 'COMMA'
parser: Reduce [term ::= STRING], go to state 70.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 70.
parser: Shift 'expr', go to state 43
parser: Reduce [nexprlist ::= nexprlist COMMA expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'COMMA', go to state 70
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA]
parser: Input 'VARIABLE'
parser: Shift 'VARIABLE'
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA VARIABLE]
parser: Input 'COMMA'
parser: Reduce [expr ::= VARIABLE], go to state 70.
parser: Shift 'expr', go to state 43
parser: Reduce [nexprlist ::= nexprlist COMMA expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'COMMA', go to state 70
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA STRING]
parser: Input 'RP'
parser: Reduce [term ::= STRING], go to state 70.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 70.
parser: Shift 'expr', go to state 43
parser: Reduce [nexprlist ::= nexprlist COMMA expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'RP'
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist RP]
parser: Input 'SEMI'
parser: Reduce [values ::= VALUES LP nexprlist RP], go to state 113.
parser: Shift 'values', go to state 400
parser: Reduce [oneselect ::= values], go to state 113.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 113.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 147.
parser: Shift 'select'
parser: Reduce [cmd ::= with insert_cmd INTO fullname idlist_opt select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Input '$'
parser: Reduce [ecmd ::= explain cmdx SEMI], go to state 0.
parser: Shift 'ecmd'
parser: Reduce [cmdlist ::= ecmd], go to state 0.
parser: Shift 'cmdlist', go to state 146
parser: Reduce [input ::= cmdlist], go to state 0.
parser: Accept!
parser: Popping $
parser: Return. Stack=]
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'SELECT'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[explain with SELECT]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'FROM'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[explain with SELECT distinct selcollist FROM]
parser: Input 'STRING'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'STRING'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix STRING]
parser: Input 'DOT'
parser: Reduce [nm ::= STRING], go to state 165.
parser: Shift 'nm', go to state 287
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Shift 'WHERE', go to state 65
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'AND', go to state 93
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 93.
parser: Shift 'expr', go to state 53
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND expr EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND expr EQ STRING]
parser: Input 'ORDER'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 93.
parser: Shift 'expr', go to state 53
parser: Reduce [expr ::= expr AND expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Reduce [where_opt ::= WHERE expr], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Shift 'ORDER', go to state 411
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY'
parser: Shift 'BY', go to state 17
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI'
parser: Reduce [expr ::= ID|INDEXED], go to state 17.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 17.
parser: Shift 'sortlist', go to state 410
parser: Reduce [orderby_opt ::= ORDER BY sortlist], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 22.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 2.
parser: Shift 'select'
parser: Reduce [cmd ::= select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'CREATE'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Shift 'CREATE'
parser: Return. Stack=[explain CREATE]
parser: Input 'INDEX'
parser: Reduce [createkw ::= CREATE], go to state 2.
parser: Shift 'createkw', go to state 107
parser: Reduce [uniqueflag ::=], go to state 107.
parser: Shift 'uniqueflag', go to state 370
parser: Shift 'INDEX', go to state 256
parser: Return. Stack=[explain createkw uniqueflag INDEX]
parser: Input 'ID'
parser: Reduce [ifnotexists ::=], go to state 256.
parser: Shift 'ifnotexists', go to state 180
parser: Shift 'ID'
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists ID]
parser: Input 'ON'
parser: Reduce [nm ::= ID|INDEXED], go to state 180.
parser: Shift 'nm', go to state 255
parser: Reduce [dbnm ::=], go to state 255.
parser: Shift 'dbnm', go to state 369
parser: Shift 'ON', go to state 179
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON ID]
parser: Input 'LP'
parser: Reduce [nm ::= ID|INDEXED], go to state 179.
parser: Shift 'nm', go to state 368
parser: Shift 'LP', go to state 12
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP ID]
parser: Input 'RP'
parser: Reduce [expr ::= ID|INDEXED], go to state 12.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 12.
parser: Shift 'sortlist', go to state 325
parser: Shift 'RP', go to state 254
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP]
parser: Input 'SEMI'
parser: Reduce [where_opt ::=], go to state 254.
parser: Shift 'where_opt'
parser: Reduce [cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'SEMI'
parser: Shift 'SEMI'
parser: Return. Stack=[SEMI]
parser: Input 'SELECT'
parser: Reduce [ecmd ::= SEMI], go to state 0.
parser: Shift 'ecmd'
parser: Reduce [cmdlist ::= ecmd], go to state 0.
parser: Shift 'cmdlist', go to state 146
parser: Reduce [explain ::=], go to state 146.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[cmdlist explain with SELECT]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct sclp ID]
parser: Input 'FROM'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist FROM]
parser: Input 'ID'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'ID'
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'WHERE'
parser: Reduce [nm ::= ID|INDEXED], go to state 165.
parser: Shift 'nm', go to state 287
parser: Reduce [dbnm ::=], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Shift 'WHERE', go to state 65
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE ID]
parser: Input 'NE'
parser: Reduce [expr ::= ID|INDEXED], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'NE', go to state 90
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE expr NE]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE expr NE STRING]
parser: Input 'ORDER'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Reduce [where_opt ::= WHERE expr], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Shift 'ORDER', go to state 411
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY'
parser: Shift 'BY', go to state 17
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI'
parser: Reduce [expr ::= ID|INDEXED], go to state 17.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 17.
parser: Shift 'sortlist', go to state 410
parser: Reduce [orderby_opt ::= ORDER BY sortlist], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 22.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 2.
parser: Shift 'select'
parser: Reduce [cmd ::= select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[cmdlist explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping cmdlist
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'SELECT'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[explain with SELECT]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'FROM'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[explain with SELECT distinct selcollist FROM]
parser: Input 'STRING'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'STRING'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix STRING]
parser: Input 'DOT'
parser: Reduce [nm ::= STRING], go to state 165.
parser: Shift 'nm', go to state 287
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Shift 'WHERE', go to state 65
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'AND', go to state 93
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'NE'
parser: Reduce [expr ::= ID|INDEXED], go to state 93.
parser: Shift 'expr', go to state 53
parser: Shift 'NE', go to state 90
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND expr NE]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND expr NE STRING]
parser: Input 'ORDER'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 93.
parser: Shift 'expr', go to state 53
parser: Reduce [expr ::= expr AND expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Reduce [where_opt ::= WHERE expr], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Shift 'ORDER', go to state 411
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY'
parser: Shift 'BY', go to state 17
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI'
parser: Reduce [expr ::= ID|INDEXED], go to state 17.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 17.
parser: Shift 'sortlist', go to state 410
parser: Reduce [orderby_opt ::= ORDER BY sortlist], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 22.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 2.
parser: Shift 'select'
parser: Reduce [cmd ::= select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'INSERT'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'INSERT', go to state 253
parser: Return. Stack=[explain with INSERT]
parser: Input 'INTO'
parser: Reduce [orconf ::=], go to state 253.
parser: Shift 'orconf'
parser: Reduce [insert_cmd ::= INSERT orconf], go to state 22.
parser: Shift 'insert_cmd', go to state 351
parser: Shift 'INTO', go to state 127
parser: Return. Stack=[explain with insert_cmd INTO]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with insert_cmd INTO ID]
parser: Input 'VALUES'
parser: Reduce [nm ::= ID|INDEXED], go to state 127.
parser: Shift 'nm', go to state 259
parser: Reduce [dbnm ::=], go to state 259.
parser: Shift 'dbnm'
parser: Reduce [fullname ::= nm dbnm], go to state 127.
parser: Shift 'fullname', go to state 241
parser: Reduce [idlist_opt ::=], go to state 241.
parser: Shift 'idlist_opt', go to state 147
parser: Reduce [with ::=], go to state 147.
parser: Shift 'with', go to state 113
parser: Shift 'VALUES', go to state 397
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES]
parser: Input 'LP'
parser: Shift 'LP', go to state 15
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP]
parser: Input 'INTEGER'
parser: Shift 'INTEGER'
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP INTEGER]
parser: Input 'COMMA'
parser: Reduce [term ::= INTEGER|FLOAT|BLOB], go to state 15.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 15.
parser: Shift 'expr', go to state 48
parser: Reduce [nexprlist ::= expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'COMMA', go to state 70
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA]
parser: Input 'INTEGER'
parser: Shift 'INTEGER'
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA INTEGER]
parser: Input 'RP'
parser: Reduce [term ::= INTEGER|FLOAT|BLOB], go to state 70.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 70.
parser: Shift 'expr', go to state 43
parser: Reduce [nexprlist ::= nexprlist COMMA expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'RP'
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist RP]
parser: Input 'SEMI'
parser: Reduce [values ::= VALUES LP nexprlist RP], go to state 113.
parser: Shift 'values', go to state 400
parser: Reduce [oneselect ::= values], go to state 113.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 113.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 147.
parser: Shift 'select'
parser: Reduce [cmd ::= with insert_cmd INTO fullname idlist_opt select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'INSERT'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'INSERT', go to state 253
parser: Return. Stack=[explain with INSERT]
parser: Input 'INTO'
parser: Reduce [orconf ::=], go to state 253.
parser: Shift 'orconf'
parser: Reduce [insert_cmd ::= INSERT orconf], go to state 22.
parser: Shift 'insert_cmd', go to state 351
parser: Shift 'INTO', go to state 127
parser: Return. Stack=[explain with insert_cmd INTO]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with insert_cmd INTO ID]
parser: Input 'VALUES'
parser: Reduce [nm ::= ID|INDEXED], go to state 127.
parser: Shift 'nm', go to state 259
parser: Reduce [dbnm ::=], go to state 259.
parser: Shift 'dbnm'
parser: Reduce [fullname ::= nm dbnm], go to state 127.
parser: Shift 'fullname', go to state 241
parser: Reduce [idlist_opt ::=], go to state 241.
parser: Shift 'idlist_opt', go to state 147
parser: Reduce [with ::=], go to state 147.
parser: Shift 'with', go to state 113
parser: Shift 'VALUES', go to state 397
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES]
parser: Input 'LP'
parser: Shift 'LP', go to state 15
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP]
parser: Input 'INTEGER'
parser: Shift 'INTEGER'
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP INTEGER]
parser: Input 'COMMA'
parser: Reduce [term ::= INTEGER|FLOAT|BLOB], go to state 15.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 15.
parser: Shift 'expr', go to state 48
parser: Reduce [nexprlist ::= expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'COMMA', go to state 70
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA]
parser: Input 'INTEGER'
parser: Shift 'INTEGER'
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA INTEGER]
parser: Input 'RP'
parser: Reduce [term ::= INTEGER|FLOAT|BLOB], go to state 70.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 70.
parser: Shift 'expr', go to state 43
parser: Reduce [nexprlist ::= nexprlist COMMA expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'RP'
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist RP]
parser: Input 'SEMI'
parser: Reduce [values ::= VALUES LP nexprlist RP], go to state 113.
parser: Shift 'values', go to state 400
parser: Reduce [oneselect ::= values], go to state 113.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 113.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 147.
parser: Shift 'select'
parser: Reduce [cmd ::= with insert_cmd INTO fullname idlist_opt select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'SELECT'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[explain with SELECT]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'FROM'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[explain with SELECT distinct selcollist FROM]
parser: Input 'ID'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'ID'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'WHERE'
parser: Reduce [nm ::= ID|INDEXED], go to state 165.
parser: Shift 'nm', go to state 287
parser: Reduce [dbnm ::=], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Shift 'WHERE', go to state 65
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'INTEGER'
parser: Shift 'INTEGER'
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr EQ INTEGER]
parser: Input 'SEMI'
parser: Reduce [term ::= INTEGER|FLOAT|BLOB], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Reduce [where_opt ::= WHERE expr], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Reduce [orderby_opt ::=], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 22.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 2.
parser: Shift 'select'
parser: Reduce [cmd ::= select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'SEMI'
parser: Shift 'SEMI'
parser: Return. Stack=[SEMI]
parser: Input 'INSERT'
parser: Reduce [ecmd ::= SEMI], go to state 0.
parser: Shift 'ecmd'
parser: Reduce [cmdlist ::= ecmd], go to state 0.
parser: Shift 'cmdlist', go to state 146
parser: Reduce [explain ::=], go to state 146.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'INSERT', go to state 253
parser: Return. Stack=[cmdlist explain with INSERT]
parser: Input 'INTO'
parser: Reduce [orconf ::=], go to state 253.
parser: Shift 'orconf'
parser: Reduce [insert_cmd ::= INSERT orconf], go to state 22.
parser: Shift 'insert_cmd', go to state 351
parser: Shift 'INTO', go to state 127
parser: Return. Stack=[cmdlist explain with insert_cmd INTO]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[cmdlist explain with insert_cmd INTO ID]
parser: Input 'VALUES'
parser: Reduce [nm ::= ID|INDEXED], go to state 127.
parser: Shift 'nm', go to state 259
parser: Reduce [dbnm ::=], go to state 259.
parser: Shift 'dbnm'
parser: Reduce [fullname ::= nm dbnm], go to state 127.
parser: Shift 'fullname', go to state 241
parser: Reduce [idlist_opt ::=], go to state 241.
parser: Shift 'idlist_opt', go to state 147
parser: Reduce [with ::=], go to state 147.
parser: Shift 'with', go to state 113
parser: Shift 'VALUES', go to state 397
parser: Return. Stack=[cmdlist explain with insert_cmd INTO fullname idlist_opt with VALUES]
parser: Input 'LP'
parser: Shift 'LP', go to state 15
parser: Return. Stack=[cmdlist explain with insert_cmd INTO fullname idlist_opt with VALUES LP]
parser: Input 'INTEGER'
parser: Shift 'INTEGER'
parser: Return. Stack=[cmdlist explain with insert_cmd INTO fullname idlist_opt with VALUES LP INTEGER]
parser: Input 'COMMA'
parser: Reduce [term ::= INTEGER|FLOAT|BLOB], go to state 15.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 15.
parser: Shift 'expr', go to state 48
parser: Reduce [nexprlist ::= expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'COMMA', go to state 70
parser: Return. Stack=[cmdlist explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA]
parser: Input 'INTEGER'
parser: Shift 'INTEGER'
parser: Return. Stack=[cmdlist explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA INTEGER]
parser: Input 'RP'
parser: Reduce [term ::= INTEGER|FLOAT|BLOB], go to state 70.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 70.
parser: Shift 'expr', go to state 43
parser: Reduce [nexprlist ::= nexprlist COMMA expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'RP'
parser: Return. Stack=[cmdlist explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist RP]
parser: Input 'SEMI'
parser: Reduce [values ::= VALUES LP nexprlist RP], go to state 113.
parser: Shift 'values', go to state 400
parser: Reduce [oneselect ::= values], go to state 113.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 113.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 147.
parser: Shift 'select'
parser: Reduce [cmd ::= with insert_cmd INTO fullname idlist_opt select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[cmdlist explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping cmdlist
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'SEMI'
parser: Shift 'SEMI'
parser: Return. Stack=[SEMI]
parser: Input 'DELETE'
parser: Reduce [ecmd ::= SEMI], go to state 0.
parser: Shift 'ecmd'
parser: Reduce [cmdlist ::= ecmd], go to state 0.
parser: Shift 'cmdlist', go to state 146
parser: Reduce [explain ::=], go to state 146.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'DELETE', go to state 353
parser: Return. Stack=[cmdlist explain with DELETE]
parser: Input 'FROM'
parser: Shift 'FROM', go to state 130
parser: Return. Stack=[cmdlist explain with DELETE FROM]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[cmdlist explain with DELETE FROM ID]
parser: Input 'WHERE'
parser: Reduce [nm ::= ID|INDEXED], go to state 130.
parser: Shift 'nm', go to state 259
parser: Reduce [dbnm ::=], go to state 259.
parser: Shift 'dbnm'
parser: Reduce [fullname ::= nm dbnm], go to state 130.
parser: Shift 'fullname', go to state 220
parser: Reduce [indexed_opt ::=], go to state 220.
parser: Shift 'indexed_opt', go to state 243
parser: Shift 'WHERE', go to state 65
parser: Return. Stack=[cmdlist explain with DELETE FROM fullname indexed_opt WHERE]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with DELETE FROM fullname indexed_opt WHERE ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[cmdlist explain with DELETE FROM fullname indexed_opt WHERE expr EQ]
parser: Input 'INTEGER'
parser: Shift 'INTEGER'
parser: Return. Stack=[cmdlist explain with DELETE FROM fullname indexed_opt WHERE expr EQ INTEGER]
parser: Input 'SEMI'
parser: Reduce [term ::= INTEGER|FLOAT|BLOB], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Reduce [where_opt ::= WHERE expr], go to state 243.
parser: Shift 'where_opt'
parser: Reduce [cmd ::= with DELETE FROM fullname indexed_opt where_opt], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[cmdlist explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping cmdlist
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'SELECT'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[explain with SELECT]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'FROM'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[explain with SELECT distinct selcollist FROM]
parser: Input 'ID'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'ID'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'WHERE'
parser: Reduce [nm ::= ID|INDEXED], go to state 165.
parser: Shift 'nm', go to state 287
parser: Reduce [dbnm ::=], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Shift 'WHERE', go to state 65
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE ID]
parser: Input 'LT'
parser: Reduce [expr ::= ID|INDEXED], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'LT', go to state 91
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr LT]
parser: Input 'FLOAT'
parser: Shift 'FLOAT'
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr LT FLOAT]
parser: Input 'ORDER'
parser: Reduce [term ::= INTEGER|FLOAT|BLOB], go to state 91.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 91.
parser: Shift 'expr', go to state 103
parser: Reduce [expr ::= expr LT|GT|GE|LE expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Reduce [where_opt ::= WHERE expr], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Shift 'ORDER', go to state 411
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY'
parser: Shift 'BY', go to state 17
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI'
parser: Reduce [expr ::= ID|INDEXED], go to state 17.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 17.
parser: Shift 'sortlist', go to state 410
parser: Reduce [orderby_opt ::= ORDER BY sortlist], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 22.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 2.
parser: Shift 'select'
parser: Reduce [cmd ::= select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'SEMI'
parser: Shift 'SEMI'
parser: Return. Stack=[SEMI]
parser: Input 'SELECT'
parser: Reduce [ecmd ::= SEMI], go to state 0.
parser: Shift 'ecmd'
parser: Reduce [cmdlist ::= ecmd], go to state 0.
parser: Shift 'cmdlist', go to state 146
parser: Reduce [explain ::=], go to state 146.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[cmdlist explain with SELECT]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct sclp ID]
parser: Input 'FROM'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist FROM]
parser: Input 'STRING'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'STRING'
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist FROM stl_prefix STRING]
parser: Input 'DOT'
parser: Reduce [nm ::= STRING], go to state 165.
parser: Shift 'nm', go to state 287
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Shift 'WHERE', go to state 65
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'AND', go to state 93
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'NE'
parser: Reduce [expr ::= ID|INDEXED], go to state 93.
parser: Shift 'expr', go to state 53
parser: Shift 'NE', go to state 90
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE expr AND expr NE]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE expr AND expr NE STRING]
parser: Input 'ORDER'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 93.
parser: Shift 'expr', go to state 53
parser: Reduce [expr ::= expr AND expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Reduce [where_opt ::= WHERE expr], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Shift 'ORDER', go to state 411
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY'
parser: Shift 'BY', go to state 17
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI'
parser: Reduce [expr ::= ID|INDEXED], go to state 17.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 17.
parser: Shift 'sortlist', go to state 410
parser: Reduce [orderby_opt ::= ORDER BY sortlist], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 22.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 2.
parser: Shift 'select'
parser: Reduce [cmd ::= select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[cmdlist explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping cmdlist
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'SEMI'
parser: Shift 'SEMI'
parser: Return. Stack=[SEMI]
parser: Input 'SELECT'
parser: Reduce [ecmd ::= SEMI], go to state 0.
parser: Shift 'ecmd'
parser: Reduce [cmdlist ::= ecmd], go to state 0.
parser: Shift 'cmdlist', go to state 146
parser: Reduce [explain ::=], go to state 146.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[cmdlist explain with SELECT]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct sclp ID]
parser: Input 'FROM'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist FROM]
parser: Input 'ID'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'ID'
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'WHERE'
parser: Reduce [nm ::= ID|INDEXED], go to state 165.
parser: Shift 'nm', go to state 287
parser: Reduce [dbnm ::=], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Shift 'WHERE', go to state 65
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE ID]
parser: Input 'LE'
parser: Reduce [expr ::= ID|INDEXED], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'LE', go to state 91
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE expr LE]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE expr LE STRING]
parser: Input 'SEMI'
parser: Reduce [term ::= STRING], go to state 91.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 91.
parser: Shift 'expr', go to state 103
parser: Reduce [expr ::= expr LT|GT|GE|LE expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Reduce [where_opt ::= WHERE expr], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Reduce [orderby_opt ::=], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 22.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 2.
parser: Shift 'select'
parser: Reduce [cmd ::= select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[cmdlist explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping cmdlist
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'SEMI'
parser: Shift 'SEMI'
parser: Return. Stack=[SEMI]
parser: Input 'SELECT'
parser: Reduce [ecmd ::= SEMI], go to state 0.
parser: Shift 'ecmd'
parser: Reduce [cmdlist ::= ecmd], go to state 0.
parser: Shift 'cmdlist', go to state 146
parser: Reduce [explain ::=], go to state 146.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[cmdlist explain with SELECT]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct sclp ID]
parser: Input 'FROM'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist FROM]
parser: Input 'ID'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'ID'
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'WHERE'
parser: Reduce [nm ::= ID|INDEXED], go to state 165.
parser: Shift 'nm', go to state 287
parser: Reduce [dbnm ::=], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Shift 'WHERE', go to state 65
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE ID]
parser: Input 'LE'
parser: Reduce [expr ::= ID|INDEXED], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'LE', go to state 91
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE expr LE]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE expr LE STRING]
parser: Input 'SEMI'
parser: Reduce [term ::= STRING], go to state 91.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 91.
parser: Shift 'expr', go to state 103
parser: Reduce [expr ::= expr LT|GT|GE|LE expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Reduce [where_opt ::= WHERE expr], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Reduce [orderby_opt ::=], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 22.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 2.
parser: Shift 'select'
parser: Reduce [cmd ::= select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[cmdlist explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping cmdlist
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'SEMI'
parser: Shift 'SEMI'
parser: Return. Stack=[SEMI]
parser: Input 'PRAGMA'
parser: Reduce [ecmd ::= SEMI], go to state 0.
parser: Shift 'ecmd'
parser: Reduce [cmdlist ::= ecmd], go to state 0.
parser: Shift 'cmdlist', go to state 146
parser: FALLBACK PRAGMA => ID
parser: Reduce [explain ::=], go to state 146.
parser: Shift 'explain', go to state 2
parser: Shift 'PRAGMA', go to state 172
parser: Return. Stack=[cmdlist explain PRAGMA]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[cmdlist explain PRAGMA ID]
parser: Input 'SEMI'
parser: Reduce [nm ::= ID|INDEXED], go to state 172.
parser: Shift 'nm', go to state 240
parser: Reduce [dbnm ::=], go to state 240.
parser: Shift 'dbnm', go to state 323
parser: Reduce [cmd ::= PRAGMA nm dbnm], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[cmdlist explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping cmdlist
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'SEMI'
parser: Shift 'SEMI'
parser: Return. Stack=[SEMI]
parser: Input 'SELECT'
parser: Reduce [ecmd ::= SEMI], go to state 0.
parser: Shift 'ecmd'
parser: Reduce [cmdlist ::= ecmd], go to state 0.
parser: Shift 'cmdlist', go to state 146
parser: Reduce [explain ::=], go to state 146.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[cmdlist explain with SELECT]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct sclp ID]
parser: Input 'FROM'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist FROM]
parser: Input 'STRING'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'STRING'
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist FROM stl_prefix STRING]
parser: Input 'DOT'
parser: Reduce [nm ::= STRING], go to state 165.
parser: Shift 'nm', go to state 287
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Shift 'WHERE', go to state 65
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'AND', go to state 93
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'NE'
parser: Reduce [expr ::= ID|INDEXED], go to state 93.
parser: Shift 'expr', go to state 53
parser: Shift 'NE', go to state 90
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE expr AND expr NE]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from WHERE expr AND expr NE STRING]
parser: Input 'ORDER'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 93.
parser: Shift 'expr', go to state 53
parser: Reduce [expr ::= expr AND expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Reduce [where_opt ::= WHERE expr], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Shift 'ORDER', go to state 411
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY'
parser: Shift 'BY', go to state 17
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[cmdlist explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI'
parser: Reduce [expr ::= ID|INDEXED], go to state 17.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 17.
parser: Shift 'sortlist', go to state 410
parser: Reduce [orderby_opt ::= ORDER BY sortlist], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 22.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 2.
parser: Shift 'select'
parser: Reduce [cmd ::= select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[cmdlist explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping cmdlist
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'SEMI'
parser: Shift 'SEMI'
parser: Return. Stack=[SEMI]
parser: Input 'DROP'
parser: Reduce [ecmd ::= SEMI], go to state 0.
parser: Shift 'ecmd'
parser: Reduce [cmdlist ::= ecmd], go to state 0.
parser: Shift 'cmdlist', go to state 146
parser: Reduce [explain ::=], go to state 146.
parser: Shift 'explain', go to state 2
parser: Shift 'DROP', go to state 316
parser: Return. Stack=[cmdlist explain DROP]
parser: Input 'TABLE'
parser: Shift 'TABLE', go to state 247
parser: Return. Stack=[cmdlist explain DROP TABLE]
parser: Input 'ID'
parser: Reduce [ifexists ::=], go to state 247.
parser: Shift 'ifexists', go to state 134
parser: Shift 'ID'
parser: Return. Stack=[cmdlist explain DROP TABLE ifexists ID]
parser: Input 'SEMI'
parser: Reduce [nm ::= ID|INDEXED], go to state 134.
parser: Shift 'nm', go to state 259
parser: Reduce [dbnm ::=], go to state 259.
parser: Shift 'dbnm'
parser: Reduce [fullname ::= nm dbnm], go to state 134.
parser: Shift 'fullname'
parser: Reduce [cmd ::= DROP TABLE ifexists fullname], go to state 2.
parser: Initialize. Empty stack. State 0
parser: Input 'DELETE'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'DELETE', go to state 353
parser: Return. Stack=[explain with DELETE]
parser: Input 'FROM'
parser: Shift 'FROM', go to state 130
parser: Return. Stack=[explain with DELETE FROM]
parser: Input 'STRING'
parser: Shift 'STRING'
parser: Return. Stack=[explain with DELETE FROM STRING]
parser: Input 'DOT'
parser: Reduce [nm ::= STRING], go to state 130.
parser: Shift 'nm', go to state 259
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[explain with DELETE FROM nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with DELETE FROM nm DOT ID]
parser: Input 'WHERE'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 259.
parser: Shift 'dbnm'
parser: Reduce [fullname ::= nm dbnm], go to state 130.
parser: Shift 'fullname', go to state 220
parser: Reduce [indexed_opt ::=], go to state 220.
parser: Shift 'indexed_opt', go to state 243
parser: Shift 'WHERE', go to state 65
parser: Return. Stack=[explain with DELETE FROM fullname indexed_opt WHERE]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with DELETE FROM fullname indexed_opt WHERE ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[explain with DELETE FROM fullname indexed_opt WHERE expr EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with DELETE FROM fullname indexed_opt WHERE expr EQ STRING]
parser: Input 'AND'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'AND', go to state 93
parser: Return. Stack=[explain with DELETE FROM fullname indexed_opt WHERE expr AND]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with DELETE FROM fullname indexed_opt WHERE expr AND ID]
parser: Input 'NE'
parser: Reduce [expr ::= ID|INDEXED], go to state 93.
parser: Shift 'expr', go to state 53
parser: Shift 'NE', go to state 90
parser: Return. Stack=[explain with DELETE FROM fullname indexed_opt WHERE expr AND expr NE]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with DELETE FROM fullname indexed_opt WHERE expr AND expr NE STRING]
parser: Input 'SEMI'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 93.
parser: Shift 'expr', go to state 53
parser: Reduce [expr ::= expr AND expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Reduce [where_opt ::= WHERE expr], go to state 243.
parser: Shift 'where_opt'
parser: Reduce [cmd ::= with DELETE FROM fullname indexed_opt where_opt], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Input '$'
parser: Reduce [ecmd ::= explain cmdx SEMI], go to state 0.
parser: Shift 'ecmd'
parser: Reduce [cmdlist ::= ecmd], go to state 0.
parser: Shift 'cmdlist', go to state 146
parser: Reduce [input ::= cmdlist], go to state 0.
parser: Accept!
parser: Popping $
parser: Return. Stack=]
parser: Initialize. Empty stack. State 0
parser: Input 'UPDATE'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'UPDATE', go to state 242
parser: Return. Stack=[explain with UPDATE]
parser: Input 'STRING'
parser: Reduce [orconf ::=], go to state 242.
parser: Shift 'orconf', go to state 129
parser: Shift 'STRING'
parser: Return. Stack=[explain with UPDATE orconf STRING]
parser: Input 'DOT'
parser: Reduce [nm ::= STRING], go to state 129.
parser: Shift 'nm', go to state 259
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[explain with UPDATE orconf nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with UPDATE orconf nm DOT ID]
parser: Input 'SET'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 259.
parser: Shift 'dbnm'
parser: Reduce [fullname ::= nm dbnm], go to state 129.
parser: Shift 'fullname', go to state 219
parser: Reduce [indexed_opt ::=], go to state 219.
parser: Shift 'indexed_opt', go to state 352
parser: Shift 'SET', go to state 128
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET ID]
parser: Input 'EQ'
parser: Reduce [nm ::= ID|INDEXED], go to state 128.
parser: Shift 'nm', go to state 360
parser: Shift 'EQ', go to state 59
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET nm EQ]
parser: Input 'INTEGER'
parser: Shift 'INTEGER'
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET nm EQ INTEGER]
parser: Input 'WHERE'
parser: Reduce [term ::= INTEGER|FLOAT|BLOB], go to state 59.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 59.
parser: Shift 'expr', go to state 36
parser: Reduce [setlist ::= nm EQ expr], go to state 128.
parser: Shift 'setlist', go to state 218
parser: Shift 'WHERE', go to state 65
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist WHERE]
parser: Input 'VARIABLE'
parser: Shift 'VARIABLE'
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist WHERE VARIABLE]
parser: Input 'AND'
parser: Reduce [expr ::= VARIABLE], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'AND', go to state 93
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist WHERE expr AND]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist WHERE expr AND ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 93.
parser: Shift 'expr', go to state 53
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist WHERE expr AND expr EQ]
parser: Input 'VARIABLE'
parser: Shift 'VARIABLE'
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist WHERE expr AND expr EQ VARIABLE]
parser: Input 'SEMI'
parser: Reduce [expr ::= VARIABLE], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 93.
parser: Shift 'expr', go to state 53
parser: Reduce [expr ::= expr AND expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Reduce [where_opt ::= WHERE expr], go to state 218.
parser: Shift 'where_opt'
parser: Reduce [cmd ::= with UPDATE orconf fullname indexed_opt SET setlist where_opt], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Input '$'
parser: Reduce [ecmd ::= explain cmdx SEMI], go to state 0.
parser: Shift 'ecmd'
parser: Reduce [cmdlist ::= ecmd], go to state 0.
parser: Shift 'cmdlist', go to state 146
parser: Reduce [input ::= cmdlist], go to state 0.
parser: Accept!
parser: Popping $
parser: Return. Stack=]
parser: Initialize. Empty stack. State 0
parser: Input 'UPDATE'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'UPDATE', go to state 242
parser: Return. Stack=[explain with UPDATE]
parser: Input 'STRING'
parser: Reduce [orconf ::=], go to state 242.
parser: Shift 'orconf', go to state 129
parser: Shift 'STRING'
parser: Return. Stack=[explain with UPDATE orconf STRING]
parser: Input 'DOT'
parser: Reduce [nm ::= STRING], go to state 129.
parser: Shift 'nm', go to state 259
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[explain with UPDATE orconf nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with UPDATE orconf nm DOT ID]
parser: Input 'SET'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 259.
parser: Shift 'dbnm'
parser: Reduce [fullname ::= nm dbnm], go to state 129.
parser: Shift 'fullname', go to state 219
parser: Reduce [indexed_opt ::=], go to state 219.
parser: Shift 'indexed_opt', go to state 352
parser: Shift 'SET', go to state 128
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET ID]
parser: Input 'EQ'
parser: Reduce [nm ::= ID|INDEXED], go to state 128.
parser: Shift 'nm', go to state 360
parser: Shift 'EQ', go to state 59
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET nm EQ]
parser: Input 'INTEGER'
parser: Shift 'INTEGER'
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET nm EQ INTEGER]
parser: Input 'WHERE'
parser: Reduce [term ::= INTEGER|FLOAT|BLOB], go to state 59.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 59.
parser: Shift 'expr', go to state 36
parser: Reduce [setlist ::= nm EQ expr], go to state 128.
parser: Shift 'setlist', go to state 218
parser: Shift 'WHERE', go to state 65
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist WHERE]
parser: Input 'VARIABLE'
parser: Shift 'VARIABLE'
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist WHERE VARIABLE]
parser: Input 'AND'
parser: Reduce [expr ::= VARIABLE], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'AND', go to state 93
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist WHERE expr AND]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist WHERE expr AND ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 93.
parser: Shift 'expr', go to state 53
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist WHERE expr AND expr EQ]
parser: Input 'VARIABLE'
parser: Shift 'VARIABLE'
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist WHERE expr AND expr EQ VARIABLE]
parser: Input 'SEMI'
parser: Reduce [expr ::= VARIABLE], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 93.
parser: Shift 'expr', go to state 53
parser: Reduce [expr ::= expr AND expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Reduce [where_opt ::= WHERE expr], go to state 218.
parser: Shift 'where_opt'
parser: Reduce [cmd ::= with UPDATE orconf fullname indexed_opt SET setlist where_opt], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Input '$'
parser: Reduce [ecmd ::= explain cmdx SEMI], go to state 0.
parser: Shift 'ecmd'
parser: Reduce [cmdlist ::= ecmd], go to state 0.
parser: Shift 'cmdlist', go to state 146
parser: Reduce [input ::= cmdlist], go to state 0.
parser: Accept!
parser: Popping $
parser: Return. Stack=]
parser: Initialize. Empty stack. State 0
parser: Input 'UPDATE'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'UPDATE', go to state 242
parser: Return. Stack=[explain with UPDATE]
parser: Input 'STRING'
parser: Reduce [orconf ::=], go to state 242.
parser: Shift 'orconf', go to state 129
parser: Shift 'STRING'
parser: Return. Stack=[explain with UPDATE orconf STRING]
parser: Input 'DOT'
parser: Reduce [nm ::= STRING], go to state 129.
parser: Shift 'nm', go to state 259
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[explain with UPDATE orconf nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with UPDATE orconf nm DOT ID]
parser: Input 'SET'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 259.
parser: Shift 'dbnm'
parser: Reduce [fullname ::= nm dbnm], go to state 129.
parser: Shift 'fullname', go to state 219
parser: Reduce [indexed_opt ::=], go to state 219.
parser: Shift 'indexed_opt', go to state 352
parser: Shift 'SET', go to state 128
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET ID]
parser: Input 'EQ'
parser: Reduce [nm ::= ID|INDEXED], go to state 128.
parser: Shift 'nm', go to state 360
parser: Shift 'EQ', go to state 59
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET nm EQ]
parser: Input 'INTEGER'
parser: Shift 'INTEGER'
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET nm EQ INTEGER]
parser: Input 'WHERE'
parser: Reduce [term ::= INTEGER|FLOAT|BLOB], go to state 59.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 59.
parser: Shift 'expr', go to state 36
parser: Reduce [setlist ::= nm EQ expr], go to state 128.
parser: Shift 'setlist', go to state 218
parser: Shift 'WHERE', go to state 65
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist WHERE]
parser: Input 'VARIABLE'
parser: Shift 'VARIABLE'
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist WHERE VARIABLE]
parser: Input 'AND'
parser: Reduce [expr ::= VARIABLE], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'AND', go to state 93
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist WHERE expr AND]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist WHERE expr AND ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 93.
parser: Shift 'expr', go to state 53
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist WHERE expr AND expr EQ]
parser: Input 'VARIABLE'
parser: Shift 'VARIABLE'
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist WHERE expr AND expr EQ VARIABLE]
parser: Input 'SEMI'
parser: Reduce [expr ::= VARIABLE], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 93.
parser: Shift 'expr', go to state 53
parser: Reduce [expr ::= expr AND expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Reduce [where_opt ::= WHERE expr], go to state 218.
parser: Shift 'where_opt'
parser: Reduce [cmd ::= with UPDATE orconf fullname indexed_opt SET setlist where_opt], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Input '$'
parser: Reduce [ecmd ::= explain cmdx SEMI], go to state 0.
parser: Shift 'ecmd'
parser: Reduce [cmdlist ::= ecmd], go to state 0.
parser: Shift 'cmdlist', go to state 146
parser: Reduce [input ::= cmdlist], go to state 0.
parser: Accept!
parser: Popping $
parser: Return. Stack=]
parser: Initialize. Empty stack. State 0
parser: Input 'UPDATE'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'UPDATE', go to state 242
parser: Return. Stack=[explain with UPDATE]
parser: Input 'STRING'
parser: Reduce [orconf ::=], go to state 242.
parser: Shift 'orconf', go to state 129
parser: Shift 'STRING'
parser: Return. Stack=[explain with UPDATE orconf STRING]
parser: Input 'DOT'
parser: Reduce [nm ::= STRING], go to state 129.
parser: Shift 'nm', go to state 259
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[explain with UPDATE orconf nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with UPDATE orconf nm DOT ID]
parser: Input 'SET'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 259.
parser: Shift 'dbnm'
parser: Reduce [fullname ::= nm dbnm], go to state 129.
parser: Shift 'fullname', go to state 219
parser: Reduce [indexed_opt ::=], go to state 219.
parser: Shift 'indexed_opt', go to state 352
parser: Shift 'SET', go to state 128
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET ID]
parser: Input 'EQ'
parser: Reduce [nm ::= ID|INDEXED], go to state 128.
parser: Shift 'nm', go to state 360
parser: Shift 'EQ', go to state 59
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET nm EQ]
parser: Input 'INTEGER'
parser: Shift 'INTEGER'
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET nm EQ INTEGER]
parser: Input 'WHERE'
parser: Reduce [term ::= INTEGER|FLOAT|BLOB], go to state 59.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 59.
parser: Shift 'expr', go to state 36
parser: Reduce [setlist ::= nm EQ expr], go to state 128.
parser: Shift 'setlist', go to state 218
parser: Shift 'WHERE', go to state 65
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist WHERE]
parser: Input 'VARIABLE'
parser: Shift 'VARIABLE'
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist WHERE VARIABLE]
parser: Input 'AND'
parser: Reduce [expr ::= VARIABLE], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'AND', go to state 93
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist WHERE expr AND]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist WHERE expr AND ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 93.
parser: Shift 'expr', go to state 53
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist WHERE expr AND expr EQ]
parser: Input 'VARIABLE'
parser: Shift 'VARIABLE'
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist WHERE expr AND expr EQ VARIABLE]
parser: Input 'SEMI'
parser: Reduce [expr ::= VARIABLE], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 93.
parser: Shift 'expr', go to state 53
parser: Reduce [expr ::= expr AND expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Reduce [where_opt ::= WHERE expr], go to state 218.
parser: Shift 'where_opt'
parser: Reduce [cmd ::= with UPDATE orconf fullname indexed_opt SET setlist where_opt], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Input '$'
parser: Reduce [ecmd ::= explain cmdx SEMI], go to state 0.
parser: Shift 'ecmd'
parser: Reduce [cmdlist ::= ecmd], go to state 0.
parser: Shift 'cmdlist', go to state 146
parser: Reduce [input ::= cmdlist], go to state 0.
parser: Accept!
parser: Popping $
parser: Return. Stack=]
parser: Initialize. Empty stack. State 0
parser: Input 'UPDATE'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'UPDATE', go to state 242
parser: Return. Stack=[explain with UPDATE]
parser: Input 'STRING'
parser: Reduce [orconf ::=], go to state 242.
parser: Shift 'orconf', go to state 129
parser: Shift 'STRING'
parser: Return. Stack=[explain with UPDATE orconf STRING]
parser: Input 'DOT'
parser: Reduce [nm ::= STRING], go to state 129.
parser: Shift 'nm', go to state 259
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[explain with UPDATE orconf nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with UPDATE orconf nm DOT ID]
parser: Input 'SET'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 259.
parser: Shift 'dbnm'
parser: Reduce [fullname ::= nm dbnm], go to state 129.
parser: Shift 'fullname', go to state 219
parser: Reduce [indexed_opt ::=], go to state 219.
parser: Shift 'indexed_opt', go to state 352
parser: Shift 'SET', go to state 128
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET ID]
parser: Input 'EQ'
parser: Reduce [nm ::= ID|INDEXED], go to state 128.
parser: Shift 'nm', go to state 360
parser: Shift 'EQ', go to state 59
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET nm EQ]
parser: Input 'INTEGER'
parser: Shift 'INTEGER'
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET nm EQ INTEGER]
parser: Input 'WHERE'
parser: Reduce [term ::= INTEGER|FLOAT|BLOB], go to state 59.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 59.
parser: Shift 'expr', go to state 36
parser: Reduce [setlist ::= nm EQ expr], go to state 128.
parser: Shift 'setlist', go to state 218
parser: Shift 'WHERE', go to state 65
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist WHERE]
parser: Input 'VARIABLE'
parser: Shift 'VARIABLE'
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist WHERE VARIABLE]
parser: Input 'AND'
parser: Reduce [expr ::= VARIABLE], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'AND', go to state 93
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist WHERE expr AND]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist WHERE expr AND ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 93.
parser: Shift 'expr', go to state 53
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist WHERE expr AND expr EQ]
parser: Input 'VARIABLE'
parser: Shift 'VARIABLE'
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist WHERE expr AND expr EQ VARIABLE]
parser: Input 'SEMI'
parser: Reduce [expr ::= VARIABLE], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 93.
parser: Shift 'expr', go to state 53
parser: Reduce [expr ::= expr AND expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Reduce [where_opt ::= WHERE expr], go to state 218.
parser: Shift 'where_opt'
parser: Reduce [cmd ::= with UPDATE orconf fullname indexed_opt SET setlist where_opt], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Input '$'
parser: Reduce [ecmd ::= explain cmdx SEMI], go to state 0.
parser: Shift 'ecmd'
parser: Reduce [cmdlist ::= ecmd], go to state 0.
parser: Shift 'cmdlist', go to state 146
parser: Reduce [input ::= cmdlist], go to state 0.
parser: Accept!
parser: Popping $
parser: Return. Stack=]
parser: Initialize. Empty stack. State 0
parser: Input 'UPDATE'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'UPDATE', go to state 242
parser: Return. Stack=[explain with UPDATE]
parser: Input 'STRING'
parser: Reduce [orconf ::=], go to state 242.
parser: Shift 'orconf', go to state 129
parser: Shift 'STRING'
parser: Return. Stack=[explain with UPDATE orconf STRING]
parser: Input 'DOT'
parser: Reduce [nm ::= STRING], go to state 129.
parser: Shift 'nm', go to state 259
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[explain with UPDATE orconf nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with UPDATE orconf nm DOT ID]
parser: Input 'SET'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 259.
parser: Shift 'dbnm'
parser: Reduce [fullname ::= nm dbnm], go to state 129.
parser: Shift 'fullname', go to state 219
parser: Reduce [indexed_opt ::=], go to state 219.
parser: Shift 'indexed_opt', go to state 352
parser: Shift 'SET', go to state 128
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET ID]
parser: Input 'EQ'
parser: Reduce [nm ::= ID|INDEXED], go to state 128.
parser: Shift 'nm', go to state 360
parser: Shift 'EQ', go to state 59
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET nm EQ]
parser: Input 'INTEGER'
parser: Shift 'INTEGER'
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET nm EQ INTEGER]
parser: Input 'WHERE'
parser: Reduce [term ::= INTEGER|FLOAT|BLOB], go to state 59.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 59.
parser: Shift 'expr', go to state 36
parser: Reduce [setlist ::= nm EQ expr], go to state 128.
parser: Shift 'setlist', go to state 218
parser: Shift 'WHERE', go to state 65
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist WHERE]
parser: Input 'VARIABLE'
parser: Shift 'VARIABLE'
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist WHERE VARIABLE]
parser: Input 'AND'
parser: Reduce [expr ::= VARIABLE], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'AND', go to state 93
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist WHERE expr AND]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist WHERE expr AND ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 93.
parser: Shift 'expr', go to state 53
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist WHERE expr AND expr EQ]
parser: Input 'VARIABLE'
parser: Shift 'VARIABLE'
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist WHERE expr AND expr EQ VARIABLE]
parser: Input 'SEMI'
parser: Reduce [expr ::= VARIABLE], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 93.
parser: Shift 'expr', go to state 53
parser: Reduce [expr ::= expr AND expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Reduce [where_opt ::= WHERE expr], go to state 218.
parser: Shift 'where_opt'
parser: Reduce [cmd ::= with UPDATE orconf fullname indexed_opt SET setlist where_opt], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Input '$'
parser: Reduce [ecmd ::= explain cmdx SEMI], go to state 0.
parser: Shift 'ecmd'
parser: Reduce [cmdlist ::= ecmd], go to state 0.
parser: Shift 'cmdlist', go to state 146
parser: Reduce [input ::= cmdlist], go to state 0.
parser: Accept!
parser: Popping $
parser: Return. Stack=]
parser: Initialize. Empty stack. State 0
parser: Input 'UPDATE'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'UPDATE', go to state 242
parser: Return. Stack=[explain with UPDATE]
parser: Input 'STRING'
parser: Reduce [orconf ::=], go to state 242.
parser: Shift 'orconf', go to state 129
parser: Shift 'STRING'
parser: Return. Stack=[explain with UPDATE orconf STRING]
parser: Input 'DOT'
parser: Reduce [nm ::= STRING], go to state 129.
parser: Shift 'nm', go to state 259
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[explain with UPDATE orconf nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with UPDATE orconf nm DOT ID]
parser: Input 'SET'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 259.
parser: Shift 'dbnm'
parser: Reduce [fullname ::= nm dbnm], go to state 129.
parser: Shift 'fullname', go to state 219
parser: Reduce [indexed_opt ::=], go to state 219.
parser: Shift 'indexed_opt', go to state 352
parser: Shift 'SET', go to state 128
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET ID]
parser: Input 'EQ'
parser: Reduce [nm ::= ID|INDEXED], go to state 128.
parser: Shift 'nm', go to state 360
parser: Shift 'EQ', go to state 59
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET nm EQ]
parser: Input 'INTEGER'
parser: Shift 'INTEGER'
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET nm EQ INTEGER]
parser: Input 'WHERE'
parser: Reduce [term ::= INTEGER|FLOAT|BLOB], go to state 59.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 59.
parser: Shift 'expr', go to state 36
parser: Reduce [setlist ::= nm EQ expr], go to state 128.
parser: Shift 'setlist', go to state 218
parser: Shift 'WHERE', go to state 65
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist WHERE]
parser: Input 'VARIABLE'
parser: Shift 'VARIABLE'
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist WHERE VARIABLE]
parser: Input 'AND'
parser: Reduce [expr ::= VARIABLE], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'AND', go to state 93
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist WHERE expr AND]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist WHERE expr AND ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 93.
parser: Shift 'expr', go to state 53
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist WHERE expr AND expr EQ]
parser: Input 'VARIABLE'
parser: Shift 'VARIABLE'
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist WHERE expr AND expr EQ VARIABLE]
parser: Input 'SEMI'
parser: Reduce [expr ::= VARIABLE], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 93.
parser: Shift 'expr', go to state 53
parser: Reduce [expr ::= expr AND expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Reduce [where_opt ::= WHERE expr], go to state 218.
parser: Shift 'where_opt'
parser: Reduce [cmd ::= with UPDATE orconf fullname indexed_opt SET setlist where_opt], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Input '$'
parser: Reduce [ecmd ::= explain cmdx SEMI], go to state 0.
parser: Shift 'ecmd'
parser: Reduce [cmdlist ::= ecmd], go to state 0.
parser: Shift 'cmdlist', go to state 146
parser: Reduce [input ::= cmdlist], go to state 0.
parser: Accept!
parser: Popping $
parser: Return. Stack=]
parser: Initialize. Empty stack. State 0
parser: Input 'UPDATE'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'UPDATE', go to state 242
parser: Return. Stack=[explain with UPDATE]
parser: Input 'STRING'
parser: Reduce [orconf ::=], go to state 242.
parser: Shift 'orconf', go to state 129
parser: Shift 'STRING'
parser: Return. Stack=[explain with UPDATE orconf STRING]
parser: Input 'DOT'
parser: Reduce [nm ::= STRING], go to state 129.
parser: Shift 'nm', go to state 259
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[explain with UPDATE orconf nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with UPDATE orconf nm DOT ID]
parser: Input 'SET'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 259.
parser: Shift 'dbnm'
parser: Reduce [fullname ::= nm dbnm], go to state 129.
parser: Shift 'fullname', go to state 219
parser: Reduce [indexed_opt ::=], go to state 219.
parser: Shift 'indexed_opt', go to state 352
parser: Shift 'SET', go to state 128
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET ID]
parser: Input 'EQ'
parser: Reduce [nm ::= ID|INDEXED], go to state 128.
parser: Shift 'nm', go to state 360
parser: Shift 'EQ', go to state 59
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET nm EQ]
parser: Input 'INTEGER'
parser: Shift 'INTEGER'
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET nm EQ INTEGER]
parser: Input 'WHERE'
parser: Reduce [term ::= INTEGER|FLOAT|BLOB], go to state 59.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 59.
parser: Shift 'expr', go to state 36
parser: Reduce [setlist ::= nm EQ expr], go to state 128.
parser: Shift 'setlist', go to state 218
parser: Shift 'WHERE', go to state 65
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist WHERE]
parser: Input 'VARIABLE'
parser: Shift 'VARIABLE'
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist WHERE VARIABLE]
parser: Input 'AND'
parser: Reduce [expr ::= VARIABLE], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'AND', go to state 93
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist WHERE expr AND]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist WHERE expr AND ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 93.
parser: Shift 'expr', go to state 53
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist WHERE expr AND expr EQ]
parser: Input 'VARIABLE'
parser: Shift 'VARIABLE'
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist WHERE expr AND expr EQ VARIABLE]
parser: Input 'SEMI'
parser: Reduce [expr ::= VARIABLE], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 93.
parser: Shift 'expr', go to state 53
parser: Reduce [expr ::= expr AND expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Reduce [where_opt ::= WHERE expr], go to state 218.
parser: Shift 'where_opt'
parser: Reduce [cmd ::= with UPDATE orconf fullname indexed_opt SET setlist where_opt], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Input '$'
parser: Reduce [ecmd ::= explain cmdx SEMI], go to state 0.
parser: Shift 'ecmd'
parser: Reduce [cmdlist ::= ecmd], go to state 0.
parser: Shift 'cmdlist', go to state 146
parser: Reduce [input ::= cmdlist], go to state 0.
parser: Accept!
parser: Popping $
parser: Return. Stack=]
parser: Initialize. Empty stack. State 0
parser: Input 'UPDATE'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'UPDATE', go to state 242
parser: Return. Stack=[explain with UPDATE]
parser: Input 'STRING'
parser: Reduce [orconf ::=], go to state 242.
parser: Shift 'orconf', go to state 129
parser: Shift 'STRING'
parser: Return. Stack=[explain with UPDATE orconf STRING]
parser: Input 'DOT'
parser: Reduce [nm ::= STRING], go to state 129.
parser: Shift 'nm', go to state 259
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[explain with UPDATE orconf nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with UPDATE orconf nm DOT ID]
parser: Input 'SET'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 259.
parser: Shift 'dbnm'
parser: Reduce [fullname ::= nm dbnm], go to state 129.
parser: Shift 'fullname', go to state 219
parser: Reduce [indexed_opt ::=], go to state 219.
parser: Shift 'indexed_opt', go to state 352
parser: Shift 'SET', go to state 128
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET ID]
parser: Input 'EQ'
parser: Reduce [nm ::= ID|INDEXED], go to state 128.
parser: Shift 'nm', go to state 360
parser: Shift 'EQ', go to state 59
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET nm EQ]
parser: Input 'INTEGER'
parser: Shift 'INTEGER'
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET nm EQ INTEGER]
parser: Input 'WHERE'
parser: Reduce [term ::= INTEGER|FLOAT|BLOB], go to state 59.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 59.
parser: Shift 'expr', go to state 36
parser: Reduce [setlist ::= nm EQ expr], go to state 128.
parser: Shift 'setlist', go to state 218
parser: Shift 'WHERE', go to state 65
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist WHERE]
parser: Input 'VARIABLE'
parser: Shift 'VARIABLE'
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist WHERE VARIABLE]
parser: Input 'AND'
parser: Reduce [expr ::= VARIABLE], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'AND', go to state 93
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist WHERE expr AND]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist WHERE expr AND ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 93.
parser: Shift 'expr', go to state 53
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist WHERE expr AND expr EQ]
parser: Input 'VARIABLE'
parser: Shift 'VARIABLE'
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist WHERE expr AND expr EQ VARIABLE]
parser: Input 'SEMI'
parser: Reduce [expr ::= VARIABLE], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 93.
parser: Shift 'expr', go to state 53
parser: Reduce [expr ::= expr AND expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Reduce [where_opt ::= WHERE expr], go to state 218.
parser: Shift 'where_opt'
parser: Reduce [cmd ::= with UPDATE orconf fullname indexed_opt SET setlist where_opt], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Input '$'
parser: Reduce [ecmd ::= explain cmdx SEMI], go to state 0.
parser: Shift 'ecmd'
parser: Reduce [cmdlist ::= ecmd], go to state 0.
parser: Shift 'cmdlist', go to state 146
parser: Reduce [input ::= cmdlist], go to state 0.
parser: Accept!
parser: Popping $
parser: Return. Stack=]
parser: Initialize. Empty stack. State 0
parser: Input 'UPDATE'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'UPDATE', go to state 242
parser: Return. Stack=[explain with UPDATE]
parser: Input 'STRING'
parser: Reduce [orconf ::=], go to state 242.
parser: Shift 'orconf', go to state 129
parser: Shift 'STRING'
parser: Return. Stack=[explain with UPDATE orconf STRING]
parser: Input 'DOT'
parser: Reduce [nm ::= STRING], go to state 129.
parser: Shift 'nm', go to state 259
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[explain with UPDATE orconf nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with UPDATE orconf nm DOT ID]
parser: Input 'SET'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 259.
parser: Shift 'dbnm'
parser: Reduce [fullname ::= nm dbnm], go to state 129.
parser: Shift 'fullname', go to state 219
parser: Reduce [indexed_opt ::=], go to state 219.
parser: Shift 'indexed_opt', go to state 352
parser: Shift 'SET', go to state 128
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET ID]
parser: Input 'EQ'
parser: Reduce [nm ::= ID|INDEXED], go to state 128.
parser: Shift 'nm', go to state 360
parser: Shift 'EQ', go to state 59
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET nm EQ]
parser: Input 'INTEGER'
parser: Shift 'INTEGER'
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET nm EQ INTEGER]
parser: Input 'WHERE'
parser: Reduce [term ::= INTEGER|FLOAT|BLOB], go to state 59.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 59.
parser: Shift 'expr', go to state 36
parser: Reduce [setlist ::= nm EQ expr], go to state 128.
parser: Shift 'setlist', go to state 218
parser: Shift 'WHERE', go to state 65
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist WHERE]
parser: Input 'VARIABLE'
parser: Shift 'VARIABLE'
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist WHERE VARIABLE]
parser: Input 'AND'
parser: Reduce [expr ::= VARIABLE], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'AND', go to state 93
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist WHERE expr AND]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist WHERE expr AND ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 93.
parser: Shift 'expr', go to state 53
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist WHERE expr AND expr EQ]
parser: Input 'VARIABLE'
parser: Shift 'VARIABLE'
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist WHERE expr AND expr EQ VARIABLE]
parser: Input 'SEMI'
parser: Reduce [expr ::= VARIABLE], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 93.
parser: Shift 'expr', go to state 53
parser: Reduce [expr ::= expr AND expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Reduce [where_opt ::= WHERE expr], go to state 218.
parser: Shift 'where_opt'
parser: Reduce [cmd ::= with UPDATE orconf fullname indexed_opt SET setlist where_opt], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Input '$'
parser: Reduce [ecmd ::= explain cmdx SEMI], go to state 0.
parser: Shift 'ecmd'
parser: Reduce [cmdlist ::= ecmd], go to state 0.
parser: Shift 'cmdlist', go to state 146
parser: Reduce [input ::= cmdlist], go to state 0.
parser: Accept!
parser: Popping $
parser: Return. Stack=]
parser: Initialize. Empty stack. State 0
parser: Input 'UPDATE'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'UPDATE', go to state 242
parser: Return. Stack=[explain with UPDATE]
parser: Input 'STRING'
parser: Reduce [orconf ::=], go to state 242.
parser: Shift 'orconf', go to state 129
parser: Shift 'STRING'
parser: Return. Stack=[explain with UPDATE orconf STRING]
parser: Input 'DOT'
parser: Reduce [nm ::= STRING], go to state 129.
parser: Shift 'nm', go to state 259
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[explain with UPDATE orconf nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with UPDATE orconf nm DOT ID]
parser: Input 'SET'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 259.
parser: Shift 'dbnm'
parser: Reduce [fullname ::= nm dbnm], go to state 129.
parser: Shift 'fullname', go to state 219
parser: Reduce [indexed_opt ::=], go to state 219.
parser: Shift 'indexed_opt', go to state 352
parser: Shift 'SET', go to state 128
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET ID]
parser: Input 'EQ'
parser: Reduce [nm ::= ID|INDEXED], go to state 128.
parser: Shift 'nm', go to state 360
parser: Shift 'EQ', go to state 59
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET nm EQ]
parser: Input 'INTEGER'
parser: Shift 'INTEGER'
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET nm EQ INTEGER]
parser: Input 'WHERE'
parser: Reduce [term ::= INTEGER|FLOAT|BLOB], go to state 59.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 59.
parser: Shift 'expr', go to state 36
parser: Reduce [setlist ::= nm EQ expr], go to state 128.
parser: Shift 'setlist', go to state 218
parser: Shift 'WHERE', go to state 65
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist WHERE]
parser: Input 'VARIABLE'
parser: Shift 'VARIABLE'
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist WHERE VARIABLE]
parser: Input 'AND'
parser: Reduce [expr ::= VARIABLE], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'AND', go to state 93
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist WHERE expr AND]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist WHERE expr AND ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 93.
parser: Shift 'expr', go to state 53
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist WHERE expr AND expr EQ]
parser: Input 'VARIABLE'
parser: Shift 'VARIABLE'
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist WHERE expr AND expr EQ VARIABLE]
parser: Input 'SEMI'
parser: Reduce [expr ::= VARIABLE], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 93.
parser: Shift 'expr', go to state 53
parser: Reduce [expr ::= expr AND expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Reduce [where_opt ::= WHERE expr], go to state 218.
parser: Shift 'where_opt'
parser: Reduce [cmd ::= with UPDATE orconf fullname indexed_opt SET setlist where_opt], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Input '$'
parser: Reduce [ecmd ::= explain cmdx SEMI], go to state 0.
parser: Shift 'ecmd'
parser: Reduce [cmdlist ::= ecmd], go to state 0.
parser: Shift 'cmdlist', go to state 146
parser: Reduce [input ::= cmdlist], go to state 0.
parser: Accept!
parser: Popping $
parser: Return. Stack=]
parser: Initialize. Empty stack. State 0
parser: Input 'UPDATE'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'UPDATE', go to state 242
parser: Return. Stack=[explain with UPDATE]
parser: Input 'STRING'
parser: Reduce [orconf ::=], go to state 242.
parser: Shift 'orconf', go to state 129
parser: Shift 'STRING'
parser: Return. Stack=[explain with UPDATE orconf STRING]
parser: Input 'DOT'
parser: Reduce [nm ::= STRING], go to state 129.
parser: Shift 'nm', go to state 259
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[explain with UPDATE orconf nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with UPDATE orconf nm DOT ID]
parser: Input 'SET'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 259.
parser: Shift 'dbnm'
parser: Reduce [fullname ::= nm dbnm], go to state 129.
parser: Shift 'fullname', go to state 219
parser: Reduce [indexed_opt ::=], go to state 219.
parser: Shift 'indexed_opt', go to state 352
parser: Shift 'SET', go to state 128
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET ID]
parser: Input 'EQ'
parser: Reduce [nm ::= ID|INDEXED], go to state 128.
parser: Shift 'nm', go to state 360
parser: Shift 'EQ', go to state 59
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET nm EQ]
parser: Input 'INTEGER'
parser: Shift 'INTEGER'
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET nm EQ INTEGER]
parser: Input 'WHERE'
parser: Reduce [term ::= INTEGER|FLOAT|BLOB], go to state 59.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 59.
parser: Shift 'expr', go to state 36
parser: Reduce [setlist ::= nm EQ expr], go to state 128.
parser: Shift 'setlist', go to state 218
parser: Shift 'WHERE', go to state 65
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist WHERE]
parser: Input 'VARIABLE'
parser: Shift 'VARIABLE'
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist WHERE VARIABLE]
parser: Input 'AND'
parser: Reduce [expr ::= VARIABLE], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'AND', go to state 93
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist WHERE expr AND]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist WHERE expr AND ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 93.
parser: Shift 'expr', go to state 53
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist WHERE expr AND expr EQ]
parser: Input 'VARIABLE'
parser: Shift 'VARIABLE'
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist WHERE expr AND expr EQ VARIABLE]
parser: Input 'SEMI'
parser: Reduce [expr ::= VARIABLE], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 93.
parser: Shift 'expr', go to state 53
parser: Reduce [expr ::= expr AND expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Reduce [where_opt ::= WHERE expr], go to state 218.
parser: Shift 'where_opt'
parser: Reduce [cmd ::= with UPDATE orconf fullname indexed_opt SET setlist where_opt], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Input '$'
parser: Reduce [ecmd ::= explain cmdx SEMI], go to state 0.
parser: Shift 'ecmd'
parser: Reduce [cmdlist ::= ecmd], go to state 0.
parser: Shift 'cmdlist', go to state 146
parser: Reduce [input ::= cmdlist], go to state 0.
parser: Accept!
parser: Popping $
parser: Return. Stack=]
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[cmdlist explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping cmdlist
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'CREATE'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Shift 'CREATE'
parser: Return. Stack=[explain CREATE]
parser: Input 'TABLE'
parser: Reduce [createkw ::= CREATE], go to state 2.
parser: Shift 'createkw', go to state 107
parser: Reduce [temp ::=], go to state 107.
parser: Shift 'temp', go to state 319
parser: Shift 'TABLE', go to state 266
parser: Return. Stack=[explain createkw temp TABLE]
parser: Input 'ID'
parser: Reduce [ifnotexists ::=], go to state 266.
parser: Shift 'ifnotexists', go to state 183
parser: Shift 'ID'
parser: Return. Stack=[explain createkw temp TABLE ifnotexists ID]
parser: Input 'LP'
parser: Reduce [nm ::= ID|INDEXED], go to state 183.
parser: Shift 'nm', go to state 265
parser: Reduce [dbnm ::=], go to state 265.
parser: Shift 'dbnm'
parser: Reduce [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 2.
parser: Shift 'create_table', go to state 234
parser: Shift 'LP', go to state 111
parser: Return. Stack=[explain create_table LP]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP ID]
parser: Input 'PRIMARY'
parser: Reduce [nm ::= ID|INDEXED], go to state 111.
parser: Shift 'nm', go to state 148
parser: Reduce [typetoken ::=], go to state 148.
parser: Shift 'typetoken'
parser: Reduce [columnname ::= nm typetoken], go to state 111.
parser: Shift 'columnname', go to state 311
parser: Reduce [carglist ::=], go to state 311.
parser: Shift 'carglist', go to state 119
parser: Shift 'PRIMARY', go to state 391
parser: Return. Stack=[explain create_table LP columnname carglist PRIMARY]
parser: Input 'KEY'
parser: Shift 'KEY', go to state 227
parser: Return. Stack=[explain create_table LP columnname carglist PRIMARY KEY]
parser: Input 'COMMA'
parser: Reduce [sortorder ::=], go to state 227.
parser: Shift 'sortorder', go to state 275
parser: Reduce [onconf ::=], go to state 275.
parser: Shift 'onconf', go to state 274
parser: Reduce [autoinc ::=], go to state 274.
parser: Shift 'autoinc'
parser: Reduce [ccons ::= PRIMARY KEY sortorder onconf autoinc], go to state 119.
parser: Initialize. Empty stack. State 0
parser: Input 'INSERT'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'INSERT', go to state 253
parser: Return. Stack=[explain with INSERT]
parser: Input 'INTO'
parser: Reduce [orconf ::=], go to state 253.
parser: Shift 'orconf'
parser: Reduce [insert_cmd ::= INSERT orconf], go to state 22.
parser: Shift 'insert_cmd', go to state 351
parser: Shift 'INTO', go to state 127
parser: Return. Stack=[explain with insert_cmd INTO]
parser: Input 'STRING'
parser: Shift 'STRING'
parser: Return. Stack=[explain with insert_cmd INTO STRING]
parser: Input 'DOT'
parser: Reduce [nm ::= STRING], go to state 127.
parser: Shift 'nm', go to state 259
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[explain with insert_cmd INTO nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with insert_cmd INTO nm DOT ID]
parser: Input 'VALUES'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 259.
parser: Shift 'dbnm'
parser: Reduce [fullname ::= nm dbnm], go to state 127.
parser: Shift 'fullname', go to state 241
parser: Reduce [idlist_opt ::=], go to state 241.
parser: Shift 'idlist_opt', go to state 147
parser: Reduce [with ::=], go to state 147.
parser: Shift 'with', go to state 113
parser: Shift 'VALUES', go to state 397
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES]
parser: Input 'LP'
parser: Shift 'LP', go to state 15
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP STRING]
parser: Input 'COMMA'
parser: Reduce [term ::= STRING], go to state 15.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 15.
parser: Shift 'expr', go to state 48
parser: Reduce [nexprlist ::= expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'COMMA', go to state 70
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA STRING]
parser: Input 'COMMA'
parser: Reduce [term ::= STRING], go to state 70.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 70.
parser: Shift 'expr', go to state 43
parser: Reduce [nexprlist ::= nexprlist COMMA expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'COMMA', go to state 70
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA STRING]
parser: Input 'COMMA'
parser: Reduce [term ::= STRING], go to state 70.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 70.
parser: Shift 'expr', go to state 43
parser: Reduce [nexprlist ::= nexprlist COMMA expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'COMMA', go to state 70
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA]
parser: Input 'VARIABLE'
parser: Shift 'VARIABLE'
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA VARIABLE]
parser: Input 'COMMA'
parser: Reduce [expr ::= VARIABLE], go to state 70.
parser: Shift 'expr', go to state 43
parser: Reduce [nexprlist ::= nexprlist COMMA expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'COMMA', go to state 70
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA]
parser: Input 'NULL'
parser: Shift 'NULL'
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA NULL]
parser: Input 'RP'
parser: Reduce [term ::= NULL], go to state 70.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 70.
parser: Shift 'expr', go to state 43
parser: Reduce [nexprlist ::= nexprlist COMMA expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'RP'
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist RP]
parser: Input 'SEMI'
parser: Reduce [values ::= VALUES LP nexprlist RP], go to state 113.
parser: Shift 'values', go to state 400
parser: Reduce [oneselect ::= values], go to state 113.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 113.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 147.
parser: Shift 'select'
parser: Reduce [cmd ::= with insert_cmd INTO fullname idlist_opt select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Input '$'
parser: Reduce [ecmd ::= explain cmdx SEMI], go to state 0.
parser: Shift 'ecmd'
parser: Reduce [cmdlist ::= ecmd], go to state 0.
parser: Shift 'cmdlist', go to state 146
parser: Reduce [input ::= cmdlist], go to state 0.
parser: Accept!
parser: Popping $
parser: Return. Stack=]
parser: Shift 'ccons'
parser: Reduce [carglist ::= carglist ccons], go to state 311.
parser: Shift 'carglist', go to state 119
parser: Reduce [columnlist ::= columnname carglist], go to state 111.
parser: Shift 'columnlist', go to state 300
parser: Shift 'COMMA', go to state 21
parser: Return. Stack=[explain create_table LP columnlist COMMA]
parser: Input 'UNIQUE'
parser: Shift 'UNIQUE', go to state 385
parser: Return. Stack=[explain create_table LP columnlist COMMA UNIQUE]
parser: Input 'LP'
parser: Shift 'LP', go to state 13
parser: Return. Stack=[explain create_table LP columnlist COMMA UNIQUE LP]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain create_table LP columnlist COMMA UNIQUE LP ID]
parser: Input 'RP'
parser: Reduce [expr ::= ID|INDEXED], go to state 13.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 13.
parser: Shift 'sortlist', go to state 327
parser: Shift 'RP', go to state 269
parser: Return. Stack=[explain create_table LP columnlist COMMA UNIQUE LP sortlist RP]
parser: Input 'RP'
parser: Reduce [onconf ::=], go to state 269.
parser: Shift 'onconf'
parser: Reduce [tcons ::= UNIQUE LP sortlist RP onconf], go to state 21.
parser: Shift 'tcons'
parser: Reduce [conslist ::= tcons], go to state 21.
parser: Shift 'conslist', go to state 225
parser: Reduce [conslist_opt ::= COMMA conslist], go to state 300.
parser: Shift 'conslist_opt', go to state 437
parser: Shift 'RP', go to state 299
parser: Return. Stack=[explain create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI'
parser: Reduce [table_options ::=], go to state 299.
parser: Shift 'table_options'
parser: Reduce [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 234.
parser: Initialize. Empty stack. State 0
parser: Input 'UPDATE'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'UPDATE', go to state 242
parser: Return. Stack=[explain with UPDATE]
parser: Input 'STRING'
parser: Reduce [orconf ::=], go to state 242.
parser: Shift 'orconf', go to state 129
parser: Shift 'STRING'
parser: Return. Stack=[explain with UPDATE orconf STRING]
parser: Input 'DOT'
parser: Reduce [nm ::= STRING], go to state 129.
parser: Shift 'nm', go to state 259
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[explain with UPDATE orconf nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with UPDATE orconf nm DOT ID]
parser: Input 'SET'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 259.
parser: Shift 'dbnm'
parser: Reduce [fullname ::= nm dbnm], go to state 129.
parser: Shift 'fullname', go to state 219
parser: Reduce [indexed_opt ::=], go to state 219.
parser: Shift 'indexed_opt', go to state 352
parser: Shift 'SET', go to state 128
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET ID]
parser: Input 'EQ'
parser: Reduce [nm ::= ID|INDEXED], go to state 128.
parser: Shift 'nm', go to state 360
parser: Shift 'EQ', go to state 59
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET nm EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET nm EQ STRING]
parser: Input 'COMMA'
parser: Reduce [term ::= STRING], go to state 59.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 59.
parser: Shift 'expr', go to state 36
parser: Reduce [setlist ::= nm EQ expr], go to state 128.
parser: Shift 'setlist', go to state 218
parser: Shift 'COMMA', go to state 176
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist COMMA]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ'
parser: Reduce [nm ::= ID|INDEXED], go to state 176.
parser: Shift 'nm', go to state 361
parser: Shift 'EQ', go to state 60
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'COMMA'
parser: Reduce [term ::= STRING], go to state 60.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 60.
parser: Shift 'expr', go to state 37
parser: Reduce [setlist ::= setlist COMMA nm EQ expr], go to state 128.
parser: Shift 'setlist', go to state 218
parser: Shift 'COMMA', go to state 176
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist COMMA]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ'
parser: Reduce [nm ::= ID|INDEXED], go to state 176.
parser: Shift 'nm', go to state 361
parser: Shift 'EQ', go to state 60
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'COMMA'
parser: Reduce [term ::= STRING], go to state 60.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 60.
parser: Shift 'expr', go to state 37
parser: Reduce [setlist ::= setlist COMMA nm EQ expr], go to state 128.
parser: Shift 'setlist', go to state 218
parser: Shift 'COMMA', go to state 176
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist COMMA]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ'
parser: Reduce [nm ::= ID|INDEXED], go to state 176.
parser: Shift 'nm', go to state 361
parser: Shift 'EQ', go to state 60
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'VARIABLE'
parser: Shift 'VARIABLE'
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist COMMA nm EQ VARIABLE]
parser: Input 'COMMA'
parser: Reduce [expr ::= VARIABLE], go to state 60.
parser: Shift 'expr', go to state 37
parser: Reduce [setlist ::= setlist COMMA nm EQ expr], go to state 128.
parser: Shift 'setlist', go to state 218
parser: Shift 'COMMA', go to state 176
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist COMMA]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ'
parser: Reduce [nm ::= ID|INDEXED], go to state 176.
parser: Shift 'nm', go to state 361
parser: Shift 'EQ', go to state 60
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'WHERE'
parser: Reduce [term ::= STRING], go to state 60.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 60.
parser: Shift 'expr', go to state 37
parser: Reduce [setlist ::= setlist COMMA nm EQ expr], go to state 128.
parser: Shift 'setlist', go to state 218
parser: Shift 'WHERE', go to state 65
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist WHERE]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist WHERE ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist WHERE expr EQ]
parser: Input 'VARIABLE'
parser: Shift 'VARIABLE'
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist WHERE expr EQ VARIABLE]
parser: Input 'SEMI'
parser: Reduce [expr ::= VARIABLE], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Reduce [where_opt ::= WHERE expr], go to state 218.
parser: Shift 'where_opt'
parser: Reduce [cmd ::= with UPDATE orconf fullname indexed_opt SET setlist where_opt], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Input '$'
parser: Reduce [ecmd ::= explain cmdx SEMI], go to state 0.
parser: Shift 'ecmd'
parser: Reduce [cmdlist ::= ecmd], go to state 0.
parser: Shift 'cmdlist', go to state 146
parser: Reduce [input ::= cmdlist], go to state 0.
parser: Accept!
parser: Popping $
parser: Return. Stack=]
parser: Shift 'create_table_args'
parser: Reduce [cmd ::= create_table create_table_args], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'SELECT'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[explain with SELECT]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'FROM'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[explain with SELECT distinct selcollist FROM]
parser: Input 'STRING'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'STRING'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix STRING]
parser: Input 'DOT'
parser: Reduce [nm ::= STRING], go to state 165.
parser: Shift 'nm', go to state 287
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Shift 'WHERE', go to state 65
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'AND', go to state 93
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'NE'
parser: Reduce [expr ::= ID|INDEXED], go to state 93.
parser: Shift 'expr', go to state 53
parser: Shift 'NE', go to state 90
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND expr NE]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND expr NE STRING]
parser: Input 'ORDER'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 93.
parser: Shift 'expr', go to state 53
parser: Reduce [expr ::= expr AND expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Reduce [where_opt ::= WHERE expr], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Shift 'ORDER', go to state 411
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY'
parser: Shift 'BY', go to state 17
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI'
parser: Reduce [expr ::= ID|INDEXED], go to state 17.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 17.
parser: Shift 'sortlist', go to state 410
parser: Reduce [orderby_opt ::= ORDER BY sortlist], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 22.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 2.
parser: Shift 'select'
parser: Reduce [cmd ::= select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'CREATE'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Shift 'CREATE'
parser: Return. Stack=[explain CREATE]
parser: Input 'TABLE'
parser: Reduce [createkw ::= CREATE], go to state 2.
parser: Shift 'createkw', go to state 107
parser: Reduce [temp ::=], go to state 107.
parser: Shift 'temp', go to state 319
parser: Shift 'TABLE', go to state 266
parser: Return. Stack=[explain createkw temp TABLE]
parser: Input 'ID'
parser: Reduce [ifnotexists ::=], go to state 266.
parser: Shift 'ifnotexists', go to state 183
parser: Shift 'ID'
parser: Return. Stack=[explain createkw temp TABLE ifnotexists ID]
parser: Input 'LP'
parser: Reduce [nm ::= ID|INDEXED], go to state 183.
parser: Shift 'nm', go to state 265
parser: Reduce [dbnm ::=], go to state 265.
parser: Shift 'dbnm'
parser: Reduce [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 2.
parser: Shift 'create_table', go to state 234
parser: Shift 'LP', go to state 111
parser: Return. Stack=[explain create_table LP]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP ID]
parser: Input 'PRIMARY'
parser: Reduce [nm ::= ID|INDEXED], go to state 111.
parser: Shift 'nm', go to state 148
parser: Reduce [typetoken ::=], go to state 148.
parser: Shift 'typetoken'
parser: Reduce [columnname ::= nm typetoken], go to state 111.
parser: Shift 'columnname', go to state 311
parser: Reduce [carglist ::=], go to state 311.
parser: Shift 'carglist', go to state 119
parser: Shift 'PRIMARY', go to state 391
parser: Return. Stack=[explain create_table LP columnname carglist PRIMARY]
parser: Input 'KEY'
parser: Shift 'KEY', go to state 227
parser: Return. Stack=[explain create_table LP columnname carglist PRIMARY KEY]
parser: Input 'COMMA'
parser: Reduce [sortorder ::=], go to state 227.
parser: Shift 'sortorder', go to state 275
parser: Reduce [onconf ::=], go to state 275.
parser: Shift 'onconf', go to state 274
parser: Reduce [autoinc ::=], go to state 274.
parser: Shift 'autoinc'
parser: Reduce [ccons ::= PRIMARY KEY sortorder onconf autoinc], go to state 119.
parser: Shift 'ccons'
parser: Reduce [carglist ::= carglist ccons], go to state 311.
parser: Shift 'carglist', go to state 119
parser: Reduce [columnlist ::= columnname carglist], go to state 111.
parser: Shift 'columnlist', go to state 300
parser: Shift 'COMMA', go to state 21
parser: Return. Stack=[explain create_table LP columnlist COMMA]
parser: Input 'UNIQUE'
parser: Shift 'UNIQUE', go to state 385
parser: Return. Stack=[explain create_table LP columnlist COMMA UNIQUE]
parser: Input 'LP'
parser: Shift 'LP', go to state 13
parser: Return. Stack=[explain create_table LP columnlist COMMA UNIQUE LP]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain create_table LP columnlist COMMA UNIQUE LP ID]
parser: Input 'RP'
parser: Reduce [expr ::= ID|INDEXED], go to state 13.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 13.
parser: Shift 'sortlist', go to state 327
parser: Shift 'RP', go to state 269
parser: Return. Stack=[explain create_table LP columnlist COMMA UNIQUE LP sortlist RP]
parser: Input 'RP'
parser: Reduce [onconf ::=], go to state 269.
parser: Shift 'onconf'
parser: Reduce [tcons ::= UNIQUE LP sortlist RP onconf], go to state 21.
parser: Shift 'tcons'
parser: Reduce [conslist ::= tcons], go to state 21.
parser: Shift 'conslist', go to state 225
parser: Reduce [conslist_opt ::= COMMA conslist], go to state 300.
parser: Shift 'conslist_opt', go to state 437
parser: Shift 'RP', go to state 299
parser: Return. Stack=[explain create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI'
parser: Reduce [table_options ::=], go to state 299.
parser: Shift 'table_options'
parser: Reduce [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 234.
parser: Shift 'create_table_args'
parser: Reduce [cmd ::= create_table create_table_args], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'INSERT'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'INSERT', go to state 253
parser: Return. Stack=[explain with INSERT]
parser: Input 'INTO'
parser: Reduce [orconf ::=], go to state 253.
parser: Shift 'orconf'
parser: Reduce [insert_cmd ::= INSERT orconf], go to state 22.
parser: Shift 'insert_cmd', go to state 351
parser: Shift 'INTO', go to state 127
parser: Return. Stack=[explain with insert_cmd INTO]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with insert_cmd INTO ID]
parser: Input 'VALUES'
parser: Reduce [nm ::= ID|INDEXED], go to state 127.
parser: Shift 'nm', go to state 259
parser: Reduce [dbnm ::=], go to state 259.
parser: Shift 'dbnm'
parser: Reduce [fullname ::= nm dbnm], go to state 127.
parser: Shift 'fullname', go to state 241
parser: Reduce [idlist_opt ::=], go to state 241.
parser: Shift 'idlist_opt', go to state 147
parser: Reduce [with ::=], go to state 147.
parser: Shift 'with', go to state 113
parser: Shift 'VALUES', go to state 397
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES]
parser: Input 'LP'
parser: Shift 'LP', go to state 15
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP]
parser: Input 'INTEGER'
parser: Shift 'INTEGER'
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP INTEGER]
parser: Input 'RP'
parser: Reduce [term ::= INTEGER|FLOAT|BLOB], go to state 15.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 15.
parser: Shift 'expr', go to state 48
parser: Reduce [nexprlist ::= expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'RP'
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist RP]
parser: Input 'SEMI'
parser: Reduce [values ::= VALUES LP nexprlist RP], go to state 113.
parser: Shift 'values', go to state 400
parser: Reduce [oneselect ::= values], go to state 113.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 113.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 147.
parser: Shift 'select'
parser: Reduce [cmd ::= with insert_cmd INTO fullname idlist_opt select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'SEMI'
parser: Shift 'SEMI'
parser: Return. Stack=[SEMI]
parser: Input 'REINDEX'
parser: Reduce [ecmd ::= SEMI], go to state 0.
parser: Shift 'ecmd'
parser: Reduce [cmdlist ::= ecmd], go to state 0.
parser: Shift 'cmdlist', go to state 146
parser: FALLBACK REINDEX => ID
parser: Reduce [explain ::=], go to state 146.
parser: Shift 'explain', go to state 2
parser: Shift 'REINDEX', go to state 171
parser: Return. Stack=[cmdlist explain REINDEX]
parser: Input 'SEMI'
parser: Reduce [cmd ::= REINDEX], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[cmdlist explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping cmdlist
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'BEGIN'
parser: FALLBACK BEGIN => ID
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Shift 'BEGIN', go to state 217
parser: Return. Stack=[explain BEGIN]
parser: Input 'SEMI'
parser: Reduce [transtype ::=], go to state 217.
parser: Shift 'transtype', go to state 306
parser: Reduce [trans_opt ::=], go to state 306.
parser: Shift 'trans_opt'
parser: Reduce [cmd ::= BEGIN transtype trans_opt], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'SELECT'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[explain with SELECT]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'LP'
parser: Shift 'LP', go to state 216
parser: Return. Stack=[explain with SELECT distinct sclp ID LP]
parser: Input 'STAR'
parser: Shift 'STAR', go to state 393
parser: Return. Stack=[explain with SELECT distinct sclp ID LP STAR]
parser: Input 'RP'
parser: Shift 'RP'
parser: Return. Stack=[explain with SELECT distinct sclp ID LP STAR RP]
parser: Input 'FROM'
parser: Reduce [expr ::= ID|INDEXED LP STAR RP], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[explain with SELECT distinct selcollist FROM]
parser: Input 'ID'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'ID'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'SEMI'
parser: Reduce [nm ::= ID|INDEXED], go to state 165.
parser: Shift 'nm', go to state 287
parser: Reduce [dbnm ::=], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Reduce [where_opt ::=], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Reduce [orderby_opt ::=], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 22.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 2.
parser: Shift 'select'
parser: Reduce [cmd ::= select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'CREATE'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Shift 'CREATE'
parser: Return. Stack=[explain CREATE]
parser: Input 'INDEX'
parser: Reduce [createkw ::= CREATE], go to state 2.
parser: Shift 'createkw', go to state 107
parser: Reduce [uniqueflag ::=], go to state 107.
parser: Shift 'uniqueflag', go to state 370
parser: Shift 'INDEX', go to state 256
parser: Return. Stack=[explain createkw uniqueflag INDEX]
parser: Input 'ID'
parser: Reduce [ifnotexists ::=], go to state 256.
parser: Shift 'ifnotexists', go to state 180
parser: Shift 'ID'
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists ID]
parser: Input 'ON'
parser: Reduce [nm ::= ID|INDEXED], go to state 180.
parser: Shift 'nm', go to state 255
parser: Reduce [dbnm ::=], go to state 255.
parser: Shift 'dbnm', go to state 369
parser: Shift 'ON', go to state 179
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON ID]
parser: Input 'LP'
parser: Reduce [nm ::= ID|INDEXED], go to state 179.
parser: Shift 'nm', go to state 368
parser: Shift 'LP', go to state 12
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP STRING]
parser: Input 'RP'
parser: Reduce [term ::= STRING], go to state 12.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 12.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 12.
parser: Shift 'sortlist', go to state 325
parser: Shift 'RP', go to state 254
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP]
parser: Input 'SEMI'
parser: Reduce [where_opt ::=], go to state 254.
parser: Shift 'where_opt'
parser: Reduce [cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt], go to state 2.
parser: Initialize. Empty stack. State 0
parser: Input 'INSERT'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'INSERT', go to state 253
parser: Return. Stack=[explain with INSERT]
parser: Input 'INTO'
parser: Reduce [orconf ::=], go to state 253.
parser: Shift 'orconf'
parser: Reduce [insert_cmd ::= INSERT orconf], go to state 22.
parser: Shift 'insert_cmd', go to state 351
parser: Shift 'INTO', go to state 127
parser: Return. Stack=[explain with insert_cmd INTO]
parser: Input 'STRING'
parser: Shift 'STRING'
parser: Return. Stack=[explain with insert_cmd INTO STRING]
parser: Input 'DOT'
parser: Reduce [nm ::= STRING], go to state 127.
parser: Shift 'nm', go to state 259
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[explain with insert_cmd INTO nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with insert_cmd INTO nm DOT ID]
parser: Input 'VALUES'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 259.
parser: Shift 'dbnm'
parser: Reduce [fullname ::= nm dbnm], go to state 127.
parser: Shift 'fullname', go to state 241
parser: Reduce [idlist_opt ::=], go to state 241.
parser: Shift 'idlist_opt', go to state 147
parser: Reduce [with ::=], go to state 147.
parser: Shift 'with', go to state 113
parser: Shift 'VALUES', go to state 397
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES]
parser: Input 'LP'
parser: Shift 'LP', go to state 15
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP STRING]
parser: Input 'COMMA'
parser: Reduce [term ::= STRING], go to state 15.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 15.
parser: Shift 'expr', go to state 48
parser: Reduce [nexprlist ::= expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'COMMA', go to state 70
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA STRING]
parser: Input 'COMMA'
parser: Reduce [term ::= STRING], go to state 70.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 70.
parser: Shift 'expr', go to state 43
parser: Reduce [nexprlist ::= nexprlist COMMA expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'COMMA', go to state 70
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA STRING]
parser: Input 'COMMA'
parser: Reduce [term ::= STRING], go to state 70.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 70.
parser: Shift 'expr', go to state 43
parser: Reduce [nexprlist ::= nexprlist COMMA expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'COMMA', go to state 70
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA]
parser: Input 'VARIABLE'
parser: Shift 'VARIABLE'
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA VARIABLE]
parser: Input 'COMMA'
parser: Reduce [expr ::= VARIABLE], go to state 70.
parser: Shift 'expr', go to state 43
parser: Reduce [nexprlist ::= nexprlist COMMA expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'COMMA', go to state 70
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA STRING]
parser: Input 'RP'
parser: Reduce [term ::= STRING], go to state 70.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 70.
parser: Shift 'expr', go to state 43
parser: Reduce [nexprlist ::= nexprlist COMMA expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'RP'
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist RP]
parser: Input 'SEMI'
parser: Reduce [values ::= VALUES LP nexprlist RP], go to state 113.
parser: Shift 'values', go to state 400
parser: Reduce [oneselect ::= values], go to state 113.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 113.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 147.
parser: Shift 'select'
parser: Reduce [cmd ::= with insert_cmd INTO fullname idlist_opt select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Input '$'
parser: Reduce [ecmd ::= explain cmdx SEMI], go to state 0.
parser: Shift 'ecmd'
parser: Reduce [cmdlist ::= ecmd], go to state 0.
parser: Shift 'cmdlist', go to state 146
parser: Reduce [input ::= cmdlist], go to state 0.
parser: Accept!
parser: Popping $
parser: Return. Stack=]
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'SELECT'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[explain with SELECT]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'FROM'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[explain with SELECT distinct selcollist FROM]
parser: Input 'STRING'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'STRING'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix STRING]
parser: Input 'DOT'
parser: Reduce [nm ::= STRING], go to state 165.
parser: Shift 'nm', go to state 287
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Shift 'WHERE', go to state 65
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'AND', go to state 93
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 93.
parser: Shift 'expr', go to state 53
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND expr EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND expr EQ STRING]
parser: Input 'ORDER'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 93.
parser: Shift 'expr', go to state 53
parser: Reduce [expr ::= expr AND expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Reduce [where_opt ::= WHERE expr], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Shift 'ORDER', go to state 411
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY'
parser: Shift 'BY', go to state 17
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI'
parser: Reduce [expr ::= ID|INDEXED], go to state 17.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 17.
parser: Shift 'sortlist', go to state 410
parser: Reduce [orderby_opt ::= ORDER BY sortlist], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 22.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 2.
parser: Shift 'select'
parser: Reduce [cmd ::= select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'CREATE'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Shift 'CREATE'
parser: Return. Stack=[explain CREATE]
parser: Input 'INDEX'
parser: Reduce [createkw ::= CREATE], go to state 2.
parser: Shift 'createkw', go to state 107
parser: Reduce [uniqueflag ::=], go to state 107.
parser: Shift 'uniqueflag', go to state 370
parser: Shift 'INDEX', go to state 256
parser: Return. Stack=[explain createkw uniqueflag INDEX]
parser: Input 'ID'
parser: Reduce [ifnotexists ::=], go to state 256.
parser: Shift 'ifnotexists', go to state 180
parser: Shift 'ID'
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists ID]
parser: Input 'ON'
parser: Reduce [nm ::= ID|INDEXED], go to state 180.
parser: Shift 'nm', go to state 255
parser: Reduce [dbnm ::=], go to state 255.
parser: Shift 'dbnm', go to state 369
parser: Shift 'ON', go to state 179
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON ID]
parser: Input 'LP'
parser: Reduce [nm ::= ID|INDEXED], go to state 179.
parser: Shift 'nm', go to state 368
parser: Shift 'LP', go to state 12
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP STRING]
parser: Input 'RP'
parser: Reduce [term ::= STRING], go to state 12.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 12.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 12.
parser: Shift 'sortlist', go to state 325
parser: Shift 'RP', go to state 254
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP]
parser: Input 'SEMI'
parser: Reduce [where_opt ::=], go to state 254.
parser: Shift 'where_opt'
parser: Reduce [cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'CREATE'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Shift 'CREATE'
parser: Return. Stack=[explain CREATE]
parser: Input 'INDEX'
parser: Reduce [createkw ::= CREATE], go to state 2.
parser: Shift 'createkw', go to state 107
parser: Reduce [uniqueflag ::=], go to state 107.
parser: Shift 'uniqueflag', go to state 370
parser: Shift 'INDEX', go to state 256
parser: Return. Stack=[explain createkw uniqueflag INDEX]
parser: Input 'ID'
parser: Reduce [ifnotexists ::=], go to state 256.
parser: Shift 'ifnotexists', go to state 180
parser: Shift 'ID'
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists ID]
parser: Input 'ON'
parser: Reduce [nm ::= ID|INDEXED], go to state 180.
parser: Shift 'nm', go to state 255
parser: Reduce [dbnm ::=], go to state 255.
parser: Shift 'dbnm', go to state 369
parser: Shift 'ON', go to state 179
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON ID]
parser: Input 'LP'
parser: Reduce [nm ::= ID|INDEXED], go to state 179.
parser: Shift 'nm', go to state 368
parser: Shift 'LP', go to state 12
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP STRING]
parser: Input 'COLLATE'
parser: Reduce [term ::= STRING], go to state 12.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 12.
parser: Shift 'expr', go to state 9
parser: Shift 'COLLATE', go to state 339
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP expr COLLATE]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP expr COLLATE ID]
parser: Input 'ASC'
parser: Reduce [expr ::= expr COLLATE ID|STRING], go to state 12.
parser: Shift 'expr', go to state 9
parser: Shift 'ASC'
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP expr ASC]
parser: Input 'RP'
parser: Reduce [sortorder ::= ASC], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 12.
parser: Shift 'sortlist', go to state 325
parser: Shift 'RP', go to state 254
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP]
parser: Input 'SEMI'
parser: Reduce [where_opt ::=], go to state 254.
parser: Shift 'where_opt'
parser: Reduce [cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt], go to state 2.
parser: Initialize. Empty stack. State 0
parser: Input 'INSERT'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'INSERT', go to state 253
parser: Return. Stack=[explain with INSERT]
parser: Input 'INTO'
parser: Reduce [orconf ::=], go to state 253.
parser: Shift 'orconf'
parser: Reduce [insert_cmd ::= INSERT orconf], go to state 22.
parser: Shift 'insert_cmd', go to state 351
parser: Shift 'INTO', go to state 127
parser: Return. Stack=[explain with insert_cmd INTO]
parser: Input 'STRING'
parser: Shift 'STRING'
parser: Return. Stack=[explain with insert_cmd INTO STRING]
parser: Input 'DOT'
parser: Reduce [nm ::= STRING], go to state 127.
parser: Shift 'nm', go to state 259
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[explain with insert_cmd INTO nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with insert_cmd INTO nm DOT ID]
parser: Input 'VALUES'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 259.
parser: Shift 'dbnm'
parser: Reduce [fullname ::= nm dbnm], go to state 127.
parser: Shift 'fullname', go to state 241
parser: Reduce [idlist_opt ::=], go to state 241.
parser: Shift 'idlist_opt', go to state 147
parser: Reduce [with ::=], go to state 147.
parser: Shift 'with', go to state 113
parser: Shift 'VALUES', go to state 397
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES]
parser: Input 'LP'
parser: Shift 'LP', go to state 15
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP STRING]
parser: Input 'COMMA'
parser: Reduce [term ::= STRING], go to state 15.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 15.
parser: Shift 'expr', go to state 48
parser: Reduce [nexprlist ::= expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'COMMA', go to state 70
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA STRING]
parser: Input 'COMMA'
parser: Reduce [term ::= STRING], go to state 70.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 70.
parser: Shift 'expr', go to state 43
parser: Reduce [nexprlist ::= nexprlist COMMA expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'COMMA', go to state 70
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA STRING]
parser: Input 'COMMA'
parser: Reduce [term ::= STRING], go to state 70.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 70.
parser: Shift 'expr', go to state 43
parser: Reduce [nexprlist ::= nexprlist COMMA expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'COMMA', go to state 70
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA]
parser: Input 'VARIABLE'
parser: Shift 'VARIABLE'
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA VARIABLE]
parser: Input 'COMMA'
parser: Reduce [expr ::= VARIABLE], go to state 70.
parser: Shift 'expr', go to state 43
parser: Reduce [nexprlist ::= nexprlist COMMA expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'COMMA', go to state 70
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA STRING]
parser: Input 'RP'
parser: Reduce [term ::= STRING], go to state 70.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 70.
parser: Shift 'expr', go to state 43
parser: Reduce [nexprlist ::= nexprlist COMMA expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'RP'
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist RP]
parser: Input 'SEMI'
parser: Reduce [values ::= VALUES LP nexprlist RP], go to state 113.
parser: Shift 'values', go to state 400
parser: Reduce [oneselect ::= values], go to state 113.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 113.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 147.
parser: Shift 'select'
parser: Reduce [cmd ::= with insert_cmd INTO fullname idlist_opt select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Input '$'
parser: Reduce [ecmd ::= explain cmdx SEMI], go to state 0.
parser: Shift 'ecmd'
parser: Reduce [cmdlist ::= ecmd], go to state 0.
parser: Shift 'cmdlist', go to state 146
parser: Reduce [input ::= cmdlist], go to state 0.
parser: Accept!
parser: Popping $
parser: Return. Stack=]
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'SELECT'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[explain with SELECT]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'FROM'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[explain with SELECT distinct selcollist FROM]
parser: Input 'STRING'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'STRING'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix STRING]
parser: Input 'DOT'
parser: Reduce [nm ::= STRING], go to state 165.
parser: Shift 'nm', go to state 287
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Shift 'WHERE', go to state 65
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'AND', go to state 93
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 93.
parser: Shift 'expr', go to state 53
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND expr EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND expr EQ STRING]
parser: Input 'ORDER'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 93.
parser: Shift 'expr', go to state 53
parser: Reduce [expr ::= expr AND expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Reduce [where_opt ::= WHERE expr], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Shift 'ORDER', go to state 411
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY'
parser: Shift 'BY', go to state 17
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI'
parser: Reduce [expr ::= ID|INDEXED], go to state 17.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 17.
parser: Shift 'sortlist', go to state 410
parser: Reduce [orderby_opt ::= ORDER BY sortlist], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 22.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 2.
parser: Shift 'select'
parser: Reduce [cmd ::= select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'CREATE'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Shift 'CREATE'
parser: Return. Stack=[explain CREATE]
parser: Input 'INDEX'
parser: Reduce [createkw ::= CREATE], go to state 2.
parser: Shift 'createkw', go to state 107
parser: Reduce [uniqueflag ::=], go to state 107.
parser: Shift 'uniqueflag', go to state 370
parser: Shift 'INDEX', go to state 256
parser: Return. Stack=[explain createkw uniqueflag INDEX]
parser: Input 'ID'
parser: Reduce [ifnotexists ::=], go to state 256.
parser: Shift 'ifnotexists', go to state 180
parser: Shift 'ID'
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists ID]
parser: Input 'ON'
parser: Reduce [nm ::= ID|INDEXED], go to state 180.
parser: Shift 'nm', go to state 255
parser: Reduce [dbnm ::=], go to state 255.
parser: Shift 'dbnm', go to state 369
parser: Shift 'ON', go to state 179
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON ID]
parser: Input 'LP'
parser: Reduce [nm ::= ID|INDEXED], go to state 179.
parser: Shift 'nm', go to state 368
parser: Shift 'LP', go to state 12
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP STRING]
parser: Input 'COLLATE'
parser: Reduce [term ::= STRING], go to state 12.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 12.
parser: Shift 'expr', go to state 9
parser: Shift 'COLLATE', go to state 339
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP expr COLLATE]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP expr COLLATE ID]
parser: Input 'ASC'
parser: Reduce [expr ::= expr COLLATE ID|STRING], go to state 12.
parser: Shift 'expr', go to state 9
parser: Shift 'ASC'
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP expr ASC]
parser: Input 'RP'
parser: Reduce [sortorder ::= ASC], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 12.
parser: Shift 'sortlist', go to state 325
parser: Shift 'RP', go to state 254
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP]
parser: Input 'SEMI'
parser: Reduce [where_opt ::=], go to state 254.
parser: Shift 'where_opt'
parser: Reduce [cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'BEGIN'
parser: FALLBACK BEGIN => ID
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Shift 'BEGIN', go to state 217
parser: Return. Stack=[explain BEGIN]
parser: Input 'SEMI'
parser: Reduce [transtype ::=], go to state 217.
parser: Shift 'transtype', go to state 306
parser: Reduce [trans_opt ::=], go to state 306.
parser: Shift 'trans_opt'
parser: Reduce [cmd ::= BEGIN transtype trans_opt], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'SEMI'
parser: Shift 'SEMI'
parser: Return. Stack=[SEMI]
parser: Input 'COMMIT'
parser: Reduce [ecmd ::= SEMI], go to state 0.
parser: Shift 'ecmd'
parser: Reduce [cmdlist ::= ecmd], go to state 0.
parser: Shift 'cmdlist', go to state 146
parser: Reduce [explain ::=], go to state 146.
parser: Shift 'explain', go to state 2
parser: Shift 'COMMIT', go to state 305
parser: Return. Stack=[cmdlist explain COMMIT]
parser: Input 'SEMI'
parser: Reduce [trans_opt ::=], go to state 305.
parser: Shift 'trans_opt'
parser: Reduce [cmd ::= COMMIT trans_opt], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[cmdlist explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping cmdlist
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'VACUUM'
parser: FALLBACK VACUUM => ID
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Shift 'VACUUM', go to state 173
parser: Return. Stack=[explain VACUUM]
parser: Input 'SEMI'
parser: Reduce [cmd ::= VACUUM], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'ATTACH'
parser: FALLBACK ATTACH => ID
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Shift 'ATTACH', go to state 239
parser: Return. Stack=[explain ATTACH]
parser: Input 'STRING'
parser: Reduce [database_kw_opt ::=], go to state 239.
parser: Shift 'database_kw_opt', go to state 58
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain ATTACH database_kw_opt STRING]
parser: Input 'AS'
parser: Reduce [term ::= STRING], go to state 58.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 58.
parser: Shift 'expr', go to state 26
parser: Shift 'AS', go to state 57
parser: Return. Stack=[explain ATTACH database_kw_opt expr AS]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain ATTACH database_kw_opt expr AS ID]
parser: Input 'SEMI'
parser: Reduce [expr ::= ID|INDEXED], go to state 57.
parser: Shift 'expr', go to state 11
parser: Reduce [key_opt ::=], go to state 11.
parser: Shift 'key_opt'
parser: Reduce [cmd ::= ATTACH database_kw_opt expr AS expr key_opt], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'CREATE'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Shift 'CREATE'
parser: Return. Stack=[explain CREATE]
parser: Input 'TABLE'
parser: Reduce [createkw ::= CREATE], go to state 2.
parser: Shift 'createkw', go to state 107
parser: Reduce [temp ::=], go to state 107.
parser: Shift 'temp', go to state 319
parser: Shift 'TABLE', go to state 266
parser: Return. Stack=[explain createkw temp TABLE]
parser: Input 'ID'
parser: Reduce [ifnotexists ::=], go to state 266.
parser: Shift 'ifnotexists', go to state 183
parser: Shift 'ID'
parser: Return. Stack=[explain createkw temp TABLE ifnotexists ID]
parser: Input 'LP'
parser: Reduce [nm ::= ID|INDEXED], go to state 183.
parser: Shift 'nm', go to state 265
parser: Reduce [dbnm ::=], go to state 265.
parser: Shift 'dbnm'
parser: Reduce [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 2.
parser: Shift 'create_table', go to state 234
parser: Shift 'LP', go to state 111
parser: Return. Stack=[explain create_table LP]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP ID]
parser: Input 'ID'
parser: Reduce [nm ::= ID|INDEXED], go to state 111.
parser: Shift 'nm', go to state 148
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP nm ID]
parser: Input 'COMMA'
parser: Reduce [typename ::= ID|STRING], go to state 148.
parser: Shift 'typename', go to state 321
parser: Reduce [typetoken ::= typename], go to state 148.
parser: Shift 'typetoken'
parser: Reduce [columnname ::= nm typetoken], go to state 111.
parser: Shift 'columnname', go to state 311
parser: Reduce [carglist ::=], go to state 311.
parser: Shift 'carglist', go to state 119
parser: Reduce [columnlist ::= columnname carglist], go to state 111.
parser: Shift 'columnlist', go to state 300
parser: Shift 'COMMA', go to state 21
parser: Return. Stack=[explain create_table LP columnlist COMMA]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP columnlist COMMA ID]
parser: Input 'ID'
parser: Reduce [nm ::= ID|INDEXED], go to state 21.
parser: Shift 'nm', go to state 148
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP columnlist COMMA nm ID]
parser: Input 'COMMA'
parser: Reduce [typename ::= ID|STRING], go to state 148.
parser: Shift 'typename', go to state 321
parser: Reduce [typetoken ::= typename], go to state 148.
parser: Shift 'typetoken'
parser: Reduce [columnname ::= nm typetoken], go to state 21.
parser: Shift 'columnname', go to state 314
parser: Reduce [carglist ::=], go to state 314.
parser: Shift 'carglist', go to state 120
parser: Reduce [columnlist ::= columnlist COMMA columnname carglist], go to state 111.
parser: Shift 'columnlist', go to state 300
parser: Shift 'COMMA', go to state 21
parser: Return. Stack=[explain create_table LP columnlist COMMA]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP columnlist COMMA ID]
parser: Input 'ID'
parser: Reduce [nm ::= ID|INDEXED], go to state 21.
parser: Shift 'nm', go to state 148
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP columnlist COMMA nm ID]
parser: Input 'COMMA'
parser: Reduce [typename ::= ID|STRING], go to state 148.
parser: Shift 'typename', go to state 321
parser: Reduce [typetoken ::= typename], go to state 148.
parser: Shift 'typetoken'
parser: Reduce [columnname ::= nm typetoken], go to state 21.
parser: Shift 'columnname', go to state 314
parser: Reduce [carglist ::=], go to state 314.
parser: Shift 'carglist', go to state 120
parser: Reduce [columnlist ::= columnlist COMMA columnname carglist], go to state 111.
parser: Shift 'columnlist', go to state 300
parser: Shift 'COMMA', go to state 21
parser: Return. Stack=[explain create_table LP columnlist COMMA]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP columnlist COMMA ID]
parser: Input 'ID'
parser: Reduce [nm ::= ID|INDEXED], go to state 21.
parser: Shift 'nm', go to state 148
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP columnlist COMMA nm ID]
parser: Input 'COMMA'
parser: Reduce [typename ::= ID|STRING], go to state 148.
parser: Shift 'typename', go to state 321
parser: Reduce [typetoken ::= typename], go to state 148.
parser: Shift 'typetoken'
parser: Reduce [columnname ::= nm typetoken], go to state 21.
parser: Shift 'columnname', go to state 314
parser: Reduce [carglist ::=], go to state 314.
parser: Shift 'carglist', go to state 120
parser: Reduce [columnlist ::= columnlist COMMA columnname carglist], go to state 111.
parser: Shift 'columnlist', go to state 300
parser: Shift 'COMMA', go to state 21
parser: Return. Stack=[explain create_table LP columnlist COMMA]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP columnlist COMMA ID]
parser: Input 'ID'
parser: Reduce [nm ::= ID|INDEXED], go to state 21.
parser: Shift 'nm', go to state 148
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP columnlist COMMA nm ID]
parser: Input 'RP'
parser: Reduce [typename ::= ID|STRING], go to state 148.
parser: Shift 'typename', go to state 321
parser: Reduce [typetoken ::= typename], go to state 148.
parser: Shift 'typetoken'
parser: Reduce [columnname ::= nm typetoken], go to state 21.
parser: Shift 'columnname', go to state 314
parser: Reduce [carglist ::=], go to state 314.
parser: Shift 'carglist', go to state 120
parser: Reduce [columnlist ::= columnlist COMMA columnname carglist], go to state 111.
parser: Shift 'columnlist', go to state 300
parser: Reduce [conslist_opt ::=], go to state 300.
parser: Shift 'conslist_opt', go to state 437
parser: Shift 'RP', go to state 299
parser: Return. Stack=[explain create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI'
parser: Reduce [table_options ::=], go to state 299.
parser: Shift 'table_options'
parser: Reduce [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 234.
parser: Shift 'create_table_args'
parser: Reduce [cmd ::= create_table create_table_args], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'SELECT'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[explain with SELECT]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'FROM'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[explain with SELECT distinct selcollist FROM]
parser: Input 'ID'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'ID'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'DOT'
parser: Reduce [nm ::= ID|INDEXED], go to state 165.
parser: Shift 'nm', go to state 287
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'ORDER'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Reduce [where_opt ::=], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Shift 'ORDER', go to state 411
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY'
parser: Shift 'BY', go to state 17
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI'
parser: Reduce [expr ::= ID|INDEXED], go to state 17.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 17.
parser: Shift 'sortlist', go to state 410
parser: Reduce [orderby_opt ::= ORDER BY sortlist], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 22.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 2.
parser: Shift 'select'
parser: Reduce [cmd ::= select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'PRAGMA'
parser: FALLBACK PRAGMA => ID
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Shift 'PRAGMA', go to state 172
parser: Return. Stack=[explain PRAGMA]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain PRAGMA ID]
parser: Input 'DOT'
parser: Reduce [nm ::= ID|INDEXED], go to state 172.
parser: Shift 'nm', go to state 240
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[explain PRAGMA nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain PRAGMA nm DOT ID]
parser: Input 'EQ'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 240.
parser: Shift 'dbnm', go to state 323
parser: Shift 'EQ', go to state 20
parser: Return. Stack=[explain PRAGMA nm dbnm EQ]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain PRAGMA nm dbnm EQ ID]
parser: Input 'SEMI'
parser: Reduce [nm ::= ID|INDEXED], go to state 20.
parser: Shift 'nm'
parser: Reduce [nmnum ::= nm], go to state 20.
parser: Shift 'nmnum'
parser: Reduce [cmd ::= PRAGMA nm dbnm EQ nmnum], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'BEGIN'
parser: FALLBACK BEGIN => ID
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Shift 'BEGIN', go to state 217
parser: Return. Stack=[explain BEGIN]
parser: Input 'SEMI'
parser: Reduce [transtype ::=], go to state 217.
parser: Shift 'transtype', go to state 306
parser: Reduce [trans_opt ::=], go to state 306.
parser: Shift 'trans_opt'
parser: Reduce [cmd ::= BEGIN transtype trans_opt], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'SELECT'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[explain with SELECT]
parser: Input 'STRING'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with SELECT distinct sclp STRING]
parser: Input 'CONCAT'
parser: Reduce [term ::= STRING], go to state 54.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 54.
parser: Shift 'expr', go to state 8
parser: Shift 'CONCAT', go to state 86
parser: Return. Stack=[explain with SELECT distinct sclp expr CONCAT]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp expr CONCAT ID]
parser: Input 'LP'
parser: Shift 'LP', go to state 216
parser: Return. Stack=[explain with SELECT distinct sclp expr CONCAT ID LP]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 216.
parser: Shift 'distinct', go to state 6
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp expr CONCAT ID LP distinct ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 6.
parser: Shift 'expr', go to state 48
parser: Reduce [nexprlist ::= expr], go to state 6.
parser: Shift 'nexprlist', go to state 412
parser: Shift 'COMMA', go to state 70
parser: Return. Stack=[explain with SELECT distinct sclp expr CONCAT ID LP distinct nexprlist COMMA]
parser: Input 'INTEGER'
parser: Shift 'INTEGER'
parser: Return. Stack=[explain with SELECT distinct sclp expr CONCAT ID LP distinct nexprlist COMMA INTEGER]
parser: Input 'RP'
parser: Reduce [term ::= INTEGER|FLOAT|BLOB], go to state 70.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 70.
parser: Shift 'expr', go to state 43
parser: Reduce [nexprlist ::= nexprlist COMMA expr], go to state 6.
parser: Shift 'nexprlist', go to state 412
parser: Reduce [exprlist ::= nexprlist], go to state 6.
parser: Shift 'exprlist', go to state 394
parser: Shift 'RP'
parser: Return. Stack=[explain with SELECT distinct sclp expr CONCAT ID LP distinct exprlist RP]
parser: Input 'FROM'
parser: Reduce [expr ::= ID|INDEXED LP distinct exprlist RP], go to state 86.
parser: Shift 'expr', go to state 114
parser: Reduce [expr ::= expr CONCAT expr], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[explain with SELECT distinct selcollist FROM]
parser: Input 'ID'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'ID'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'WHERE'
parser: Reduce [nm ::= ID|INDEXED], go to state 165.
parser: Shift 'nm', go to state 287
parser: Reduce [dbnm ::=], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Shift 'WHERE', go to state 65
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'AND', go to state 93
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'NE'
parser: Reduce [expr ::= ID|INDEXED], go to state 93.
parser: Shift 'expr', go to state 53
parser: Shift 'NE', go to state 90
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND expr NE]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND expr NE STRING]
parser: Input 'AND'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 93.
parser: Shift 'expr', go to state 53
parser: Reduce [expr ::= expr AND expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'AND', go to state 93
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'LP'
parser: Shift 'LP', go to state 216
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND ID LP]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 216.
parser: Shift 'distinct', go to state 6
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND ID LP distinct ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 6.
parser: Shift 'expr', go to state 48
parser: Reduce [nexprlist ::= expr], go to state 6.
parser: Shift 'nexprlist', go to state 412
parser: Shift 'COMMA', go to state 70
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND ID LP distinct nexprlist COMMA]
parser: Input 'INTEGER'
parser: Shift 'INTEGER'
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND ID LP distinct nexprlist COMMA INTEGER]
parser: Input 'RP'
parser: Reduce [term ::= INTEGER|FLOAT|BLOB], go to state 70.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 70.
parser: Shift 'expr', go to state 43
parser: Reduce [nexprlist ::= nexprlist COMMA expr], go to state 6.
parser: Shift 'nexprlist', go to state 412
parser: Reduce [exprlist ::= nexprlist], go to state 6.
parser: Shift 'exprlist', go to state 394
parser: Shift 'RP'
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND ID LP distinct exprlist RP]
parser: Input 'GT'
parser: Reduce [expr ::= ID|INDEXED LP distinct exprlist RP], go to state 93.
parser: Shift 'expr', go to state 53
parser: Shift 'GT', go to state 91
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND expr GT]
parser: Input 'INTEGER'
parser: Shift 'INTEGER'
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND expr GT INTEGER]
parser: Input 'SEMI'
parser: Reduce [term ::= INTEGER|FLOAT|BLOB], go to state 91.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 91.
parser: Shift 'expr', go to state 103
parser: Reduce [expr ::= expr LT|GT|GE|LE expr], go to state 93.
parser: Shift 'expr', go to state 53
parser: Reduce [expr ::= expr AND expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Reduce [where_opt ::= WHERE expr], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Reduce [orderby_opt ::=], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 22.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 2.
parser: Shift 'select'
parser: Reduce [cmd ::= select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'CREATE'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Shift 'CREATE'
parser: Return. Stack=[explain CREATE]
parser: Input 'TABLE'
parser: Reduce [createkw ::= CREATE], go to state 2.
parser: Shift 'createkw', go to state 107
parser: Reduce [temp ::=], go to state 107.
parser: Shift 'temp', go to state 319
parser: Shift 'TABLE', go to state 266
parser: Return. Stack=[explain createkw temp TABLE]
parser: Input 'ID'
parser: Reduce [ifnotexists ::=], go to state 266.
parser: Shift 'ifnotexists', go to state 183
parser: Shift 'ID'
parser: Return. Stack=[explain createkw temp TABLE ifnotexists ID]
parser: Input 'DOT'
parser: Reduce [nm ::= ID|INDEXED], go to state 183.
parser: Shift 'nm', go to state 265
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[explain createkw temp TABLE ifnotexists nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain createkw temp TABLE ifnotexists nm DOT ID]
parser: Input 'LP'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 265.
parser: Shift 'dbnm'
parser: Reduce [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 2.
parser: Shift 'create_table', go to state 234
parser: Shift 'LP', go to state 111
parser: Return. Stack=[explain create_table LP]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP ID]
parser: Input 'PRIMARY'
parser: Reduce [nm ::= ID|INDEXED], go to state 111.
parser: Shift 'nm', go to state 148
parser: Reduce [typetoken ::=], go to state 148.
parser: Shift 'typetoken'
parser: Reduce [columnname ::= nm typetoken], go to state 111.
parser: Shift 'columnname', go to state 311
parser: Reduce [carglist ::=], go to state 311.
parser: Shift 'carglist', go to state 119
parser: Shift 'PRIMARY', go to state 391
parser: Return. Stack=[explain create_table LP columnname carglist PRIMARY]
parser: Input 'KEY'
parser: Shift 'KEY', go to state 227
parser: Return. Stack=[explain create_table LP columnname carglist PRIMARY KEY]
parser: Input 'COMMA'
parser: Reduce [sortorder ::=], go to state 227.
parser: Shift 'sortorder', go to state 275
parser: Reduce [onconf ::=], go to state 275.
parser: Shift 'onconf', go to state 274
parser: Reduce [autoinc ::=], go to state 274.
parser: Shift 'autoinc'
parser: Reduce [ccons ::= PRIMARY KEY sortorder onconf autoinc], go to state 119.
parser: Initialize. Empty stack. State 0
parser: Input 'INSERT'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'INSERT', go to state 253
parser: Return. Stack=[explain with INSERT]
parser: Input 'INTO'
parser: Reduce [orconf ::=], go to state 253.
parser: Shift 'orconf'
parser: Reduce [insert_cmd ::= INSERT orconf], go to state 22.
parser: Shift 'insert_cmd', go to state 351
parser: Shift 'INTO', go to state 127
parser: Return. Stack=[explain with insert_cmd INTO]
parser: Input 'STRING'
parser: Shift 'STRING'
parser: Return. Stack=[explain with insert_cmd INTO STRING]
parser: Input 'DOT'
parser: Reduce [nm ::= STRING], go to state 127.
parser: Shift 'nm', go to state 259
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[explain with insert_cmd INTO nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with insert_cmd INTO nm DOT ID]
parser: Input 'VALUES'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 259.
parser: Shift 'dbnm'
parser: Reduce [fullname ::= nm dbnm], go to state 127.
parser: Shift 'fullname', go to state 241
parser: Reduce [idlist_opt ::=], go to state 241.
parser: Shift 'idlist_opt', go to state 147
parser: Reduce [with ::=], go to state 147.
parser: Shift 'with', go to state 113
parser: Shift 'VALUES', go to state 397
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES]
parser: Input 'LP'
parser: Shift 'LP', go to state 15
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP STRING]
parser: Input 'COMMA'
parser: Reduce [term ::= STRING], go to state 15.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 15.
parser: Shift 'expr', go to state 48
parser: Reduce [nexprlist ::= expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'COMMA', go to state 70
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA STRING]
parser: Input 'COMMA'
parser: Reduce [term ::= STRING], go to state 70.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 70.
parser: Shift 'expr', go to state 43
parser: Reduce [nexprlist ::= nexprlist COMMA expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'COMMA', go to state 70
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA STRING]
parser: Input 'COMMA'
parser: Reduce [term ::= STRING], go to state 70.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 70.
parser: Shift 'expr', go to state 43
parser: Reduce [nexprlist ::= nexprlist COMMA expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'COMMA', go to state 70
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA]
parser: Input 'VARIABLE'
parser: Shift 'VARIABLE'
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA VARIABLE]
parser: Input 'COMMA'
parser: Reduce [expr ::= VARIABLE], go to state 70.
parser: Shift 'expr', go to state 43
parser: Reduce [nexprlist ::= nexprlist COMMA expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'COMMA', go to state 70
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA]
parser: Input 'NULL'
parser: Shift 'NULL'
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA NULL]
parser: Input 'RP'
parser: Reduce [term ::= NULL], go to state 70.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 70.
parser: Shift 'expr', go to state 43
parser: Reduce [nexprlist ::= nexprlist COMMA expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'RP'
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist RP]
parser: Input 'SEMI'
parser: Reduce [values ::= VALUES LP nexprlist RP], go to state 113.
parser: Shift 'values', go to state 400
parser: Reduce [oneselect ::= values], go to state 113.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 113.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 147.
parser: Shift 'select'
parser: Reduce [cmd ::= with insert_cmd INTO fullname idlist_opt select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Input '$'
parser: Reduce [ecmd ::= explain cmdx SEMI], go to state 0.
parser: Shift 'ecmd'
parser: Reduce [cmdlist ::= ecmd], go to state 0.
parser: Shift 'cmdlist', go to state 146
parser: Reduce [input ::= cmdlist], go to state 0.
parser: Accept!
parser: Popping $
parser: Return. Stack=]
parser: Shift 'ccons'
parser: Reduce [carglist ::= carglist ccons], go to state 311.
parser: Shift 'carglist', go to state 119
parser: Reduce [columnlist ::= columnname carglist], go to state 111.
parser: Shift 'columnlist', go to state 300
parser: Shift 'COMMA', go to state 21
parser: Return. Stack=[explain create_table LP columnlist COMMA]
parser: Input 'UNIQUE'
parser: Shift 'UNIQUE', go to state 385
parser: Return. Stack=[explain create_table LP columnlist COMMA UNIQUE]
parser: Input 'LP'
parser: Shift 'LP', go to state 13
parser: Return. Stack=[explain create_table LP columnlist COMMA UNIQUE LP]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain create_table LP columnlist COMMA UNIQUE LP ID]
parser: Input 'RP'
parser: Reduce [expr ::= ID|INDEXED], go to state 13.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 13.
parser: Shift 'sortlist', go to state 327
parser: Shift 'RP', go to state 269
parser: Return. Stack=[explain create_table LP columnlist COMMA UNIQUE LP sortlist RP]
parser: Input 'RP'
parser: Reduce [onconf ::=], go to state 269.
parser: Shift 'onconf'
parser: Reduce [tcons ::= UNIQUE LP sortlist RP onconf], go to state 21.
parser: Shift 'tcons'
parser: Reduce [conslist ::= tcons], go to state 21.
parser: Shift 'conslist', go to state 225
parser: Reduce [conslist_opt ::= COMMA conslist], go to state 300.
parser: Shift 'conslist_opt', go to state 437
parser: Shift 'RP', go to state 299
parser: Return. Stack=[explain create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI'
parser: Reduce [table_options ::=], go to state 299.
parser: Shift 'table_options'
parser: Reduce [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 234.
parser: Initialize. Empty stack. State 0
parser: Input 'UPDATE'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'UPDATE', go to state 242
parser: Return. Stack=[explain with UPDATE]
parser: Input 'STRING'
parser: Reduce [orconf ::=], go to state 242.
parser: Shift 'orconf', go to state 129
parser: Shift 'STRING'
parser: Return. Stack=[explain with UPDATE orconf STRING]
parser: Input 'DOT'
parser: Reduce [nm ::= STRING], go to state 129.
parser: Shift 'nm', go to state 259
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[explain with UPDATE orconf nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with UPDATE orconf nm DOT ID]
parser: Input 'SET'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 259.
parser: Shift 'dbnm'
parser: Reduce [fullname ::= nm dbnm], go to state 129.
parser: Shift 'fullname', go to state 219
parser: Reduce [indexed_opt ::=], go to state 219.
parser: Shift 'indexed_opt', go to state 352
parser: Shift 'SET', go to state 128
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET ID]
parser: Input 'EQ'
parser: Reduce [nm ::= ID|INDEXED], go to state 128.
parser: Shift 'nm', go to state 360
parser: Shift 'EQ', go to state 59
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET nm EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET nm EQ STRING]
parser: Input 'COMMA'
parser: Reduce [term ::= STRING], go to state 59.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 59.
parser: Shift 'expr', go to state 36
parser: Reduce [setlist ::= nm EQ expr], go to state 128.
parser: Shift 'setlist', go to state 218
parser: Shift 'COMMA', go to state 176
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist COMMA]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ'
parser: Reduce [nm ::= ID|INDEXED], go to state 176.
parser: Shift 'nm', go to state 361
parser: Shift 'EQ', go to state 60
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'COMMA'
parser: Reduce [term ::= STRING], go to state 60.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 60.
parser: Shift 'expr', go to state 37
parser: Reduce [setlist ::= setlist COMMA nm EQ expr], go to state 128.
parser: Shift 'setlist', go to state 218
parser: Shift 'COMMA', go to state 176
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist COMMA]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ'
parser: Reduce [nm ::= ID|INDEXED], go to state 176.
parser: Shift 'nm', go to state 361
parser: Shift 'EQ', go to state 60
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'COMMA'
parser: Reduce [term ::= STRING], go to state 60.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 60.
parser: Shift 'expr', go to state 37
parser: Reduce [setlist ::= setlist COMMA nm EQ expr], go to state 128.
parser: Shift 'setlist', go to state 218
parser: Shift 'COMMA', go to state 176
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist COMMA]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ'
parser: Reduce [nm ::= ID|INDEXED], go to state 176.
parser: Shift 'nm', go to state 361
parser: Shift 'EQ', go to state 60
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'VARIABLE'
parser: Shift 'VARIABLE'
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist COMMA nm EQ VARIABLE]
parser: Input 'COMMA'
parser: Reduce [expr ::= VARIABLE], go to state 60.
parser: Shift 'expr', go to state 37
parser: Reduce [setlist ::= setlist COMMA nm EQ expr], go to state 128.
parser: Shift 'setlist', go to state 218
parser: Shift 'COMMA', go to state 176
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist COMMA]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ'
parser: Reduce [nm ::= ID|INDEXED], go to state 176.
parser: Shift 'nm', go to state 361
parser: Shift 'EQ', go to state 60
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'WHERE'
parser: Reduce [term ::= STRING], go to state 60.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 60.
parser: Shift 'expr', go to state 37
parser: Reduce [setlist ::= setlist COMMA nm EQ expr], go to state 128.
parser: Shift 'setlist', go to state 218
parser: Shift 'WHERE', go to state 65
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist WHERE]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist WHERE ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist WHERE expr EQ]
parser: Input 'VARIABLE'
parser: Shift 'VARIABLE'
parser: Return. Stack=[explain with UPDATE orconf fullname indexed_opt SET setlist WHERE expr EQ VARIABLE]
parser: Input 'SEMI'
parser: Reduce [expr ::= VARIABLE], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Reduce [where_opt ::= WHERE expr], go to state 218.
parser: Shift 'where_opt'
parser: Reduce [cmd ::= with UPDATE orconf fullname indexed_opt SET setlist where_opt], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Input '$'
parser: Reduce [ecmd ::= explain cmdx SEMI], go to state 0.
parser: Shift 'ecmd'
parser: Reduce [cmdlist ::= ecmd], go to state 0.
parser: Shift 'cmdlist', go to state 146
parser: Reduce [input ::= cmdlist], go to state 0.
parser: Accept!
parser: Popping $
parser: Return. Stack=]
parser: Shift 'create_table_args'
parser: Reduce [cmd ::= create_table create_table_args], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'SELECT'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[explain with SELECT]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'FROM'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[explain with SELECT distinct selcollist FROM]
parser: Input 'STRING'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'STRING'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix STRING]
parser: Input 'DOT'
parser: Reduce [nm ::= STRING], go to state 165.
parser: Shift 'nm', go to state 287
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Shift 'WHERE', go to state 65
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'AND', go to state 93
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'NE'
parser: Reduce [expr ::= ID|INDEXED], go to state 93.
parser: Shift 'expr', go to state 53
parser: Shift 'NE', go to state 90
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND expr NE]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND expr NE STRING]
parser: Input 'ORDER'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 93.
parser: Shift 'expr', go to state 53
parser: Reduce [expr ::= expr AND expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Reduce [where_opt ::= WHERE expr], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Shift 'ORDER', go to state 411
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY'
parser: Shift 'BY', go to state 17
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI'
parser: Reduce [expr ::= ID|INDEXED], go to state 17.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 17.
parser: Shift 'sortlist', go to state 410
parser: Reduce [orderby_opt ::= ORDER BY sortlist], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 22.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 2.
parser: Shift 'select'
parser: Reduce [cmd ::= select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'CREATE'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Shift 'CREATE'
parser: Return. Stack=[explain CREATE]
parser: Input 'TABLE'
parser: Reduce [createkw ::= CREATE], go to state 2.
parser: Shift 'createkw', go to state 107
parser: Reduce [temp ::=], go to state 107.
parser: Shift 'temp', go to state 319
parser: Shift 'TABLE', go to state 266
parser: Return. Stack=[explain createkw temp TABLE]
parser: Input 'ID'
parser: Reduce [ifnotexists ::=], go to state 266.
parser: Shift 'ifnotexists', go to state 183
parser: Shift 'ID'
parser: Return. Stack=[explain createkw temp TABLE ifnotexists ID]
parser: Input 'LP'
parser: Reduce [nm ::= ID|INDEXED], go to state 183.
parser: Shift 'nm', go to state 265
parser: Reduce [dbnm ::=], go to state 265.
parser: Shift 'dbnm'
parser: Reduce [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 2.
parser: Shift 'create_table', go to state 234
parser: Shift 'LP', go to state 111
parser: Return. Stack=[explain create_table LP]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain create_table LP ID]
parser: Input 'PRIMARY'
parser: Reduce [nm ::= ID|INDEXED], go to state 111.
parser: Shift 'nm', go to state 148
parser: Reduce [typetoken ::=], go to state 148.
parser: Shift 'typetoken'
parser: Reduce [columnname ::= nm typetoken], go to state 111.
parser: Shift 'columnname', go to state 311
parser: Reduce [carglist ::=], go to state 311.
parser: Shift 'carglist', go to state 119
parser: Shift 'PRIMARY', go to state 391
parser: Return. Stack=[explain create_table LP columnname carglist PRIMARY]
parser: Input 'KEY'
parser: Shift 'KEY', go to state 227
parser: Return. Stack=[explain create_table LP columnname carglist PRIMARY KEY]
parser: Input 'COMMA'
parser: Reduce [sortorder ::=], go to state 227.
parser: Shift 'sortorder', go to state 275
parser: Reduce [onconf ::=], go to state 275.
parser: Shift 'onconf', go to state 274
parser: Reduce [autoinc ::=], go to state 274.
parser: Shift 'autoinc'
parser: Reduce [ccons ::= PRIMARY KEY sortorder onconf autoinc], go to state 119.
parser: Shift 'ccons'
parser: Reduce [carglist ::= carglist ccons], go to state 311.
parser: Shift 'carglist', go to state 119
parser: Reduce [columnlist ::= columnname carglist], go to state 111.
parser: Shift 'columnlist', go to state 300
parser: Shift 'COMMA', go to state 21
parser: Return. Stack=[explain create_table LP columnlist COMMA]
parser: Input 'UNIQUE'
parser: Shift 'UNIQUE', go to state 385
parser: Return. Stack=[explain create_table LP columnlist COMMA UNIQUE]
parser: Input 'LP'
parser: Shift 'LP', go to state 13
parser: Return. Stack=[explain create_table LP columnlist COMMA UNIQUE LP]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain create_table LP columnlist COMMA UNIQUE LP ID]
parser: Input 'RP'
parser: Reduce [expr ::= ID|INDEXED], go to state 13.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 13.
parser: Shift 'sortlist', go to state 327
parser: Shift 'RP', go to state 269
parser: Return. Stack=[explain create_table LP columnlist COMMA UNIQUE LP sortlist RP]
parser: Input 'RP'
parser: Reduce [onconf ::=], go to state 269.
parser: Shift 'onconf'
parser: Reduce [tcons ::= UNIQUE LP sortlist RP onconf], go to state 21.
parser: Shift 'tcons'
parser: Reduce [conslist ::= tcons], go to state 21.
parser: Shift 'conslist', go to state 225
parser: Reduce [conslist_opt ::= COMMA conslist], go to state 300.
parser: Shift 'conslist_opt', go to state 437
parser: Shift 'RP', go to state 299
parser: Return. Stack=[explain create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI'
parser: Reduce [table_options ::=], go to state 299.
parser: Shift 'table_options'
parser: Reduce [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 234.
parser: Shift 'create_table_args'
parser: Reduce [cmd ::= create_table create_table_args], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'SELECT'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[explain with SELECT]
parser: Input 'STRING'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with SELECT distinct sclp STRING]
parser: Input 'CONCAT'
parser: Reduce [term ::= STRING], go to state 54.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 54.
parser: Shift 'expr', go to state 8
parser: Shift 'CONCAT', go to state 86
parser: Return. Stack=[explain with SELECT distinct sclp expr CONCAT]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp expr CONCAT ID]
parser: Input 'LP'
parser: Shift 'LP', go to state 216
parser: Return. Stack=[explain with SELECT distinct sclp expr CONCAT ID LP]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 216.
parser: Shift 'distinct', go to state 6
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp expr CONCAT ID LP distinct ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 6.
parser: Shift 'expr', go to state 48
parser: Reduce [nexprlist ::= expr], go to state 6.
parser: Shift 'nexprlist', go to state 412
parser: Shift 'COMMA', go to state 70
parser: Return. Stack=[explain with SELECT distinct sclp expr CONCAT ID LP distinct nexprlist COMMA]
parser: Input 'INTEGER'
parser: Shift 'INTEGER'
parser: Return. Stack=[explain with SELECT distinct sclp expr CONCAT ID LP distinct nexprlist COMMA INTEGER]
parser: Input 'RP'
parser: Reduce [term ::= INTEGER|FLOAT|BLOB], go to state 70.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 70.
parser: Shift 'expr', go to state 43
parser: Reduce [nexprlist ::= nexprlist COMMA expr], go to state 6.
parser: Shift 'nexprlist', go to state 412
parser: Reduce [exprlist ::= nexprlist], go to state 6.
parser: Shift 'exprlist', go to state 394
parser: Shift 'RP'
parser: Return. Stack=[explain with SELECT distinct sclp expr CONCAT ID LP distinct exprlist RP]
parser: Input 'FROM'
parser: Reduce [expr ::= ID|INDEXED LP distinct exprlist RP], go to state 86.
parser: Shift 'expr', go to state 114
parser: Reduce [expr ::= expr CONCAT expr], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[explain with SELECT distinct selcollist FROM]
parser: Input 'ID'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'ID'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'WHERE'
parser: Reduce [nm ::= ID|INDEXED], go to state 165.
parser: Shift 'nm', go to state 287
parser: Reduce [dbnm ::=], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Shift 'WHERE', go to state 65
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE ID]
parser: Input 'LIKE_KW'
parser: FALLBACK LIKE_KW => ID
parser: Reduce [expr ::= ID|INDEXED], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'LIKE_KW'
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr LIKE_KW]
parser: Input 'STRING'
parser: Reduce [likeop ::= LIKE_KW|MATCH], go to state 40.
parser: Shift 'likeop', go to state 85
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr likeop STRING]
parser: Input 'SEMI'
parser: Reduce [term ::= STRING], go to state 85.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 85.
parser: Shift 'expr', go to state 97
parser: Reduce [expr ::= expr likeop expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Reduce [where_opt ::= WHERE expr], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Reduce [orderby_opt ::=], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 22.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 2.
parser: Shift 'select'
parser: Reduce [cmd ::= select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'CREATE'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Shift 'CREATE'
parser: Return. Stack=[explain CREATE]
parser: Input 'INDEX'
parser: Reduce [createkw ::= CREATE], go to state 2.
parser: Shift 'createkw', go to state 107
parser: Reduce [uniqueflag ::=], go to state 107.
parser: Shift 'uniqueflag', go to state 370
parser: Shift 'INDEX', go to state 256
parser: Return. Stack=[explain createkw uniqueflag INDEX]
parser: Input 'ID'
parser: Reduce [ifnotexists ::=], go to state 256.
parser: Shift 'ifnotexists', go to state 180
parser: Shift 'ID'
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists ID]
parser: Input 'DOT'
parser: Reduce [nm ::= ID|INDEXED], go to state 180.
parser: Shift 'nm', go to state 255
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm DOT ID]
parser: Input 'ON'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 255.
parser: Shift 'dbnm', go to state 369
parser: Shift 'ON', go to state 179
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON ID]
parser: Input 'LP'
parser: Reduce [nm ::= ID|INDEXED], go to state 179.
parser: Shift 'nm', go to state 368
parser: Shift 'LP', go to state 12
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP STRING]
parser: Input 'RP'
parser: Reduce [term ::= STRING], go to state 12.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 12.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 12.
parser: Shift 'sortlist', go to state 325
parser: Shift 'RP', go to state 254
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP]
parser: Input 'SEMI'
parser: Reduce [where_opt ::=], go to state 254.
parser: Shift 'where_opt'
parser: Reduce [cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt], go to state 2.
parser: Initialize. Empty stack. State 0
parser: Input 'INSERT'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'INSERT', go to state 253
parser: Return. Stack=[explain with INSERT]
parser: Input 'INTO'
parser: Reduce [orconf ::=], go to state 253.
parser: Shift 'orconf'
parser: Reduce [insert_cmd ::= INSERT orconf], go to state 22.
parser: Shift 'insert_cmd', go to state 351
parser: Shift 'INTO', go to state 127
parser: Return. Stack=[explain with insert_cmd INTO]
parser: Input 'STRING'
parser: Shift 'STRING'
parser: Return. Stack=[explain with insert_cmd INTO STRING]
parser: Input 'DOT'
parser: Reduce [nm ::= STRING], go to state 127.
parser: Shift 'nm', go to state 259
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[explain with insert_cmd INTO nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with insert_cmd INTO nm DOT ID]
parser: Input 'VALUES'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 259.
parser: Shift 'dbnm'
parser: Reduce [fullname ::= nm dbnm], go to state 127.
parser: Shift 'fullname', go to state 241
parser: Reduce [idlist_opt ::=], go to state 241.
parser: Shift 'idlist_opt', go to state 147
parser: Reduce [with ::=], go to state 147.
parser: Shift 'with', go to state 113
parser: Shift 'VALUES', go to state 397
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES]
parser: Input 'LP'
parser: Shift 'LP', go to state 15
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP STRING]
parser: Input 'COMMA'
parser: Reduce [term ::= STRING], go to state 15.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 15.
parser: Shift 'expr', go to state 48
parser: Reduce [nexprlist ::= expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'COMMA', go to state 70
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA STRING]
parser: Input 'COMMA'
parser: Reduce [term ::= STRING], go to state 70.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 70.
parser: Shift 'expr', go to state 43
parser: Reduce [nexprlist ::= nexprlist COMMA expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'COMMA', go to state 70
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA STRING]
parser: Input 'COMMA'
parser: Reduce [term ::= STRING], go to state 70.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 70.
parser: Shift 'expr', go to state 43
parser: Reduce [nexprlist ::= nexprlist COMMA expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'COMMA', go to state 70
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA]
parser: Input 'VARIABLE'
parser: Shift 'VARIABLE'
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA VARIABLE]
parser: Input 'COMMA'
parser: Reduce [expr ::= VARIABLE], go to state 70.
parser: Shift 'expr', go to state 43
parser: Reduce [nexprlist ::= nexprlist COMMA expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'COMMA', go to state 70
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA STRING]
parser: Input 'RP'
parser: Reduce [term ::= STRING], go to state 70.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 70.
parser: Shift 'expr', go to state 43
parser: Reduce [nexprlist ::= nexprlist COMMA expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'RP'
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist RP]
parser: Input 'SEMI'
parser: Reduce [values ::= VALUES LP nexprlist RP], go to state 113.
parser: Shift 'values', go to state 400
parser: Reduce [oneselect ::= values], go to state 113.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 113.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 147.
parser: Shift 'select'
parser: Reduce [cmd ::= with insert_cmd INTO fullname idlist_opt select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Input '$'
parser: Reduce [ecmd ::= explain cmdx SEMI], go to state 0.
parser: Shift 'ecmd'
parser: Reduce [cmdlist ::= ecmd], go to state 0.
parser: Shift 'cmdlist', go to state 146
parser: Reduce [input ::= cmdlist], go to state 0.
parser: Accept!
parser: Popping $
parser: Return. Stack=]
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'SELECT'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[explain with SELECT]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'FROM'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[explain with SELECT distinct selcollist FROM]
parser: Input 'STRING'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'STRING'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix STRING]
parser: Input 'DOT'
parser: Reduce [nm ::= STRING], go to state 165.
parser: Shift 'nm', go to state 287
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Shift 'WHERE', go to state 65
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'AND', go to state 93
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 93.
parser: Shift 'expr', go to state 53
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND expr EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND expr EQ STRING]
parser: Input 'ORDER'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 93.
parser: Shift 'expr', go to state 53
parser: Reduce [expr ::= expr AND expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Reduce [where_opt ::= WHERE expr], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Shift 'ORDER', go to state 411
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY'
parser: Shift 'BY', go to state 17
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI'
parser: Reduce [expr ::= ID|INDEXED], go to state 17.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 17.
parser: Shift 'sortlist', go to state 410
parser: Reduce [orderby_opt ::= ORDER BY sortlist], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 22.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 2.
parser: Shift 'select'
parser: Reduce [cmd ::= select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'CREATE'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Shift 'CREATE'
parser: Return. Stack=[explain CREATE]
parser: Input 'INDEX'
parser: Reduce [createkw ::= CREATE], go to state 2.
parser: Shift 'createkw', go to state 107
parser: Reduce [uniqueflag ::=], go to state 107.
parser: Shift 'uniqueflag', go to state 370
parser: Shift 'INDEX', go to state 256
parser: Return. Stack=[explain createkw uniqueflag INDEX]
parser: Input 'ID'
parser: Reduce [ifnotexists ::=], go to state 256.
parser: Shift 'ifnotexists', go to state 180
parser: Shift 'ID'
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists ID]
parser: Input 'ON'
parser: Reduce [nm ::= ID|INDEXED], go to state 180.
parser: Shift 'nm', go to state 255
parser: Reduce [dbnm ::=], go to state 255.
parser: Shift 'dbnm', go to state 369
parser: Shift 'ON', go to state 179
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON ID]
parser: Input 'LP'
parser: Reduce [nm ::= ID|INDEXED], go to state 179.
parser: Shift 'nm', go to state 368
parser: Shift 'LP', go to state 12
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP STRING]
parser: Input 'RP'
parser: Reduce [term ::= STRING], go to state 12.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 12.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 12.
parser: Shift 'sortlist', go to state 325
parser: Shift 'RP', go to state 254
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP]
parser: Input 'SEMI'
parser: Reduce [where_opt ::=], go to state 254.
parser: Shift 'where_opt'
parser: Reduce [cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'CREATE'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Shift 'CREATE'
parser: Return. Stack=[explain CREATE]
parser: Input 'INDEX'
parser: Reduce [createkw ::= CREATE], go to state 2.
parser: Shift 'createkw', go to state 107
parser: Reduce [uniqueflag ::=], go to state 107.
parser: Shift 'uniqueflag', go to state 370
parser: Shift 'INDEX', go to state 256
parser: Return. Stack=[explain createkw uniqueflag INDEX]
parser: Input 'ID'
parser: Reduce [ifnotexists ::=], go to state 256.
parser: Shift 'ifnotexists', go to state 180
parser: Shift 'ID'
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists ID]
parser: Input 'DOT'
parser: Reduce [nm ::= ID|INDEXED], go to state 180.
parser: Shift 'nm', go to state 255
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm DOT ID]
parser: Input 'ON'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 255.
parser: Shift 'dbnm', go to state 369
parser: Shift 'ON', go to state 179
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON ID]
parser: Input 'LP'
parser: Reduce [nm ::= ID|INDEXED], go to state 179.
parser: Shift 'nm', go to state 368
parser: Shift 'LP', go to state 12
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP STRING]
parser: Input 'COLLATE'
parser: Reduce [term ::= STRING], go to state 12.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 12.
parser: Shift 'expr', go to state 9
parser: Shift 'COLLATE', go to state 339
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP expr COLLATE]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP expr COLLATE ID]
parser: Input 'ASC'
parser: Reduce [expr ::= expr COLLATE ID|STRING], go to state 12.
parser: Shift 'expr', go to state 9
parser: Shift 'ASC'
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP expr ASC]
parser: Input 'RP'
parser: Reduce [sortorder ::= ASC], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 12.
parser: Shift 'sortlist', go to state 325
parser: Shift 'RP', go to state 254
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP]
parser: Input 'SEMI'
parser: Reduce [where_opt ::=], go to state 254.
parser: Shift 'where_opt'
parser: Reduce [cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt], go to state 2.
parser: Initialize. Empty stack. State 0
parser: Input 'INSERT'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'INSERT', go to state 253
parser: Return. Stack=[explain with INSERT]
parser: Input 'INTO'
parser: Reduce [orconf ::=], go to state 253.
parser: Shift 'orconf'
parser: Reduce [insert_cmd ::= INSERT orconf], go to state 22.
parser: Shift 'insert_cmd', go to state 351
parser: Shift 'INTO', go to state 127
parser: Return. Stack=[explain with insert_cmd INTO]
parser: Input 'STRING'
parser: Shift 'STRING'
parser: Return. Stack=[explain with insert_cmd INTO STRING]
parser: Input 'DOT'
parser: Reduce [nm ::= STRING], go to state 127.
parser: Shift 'nm', go to state 259
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[explain with insert_cmd INTO nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with insert_cmd INTO nm DOT ID]
parser: Input 'VALUES'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 259.
parser: Shift 'dbnm'
parser: Reduce [fullname ::= nm dbnm], go to state 127.
parser: Shift 'fullname', go to state 241
parser: Reduce [idlist_opt ::=], go to state 241.
parser: Shift 'idlist_opt', go to state 147
parser: Reduce [with ::=], go to state 147.
parser: Shift 'with', go to state 113
parser: Shift 'VALUES', go to state 397
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES]
parser: Input 'LP'
parser: Shift 'LP', go to state 15
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP STRING]
parser: Input 'COMMA'
parser: Reduce [term ::= STRING], go to state 15.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 15.
parser: Shift 'expr', go to state 48
parser: Reduce [nexprlist ::= expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'COMMA', go to state 70
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA STRING]
parser: Input 'COMMA'
parser: Reduce [term ::= STRING], go to state 70.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 70.
parser: Shift 'expr', go to state 43
parser: Reduce [nexprlist ::= nexprlist COMMA expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'COMMA', go to state 70
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA STRING]
parser: Input 'COMMA'
parser: Reduce [term ::= STRING], go to state 70.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 70.
parser: Shift 'expr', go to state 43
parser: Reduce [nexprlist ::= nexprlist COMMA expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'COMMA', go to state 70
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA]
parser: Input 'VARIABLE'
parser: Shift 'VARIABLE'
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA VARIABLE]
parser: Input 'COMMA'
parser: Reduce [expr ::= VARIABLE], go to state 70.
parser: Shift 'expr', go to state 43
parser: Reduce [nexprlist ::= nexprlist COMMA expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'COMMA', go to state 70
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist COMMA STRING]
parser: Input 'RP'
parser: Reduce [term ::= STRING], go to state 70.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 70.
parser: Shift 'expr', go to state 43
parser: Reduce [nexprlist ::= nexprlist COMMA expr], go to state 15.
parser: Shift 'nexprlist', go to state 332
parser: Shift 'RP'
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with VALUES LP nexprlist RP]
parser: Input 'SEMI'
parser: Reduce [values ::= VALUES LP nexprlist RP], go to state 113.
parser: Shift 'values', go to state 400
parser: Reduce [oneselect ::= values], go to state 113.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 113.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 147.
parser: Shift 'select'
parser: Reduce [cmd ::= with insert_cmd INTO fullname idlist_opt select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Input '$'
parser: Reduce [ecmd ::= explain cmdx SEMI], go to state 0.
parser: Shift 'ecmd'
parser: Reduce [cmdlist ::= ecmd], go to state 0.
parser: Shift 'cmdlist', go to state 146
parser: Reduce [input ::= cmdlist], go to state 0.
parser: Accept!
parser: Popping $
parser: Return. Stack=]
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'SELECT'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[explain with SELECT]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'COMMA'
parser: Return. Stack=[explain with SELECT distinct selcollist COMMA]
parser: Input 'ID'
parser: Reduce [sclp ::= selcollist COMMA], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp ID]
parser: Input 'FROM'
parser: Reduce [expr ::= ID|INDEXED], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[explain with SELECT distinct selcollist FROM]
parser: Input 'STRING'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'STRING'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix STRING]
parser: Input 'DOT'
parser: Reduce [nm ::= STRING], go to state 165.
parser: Shift 'nm', go to state 287
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Shift 'WHERE', go to state 65
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'AND', go to state 93
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 93.
parser: Shift 'expr', go to state 53
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND expr EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND expr EQ STRING]
parser: Input 'ORDER'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 93.
parser: Shift 'expr', go to state 53
parser: Reduce [expr ::= expr AND expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Reduce [where_opt ::= WHERE expr], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Shift 'ORDER', go to state 411
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY'
parser: Shift 'BY', go to state 17
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI'
parser: Reduce [expr ::= ID|INDEXED], go to state 17.
parser: Shift 'expr', go to state 9
parser: Reduce [sortorder ::=], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 17.
parser: Shift 'sortlist', go to state 410
parser: Reduce [orderby_opt ::= ORDER BY sortlist], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 22.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 2.
parser: Shift 'select'
parser: Reduce [cmd ::= select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'CREATE'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Shift 'CREATE'
parser: Return. Stack=[explain CREATE]
parser: Input 'INDEX'
parser: Reduce [createkw ::= CREATE], go to state 2.
parser: Shift 'createkw', go to state 107
parser: Reduce [uniqueflag ::=], go to state 107.
parser: Shift 'uniqueflag', go to state 370
parser: Shift 'INDEX', go to state 256
parser: Return. Stack=[explain createkw uniqueflag INDEX]
parser: Input 'ID'
parser: Reduce [ifnotexists ::=], go to state 256.
parser: Shift 'ifnotexists', go to state 180
parser: Shift 'ID'
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists ID]
parser: Input 'ON'
parser: Reduce [nm ::= ID|INDEXED], go to state 180.
parser: Shift 'nm', go to state 255
parser: Reduce [dbnm ::=], go to state 255.
parser: Shift 'dbnm', go to state 369
parser: Shift 'ON', go to state 179
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON ID]
parser: Input 'LP'
parser: Reduce [nm ::= ID|INDEXED], go to state 179.
parser: Shift 'nm', go to state 368
parser: Shift 'LP', go to state 12
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP STRING]
parser: Input 'COLLATE'
parser: Reduce [term ::= STRING], go to state 12.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 12.
parser: Shift 'expr', go to state 9
parser: Shift 'COLLATE', go to state 339
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP expr COLLATE]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP expr COLLATE ID]
parser: Input 'ASC'
parser: Reduce [expr ::= expr COLLATE ID|STRING], go to state 12.
parser: Shift 'expr', go to state 9
parser: Shift 'ASC'
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP expr ASC]
parser: Input 'RP'
parser: Reduce [sortorder ::= ASC], go to state 9.
parser: Shift 'sortorder'
parser: Reduce [sortlist ::= expr sortorder], go to state 12.
parser: Shift 'sortlist', go to state 325
parser: Shift 'RP', go to state 254
parser: Return. Stack=[explain createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP]
parser: Input 'SEMI'
parser: Reduce [where_opt ::=], go to state 254.
parser: Shift 'where_opt'
parser: Reduce [cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'SELECT'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[explain with SELECT]
parser: Input 'STRING'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with SELECT distinct sclp STRING]
parser: Input 'CONCAT'
parser: Reduce [term ::= STRING], go to state 54.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 54.
parser: Shift 'expr', go to state 8
parser: Shift 'CONCAT', go to state 86
parser: Return. Stack=[explain with SELECT distinct sclp expr CONCAT]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp expr CONCAT ID]
parser: Input 'LP'
parser: Shift 'LP', go to state 216
parser: Return. Stack=[explain with SELECT distinct sclp expr CONCAT ID LP]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 216.
parser: Shift 'distinct', go to state 6
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp expr CONCAT ID LP distinct ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 6.
parser: Shift 'expr', go to state 48
parser: Reduce [nexprlist ::= expr], go to state 6.
parser: Shift 'nexprlist', go to state 412
parser: Shift 'COMMA', go to state 70
parser: Return. Stack=[explain with SELECT distinct sclp expr CONCAT ID LP distinct nexprlist COMMA]
parser: Input 'INTEGER'
parser: Shift 'INTEGER'
parser: Return. Stack=[explain with SELECT distinct sclp expr CONCAT ID LP distinct nexprlist COMMA INTEGER]
parser: Input 'RP'
parser: Reduce [term ::= INTEGER|FLOAT|BLOB], go to state 70.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 70.
parser: Shift 'expr', go to state 43
parser: Reduce [nexprlist ::= nexprlist COMMA expr], go to state 6.
parser: Shift 'nexprlist', go to state 412
parser: Reduce [exprlist ::= nexprlist], go to state 6.
parser: Shift 'exprlist', go to state 394
parser: Shift 'RP'
parser: Return. Stack=[explain with SELECT distinct sclp expr CONCAT ID LP distinct exprlist RP]
parser: Input 'FROM'
parser: Reduce [expr ::= ID|INDEXED LP distinct exprlist RP], go to state 86.
parser: Shift 'expr', go to state 114
parser: Reduce [expr ::= expr CONCAT expr], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[explain with SELECT distinct selcollist FROM]
parser: Input 'ID'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'ID'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'WHERE'
parser: Reduce [nm ::= ID|INDEXED], go to state 165.
parser: Shift 'nm', go to state 287
parser: Reduce [dbnm ::=], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Shift 'WHERE', go to state 65
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE ID]
parser: Input 'LIKE_KW'
parser: FALLBACK LIKE_KW => ID
parser: Reduce [expr ::= ID|INDEXED], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'LIKE_KW'
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr LIKE_KW]
parser: Input 'STRING'
parser: Reduce [likeop ::= LIKE_KW|MATCH], go to state 40.
parser: Shift 'likeop', go to state 85
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr likeop STRING]
parser: Input 'SEMI'
parser: Reduce [term ::= STRING], go to state 85.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 85.
parser: Shift 'expr', go to state 97
parser: Reduce [expr ::= expr likeop expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Reduce [where_opt ::= WHERE expr], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Reduce [orderby_opt ::=], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 22.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 2.
parser: Shift 'select'
parser: Reduce [cmd ::= select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'SELECT'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[explain with SELECT]
parser: Input 'STRING'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with SELECT distinct sclp STRING]
parser: Input 'CONCAT'
parser: Reduce [term ::= STRING], go to state 54.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 54.
parser: Shift 'expr', go to state 8
parser: Shift 'CONCAT', go to state 86
parser: Return. Stack=[explain with SELECT distinct sclp expr CONCAT]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp expr CONCAT ID]
parser: Input 'LP'
parser: Shift 'LP', go to state 216
parser: Return. Stack=[explain with SELECT distinct sclp expr CONCAT ID LP]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 216.
parser: Shift 'distinct', go to state 6
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp expr CONCAT ID LP distinct ID]
parser: Input 'RP'
parser: Reduce [expr ::= ID|INDEXED], go to state 6.
parser: Shift 'expr', go to state 48
parser: Reduce [nexprlist ::= expr], go to state 6.
parser: Shift 'nexprlist', go to state 412
parser: Reduce [exprlist ::= nexprlist], go to state 6.
parser: Shift 'exprlist', go to state 394
parser: Shift 'RP'
parser: Return. Stack=[explain with SELECT distinct sclp expr CONCAT ID LP distinct exprlist RP]
parser: Input 'CONCAT'
parser: Reduce [expr ::= ID|INDEXED LP distinct exprlist RP], go to state 86.
parser: Shift 'expr', go to state 114
parser: Reduce [expr ::= expr CONCAT expr], go to state 54.
parser: Shift 'expr', go to state 8
parser: Shift 'CONCAT', go to state 86
parser: Return. Stack=[explain with SELECT distinct sclp expr CONCAT]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with SELECT distinct sclp expr CONCAT STRING]
parser: Input 'CONCAT'
parser: Reduce [term ::= STRING], go to state 86.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 86.
parser: Shift 'expr', go to state 114
parser: Reduce [expr ::= expr CONCAT expr], go to state 54.
parser: Shift 'expr', go to state 8
parser: Shift 'CONCAT', go to state 86
parser: Return. Stack=[explain with SELECT distinct sclp expr CONCAT]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp expr CONCAT ID]
parser: Input 'LP'
parser: Shift 'LP', go to state 216
parser: Return. Stack=[explain with SELECT distinct sclp expr CONCAT ID LP]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 216.
parser: Shift 'distinct', go to state 6
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct sclp expr CONCAT ID LP distinct ID]
parser: Input 'RP'
parser: Reduce [expr ::= ID|INDEXED], go to state 6.
parser: Shift 'expr', go to state 48
parser: Reduce [nexprlist ::= expr], go to state 6.
parser: Shift 'nexprlist', go to state 412
parser: Reduce [exprlist ::= nexprlist], go to state 6.
parser: Shift 'exprlist', go to state 394
parser: Shift 'RP'
parser: Return. Stack=[explain with SELECT distinct sclp expr CONCAT ID LP distinct exprlist RP]
parser: Input 'CONCAT'
parser: Reduce [expr ::= ID|INDEXED LP distinct exprlist RP], go to state 86.
parser: Shift 'expr', go to state 114
parser: Reduce [expr ::= expr CONCAT expr], go to state 54.
parser: Shift 'expr', go to state 8
parser: Shift 'CONCAT', go to state 86
parser: Return. Stack=[explain with SELECT distinct sclp expr CONCAT]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with SELECT distinct sclp expr CONCAT STRING]
parser: Input 'FROM'
parser: Reduce [term ::= STRING], go to state 86.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 86.
parser: Shift 'expr', go to state 114
parser: Reduce [expr ::= expr CONCAT expr], go to state 54.
parser: Shift 'expr', go to state 8
parser: Reduce [as ::=], go to state 8.
parser: Shift 'as'
parser: Reduce [selcollist ::= sclp expr as], go to state 159.
parser: Shift 'selcollist', go to state 232
parser: Shift 'FROM', go to state 158
parser: Return. Stack=[explain with SELECT distinct selcollist FROM]
parser: Input 'ID'
parser: Reduce [stl_prefix ::=], go to state 158.
parser: Shift 'stl_prefix', go to state 165
parser: Shift 'ID'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'DOT'
parser: Reduce [nm ::= ID|INDEXED], go to state 165.
parser: Shift 'nm', go to state 287
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE'
parser: Reduce [nm ::= ID|INDEXED], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 287.
parser: Shift 'dbnm', go to state 195
parser: Reduce [as ::=], go to state 195.
parser: Shift 'as', go to state 228
parser: Reduce [indexed_opt ::=], go to state 228.
parser: Shift 'indexed_opt', go to state 286
parser: Reduce [on_opt ::=], go to state 286.
parser: Shift 'on_opt', go to state 285
parser: Reduce [using_opt ::=], go to state 285.
parser: Shift 'using_opt'
parser: Reduce [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 158.
parser: Shift 'seltablist', go to state 214
parser: Reduce [from ::= FROM seltablist], go to state 232.
parser: Shift 'from', go to state 298
parser: Shift 'WHERE', go to state 65
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ'
parser: Reduce [expr ::= ID|INDEXED], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'EQ', go to state 90
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'AND', go to state 93
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'NE'
parser: Reduce [expr ::= ID|INDEXED], go to state 93.
parser: Shift 'expr', go to state 53
parser: Shift 'NE', go to state 90
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND expr NE]
parser: Input 'STRING'
parser: Shift 'STRING', go to state 436
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND expr NE STRING]
parser: Input 'AND'
parser: Reduce [term ::= STRING], go to state 90.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 90.
parser: Shift 'expr', go to state 102
parser: Reduce [expr ::= expr EQ|NE expr], go to state 93.
parser: Shift 'expr', go to state 53
parser: Reduce [expr ::= expr AND expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Shift 'AND', go to state 93
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID'
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'LP'
parser: Shift 'LP', go to state 216
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND ID LP]
parser: Input 'ID'
parser: Reduce [distinct ::=], go to state 216.
parser: Shift 'distinct', go to state 6
parser: Shift 'ID', go to state 340
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND ID LP distinct ID]
parser: Input 'COMMA'
parser: Reduce [expr ::= ID|INDEXED], go to state 6.
parser: Shift 'expr', go to state 48
parser: Reduce [nexprlist ::= expr], go to state 6.
parser: Shift 'nexprlist', go to state 412
parser: Shift 'COMMA', go to state 70
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND ID LP distinct nexprlist COMMA]
parser: Input 'INTEGER'
parser: Shift 'INTEGER'
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND ID LP distinct nexprlist COMMA INTEGER]
parser: Input 'RP'
parser: Reduce [term ::= INTEGER|FLOAT|BLOB], go to state 70.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 70.
parser: Shift 'expr', go to state 43
parser: Reduce [nexprlist ::= nexprlist COMMA expr], go to state 6.
parser: Shift 'nexprlist', go to state 412
parser: Reduce [exprlist ::= nexprlist], go to state 6.
parser: Shift 'exprlist', go to state 394
parser: Shift 'RP'
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND ID LP distinct exprlist RP]
parser: Input 'GT'
parser: Reduce [expr ::= ID|INDEXED LP distinct exprlist RP], go to state 93.
parser: Shift 'expr', go to state 53
parser: Shift 'GT', go to state 91
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND expr GT]
parser: Input 'INTEGER'
parser: Shift 'INTEGER'
parser: Return. Stack=[explain with SELECT distinct selcollist from WHERE expr AND expr GT INTEGER]
parser: Input 'SEMI'
parser: Reduce [term ::= INTEGER|FLOAT|BLOB], go to state 91.
parser: Shift 'term'
parser: Reduce [expr ::= term], go to state 91.
parser: Shift 'expr', go to state 103
parser: Reduce [expr ::= expr LT|GT|GE|LE expr], go to state 93.
parser: Shift 'expr', go to state 53
parser: Reduce [expr ::= expr AND expr], go to state 65.
parser: Shift 'expr', go to state 40
parser: Reduce [where_opt ::= WHERE expr], go to state 298.
parser: Shift 'where_opt', go to state 297
parser: Reduce [groupby_opt ::=], go to state 297.
parser: Shift 'groupby_opt', go to state 296
parser: Reduce [having_opt ::=], go to state 296.
parser: Shift 'having_opt', go to state 295
parser: Reduce [orderby_opt ::=], go to state 295.
parser: Shift 'orderby_opt', go to state 294
parser: Reduce [limit_opt ::=], go to state 294.
parser: Shift 'limit_opt'
parser: Reduce [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 22.
parser: Shift 'oneselect'
parser: Reduce [selectnowith ::= oneselect], go to state 22.
parser: Shift 'selectnowith', go to state 215
parser: Reduce [select ::= with selectnowith], go to state 2.
parser: Shift 'select'
parser: Reduce [cmd ::= select], go to state 2.
parser: Shift 'cmd'
parser: Reduce [cmdx ::= cmd], go to state 2.
parser: Shift 'cmdx', go to state 439
parser: Shift 'SEMI'
parser: Return. Stack=[explain cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping explain
parser: Popping $
parser: Initialize. Empty stack. State 0
parser: Input 'INSERT'
parser: Reduce [explain ::=], go to state 0.
parser: Shift 'explain', go to state 2
parser: Reduce [with ::=], go to state 2.
parser: Shift 'with', go to state 22
parser: Shift 'INSERT', go to state 253
parser: Return. Stack=[explain with INSERT]
parser: Input 'INTO'
parser: Reduce [orconf ::=], go to state 253.
parser: Shift 'orconf'
parser: Reduce [insert_cmd ::= INSERT orconf], go to state 22.
parser: Shift 'insert_cmd', go to state 351
parser: Shift 'INTO', go to state 127
parser: Return. Stack=[explain with insert_cmd INTO]
parser: Input 'ID'
parser: Shift 'ID'
parser: Return. Stack=[explain with insert_cmd INTO ID]
parser: Input 'DOT'
parser: Reduce [nm ::= ID|INDEXED], go to state 127.
parser: Shift 'nm', go to state 259
parser: Shift 'DOT', go to state 196
parser: Return. Stack=[explain with insert_cmd INTO nm DOT]
parser: Input 'STRING'
parser: Shift 'STRING'
parser: Return. Stack=[explain with insert_cmd INTO nm DOT STRING]
parser: Input 'SELECT'
parser: Reduce [nm ::= STRING], go to state 196.
parser: Shift 'nm'
parser: Reduce [dbnm ::= DOT nm], go to state 259.
parser: Shift 'dbnm'
parser: Reduce [fullname ::= nm dbnm], go to state 127.
parser: Shift 'fullname', go to state 241
parser: Reduce [idlist_opt ::=], go to state 241.
parser: Shift 'idlist_opt', go to state 147
parser: Reduce [with ::=], go to state 147.
parser: Shift 'with', go to state 113
parser: Shift 'SELECT', go to state 233
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with SELECT]
parser: Input 'STAR'
parser: Reduce [distinct ::=], go to state 233.
parser: Shift 'distinct', go to state 159
parser: Reduce [sclp ::=], go to state 159.
parser: Shift 'sclp', go to state 54
parser: Shift 'STAR'
parser: Return. Stack=[explain with insert_cmd INTO fullname idlist_opt with SELECT distinct sclp STAR]
parser: Input 'FROM'
parser: Reduce [selcollist ::= sclp STAR], go to state 159.
parser: Shift 'selcollist', go to stat
Program received signal SIGABRT, Aborted.
__GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:50
(gdb) #0  __GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:50
#1  0x00007fa68f733859 in __GI_abort () at abort.c:79
#2  0x00007fa68f733729 in __assert_fail_base (fmt=0x7fa68f8c9588 "%s%s%s:%u: %s%sAssertion `%s' failed.\n%n", assertion=0x227729 "sqlite3_stricmp(sqlite3StrBINARY, zColl)!=0 || sqlite3StrBINARY==zColl", 
    file=0x222c23 "sqlite3.c", line=108020, function=<optimized out>) at assert.c:92
#3  0x00007fa68f744fd6 in __GI___assert_fail (assertion=0x227729 "sqlite3_stricmp(sqlite3StrBINARY, zColl)!=0 || sqlite3StrBINARY==zColl", file=0x222c23 "sqlite3.c", line=108020, 
    function=0x20a00b "int xferOptimization(Parse *, Table *, Select *, int, int)") at assert.c:101
#4  0x0000000000345560 in sqlite3Insert (pParse=<optimized out>, pTabList=<optimized out>, pSelect=<optimized out>, pColumn=0x0, onError=<optimized out>) at sqlite3.c:108019
#5  0x00000000003066b3 in yy_reduce (yypParser=0x171b400, yyruleno=<optimized out>) at sqlite3.c:133484
#6  0x00000000002fef8e in sqlite3Parser (yyp=0x171b400, yymajor=<optimized out>, yyminor=..., pParse=<optimized out>) at sqlite3.c:134258
#7  0x00000000002fc544 in sqlite3RunParser (pParse=0x16723b0, zSql=0x1680320 "INSERT INTO vacuum_db.'t10' SELECT * FROM main.'t10';", pzErrMsg=0x7fffe58d5268) at sqlite3.c:135186
#8  0x00000000002facac in sqlite3Prepare (db=0x166f850, zSql=0x1680320 "INSERT INTO vacuum_db.'t10' SELECT * FROM main.'t10';", nBytes=<optimized out>, saveSqlFlag=0, pReprepare=<optimized out>, ppStmt=0x7fffe58d5328, 
    pzTail=0x0) at sqlite3.c:112596
#9  0x00000000002fa0f4 in sqlite3LockAndPrepare (db=0x166f850, zSql=0x1680320 "INSERT INTO vacuum_db.'t10' SELECT * FROM main.'t10';", nBytes=-1, saveSqlFlag=0, pOld=0x0, ppStmt=<optimized out>, pzTail=0x0)
    at sqlite3.c:112688
#10 0x00000000003fb16b in execSql (db=0x166f850, pzErrMsg=0x1686e78, zSql=<optimized out>) at sqlite3.c:112752
#11 0x00000000003fb5ec in execExecSql (db=0x166f850, pzErrMsg=0x1686e78, zSql=<optimized out>) at sqlite3.c:120748
#12 0x00000000003de49e in sqlite3VdbeExec (p=<optimized out>) at sqlite3.c:120939
#13 0x000000000028b140 in sqlite3_step (pStmt=<optimized out>) at sqlite3.c:75131
#14 0x000000000024b5e9 in main (argc=1, argv=0x7fffe58d5ac8) at target.cc:139
(gdb) quit
A debugging session is active.

	Inferior 1 [process 10746] will be killed.

Quit anyway? (y or n) [answered Y; input not from terminal]
