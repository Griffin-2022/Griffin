GNU gdb (Ubuntu 9.2-0ubuntu1~20.04.1) 9.2
Copyright (C) 2020 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type "show copying" and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
    <http://www.gnu.org/software/gdb/documentation/>.

For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from /root/sqlite_driver_fast...
(gdb) Starting program: /root/sqlite_driver_fast < "/root/out/default/crashes/id:000407,sig:06,src:020805+012652,time:13500691,execs:3379953,op:merge.so,pos:0"
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
SQL: [;PRAGMA vdbe_trace=on;]
VDBE Trace:
   0 Init             0    1    0               00 Start at 1
   1 Expire           0    0    0               00 
   2 Halt             0    0    0               00 
SQL: [SELECT (SELECT 1, 2, 3) == (SELECT 1, 2, 3)
;]
VDBE Trace:
   0 Init             0    1    0               00 Start at 1
   1 Explain          1    0    0 SCAN CONSTANT ROW 00 
   2 Integer         12    2    0               00 r[2]=12; return address
REG[2] =  i:12
   3 Once             0   12    0               00 
   4 Explain          4    0    0 SCALAR SUBQUERY 1 00 
   5 Null             0    3    5               00 r[3..5]=NULL; Init subquery result
REG[3] =  NULL
   6 Integer          1    6    0               00 r[6]=1; LIMIT counter
REG[6] =  i:1
   7 Explain          7    4    0 SCAN CONSTANT ROW 00 
   8 Integer          1    3    0               00 r[3]=1
REG[3] =  i:1
   9 Integer          2    4    0               00 r[4]=2
REG[4] =  i:2
  10 Integer          3    5    0               00 r[5]=3
REG[5] =  i:3
  11 DecrJumpZero     6   12    0               00 if (--r[6])==0 goto 12
REG[6] =  i:1
  12 Return           2    0    0               00 
REG[2] =  i:12
  13 Integer         23    7    0               00 r[7]=23; return address
REG[7] =  i:23
  14 Once             0   23    0               00 
  15 Explain         15    0    0 SCALAR SUBQUERY 2 00 
  16 Null             0    8   10               00 r[8..10]=NULL; Init subquery result
REG[8] =  NULL
  17 Integer          1   11    0               00 r[11]=1; LIMIT counter
REG[11] =  i:1
  18 Explain         18   15    0 SCAN CONSTANT ROW 00 
  19 Integer          1    8    0               00 r[8]=1
REG[8] =  i:1
  20 Integer          2    9    0               00 r[9]=2
REG[9] =  i:2
  21 Integer          3   10    0               00 r[10]=3
REG[10] =  i:3
  22 DecrJumpZero    11   23    0               00 if (--r[11])==0 goto 23
REG[11] =  i:1
  23 Return           7    0    0               00 
REG[7] =  i:23
  24 Eq               8    1    3               61 r[1] = (r[3]==r[8])
REG[8] =  i:1
REG[3] =  i:1
REG[1] =  i:1
  25 IfNot            1   29    0               00 
REG[1] =  i:1
  26 Eq               9    1    4               69 r[1] = (r[4]==r[9])
REG[9] =  i:2
REG[4] =  i:2
  27 IfNot            1   29    0               00 
REG[1] =  i:1
  28 Eq              10    1    5               69 r[1] = (r[5]==r[10])
REG[10] =  i:3
REG[5] =  i:3
  29 ResultRow        1    1    0               00 output=r[1]
REG[1] =  i:1
  30 Halt             0    0    0               00 
SQL: [select zeroblob(-100)
;]
VDBE Trace:
   0 Init             0    5    0               00 Start at 5
   5 Integer       -100    3    0               00 r[3]=-100
REG[3] =  i:-100
   6 Function0        1    3    2 zeroblob(1)   01 r[2]=func(r[3])
REG[3] =  i:-100
REG[2] =  s0[]+0z
   7 Goto             0    1    0               00 
   1 Explain          1    0    0 SCAN CONSTANT ROW 00 
   2 Copy             2    1    0               00 r[1]=r[2]
REG[1] =  s0[]
   3 ResultRow        1    1    0               00 output=r[1]
REG[1] =  s0[]
   4 Halt             0    0    0               00 
SQL: [SELECT (1, 0, 3) != (1, 2, 3)
;]
VDBE Trace:
   0 Init             0    9    0               00 Start at 9
   9 Integer          1    2    0               00 r[2]=1
REG[2] =  i:1
  10 Integer          0    3    0               00 r[3]=0
REG[3] =  i:0
  11 Integer          2    4    0               00 r[4]=2
REG[4] =  i:2
  12 Integer          3    5    0               00 r[5]=3
REG[5] =  i:3
  13 Goto             0    1    0               00 
   1 Explain          1    0    0 SCAN CONSTANT ROW 00 
   2 Ne               2    1    2               61 r[1] = (r[2]!=r[2])
REG[2] =  i:1
REG[2] =  i:1
REG[1] =  i:0
   3 If               1    7    0               00 
REG[1] =  i:0
   4 Ne               4    1    3               69 r[1] = (r[3]!=r[4])
REG[4] =  i:2
REG[3] =  i:0
REG[1] =  i:1
   5 If               1    7    0               00 
REG[1] =  i:1
   7 ResultRow        1    1    0               00 output=r[1]
REG[1] =  i:1
   8 Halt             0    0    0               00 
SQL: [SELECT (1, 0, 3) IS (1, 2, 3)
;]
VDBE Trace:
   0 Init             0    9    0               00 Start at 9
   9 Integer          1    2    0               00 r[2]=1
REG[2] =  i:1
  10 Integer          0    3    0               00 r[3]=0
REG[3] =  i:0
  11 Integer          2    4    0               00 r[4]=2
REG[4] =  i:2
  12 Integer          3    5    0               00 r[5]=3
REG[5] =  i:3
  13 Goto             0    1    0               00 
   1 Explain          1    0    0 SCAN CONSTANT ROW 00 
   2 Eq               2    1    2               E1 r[1] = (r[2]==r[2])
REG[2] =  i:1
REG[2] =  i:1
REG[1] =  i:1
   3 IfNot            1    7    0               00 
REG[1] =  i:1
   4 Eq               4    1    3               E9 r[1] = (r[3]==r[4])
REG[4] =  i:2
REG[3] =  i:0
REG[1] =  i:0
   5 IfNot            1    7    0               00 
REG[1] =  i:0
   7 ResultRow        1    1    0               00 output=r[1]
REG[1] =  i:0
   8 Halt             0    0    0               00 
SQL: [SELECT (1, 0, 3) IS NOT (1, 2, 3)
;]
VDBE Trace:
   0 Init             0    9    0               00 Start at 9
   9 Integer          1    2    0               00 r[2]=1
REG[2] =  i:1
  10 Integer          0    3    0               00 r[3]=0
REG[3] =  i:0
  11 Integer          2    4    0               00 r[4]=2
REG[4] =  i:2
  12 Integer          3    5    0               00 r[5]=3
REG[5] =  i:3
  13 Goto             0    1    0               00 
   1 Explain          1    0    0 SCAN CONSTANT ROW 00 
   2 Ne               2    1    2               E1 r[1] = (r[2]!=r[2])
REG[2] =  i:1
REG[2] =  i:1
REG[1] =  i:0
   3 If               1    7    0               00 
REG[1] =  i:0
   4 Ne               4    1    3               E9 r[1] = (r[3]!=r[4])
REG[4] =  i:2
REG[3] =  i:0
REG[1] =  i:1
   5 If               1    7    0               00 
REG[1] =  i:1
   7 ResultRow        1    1    0               00 output=r[1]
REG[1] =  i:1
   8 Halt             0    0    0               00 
SQL: [SELECT (SELECT 1, 0, 3) == (SELECT 1, 2, 3)
;]
VDBE Trace:
   0 Init             0    1    0               00 Start at 1
   1 Explain          1    0    0 SCAN CONSTANT ROW 00 
   2 Integer         12    2    0               00 r[2]=12; return address
REG[2] =  i:12
   3 Once             0   12    0               00 
   4 Explain          4    0    0 SCALAR SUBQUERY 1 00 
   5 Null             0    3    5               00 r[3..5]=NULL; Init subquery result
REG[3] =  NULL
   6 Integer          1    6    0               00 r[6]=1; LIMIT counter
REG[6] =  i:1
   7 Explain          7    4    0 SCAN CONSTANT ROW 00 
   8 Integer          1    3    0               00 r[3]=1
REG[3] =  i:1
   9 Integer          0    4    0               00 r[4]=0
REG[4] =  i:0
  10 Integer          3    5    0               00 r[5]=3
REG[5] =  i:3
  11 DecrJumpZero     6   12    0               00 if (--r[6])==0 goto 12
REG[6] =  i:1
  12 Return           2    0    0               00 
REG[2] =  i:12
  13 Integer         23    7    0               00 r[7]=23; return address
REG[7] =  i:23
  14 Once             0   23    0               00 
  15 Explain         15    0    0 SCALAR SUBQUERY 2 00 
  16 Null             0    8   10               00 r[8..10]=NULL; Init subquery result
REG[8] =  NULL
  17 Integer          1   11    0               00 r[11]=1; LIMIT counter
REG[11] =  i:1
  18 Explain         18   15    0 SCAN CONSTANT ROW 00 
  19 Integer          1    8    0               00 r[8]=1
REG[8] =  i:1
  20 Integer          2    9    0               00 r[9]=2
REG[9] =  i:2
  21 Integer          3   10    0               00 r[10]=3
REG[10] =  i:3
  22 DecrJumpZero    11   23    0               00 if (--r[11])==0 goto 23
REG[11] =  i:1
  23 Return           7    0    0               00 
REG[7] =  i:23
  24 Eq               8    1    3               61 r[1] = (r[3]==r[8])
REG[8] =  i:1
REG[3] =  i:1
REG[1] =  i:1
  25 IfNot            1   29    0               00 
REG[1] =  i:1
  26 Eq               9    1    4               69 r[1] = (r[4]==r[9])
REG[9] =  i:2
REG[4] =  i:0
REG[1] =  i:0
  27 IfNot            1   29    0               00 
REG[1] =  i:0
  29 ResultRow        1    1    0               00 output=r[1]
REG[1] =  i:0
  30 Halt             0    0    0               00 
SQL: [SELECT (SELECT 1, 0, 3) != (SELECT 1, 2, 3)
;]
VDBE Trace:
   0 Init             0    1    0               00 Start at 1
   1 Explain          1    0    0 SCAN CONSTANT ROW 00 
   2 Integer         12    2    0               00 r[2]=12; return address
REG[2] =  i:12
   3 Once             0   12    0               00 
   4 Explain          4    0    0 SCALAR SUBQUERY 1 00 
   5 Null             0    3    5               00 r[3..5]=NULL; Init subquery result
REG[3] =  NULL
   6 Integer          1    6    0               00 r[6]=1; LIMIT counter
REG[6] =  i:1
   7 Explain          7    4    0 SCAN CONSTANT ROW 00 
   8 Integer          1    3    0               00 r[3]=1
REG[3] =  i:1
   9 Integer          0    4    0               00 r[4]=0
REG[4] =  i:0
  10 Integer          3    5    0               00 r[5]=3
REG[5] =  i:3
  11 DecrJumpZero     6   12    0               00 if (--r[6])==0 goto 12
REG[6] =  i:1
  12 Return           2    0    0               00 
REG[2] =  i:12
  13 Integer         23    7    0               00 r[7]=23; return address
REG[7] =  i:23
  14 Once             0   23    0               00 
  15 Explain         15    0    0 SCALAR SUBQUERY 2 00 
  16 Null             0    8   10               00 r[8..10]=NULL; Init subquery result
REG[8] =  NULL
  17 Integer          1   11    0               00 r[11]=1; LIMIT counter
REG[11] =  i:1
  18 Explain         18   15    0 SCAN CONSTANT ROW 00 
  19 Integer          1    8    0               00 r[8]=1
REG[8] =  i:1
  20 Integer          2    9    0               00 r[9]=2
REG[9] =  i:2
  21 Integer          3   10    0               00 r[10]=3
REG[10] =  i:3
  22 DecrJumpZero    11   23    0               00 if (--r[11])==0 goto 23
REG[11] =  i:1
  23 Return           7    0    0               00 
REG[7] =  i:23
  24 Ne               8    1    3               61 r[1] = (r[3]!=r[8])
REG[8] =  i:1
REG[3] =  i:1
REG[1] =  i:0
  25 If               1   29    0               00 
REG[1] =  i:0
  26 Ne               9    1    4               69 r[1] = (r[4]!=r[9])
REG[9] =  i:2
REG[4] =  i:0
REG[1] =  i:1
  27 If               1   29    0               00 
REG[1] =  i:1
  29 ResultRow        1    1    0               00 output=r[1]
REG[1] =  i:1
  30 Halt             0    0    0               00 
SQL: [SELECT (1, 2, NULL) == (1, 2, 3)
;]
VDBE Trace:
   0 Init             0    9    0               00 Start at 9
   9 Integer          1    2    0               00 r[2]=1
REG[2] =  i:1
  10 Integer          2    3    0               00 r[3]=2
REG[3] =  i:2
  11 Null             0    4    0               00 r[4]=NULL
REG[4] =  NULL
  12 Integer          3    5    0               00 r[5]=3
REG[5] =  i:3
  13 Goto             0    1    0               00 
   1 Explain          1    0    0 SCAN CONSTANT ROW 00 
   2 Eq               2    1    2               61 r[1] = (r[2]==r[2])
REG[2] =  i:1
REG[2] =  i:1
REG[1] =  i:1
   3 IfNot            1    7    0               00 
REG[1] =  i:1
   4 Eq               3    1    3               69 r[1] = (r[3]==r[3])
REG[3] =  i:2
REG[3] =  i:2
   5 IfNot            1    7    0               00 
REG[1] =  i:1
   6 Eq               5    1    4               69 r[1] = (r[4]==r[5])
REG[5] =  i:3
REG[4] =  NULL
REG[1] =  NULL
   7 ResultRow        1    1    0               00 output=r[1]
REG[1] =  NULL
   8 Halt             0    0    0               00 
SQL: [SELECT (1, 2, NULL) IS (1, 2, 3)
;]
VDBE Trace:
   0 Init             0    9    0               00 Start at 9
   9 Integer          1    2    0               00 r[2]=1
REG[2] =  i:1
  10 Integer          2    3    0               00 r[3]=2
REG[3] =  i:2
  11 Null             0    4    0               00 r[4]=NULL
REG[4] =  NULL
  12 Integer          3    5    0               00 r[5]=3
REG[5] =  i:3
  13 Goto             0    1    0               00 
   1 Explain          1    0    0 SCAN CONSTANT ROW 00 
   2 Eq               2    1    2               E1 r[1] = (r[2]==r[2])
REG[2] =  i:1
REG[2] =  i:1
REG[1] =  i:1
   3 IfNot            1    7    0               00 
REG[1] =  i:1
   4 Eq               3    1    3               E9 r[1] = (r[3]==r[3])
REG[3] =  i:2
REG[3] =  i:2
   5 IfNot            1    7    0               00 
REG[1] =  i:1
   6 Eq               5    1    4               E9 r[1] = (r[4]==r[5])
REG[5] =  i:3
REG[4] =  NULL
REG[1] =  i:0
   7 ResultRow        1    1    0               00 output=r[1]
REG[1] =  i:0
   8 Halt             0    0    0               00 
SQL: [SELECT (1, 2, NULL) == (1, 2, NULL)
;]
VDBE Trace:
   0 Init             0    9    0               00 Start at 9
   9 Integer          1    2    0               00 r[2]=1
REG[2] =  i:1
  10 Integer          2    3    0               00 r[3]=2
REG[3] =  i:2
  11 Null             0    4    0               00 r[4]=NULL
REG[4] =  NULL
  12 Goto             0    1    0               00 
   1 Explain          1    0    0 SCAN CONSTANT ROW 00 
   2 Eq               2    1    2               61 r[1] = (r[2]==r[2])
REG[2] =  i:1
REG[2] =  i:1
REG[1] =  i:1
   3 IfNot            1    7    0               00 
REG[1] =  i:1
   4 Eq               3    1    3               69 r[1] = (r[3]==r[3])
REG[3] =  i:2
REG[3] =  i:2
   5 IfNot            1    7    0               00 
REG[1] =  i:1
   6 Eq               4    1    4               69 r[1] = (r[4]==r[4])
REG[4] =  NULL
REG[4] =  NULL
REG[1] =  NULL
   7 ResultRow        1    1    0               00 output=r[1]
REG[1] =  NULL
   8 Halt             0    0    0               00 
SQL: [SELECT (1, 2, NULL) != (1, 2, NULL)
;]
VDBE Trace:
   0 Init             0    9    0               00 Start at 9
   9 Integer          1    2    0               00 r[2]=1
REG[2] =  i:1
  10 Integer          2    3    0               00 r[3]=2
REG[3] =  i:2
  11 Null             0    4    0               00 r[4]=NULL
REG[4] =  NULL
  12 Goto             0    1    0               00 
   1 Explain          1    0    0 SCAN CONSTANT ROW 00 
   2 Ne               2    1    2               61 r[1] = (r[2]!=r[2])
REG[2] =  i:1
REG[2] =  i:1
REG[1] =  i:0
   3 If               1    7    0               00 
REG[1] =  i:0
   4 Ne               3    1    3               69 r[1] = (r[3]!=r[3])
REG[3] =  i:2
REG[3] =  i:2
   5 If               1    7    0               00 
REG[1] =  i:0
   6 Ne               4    1    4               69 r[1] = (r[4]!=r[4])
REG[4] =  NULL
REG[4] =  NULL
REG[1] =  NULL
   7 ResultRow        1    1    0               00 output=r[1]
REG[1] =  NULL
   8 Halt             0    0    0               00 
SQL: [SELECT (1, 2, NULL) IS (1, 2, NULL)
;]
VDBE Trace:
   0 Init             0    9    0               00 Start at 9
   9 Integer          1    2    0               00 r[2]=1
REG[2] =  i:1
  10 Integer          2    3    0               00 r[3]=2
REG[3] =  i:2
  11 Null             0    4    0               00 r[4]=NULL
REG[4] =  NULL
  12 Goto             0    1    0               00 
   1 Explain          1    0    0 SCAN CONSTANT ROW 00 
   2 Eq               2    1    2               E1 r[1] = (r[2]==r[2])
REG[2] =  i:1
REG[2] =  i:1
REG[1] =  i:1
   3 IfNot            1    7    0               00 
REG[1] =  i:1
   4 Eq               3    1    3               E9 r[1] = (r[3]==r[3])
REG[3] =  i:2
REG[3] =  i:2
   5 IfNot            1    7    0               00 
REG[1] =  i:1
   6 Eq               4    1    4               E9 r[1] = (r[4]==r[4])
REG[4] =  NULL
REG[4] =  NULL
   7 ResultRow        1    1    0               00 output=r[1]
REG[1] =  i:1
   8 Halt             0    0    0               00 
SQL: [SELECT (NULL, NULL, NULL) == (NULL, NULL, NULL)
;]
VDBE Trace:
   0 Init             0    9    0               00 Start at 9
   9 Null             0    2    0               00 r[2]=NULL
REG[2] =  NULL
  10 Goto             0    1    0               00 
   1 Explain          1    0    0 SCAN CONSTANT ROW 00 
   2 Eq               2    1    2               61 r[1] = (r[2]==r[2])
REG[2] =  NULL
REG[2] =  NULL
REG[1] =  NULL
   3 IfNot            1    7    0               00 
REG[1] =  NULL
   4 Eq               2    1    2               69 r[1] = (r[2]==r[2])
REG[2] =  NULL
REG[2] =  NULL
REG[1] =  NULL
   5 IfNot            1    7    0               00 
REG[1] =  NULL
   6 Eq               2    1    2               69 r[1] = (r[2]==r[2])
REG[2] =  NULL
REG[2] =  NULL
REG[1] =  NULL
   7 ResultRow        1    1    0               00 output=r[1]
REG[1] =  NULL
   8 Halt             0    0    0               00 
SQL: [SELECT (NULL, NULL, NULL) IS (NULL, NULL, NULL)
;]
VDBE Trace:
   0 Init             0    9    0               00 Start at 9
   9 Null             0    2    0               00 r[2]=NULL
REG[2] =  NULL
  10 Goto             0    1    0               00 
   1 Explain          1    0    0 SCAN CONSTANT ROW 00 
   2 Eq               2    1    2               E1 r[1] = (r[2]==r[2])
REG[2] =  NULL
REG[2] =  NULL
REG[1] =  i:1
   3 IfNot            1    7    0               00 
REG[1] =  i:1
   4 Eq               2    1    2               E9 r[1] = (r[2]==r[2])
REG[2] =  NULL
REG[2] =  NULL
   5 IfNot            1    7    0               00 
REG[1] =  i:1
   6 Eq               2    1    2               E9 r[1] = (r[2]==r[2])
REG[2] =  NULL
REG[2] =  NULL
   7 ResultRow        1    1    0               00 output=r[1]
REG[1] =  i:1
   8 Halt             0    0    0               00 
SQL: [SELECT (NULL, NULL, NULL) IS NOT (NULL, NULL, NULL)
;]
VDBE Trace:
   0 Init             0    9    0               00 Start at 9
   9 Null             0    2    0               00 r[2]=NULL
REG[2] =  NULL
  10 Goto             0    1    0               00 
   1 Explain          1    0    0 SCAN CONSTANT ROW 00 
   2 Ne               2    1    2               E1 r[1] = (r[2]!=r[2])
REG[2] =  NULL
REG[2] =  NULL
REG[1] =  i:0
   3 If               1    7    0               00 
REG[1] =  i:0
   4 Ne               2    1    2               E9 r[1] = (r[2]!=r[2])
REG[2] =  NULL
REG[2] =  NULL
   5 If               1    7    0               00 
REG[1] =  i:0
   6 Ne               2    1    2               E9 r[1] = (r[2]!=r[2])
REG[2] =  NULL
REG[2] =  NULL
   7 ResultRow        1    1    0               00 output=r[1]
REG[1] =  i:0
   8 Halt             0    0    0               00 
SQL: [SELECT (SELECT NULL, NULL, NULL) == (SELECT NULL, NULL, NULL)
;]
VDBE Trace:
   0 Init             0    1    0               00 Start at 1
   1 Explain          1    0    0 SCAN CONSTANT ROW 00 
   2 Integer         12    2    0               00 r[2]=12; return address
REG[2] =  i:12
   3 Once             0   12    0               00 
   4 Explain          4    0    0 SCALAR SUBQUERY 1 00 
   5 Null             0    3    5               00 r[3..5]=NULL; Init subquery result
REG[3] =  NULL
   6 Integer          1    6    0               00 r[6]=1; LIMIT counter
REG[6] =  i:1
   7 Explain          7    4    0 SCAN CONSTANT ROW 00 
   8 Null             0    3    0               00 r[3]=NULL
REG[3] =  NULL
   9 Null             0    4    0               00 r[4]=NULL
REG[4] =  NULL
  10 Null             0    5    0               00 r[5]=NULL
REG[5] =  NULL
  11 DecrJumpZero     6   12    0               00 if (--r[6])==0 goto 12
REG[6] =  i:1
  12 Return           2    0    0               00 
REG[2] =  i:12
  13 Integer         23    7    0               00 r[7]=23; return address
REG[7] =  i:23
  14 Once             0   23    0               00 
  15 Explain         15    0    0 SCALAR SUBQUERY 2 00 
  16 Null             0    8   10               00 r[8..10]=NULL; Init subquery result
REG[8] =  NULL
  17 Integer          1   11    0               00 r[11]=1; LIMIT counter
REG[11] =  i:1
  18 Explain         18   15    0 SCAN CONSTANT ROW 00 
  19 Null             0    8    0               00 r[8]=NULL
REG[8] =  NULL
  20 Null             0    9    0               00 r[9]=NULL
REG[9] =  NULL
  21 Null             0   10    0               00 r[10]=NULL
REG[10] =  NULL
  22 DecrJumpZero    11   23    0               00 if (--r[11])==0 goto 23
REG[11] =  i:1
  23 Return           7    0    0               00 
REG[7] =  i:23
  24 Eq               8    1    3               61 r[1] = (r[3]==r[8])
REG[8] =  NULL
REG[3] =  NULL
REG[1] =  NULL
  25 IfNot            1   29    0               00 
REG[1] =  NULL
  26 Eq               9    1    4               69 r[1] = (r[4]==r[9])
REG[9] =  NULL
REG[4] =  NULL
REG[1] =  NULL
  27 IfNot            1   29    0               00 
REG[1] =  NULL
  28 Eq              10    1    5               69 r[1] = (r[5]==r[10])
REG[10] =  NULL
REG[5] =  NULL
REG[1] =  NULL
  29 ResultRow        1    1    0               00 output=r[1]
REG[1] =  NULL
  30 Halt             0    0    0               00 
SQL: [SELECT (SELECT NULL, NULL, NULL) != (SELECT NULL, NULL, NULL)
;]
VDBE Trace:
   0 Init             0    1    0               00 Start at 1
   1 Explain          1    0    0 SCAN CONSTANT ROW 00 
   2 Integer         12    2    0               00 r[2]=12; return address
REG[2] =  i:12
   3 Once             0   12    0               00 
   4 Explain          4    0    0 SCALAR SUBQUERY 1 00 
   5 Null             0    3    5               00 r[3..5]=NULL; Init subquery result
REG[3] =  NULL
   6 Integer          1    6    0               00 r[6]=1; LIMIT counter
REG[6] =  i:1
   7 Explain          7    4    0 SCAN CONSTANT ROW 00 
   8 Null             0    3    0               00 r[3]=NULL
REG[3] =  NULL
   9 Null             0    4    0               00 r[4]=NULL
REG[4] =  NULL
  10 Null             0    5    0               00 r[5]=NULL
REG[5] =  NULL
  11 DecrJumpZero     6   12    0               00 if (--r[6])==0 goto 12
REG[6] =  i:1
  12 Return           2    0    0               00 
REG[2] =  i:12
  13 Integer         23    7    0               00 r[7]=23; return address
REG[7] =  i:23
  14 Once             0   23    0               00 
  15 Explain         15    0    0 SCALAR SUBQUERY 2 00 
  16 Null             0    8   10               00 r[8..10]=NULL; Init subquery result
REG[8] =  NULL
  17 Integer          1   11    0               00 r[11]=1; LIMIT counter
REG[11] =  i:1
  18 Explain         18   15    0 SCAN CONSTANT ROW 00 
  19 Null             0    8    0               00 r[8]=NULL
REG[8] =  NULL
  20 Null             0    9    0               00 r[9]=NULL
REG[9] =  NULL
  21 Null             0   10    0               00 r[10]=NULL
REG[10] =  NULL
  22 DecrJumpZero    11   23    0               00 if (--r[11])==0 goto 23
REG[11] =  i:1
  23 Return           7    0    0               00 
REG[7] =  i:23
  24 Ne               8    1    3               61 r[1] = (r[3]!=r[8])
REG[8] =  NULL
REG[3] =  NULL
REG[1] =  NULL
  25 If               1   29    0               00 
REG[1] =  NULL
  26 Ne               9    1    4               69 r[1] = (r[4]!=r[9])
REG[9] =  NULL
REG[4] =  NULL
REG[1] =  NULL
  27 If               1   29    0               00 
REG[1] =  NULL
  28 Ne              10    1    5               69 r[1] = (r[5]!=r[10])
REG[10] =  NULL
REG[5] =  NULL
REG[1] =  NULL
  29 ResultRow        1    1    0               00 output=r[1]
REG[1] =  NULL
  30 Halt             0    0    0               00 
SQL: [SELECT (1, NULL, 1) != (1, 1, 1)
;]
VDBE Trace:
   0 Init             0    9    0               00 Start at 9
   9 Integer          1    2    0               00 r[2]=1
REG[2] =  i:1
  10 Null             0    3    0               00 r[3]=NULL
REG[3] =  NULL
  11 Goto             0    1    0               00 
   1 Explain          1    0    0 SCAN CONSTANT ROW 00 
   2 Ne               2    1    2               61 r[1] = (r[2]!=r[2])
REG[2] =  i:1
REG[2] =  i:1
REG[1] =  i:0
   3 If               1    7    0               00 
REG[1] =  i:0
   4 Ne               2    1    3               69 r[1] = (r[3]!=r[2])
REG[2] =  i:1
REG[3] =  NULL
REG[1] =  NULL
   5 If               1    7    0               00 
REG[1] =  NULL
   6 Ne               2    1    2               69 r[1] = (r[2]!=r[2])
REG[2] =  i:1
REG[2] =  i:1
   7 ResultRow        1    1    0               00 output=r[1]
REG[1] =  NULL
   8 Halt             0    0    0               00 
SQL: [SELECT (1, NULL, 1) IS (1, 1, 1)
;]
VDBE Trace:
   0 Init             0    9    0               00 Start at 9
   9 Integer          1    2    0               00 r[2]=1
REG[2] =  i:1
  10 Null             0    3    0               00 r[3]=NULL
REG[3] =  NULL
  11 Goto             0    1    0               00 
   1 Explain          1    0    0 SCAN CONSTANT ROW 00 
   2 Eq               2    1    2               E1 r[1] = (r[2]==r[2])
REG[2] =  i:1
REG[2] =  i:1
REG[1] =  i:1
   3 IfNot            1    7    0               00 
REG[1] =  i:1
   4 Eq               2    1    3               E9 r[1] = (r[3]==r[2])
REG[2] =  i:1
REG[3] =  NULL
REG[1] =  i:0
   5 IfNot            1    7    0               00 
REG[1] =  i:0
   7 ResultRow        1    1    0               00 output=r[1]
REG[1] =  i:0
   8 Halt             0    0    0               00 
SQL: [SELECT (1, NULL, 1) IS NOT (1, 1, 1)
;]
VDBE Trace:
   0 Init             0    9    0               00 Start at 9
   9 Integer          1    2    0               00 r[2]=1
REG[2] =  i:1
  10 Null             0    3    0               00 r[3]=NULL
REG[3] =  NULL
  11 Goto             0    1    0               00 
   1 Explain          1    0    0 SCAN CONSTANT ROW 00 
   2 Ne               2    1    2               E1 r[1] = (r[2]!=r[2])
REG[2] =  i:1
REG[2] =  i:1
REG[1] =  i:0
   3 If               1    7    0               00 
REG[1] =  i:0
   4 Ne               2    1    3               E9 r[1] = (r[3]!=r[2])
REG[2] =  i:1
REG[3] =  NULL
REG[1] =  i:1
   5 If               1    7    0               00 
REG[1] =  i:1
   7 ResultRow        1    1    0               00 output=r[1]
REG[1] =  i:1
   8 Halt             0    0    0               00 
SQL: [SELECT (SELECT 1, NULL, 1) == (SELECT 1, 1, 1)
;]
VDBE Trace:
   0 Init             0    1    0               00 Start at 1
   1 Explain          1    0    0 SCAN CONSTANT ROW 00 
   2 Integer         12    2    0               00 r[2]=12; return address
REG[2] =  i:12
   3 Once             0   12    0               00 
   4 Explain          4    0    0 SCALAR SUBQUERY 1 00 
   5 Null             0    3    5               00 r[3..5]=NULL; Init subquery result
REG[3] =  NULL
   6 Integer          1    6    0               00 r[6]=1; LIMIT counter
REG[6] =  i:1
   7 Explain          7    4    0 SCAN CONSTANT ROW 00 
   8 Integer          1    3    0               00 r[3]=1
REG[3] =  i:1
   9 Null             0    4    0               00 r[4]=NULL
REG[4] =  NULL
  10 Integer          1    5    0               00 r[5]=1
REG[5] =  i:1
  11 DecrJumpZero     6   12    0               00 if (--r[6])==0 goto 12
REG[6] =  i:1
  12 Return           2    0    0               00 
REG[2] =  i:12
  13 Integer         23    7    0               00 r[7]=23; return address
REG[7] =  i:23
  14 Once             0   23    0               00 
  15 Explain         15    0    0 SCALAR SUBQUERY 2 00 
  16 Null             0    8   10               00 r[8..10]=NULL; Init subquery result
REG[8] =  NULL
  17 Integer          1   11    0               00 r[11]=1; LIMIT counter
REG[11] =  i:1
  18 Explain         18   15    0 SCAN CONSTANT ROW 00 
  19 Integer          1    8    0               00 r[8]=1
REG[8] =  i:1
  20 Integer          1    9    0               00 r[9]=1
REG[9] =  i:1
  21 Integer          1   10    0               00 r[10]=1
REG[10] =  i:1
  22 DecrJumpZero    11   23    0               00 if (--r[11])==0 goto 23
REG[11] =  i:1
  23 Return           7    0    0               00 
REG[7] =  i:23
  24 Eq               8    1    3               61 r[1] = (r[3]==r[8])
REG[8] =  i:1
REG[3] =  i:1
REG[1] =  i:1
  25 IfNot            1   29    0               00 
REG[1] =  i:1
  26 Eq               9    1    4               69 r[1] = (r[4]==r[9])
REG[9] =  i:1
REG[4] =  NULL
REG[1] =  NULL
  27 IfNot            1   29    0               00 
REG[1] =  NULL
  28 Eq              10    1    5               69 r[1] = (r[5]==r[10])
REG[10] =  i:1
REG[5] =  i:1
  29 ResultRow        1    1    0               00 output=r[1]
REG[1] =  NULL
  30 Halt             0    0    0               00 
SQL: [SELECT (SELECT 1, NULL, 1) != (SELECT 1, 1, 1)
;]
VDBE Trace:
   0 Init             0    1    0               00 Start at 1
   1 Explain          1    0    0 SCAN CONSTANT ROW 00 
   2 Integer         12    2    0               00 r[2]=12; return address
REG[2] =  i:12
   3 Once             0   12    0               00 
   4 Explain          4    0    0 SCALAR SUBQUERY 1 00 
   5 Null             0    3    5               00 r[3..5]=NULL; Init subquery result
REG[3] =  NULL
   6 Integer          1    6    0               00 r[6]=1; LIMIT counter
REG[6] =  i:1
   7 Explain          7    4    0 SCAN CONSTANT ROW 00 
   8 Integer          1    3    0               00 r[3]=1
REG[3] =  i:1
   9 Null             0    4    0               00 r[4]=NULL
REG[4] =  NULL
  10 Integer          1    5    0               00 r[5]=1
REG[5] =  i:1
  11 DecrJumpZero     6   12    0               00 if (--r[6])==0 goto 12
REG[6] =  i:1
  12 Return           2    0    0               00 
REG[2] =  i:12
  13 Integer         23    7    0               00 r[7]=23; return address
REG[7] =  i:23
  14 Once             0   23    0               00 
  15 Explain         15    0    0 SCALAR SUBQUERY 2 00 
  16 Null             0    8   10               00 r[8..10]=NULL; Init subquery result
REG[8] =  NULL
  17 Integer          1   11    0               00 r[11]=1; LIMIT counter
REG[11] =  i:1
  18 Explain         18   15    0 SCAN CONSTANT ROW 00 
  19 Integer          1    8    0               00 r[8]=1
REG[8] =  i:1
  20 Integer          1    9    0               00 r[9]=1
REG[9] =  i:1
  21 Integer          1   10    0               00 r[10]=1
REG[10] =  i:1
  22 DecrJumpZero    11   23    0               00 if (--r[11])==0 goto 23
REG[11] =  i:1
  23 Return           7    0    0               00 
REG[7] =  i:23
  24 Ne               8    1    3               61 r[1] = (r[3]!=r[8])
REG[8] =  i:1
REG[3] =  i:1
REG[1] =  i:0
  25 If               1   29    0               00 
REG[1] =  i:0
  26 Ne               9    1    4               69 r[1] = (r[4]!=r[9])
REG[9] =  i:1
REG[4] =  NULL
REG[1] =  NULL
  27 If               1   29    0               00 
REG[1] =  NULL
  28 Ne              10    1    5               69 r[1] = (r[5]!=r[10])
REG[10] =  i:1
REG[5] =  i:1
  29 ResultRow        1    1    0               00 output=r[1]
REG[1] =  NULL
  30 Halt             0    0    0               00 
SQL: [SELECT (1, NULL, 1) == (1, 1, 2)
;]
VDBE Trace:
   0 Init             0    9    0               00 Start at 9
   9 Integer          1    2    0               00 r[2]=1
REG[2] =  i:1
  10 Null             0    3    0               00 r[3]=NULL
REG[3] =  NULL
  11 Integer          2    4    0               00 r[4]=2
REG[4] =  i:2
  12 Goto             0    1    0               00 
   1 Explain          1    0    0 SCAN CONSTANT ROW 00 
   2 Eq               2    1    2               61 r[1] = (r[2]==r[2])
REG[2] =  i:1
REG[2] =  i:1
REG[1] =  i:1
   3 IfNot            1    7    0               00 
REG[1] =  i:1
   4 Eq               2    1    3               69 r[1] = (r[3]==r[2])
REG[2] =  i:1
REG[3] =  NULL
REG[1] =  NULL
   5 IfNot            1    7    0               00 
REG[1] =  NULL
   6 Eq               4    1    2               69 r[1] = (r[2]==r[4])
REG[4] =  i:2
REG[2] =  i:1
REG[1] =  i:0
   7 ResultRow        1    1    0               00 output=r[1]
REG[1] =  i:0
   8 Halt             0    0    0               00 
SQL: [SELECT (1, NULL, 1) != (1, 1, 2)
;]
VDBE Trace:
   0 Init             0    9    0               00 Start at 9
   9 Integer          1    2    0               00 r[2]=1
REG[2] =  i:1
  10 Null             0    3    0               00 r[3]=NULL
REG[3] =  NULL
  11 Integer          2    4    0               00 r[4]=2
REG[4] =  i:2
  12 Goto             0    1    0               00 
   1 Explain          1    0    0 SCAN CONSTANT ROW 00 
   2 Ne               2    1    2               61 r[1] = (r[2]!=r[2])
REG[2] =  i:1
REG[2] =  i:1
REG[1] =  i:0
   3 If               1    7    0               00 
REG[1] =  i:0
   4 Ne               2    1    3               69 r[1] = (r[3]!=r[2])
REG[2] =  i:1
REG[3] =  NULL
REG[1] =  NULL
   5 If               1    7    0               00 
REG[1] =  NULL
   6 Ne               4    1    2               69 r[1] = (r[2]!=r[4])
REG[4] =  i:2
REG[2] =  i:1
REG[1] =  i:1
   7 ResultRow        1    1    0               00 output=r[1]
REG[1] =  i:1
   8 Halt             0    0    0               00 
SQL: [SELECT (1, NULL, 1) IS (1, 1, 2)
;]
VDBE Trace:
   0 Init             0    9    0               00 Start at 9
   9 Integer          1    2    0               00 r[2]=1
REG[2] =  i:1
  10 Null             0    3    0               00 r[3]=NULL
REG[3] =  NULL
  11 Integer          2    4    0               00 r[4]=2
REG[4] =  i:2
  12 Goto             0    1    0               00 
   1 Explain          1    0    0 SCAN CONSTANT ROW 00 
   2 Eq               2    1    2               E1 r[1] = (r[2]==r[2])
REG[2] =  i:1
REG[2] =  i:1
REG[1] =  i:1
   3 IfNot            1    7    0               00 
REG[1] =  i:1
   4 Eq               2    1    3               E9 r[1] = (r[3]==r[2])
REG[2] =  i:1
REG[3] =  NULL
REG[1] =  i:0
   5 IfNot            1    7    0               00 
REG[1] =  i:0
   7 ResultRow        1    1    0               00 output=r[1]
REG[1] =  i:0
   8 Halt             0    0    0               00 
SQL: [SELECT (1, NULL, 1) IS NOT (1, 1, 2)
;]
VDBE Trace:
   0 Init             0    9    0               00 Start at 9
   9 Integer          1    2    0               00 r[2]=1
REG[2] =  i:1
  10 Null             0    3    0               00 r[3]=NULL
REG[3] =  NULL
  11 Integer          2    4    0               00 r[4]=2
REG[4] =  i:2
  12 Goto             0    1    0               00 
   1 Explain          1    0    0 SCAN CONSTANT ROW 00 
   2 Ne               2    1    2               E1 r[1] = (r[2]!=r[2])
REG[2] =  i:1
REG[2] =  i:1
REG[1] =  i:0
   3 If               1    7    0               00 
REG[1] =  i:0
   4 Ne               2    1    3               E9 r[1] = (r[3]!=r[2])
REG[2] =  i:1
REG[3] =  NULL
REG[1] =  i:1
   5 If               1    7    0               00 
REG[1] =  i:1
   7 ResultRow        1    1    0               00 output=r[1]
REG[1] =  i:1
   8 Halt             0    0    0               00 
SQL: [SELECT (SELECT 1, NULL, 1) != (SELECT 1, 1, 2)
;]
VDBE Trace:
   0 Init             0    1    0               00 Start at 1
   1 Explain          1    0    0 SCAN CONSTANT ROW 00 
   2 Integer         12    2    0               00 r[2]=12; return address
REG[2] =  i:12
   3 Once             0   12    0               00 
   4 Explain          4    0    0 SCALAR SUBQUERY 1 00 
   5 Null             0    3    5               00 r[3..5]=NULL; Init subquery result
REG[3] =  NULL
   6 Integer          1    6    0               00 r[6]=1; LIMIT counter
REG[6] =  i:1
   7 Explain          7    4    0 SCAN CONSTANT ROW 00 
   8 Integer          1    3    0               00 r[3]=1
REG[3] =  i:1
   9 Null             0    4    0               00 r[4]=NULL
REG[4] =  NULL
  10 Integer          1    5    0               00 r[5]=1
REG[5] =  i:1
  11 DecrJumpZero     6   12    0               00 if (--r[6])==0 goto 12
REG[6] =  i:1
  12 Return           2    0    0               00 
REG[2] =  i:12
  13 Integer         23    7    0               00 r[7]=23; return address
REG[7] =  i:23
  14 Once             0   23    0               00 
  15 Explain         15    0    0 SCALAR SUBQUERY 2 00 
  16 Null             0    8   10               00 r[8..10]=NULL; Init subquery result
REG[8] =  NULL
  17 Integer          1   11    0               00 r[11]=1; LIMIT counter
REG[11] =  i:1
  18 Explain         18   15    0 SCAN CONSTANT ROW 00 
  19 Integer          1    8    0               00 r[8]=1
REG[8] =  i:1
  20 Integer          1    9    0               00 r[9]=1
REG[9] =  i:1
  21 Integer          2   10    0               00 r[10]=2
REG[10] =  i:2
  22 DecrJumpZero    11   23    0               00 if (--r[11])==0 goto 23
REG[11] =  i:1
  23 Return           7    0    0               00 
REG[7] =  i:23
  24 Ne               8    1    3               61 r[1] = (r[3]!=r[8])
REG[8] =  i:1
REG[3] =  i:1
REG[1] =  i:0
  25 If               1   29    0               00 
REG[1] =  i:0
  26 Ne               9    1    4               69 r[1] = (r[4]!=r[9])
REG[9] =  i:1
REG[4] =  NULL
REG[1] =  NULL
  27 If               1   29    0               00 
REG[1] =  NULL
  28 Ne              10    1    5               69 r[1] = (r[5]!=r[10])
REG[10] =  i:2
REG[5] =  i:1
REG[1] =  i:1
  29 ResultRow        1    1    0               00 output=r[1]
REG[1] =  i:1
  30 Halt             0    0    0               00 
SQL: [SELECT (1, 1, 3) < (1, 2, 3)
;]
VDBE Trace:
   0 Init             0    9    0               00 Start at 9
   9 Integer          1    2    0               00 r[2]=1
REG[2] =  i:1
  10 Integer          2    3    0               00 r[3]=2
REG[3] =  i:2
  11 Integer          3    4    0               00 r[4]=3
REG[4] =  i:3
  12 Goto             0    1    0               00 
   1 Explain          1    0    0 SCAN CONSTANT ROW 00 
   2 Lt               2    1    2               61 r[1] = (r[2]<r[2])
REG[2] =  i:1
REG[2] =  i:1
REG[1] =  i:0
   3 ElseNotEq        0    7    0               00 
   4 Lt               3    1    2               61 r[1] = (r[2]<r[3])
REG[3] =  i:2
REG[2] =  i:1
REG[1] =  i:1
   5 ElseNotEq        0    7    0               00 
   7 ResultRow        1    1    0               00 output=r[1]
REG[1] =  i:1
   8 Halt             0    0    0               00 
SQL: [SELECT (1, 1, 3) >= (1, 2, 3)
;]
VDBE Trace:
   0 Init             0    9    0               00 Start at 9
   9 Integer          1    2    0               00 r[2]=1
REG[2] =  i:1
  10 Integer          2    3    0               00 r[3]=2
REG[3] =  i:2
  11 Integer          3    4    0               00 r[4]=3
REG[4] =  i:3
  12 Goto             0    1    0               00 
   1 Explain          1    0    0 SCAN CONSTANT ROW 00 
   2 Gt               2    1    2               61 r[1] = (r[2]>r[2])
REG[2] =  i:1
REG[2] =  i:1
REG[1] =  i:0
   3 ElseNotEq        0    7    0               00 
   4 Gt               3    1    2               61 r[1] = (r[2]>r[3])
REG[3] =  i:2
REG[2] =  i:1
REG[1] =  i:0
   5 ElseNotEq        0    7    0               00 
   7 ResultRow        1    1    0               00 output=r[1]
REG[1] =  i:0
   8 Halt             0    0    0               00 
SQL: [SELECT (1, 2, 3) <= (1, 2, 3)
;]
VDBE Trace:
   0 Init             0    9    0               00 Start at 9
   9 Integer          1    2    0               00 r[2]=1
REG[2] =  i:1
  10 Integer          2    3    0               00 r[3]=2
REG[3] =  i:2
  11 Integer          3    4    0               00 r[4]=3
REG[4] =  i:3
  12 Goto             0    1    0               00 
   1 Explain          1    0    0 SCAN CONSTANT ROW 00 
   2 Lt               2    1    2               61 r[1] = (r[2]<r[2])
REG[2] =  i:1
REG[2] =  i:1
REG[1] =  i:0
   3 ElseNotEq        0    7    0               00 
   4 Lt               3    1    3               61 r[1] = (r[3]<r[3])
REG[3] =  i:2
REG[3] =  i:2
REG[1] =  i:0
   5 ElseNotEq        0    7    0               00 
   6 Le               4    1    4               61 r[1] = (r[4]<=r[4])
REG[4] =  i:3
REG[4] =  i:3
REG[1] =  i:1
   7 ResultRow        1    1    0               00 output=r[1]
REG[1] =  i:1
   8 Halt             0    0    0               00 
SQL: [SELECT (1, 3, 3) < (1, 2, 3)
;]
VDBE Trace:
   0 Init             0    9    0               00 Start at 9
   9 Integer          1    2    0               00 r[2]=1
REG[2] =  i:1
  10 Integer          3    3    0               00 r[3]=3
REG[3] =  i:3
  11 Integer          2    4    0               00 r[4]=2
REG[4] =  i:2
  12 Goto             0    1    0               00 
   1 Explain          1    0    0 SCAN CONSTANT ROW 00 
   2 Lt               2    1    2               61 r[1] = (r[2]<r[2])
REG[2] =  i:1
REG[2] =  i:1
REG[1] =  i:0
   3 ElseNotEq        0    7    0               00 
   4 Lt               4    1    3               61 r[1] = (r[3]<r[4])
REG[4] =  i:2
REG[3] =  i:3
REG[1] =  i:0
   5 ElseNotEq        0    7    0               00 
   7 ResultRow        1    1    0               00 output=r[1]
REG[1] =  i:0
   8 Halt             0    0    0               00 
SQL: [SELECT (1, 3, 3) > (1, 2, 3)
;]
VDBE Trace:
   0 Init             0    9    0               00 Start at 9
   9 Integer          1    2    0               00 r[2]=1
REG[2] =  i:1
  10 Integer          3    3    0               00 r[3]=3
REG[3] =  i:3
  11 Integer          2    4    0               00 r[4]=2
REG[4] =  i:2
  12 Goto             0    1    0               00 
   1 Explain          1    0    0 SCAN CONSTANT ROW 00 
   2 Gt               2    1    2               61 r[1] = (r[2]>r[2])
REG[2] =  i:1
REG[2] =  i:1
REG[1] =  i:0
   3 ElseNotEq        0    7    0               00 
   4 Gt               4    1    3               61 r[1] = (r[3]>r[4])
REG[4] =  i:2
REG[3] =  i:3
REG[1] =  i:1
   5 ElseNotEq        0    7    0               00 
   7 ResultRow        1    1    0               00 output=r[1]
REG[1] =  i:1
   8 Halt             0    0    0               00 
SQL: [SELECT (1, 3, 3) <= (1, 2, 3)
;]
VDBE Trace:
   0 Init             0    9    0               00 Start at 9
   9 Integer          1    2    0               00 r[2]=1
REG[2] =  i:1
  10 Integer          3    3    0               00 r[3]=3
REG[3] =  i:3
  11 Integer          2    4    0               00 r[4]=2
REG[4] =  i:2
  12 Goto             0    1    0               00 
   1 Explain          1    0    0 SCAN CONSTANT ROW 00 
   2 Lt               2    1    2               61 r[1] = (r[2]<r[2])
REG[2] =  i:1
REG[2] =  i:1
REG[1] =  i:0
   3 ElseNotEq        0    7    0               00 
   4 Lt               4    1    3               61 r[1] = (r[3]<r[4])
REG[4] =  i:2
REG[3] =  i:3
REG[1] =  i:0
   5 ElseNotEq        0    7    0               00 
   7 ResultRow        1    1    0               00 output=r[1]
REG[1] =  i:0
   8 Halt             0    0    0               00 
SQL: [SELECT (1, 3, 3) >= (1, 2, 3)
;]
VDBE Trace:
   0 Init             0    9    0               00 Start at 9
   9 Integer          1    2    0               00 r[2]=1
REG[2] =  i:1
  10 Integer          3    3    0               00 r[3]=3
REG[3] =  i:3
  11 Integer          2    4    0               00 r[4]=2
REG[4] =  i:2
  12 Goto             0    1    0               00 
   1 Explain          1    0    0 SCAN CONSTANT ROW 00 
   2 Gt               2    1    2               61 r[1] = (r[2]>r[2])
REG[2] =  i:1
REG[2] =  i:1
REG[1] =  i:0
   3 ElseNotEq        0    7    0               00 
   4 Gt               4    1    3               61 r[1] = (r[3]>r[4])
REG[4] =  i:2
REG[3] =  i:3
REG[1] =  i:1
   5 ElseNotEq        0    7    0               00 
   7 ResultRow        1    1    0               00 output=r[1]
REG[1] =  i:1
   8 Halt             0    0    0               00 
SQL: [SELECT (1, NULL, 3) < (1, 2, 3)
;]
VDBE Trace:
   0 Init             0    9    0               00 Start at 9
   9 Integer          1    2    0               00 r[2]=1
REG[2] =  i:1
  10 Null             0    3    0               00 r[3]=NULL
REG[3] =  NULL
  11 Integer          2    4    0               00 r[4]=2
REG[4] =  i:2
  12 Integer          3    5    0               00 r[5]=3
REG[5] =  i:3
  13 Goto             0    1    0               00 
   1 Explain          1    0    0 SCAN CONSTANT ROW 00 
   2 Lt               2    1    2               61 r[1] = (r[2]<r[2])
REG[2] =  i:1
REG[2] =  i:1
REG[1] =  i:0
   3 ElseNotEq        0    7    0               00 
   4 Lt               4    1    3               61 r[1] = (r[3]<r[4])
REG[4] =  i:2
REG[3] =  NULL
REG[1] =  NULL
   5 ElseNotEq        0    7    0               00 
   7 ResultRow        1    1    0               00 output=r[1]
REG[1] =  NULL
   8 Halt             0    0    0               00 
SQL: [SELECT (1, NULL, 3) <= (1, 2, 3)
;]
VDBE Trace:
   0 Init             0    9    0               00 Start at 9
   9 Integer          1    2    0               00 r[2]=1
REG[2] =  i:1
  10 Null             0    3    0               00 r[3]=NULL
REG[3] =  NULL
  11 Integer          2    4    0               00 r[4]=2
REG[4] =  i:2
  12 Integer          3    5    0               00 r[5]=3
REG[5] =  i:3
  13 Goto             0    1    0               00 
   1 Explain          1    0    0 SCAN CONSTANT ROW 00 
   2 Lt               2    1    2               61 r[1] = (r[2]<r[2])
REG[2] =  i:1
REG[2] =  i:1
REG[1] =  i:0
   3 ElseNotEq        0    7    0               00 
   4 Lt               4    1    3               61 r[1] = (r[3]<r[4])
REG[4] =  i:2
REG[3] =  NULL
REG[1] =  NULL
   5 ElseNotEq        0    7    0               00 
   7 ResultRow        1    1    0               00 output=r[1]
REG[1] =  NULL
   8 Halt             0    0    0               00 
SQL: [SELECT (1, 3, 3) < (1, NULL, 3)
;]
VDBE Trace:
   0 Init             0    9    0               00 Start at 9
   9 Integer          1    2    0               00 r[2]=1
REG[2] =  i:1
  10 Integer          3    3    0               00 r[3]=3
REG[3] =  i:3
  11 Null             0    4    0               00 r[4]=NULL
REG[4] =  NULL
  12 Goto             0    1    0               00 
   1 Explain          1    0    0 SCAN CONSTANT ROW 00 
   2 Lt               2    1    2               61 r[1] = (r[2]<r[2])
REG[2] =  i:1
REG[2] =  i:1
REG[1] =  i:0
   3 ElseNotEq        0    7    0               00 
   4 Lt               4    1    3               61 r[1] = (r[3]<r[4])
REG[4] =  NULL
REG[3] =  i:3
REG[1] =  NULL
   5 ElseNotEq        0    7    0               00 
   7 ResultRow        1    1    0               00 output=r[1]
REG[1] =  NULL
   8 Halt             0    0    0               00 
SQL: [SELECT (1, 3, 3) > (1, NULL, 3)
;]
VDBE Trace:
   0 Init             0    9    0               00 Start at 9
   9 Integer          1    2    0               00 r[2]=1
REG[2] =  i:1
  10 Integer          3    3    0               00 r[3]=3
REG[3] =  i:3
  11 Null             0    4    0               00 r[4]=NULL
REG[4] =  NULL
  12 Goto             0    1    0               00 
   1 Explain          1    0    0 SCAN CONSTANT ROW 00 
   2 Gt               2    1    2               61 r[1] = (r[2]>r[2])
REG[2] =  i:1
REG[2] =  i:1
REG[1] =  i:0
   3 ElseNotEq        0    7    0               00 
   4 Gt               4    1    3               61 r[1] = (r[3]>r[4])
REG[4] =  NULL
REG[3] =  i:3
REG[1] =  NULL
   5 ElseNotEq        0    7    0               00 
   7 ResultRow        1    1    0               00 output=r[1]
REG[1] =  NULL
   8 Halt             0    0    0               00 
SQL: [SELECT (1, 3, 3) >= (1, NULL, 3)
;]
VDBE Trace:
   0 Init             0    9    0               00 Start at 9
   9 Integer          1    2    0               00 r[2]=1
REG[2] =  i:1
  10 Integer          3    3    0               00 r[3]=3
REG[3] =  i:3
  11 Null             0    4    0               00 r[4]=NULL
REG[4] =  NULL
  12 Goto             0    1    0               00 
   1 Explain          1    0    0 SCAN CONSTANT ROW 00 
   2 Gt               2    1    2               61 r[1] = (r[2]>r[2])
REG[2] =  i:1
REG[2] =  i:1
REG[1] =  i:0
   3 ElseNotEq        0    7    0               00 
   4 Gt               4    1    3               61 r[1] = (r[3]>r[4])
REG[4] =  NULL
REG[3] =  i:3
REG[1] =  NULL
   5 ElseNotEq        0    7    0               00 
   7 ResultRow        1    1    0               00 output=r[1]
REG[1] =  NULL
   8 Halt             0    0    0               00 
SQL: [SELECT (1, NULL, 3) <= (1, NULL, 3)
;]
VDBE Trace:
   0 Init             0    9    0               00 Start at 9
   9 Integer          1    2    0               00 r[2]=1
REG[2] =  i:1
  10 Null             0    3    0               00 r[3]=NULL
REG[3] =  NULL
  11 Integer          3    4    0               00 r[4]=3
REG[4] =  i:3
  12 Goto             0    1    0               00 
   1 Explain          1    0    0 SCAN CONSTANT ROW 00 
   2 Lt               2    1    2               61 r[1] = (r[2]<r[2])
REG[2] =  i:1
REG[2] =  i:1
REG[1] =  i:0
   3 ElseNotEq        0    7    0               00 
   4 Lt               3    1    3               61 r[1] = (r[3]<r[3])
REG[3] =  NULL
REG[3] =  NULL
REG[1] =  NULL
   5 ElseNotEq        0    7    0               00 
   7 ResultRow        1    1    0               00 output=r[1]
REG[1] =  NULL
   8 Halt             0    0    0               00 
SQL: [SELECT (1, NULL, 3) >= (1, NULL, 3)
;]
VDBE Trace:
   0 Init             0    9    0               00 Start at 9
   9 Integer          1    2    0               00 r[2]=1
REG[2] =  i:1
  10 Null             0    3    0               00 r[3]=NULL
REG[3] =  NULL
  11 Integer          3    4    0               00 r[4]=3
REG[4] =  i:3
  12 Goto             0    1    0               00 
   1 Explain          1    0    0 SCAN CONSTANT ROW 00 
   2 Gt               2    1    2               61 r[1] = (r[2]>r[2])
REG[2] =  i:1
REG[2] =  i:1
REG[1] =  i:0
   3 ElseNotEq        0    7    0               00 
   4 Gt               3    1    3               61 r[1] = (r[3]>r[3])
REG[3] =  NULL
REG[3] =  NULL
REG[1] =  NULL
   5 ElseNotEq        0    7    0               00 
   7 ResultRow        1    1    0               00 output=r[1]
REG[1] =  NULL
   8 Halt             0    0    0               00 
SQL: [CREATE TABLE t0(c0, c1);]
VDBE Trace:
   0 Init             0   28    0               00 Start at 28
  28 Transaction      0    1    0 0             01 usesStmtJournal=0
  29 Goto             0    1    0               00 
   1 ReadCookie       0    3    2               00 
REG[3] =  i:0
   2 If               3    5    0               00 
REG[3] =  i:0
   3 SetCookie        0    2    4               00 
   4 SetCookie        0    5    1               00 
   5 CreateBtree      0    2    1               00 r[2]=root iDb=0 flags=1
REG[2] =  i:2
   6 OpenWrite        0    1    0 5             00 root=1 iDb=0
   7 NewRowid         0    1    0               00 r[1]=rowid
REG[1] =  i:1
   8 Blob             6    3    0              00 r[3]= (len=6)
REG[3] =  t6[060000000000......]
   9 Insert           0    3    1               08 intkey=r[1] data=r[3]
REG[3] =  t6[060000000000......]
REG[1] =  i:1
  10 Close            0    0    0               00 
  11 Close            0    0    0               00 
  12 Null             0    4    5               00 r[4..5]=NULL
REG[4] =  NULL
  13 OpenWrite        1    1    0 5             00 root=1 iDb=0; sqlite_master
  14 Explain         14    0    0 SEARCH TABLE sqlite_master USING INTEGER PRIMARY KEY (rowid=?) 00 
  15 SeekRowid        1   17    1               00 intkey=r[1]
REG[1] =  i:1
  16 Rowid            1    5    0               00 r[5]=rowid
REG[5] =  i:1
  17 IsNull           5   25    0               00 if r[5]==NULL goto 25
REG[5] =  i:1
  18 String8          0    6    0 table         00 r[6]='table'
REG[6] =   t5[table](8)
  19 String8          0    7    0 t0            00 r[7]='t0'
REG[7] =   t2[t0](8)
  20 String8          0    8    0 t0            00 r[8]='t0'
REG[8] =   t2[t0](8)
  21 Copy             2    9    0               00 r[9]=r[2]
REG[9] =  i:2
  22 String8          0   10    0 CREATE TABLE t0(c0, c1) 00 r[10]='CREATE TABLE t0(c0, c1)'
REG[10] =   t23[CREATE TABLE t0](8)
  23 MakeRecord       6    5   11 BBBDB         00 r[11]=mkrec(r[6..10])
REG[11] =  s39[06171111013B7461626C657430743002.....;tablet0t0.]
  24 Insert           1   11    5               00 intkey=r[5] data=r[11]
REG[11] =  s39[06171111013B7461626C657430743002.....;tablet0t0.]
REG[5] =  i:1
  25 SetCookie        0    1    1               00 
  26 ParseSchema      0    0    0 tbl_name='t0' AND type!='trigger' 00 
VDBE Trace:
   0 Init             0   15    0               00 Start at 15
  15 Transaction      0    0    1 0             00 usesStmtJournal=0
  16 String8          0    2    0 t0            00 r[2]='t0'
REG[2] =   t2[t0](8)
  17 String8          0    3    0 trigger       00 r[3]='trigger'
REG[3] =   t7[trigger](8)
  18 Goto             0    1    0               00 
   1 Noop             1    5    0               00 
   2 OpenRead         0    1    0 5             00 root=1 iDb=0; sqlite_master
   3 Explain          3    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   14    0               00 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[t0](8)
   6 Ne               2   13    1 (BINARY)      52 if r[1]!=r[2] goto 13
REG[2] =   t2[t0](8)
REG[1] =   s2[t0](8)
   7 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[table](8)
   8 Eq               3   13    1 (BINARY)      52 if r[1]==r[3] goto 13
REG[3] =   t7[trigger](8)
REG[1] =   s5[table](8)
   9 Column           0    1    4               00 r[4]=sqlite_master.name
REG[4] =   s2[t0](8)
  10 Column           0    3    5               00 r[5]=sqlite_master.rootpage
REG[5] =  i:2
  11 Column           0    4    6               00 r[6]=sqlite_master.sql
REG[6] =   s23[CREATE TABLE t0](8)
  12 ResultRow        4    3    0               00 output=r[4..6]
REG[4] =   s2[t0](8)
REG[5] =  i:2
REG[6] =   s23[CREATE TABLE t0](8)
  13 Next             0    5    0               01 
  14 Halt             0    0    0               00 
  27 Halt             0    0    0               00 
SQL: [;INSERT INTO t0 VALUES(1, 2);]
VDBE Trace:
   0 Init             0    8    0               00 Start at 8
   8 Transaction      0    1    1 0             01 usesStmtJournal=0
   9 Goto             0    1    0               00 
   1 OpenWrite        0    2    0 2             00 root=2 iDb=0; t0
   2 NewRowid         0    1    0               00 r[1]=rowid
REG[1] =  i:1
   3 Integer          1    2    0               00 r[2]=1
REG[2] =  i:1
   4 Integer          2    3    0               00 r[3]=2
REG[3] =  i:2
   5 MakeRecord       2    2    4               00 r[4]=mkrec(r[2..3])
REG[4] =  s4[03090102....]
   6 Insert           0    4    1 t0            39 intkey=r[1] data=r[4]
REG[4] =  s4[03090102....]
REG[1] =  i:1
   7 Halt             0    0    0               00 
SQL: [;INSERT INTO t0 VALUES(3, 6);]
VDBE Trace:
   0 Init             0    8    0               00 Start at 8
   8 Transaction      0    1    1 0             01 usesStmtJournal=0
   9 Goto             0    1    0               00 
   1 OpenWrite        0    2    0 2             00 root=2 iDb=0; t0
   2 NewRowid         0    1    0               00 r[1]=rowid
REG[1] =  i:2
   3 Integer          3    2    0               00 r[2]=3
REG[2] =  i:3
   4 Integer          6    3    0               00 r[3]=6
REG[3] =  i:6
   5 MakeRecord       2    2    4               00 r[4]=mkrec(r[2..3])
REG[4] =  s5[0301010306.....]
   6 Insert           0    4    1 t0            39 intkey=r[1] data=r[4]
REG[4] =  s5[0301010306.....]
REG[1] =  i:2
   7 Halt             0    0    0               00 
SQL: [SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c0)
  
;]
VDBE Trace:
   0 Init             0   43    0               00 Start at 43
  43 Transaction      0    0    1 0             01 usesStmtJournal=0
  44 Goto             0    1    0               00 
   1 Explain          1    0    0 SCAN CONSTANT ROW 00 
   2 Integer         11    2    0               00 r[2]=11; return address
REG[2] =  i:11
   3 Once             0   11    0               00 
   4 Explain          4    0    0 SCALAR SUBQUERY 1 00 
   5 Null             0    3    4               00 r[3..4]=NULL; Init subquery result
REG[3] =  NULL
   6 Integer          1    5    0               00 r[5]=1; LIMIT counter
REG[5] =  i:1
   7 Explain          7    4    0 SCAN CONSTANT ROW 00 
   8 Integer          0    3    0               00 r[3]=0
REG[3] =  i:0
   9 Integer          0    4    0               00 r[4]=0
REG[4] =  i:0
  10 DecrJumpZero     5   11    0               00 if (--r[5])==0 goto 11
REG[5] =  i:1
  11 Return           2    0    0               00 
REG[2] =  i:11
  12 Integer         37    6    0               00 r[6]=37; return address
REG[6] =  i:37
  13 Once             0   37    0               00 
  14 Explain         14    0    0 SCALAR SUBQUERY 2 00 
  15 Null             0    7    8               00 r[7..8]=NULL; Init subquery result
REG[7] =  NULL
  16 OpenEphemeral    1    4    0 k(1,B)        00 nColumn=4
  17 Integer          1    9    0               00 r[9]=1; LIMIT counter
REG[9] =  i:1
  18 OpenRead         0    2    0 2             00 root=2 iDb=0; t0
  19 Explain         19   14    0 SCAN TABLE t0 00 
  20 Rewind           0   32    0               00 
  21 Column           0    1    7               00 r[7]=t0.c1
REG[7] =  i:2
  22 Column           0    0   10               00 r[10]=t0.c0
REG[10] =  i:1
  23 Sequence         1   11    0               00 r[11]=cursor[1].ctr++
REG[11] =  i:0
  24 Move             7   12    1               00 r[12]=r[7]
REG[12] =  i:2
  25 IfNotZero        9   29    0               00 if r[9]!=0 then r[9]--, goto 29
REG[9] =  i:1
  29 MakeRecord      10    3   13               00 r[13]=mkrec(r[10..12])
REG[13] =  s5[0409080102.....]
  30 IdxInsert        1   13   10 3             00 key=r[13]
REG[13] =  s5[0409080102.....]
  31 Next             0   21    0               01 
  21 Column           0    1    7               00 r[7]=t0.c1
REG[7] =  i:6
  22 Column           0    0   10               00 r[10]=t0.c0
REG[10] =  i:3
  23 Sequence         1   11    0               00 r[11]=cursor[1].ctr++
REG[11] =  i:1
  24 Move             7   12    1               00 r[12]=r[7]
REG[12] =  i:6
  25 IfNotZero        9   29    0               00 if r[9]!=0 then r[9]--, goto 29
REG[9] =  i:0
  26 Last             1    0    0               00 
  27 IdxLE            1   31   10 1             00 key=r[10]
REG[10] =  i:3
  31 Next             0   21    0               01 
  32 Explain         32   14    0 USE TEMP B-TREE FOR ORDER BY 00 
  33 Sort             1   37    0               00 
  34 Column           1    2    8               00 r[8]=c1
REG[8] =  i:2
  35 Column           1    0    7               00 r[7]=c0
REG[7] =  i:1
  36 Next             1   34    0               00 
  37 Return           6    0    0               00 
REG[6] =  i:37
  38 Eq               7    1    3 (BINARY)      61 r[1] = (r[3]==r[7])
REG[7] =  i:1
REG[3] =  i:0
REG[1] =  i:0
  39 IfNot            1   41    0               00 
REG[1] =  i:0
  41 ResultRow        1    1    0               00 output=r[1]
REG[1] =  i:0
  42 Halt             0    0    0               00 
SQL: [SELECT (1, 1) == (SELECT c1,c1 FROM t0 ORDER BY c1, c1)
;]
VDBE Trace:
   0 Init             0   34    0               00 Start at 34
  34 Transaction      0    0    1 0             01 usesStmtJournal=0
  35 Integer          1   11    0               00 r[11]=1
REG[11] =  i:1
  36 Goto             0    1    0               00 
   1 Explain          1    0    0 SCAN CONSTANT ROW 00 
   2 Integer         28    2    0               00 r[2]=28; return address
REG[2] =  i:28
   3 Once             0   28    0               00 
   4 Explain          4    0    0 SCALAR SUBQUERY 1 00 
   5 Null             0    3    4               00 r[3..4]=NULL; Init subquery result
REG[3] =  NULL
   6 OpenEphemeral    1    5    0 k(2,B,B)      00 nColumn=5
   7 Integer          1    5    0               00 r[5]=1; LIMIT counter
REG[5] =  i:1
   8 OpenRead         0    2    0 2             00 root=2 iDb=0; t0
   9 Explain          9    4    0 SCAN TABLE t0 00 
  10 Rewind           0   23    0               00 
  11 Column           0    1    3               00 r[3]=t0.c1
REG[3] =  i:2
  12 Column           0    1    6               00 r[6]=t0.c1
REG[6] =  i:2
  13 Column           0    1    7               00 r[7]=t0.c1
REG[7] =  i:2
  14 Sequence         1    8    0               00 r[8]=cursor[1].ctr++
REG[8] =  i:0
  15 Move             3    9    1               00 r[9]=r[3]
REG[9] =  i:2
  16 IfNotZero        5   20    0               00 if r[5]!=0 then r[5]--, goto 20
REG[5] =  i:1
  20 MakeRecord       6    4   10               00 r[10]=mkrec(r[6..9])
REG[10] =  s8[0501010801020202........]
  21 IdxInsert        1   10    6 4             00 key=r[10]
REG[10] =  s8[0501010801020202........]
  22 Next             0   11    0               01 
  11 Column           0    1    3               00 r[3]=t0.c1
REG[3] =  i:6
  12 Column           0    1    6               00 r[6]=t0.c1
REG[6] =  i:6
  13 Column           0    1    7               00 r[7]=t0.c1
REG[7] =  i:6
  14 Sequence         1    8    0               00 r[8]=cursor[1].ctr++
REG[8] =  i:1
  15 Move             3    9    1               00 r[9]=r[3]
REG[9] =  i:6
  16 IfNotZero        5   20    0               00 if r[5]!=0 then r[5]--, goto 20
REG[5] =  i:0
  17 Last             1    0    0               00 
  18 IdxLE            1   22    6 2             00 key=r[6..7]
REG[6] =  i:6
REG[7] =  i:6
  22 Next             0   11    0               01 
  23 Explain         23    4    0 USE TEMP B-TREE FOR ORDER BY 00 
  24 Sort             1   28    0               00 
  25 Column           1    1    4               00 r[4]=c1
REG[4] =  i:2
  26 Column           1    3    3               00 r[3]=c1
REG[3] =  i:2
  27 Next             1   25    0               00 
  28 Return           2    0    0               00 
REG[2] =  i:28
  29 Eq               3    1   11 (BINARY)      61 r[1] = (r[11]==r[3])
REG[3] =  i:2
REG[11] =  i:1
REG[1] =  i:0
  30 IfNot            1   32    0               00 
REG[1] =  i:0
  32 ResultRow        1    1    0               00 output=r[1]
REG[1] =  i:0
  33 Halt             0    0    0               00 
SQL: [SELECT (1, 1) == (SELECT * FROM t0 ORDER BY c1, c1)
;]
VDBE Trace:
   0 Init             0   34    0               00 Start at 34
  34 Transaction      0    0    1 0             01 usesStmtJournal=0
  35 Integer          1   11    0               00 r[11]=1
REG[11] =  i:1
  36 Goto             0    1    0               00 
   1 Explain          1    0    0 SCAN CONSTANT ROW 00 
   2 Integer         28    2    0               00 r[2]=28; return address
REG[2] =  i:28
   3 Once             0   28    0               00 
   4 Explain          4    0    0 SCALAR SUBQUERY 1 00 
   5 Null             0    3    4               00 r[3..4]=NULL; Init subquery result
REG[3] =  NULL
   6 OpenEphemeral    1    5    0 k(2,B,B)      00 nColumn=5
   7 Integer          1    5    0               00 r[5]=1; LIMIT counter
REG[5] =  i:1
   8 OpenRead         0    2    0 2             00 root=2 iDb=0; t0
   9 Explain          9    4    0 SCAN TABLE t0 00 
  10 Rewind           0   23    0               00 
  11 Column           0    0    3               00 r[3]=t0.c0
REG[3] =  i:1
  12 Column           0    1    6               00 r[6]=t0.c1
REG[6] =  i:2
  13 Column           0    1    7               00 r[7]=t0.c1
REG[7] =  i:2
  14 Sequence         1    8    0               00 r[8]=cursor[1].ctr++
REG[8] =  i:0
  15 Move             3    9    1               00 r[9]=r[3]
REG[9] =  i:1
  16 IfNotZero        5   20    0               00 if r[5]!=0 then r[5]--, goto 20
REG[5] =  i:1
  20 MakeRecord       6    4   10               00 r[10]=mkrec(r[6..9])
REG[10] =  s7[05010108090202.......]
  21 IdxInsert        1   10    6 4             00 key=r[10]
REG[10] =  s7[05010108090202.......]
  22 Next             0   11    0               01 
  11 Column           0    0    3               00 r[3]=t0.c0
REG[3] =  i:3
  12 Column           0    1    6               00 r[6]=t0.c1
REG[6] =  i:6
  13 Column           0    1    7               00 r[7]=t0.c1
REG[7] =  i:6
  14 Sequence         1    8    0               00 r[8]=cursor[1].ctr++
REG[8] =  i:1
  15 Move             3    9    1               00 r[9]=r[3]
REG[9] =  i:3
  16 IfNotZero        5   20    0               00 if r[5]!=0 then r[5]--, goto 20
REG[5] =  i:0
  17 Last             1    0    0               00 
  18 IdxLE            1   22    6 2             00 key=r[6..7]
REG[6] =  i:6
REG[7] =  i:6
  22 Next             0   11    0               01 
  23 Explain         23    4    0 USE TEMP B-TREE FOR ORDER BY 00 
  24 Sort             1   28    0               00 
  25 Column           1    1    4               00 r[4]=c1
REG[4] =  i:2
  26 Column           1    3    3               00 r[3]=c0
REG[3] =  i:1
  27 Next             1   25    0               00 
  28 Return           2    0    0               00 
REG[2] =  i:28
  29 Eq               3    1   11 (BINARY)      61 r[1] = (r[11]==r[3])
REG[3] =  i:1
REG[11] =  i:1
REG[1] =  i:1
  30 IfNot            1   32    0               00 
REG[1] =  i:1
  31 Eq               4    1   11 (BINARY)      69 r[1] = (r[11]==r[4])
REG[4] =  i:2
REG[11] =  i:1
REG[1] =  i:0
  32 ResultRow        1    1    0               00 output=r[1]
REG[1] =  i:0
  33 Halt             0    0    0               00 
SQL: [SELECT (SELECT * FROM t0 ORDER BY c1, c1) == (SELECT * FROM t0 ORDER BY c1, c1)
  
;]
VDBE Trace:
   0 Init             0   61    0               00 Start at 61
  61 Transaction      0    0    1 0             01 usesStmtJournal=0
  62 Goto             0    1    0               00 
   1 Explain          1    0    0 SCAN CONSTANT ROW 00 
   2 Integer         28    2    0               00 r[2]=28; return address
REG[2] =  i:28
   3 Once             0   28    0               00 
   4 Explain          4    0    0 SCALAR SUBQUERY 1 00 
   5 Null             0    3    4               00 r[3..4]=NULL; Init subquery result
REG[3] =  NULL
   6 OpenEphemeral    2    5    0 k(2,B,B)      00 nColumn=5
   7 Integer          1    5    0               00 r[5]=1; LIMIT counter
REG[5] =  i:1
   8 OpenRead         0    2    0 2             00 root=2 iDb=0; t0
   9 Explain          9    4    0 SCAN TABLE t0 00 
  10 Rewind           0   23    0               00 
  11 Column           0    0    3               00 r[3]=t0.c0
REG[3] =  i:1
  12 Column           0    1    6               00 r[6]=t0.c1
REG[6] =  i:2
  13 Column           0    1    7               00 r[7]=t0.c1
REG[7] =  i:2
  14 Sequence         2    8    0               00 r[8]=cursor[2].ctr++
REG[8] =  i:0
  15 Move             3    9    1               00 r[9]=r[3]
REG[9] =  i:1
  16 IfNotZero        5   20    0               00 if r[5]!=0 then r[5]--, goto 20
REG[5] =  i:1
  20 MakeRecord       6    4   10               00 r[10]=mkrec(r[6..9])
REG[10] =  s7[05010108090202.......]
  21 IdxInsert        2   10    6 4             00 key=r[10]
REG[10] =  s7[05010108090202.......]
  22 Next             0   11    0               01 
  11 Column           0    0    3               00 r[3]=t0.c0
REG[3] =  i:3
  12 Column           0    1    6               00 r[6]=t0.c1
REG[6] =  i:6
  13 Column           0    1    7               00 r[7]=t0.c1
REG[7] =  i:6
  14 Sequence         2    8    0               00 r[8]=cursor[2].ctr++
REG[8] =  i:1
  15 Move             3    9    1               00 r[9]=r[3]
REG[9] =  i:3
  16 IfNotZero        5   20    0               00 if r[5]!=0 then r[5]--, goto 20
REG[5] =  i:0
  17 Last             2    0    0               00 
  18 IdxLE            2   22    6 2             00 key=r[6..7]
REG[6] =  i:6
REG[7] =  i:6
  22 Next             0   11    0               01 
  23 Explain         23    4    0 USE TEMP B-TREE FOR ORDER BY 00 
  24 Sort             2   28    0               00 
  25 Column           2    1    4               00 r[4]=c1
REG[4] =  i:2
  26 Column           2    3    3               00 r[3]=c0
REG[3] =  i:1
  27 Next             2   25    0               00 
  28 Return           2    0    0               00 
REG[2] =  i:28
  29 Integer         55   11    0               00 r[11]=55; return address
REG[11] =  i:55
  30 Once             0   55    0               00 
  31 Explain         31    0    0 SCALAR SUBQUERY 2 00 
  32 Null             0   12   13               00 r[12..13]=NULL; Init subquery result
REG[12] =  NULL
  33 OpenEphemeral    3    5    0 k(2,B,B)      00 nColumn=5
  34 Integer          1   14    0               00 r[14]=1; LIMIT counter
REG[14] =  i:1
  35 OpenRead         1    2    0 2             00 root=2 iDb=0; t0
  36 Explain         36   31    0 SCAN TABLE t0 00 
  37 Rewind           1   50    0               00 
  38 Column           1    0   12               00 r[12]=t0.c0
REG[12] =  i:1
  39 Column           1    1   15               00 r[15]=t0.c1
REG[15] =  i:2
  40 Column           1    1   16               00 r[16]=t0.c1
REG[16] =  i:2
  41 Sequence         3   17    0               00 r[17]=cursor[3].ctr++
REG[17] =  i:0
  42 Move            12   18    1               00 r[18]=r[12]
REG[18] =  i:1
  43 IfNotZero       14   47    0               00 if r[14]!=0 then r[14]--, goto 47
REG[14] =  i:1
  47 MakeRecord      15    4   19               00 r[19]=mkrec(r[15..18])
REG[19] =  s7[05010108090202.......]
  48 IdxInsert        3   19   15 4             00 key=r[19]
REG[19] =  s7[05010108090202.......]
  49 Next             1   38    0               01 
  38 Column           1    0   12               00 r[12]=t0.c0
REG[12] =  i:3
  39 Column           1    1   15               00 r[15]=t0.c1
REG[15] =  i:6
  40 Column           1    1   16               00 r[16]=t0.c1
REG[16] =  i:6
  41 Sequence         3   17    0               00 r[17]=cursor[3].ctr++
REG[17] =  i:1
  42 Move            12   18    1               00 r[18]=r[12]
REG[18] =  i:3
  43 IfNotZero       14   47    0               00 if r[14]!=0 then r[14]--, goto 47
REG[14] =  i:0
  44 Last             3    0    0               00 
  45 IdxLE            3   49   15 2             00 key=r[15..16]
REG[15] =  i:6
REG[16] =  i:6
  49 Next             1   38    0               01 
  50 Explain         50   31    0 USE TEMP B-TREE FOR ORDER BY 00 
  51 Sort             3   55    0               00 
  52 Column           3    1   13               00 r[13]=c1
REG[13] =  i:2
  53 Column           3    3   12               00 r[12]=c0
REG[12] =  i:1
  54 Next             3   52    0               00 
  55 Return          11    0    0               00 
REG[11] =  i:55
  56 Eq              12    1    3 (BINARY)      61 r[1] = (r[3]==r[12])
REG[12] =  i:1
REG[3] =  i:1
REG[1] =  i:1
  57 IfNot            1   59    0               00 
REG[1] =  i:1
  58 Eq              13    1    4 (BINARY)      69 r[1] = (r[4]==r[13])
REG[13] =  i:2
REG[4] =  i:2
  59 ResultRow        1    1    0               00 output=r[1]
REG[1] =  i:1
  60 Halt             0    0    0               00 
SQL: [SELECT (SELECT * FROM t0 ORDER BY c1, c0 DESC) == (SELECT * FROM t0 ORDER BY c1, c0 DESC)
  
;]
VDBE Trace:
   0 Init             0   57    0               00 Start at 57
  57 Transaction      0    0    1 0             01 usesStmtJournal=0
  58 Goto             0    1    0               00 
   1 Explain          1    0    0 SCAN CONSTANT ROW 00 
   2 Integer         26    2    0               00 r[2]=26; return address
REG[2] =  i:26
   3 Once             0   26    0               00 
   4 Explain          4    0    0 SCALAR SUBQUERY 1 00 
   5 Null             0    3    4               00 r[3..4]=NULL; Init subquery result
REG[3] =  NULL
   6 OpenEphemeral    2    5    0 k(2,B,-B)     00 nColumn=5
   7 Integer          1    5    0               00 r[5]=1; LIMIT counter
REG[5] =  i:1
   8 OpenRead         0    2    0 2             00 root=2 iDb=0; t0
   9 Explain          9    4    0 SCAN TABLE t0 00 
  10 Rewind           0   21    0               00 
  11 Column           0    1    6               00 r[6]=t0.c1
REG[6] =  i:2
  12 Column           0    0    7               00 r[7]=t0.c0
REG[7] =  i:1
  13 Sequence         2    8    0               00 r[8]=cursor[2].ctr++
REG[8] =  i:0
  14 IfNotZero        5   18    0               00 if r[5]!=0 then r[5]--, goto 18
REG[5] =  i:1
  18 MakeRecord       6    3    9               00 r[9]=mkrec(r[6..8])
REG[9] =  s5[0401090802.....]
  19 IdxInsert        2    9    6 3             00 key=r[9]
REG[9] =  s5[0401090802.....]
  20 Next             0   11    0               01 
  11 Column           0    1    6               00 r[6]=t0.c1
REG[6] =  i:6
  12 Column           0    0    7               00 r[7]=t0.c0
REG[7] =  i:3
  13 Sequence         2    8    0               00 r[8]=cursor[2].ctr++
REG[8] =  i:1
  14 IfNotZero        5   18    0               00 if r[5]!=0 then r[5]--, goto 18
REG[5] =  i:0
  15 Last             2    0    0               00 
  16 IdxLE            2   20    6 2             00 key=r[6..7]
REG[6] =  i:6
REG[7] =  i:3
  20 Next             0   11    0               01 
  21 Explain         21    4    0 USE TEMP B-TREE FOR ORDER BY 00 
  22 Sort             2   26    0               00 
  23 Column           2    0    4               00 r[4]=c1
REG[4] =  i:2
  24 Column           2    1    3               00 r[3]=c0
REG[3] =  i:1
  25 Next             2   23    0               00 
  26 Return           2    0    0               00 
REG[2] =  i:26
  27 Integer         51   10    0               00 r[10]=51; return address
REG[10] =  i:51
  28 Once             0   51    0               00 
  29 Explain         29    0    0 SCALAR SUBQUERY 2 00 
  30 Null             0   11   12               00 r[11..12]=NULL; Init subquery result
REG[11] =  NULL
  31 OpenEphemeral    3    5    0 k(2,B,-B)     00 nColumn=5
  32 Integer          1   13    0               00 r[13]=1; LIMIT counter
REG[13] =  i:1
  33 OpenRead         1    2    0 2             00 root=2 iDb=0; t0
  34 Explain         34   29    0 SCAN TABLE t0 00 
  35 Rewind           1   46    0               00 
  36 Column           1    1   14               00 r[14]=t0.c1
REG[14] =  i:2
  37 Column           1    0   15               00 r[15]=t0.c0
REG[15] =  i:1
  38 Sequence         3   16    0               00 r[16]=cursor[3].ctr++
REG[16] =  i:0
  39 IfNotZero       13   43    0               00 if r[13]!=0 then r[13]--, goto 43
REG[13] =  i:1
  43 MakeRecord      14    3   17               00 r[17]=mkrec(r[14..16])
REG[17] =  s5[0401090802.....]
  44 IdxInsert        3   17   14 3             00 key=r[17]
REG[17] =  s5[0401090802.....]
  45 Next             1   36    0               01 
  36 Column           1    1   14               00 r[14]=t0.c1
REG[14] =  i:6
  37 Column           1    0   15               00 r[15]=t0.c0
REG[15] =  i:3
  38 Sequence         3   16    0               00 r[16]=cursor[3].ctr++
REG[16] =  i:1
  39 IfNotZero       13   43    0               00 if r[13]!=0 then r[13]--, goto 43
REG[13] =  i:0
  40 Last             3    0    0               00 
  41 IdxLE            3   45   14 2             00 key=r[14..15]
REG[14] =  i:6
REG[15] =  i:3
  45 Next             1   36    0               01 
  46 Explain         46   29    0 USE TEMP B-TREE FOR ORDER BY 00 
  47 Sort             3   51    0               00 
  48 Column           3    0   12               00 r[12]=c1
REG[12] =  i:2
  49 Column           3    1   11               00 r[11]=c0
REG[11] =  i:1
  50 Next             3   48    0               00 
  51 Return          10    0    0               00 
REG[10] =  i:51
  52 Eq              11    1    3 (BINARY)      61 r[1] = (r[3]==r[11])
REG[11] =  i:1
REG[3] =  i:1
REG[1] =  i:1
  53 IfNot            1   55    0               00 
REG[1] =  i:1
  54 Eq              12    1    4 (BINARY)      69 r[1] = (r[4]==r[12])
REG[12] =  i:2
REG[4] =  i:2
  55 ResultRow        1    1    0               00 output=r[1]
REG[1] =  i:1
  56 Halt             0    0    0               00 
SQL: [SELECT (3, 6) == (SELECT * FROM t0 ORDER BY c1 DESC, c0 DESC)
;]
VDBE Trace:
   0 Init             0   32    0               00 Start at 32
  32 Transaction      0    0    1 0             01 usesStmtJournal=0
  33 Integer          3   10    0               00 r[10]=3
REG[10] =  i:3
  34 Integer          6   11    0               00 r[11]=6
REG[11] =  i:6
  35 Goto             0    1    0               00 
   1 Explain          1    0    0 SCAN CONSTANT ROW 00 
   2 Integer         26    2    0               00 r[2]=26; return address
REG[2] =  i:26
   3 Once             0   26    0               00 
   4 Explain          4    0    0 SCALAR SUBQUERY 1 00 
   5 Null             0    3    4               00 r[3..4]=NULL; Init subquery result
REG[3] =  NULL
   6 OpenEphemeral    1    5    0 k(2,-B,-B)    00 nColumn=5
   7 Integer          1    5    0               00 r[5]=1; LIMIT counter
REG[5] =  i:1
   8 OpenRead         0    2    0 2             00 root=2 iDb=0; t0
   9 Explain          9    4    0 SCAN TABLE t0 00 
  10 Rewind           0   21    0               00 
  11 Column           0    1    6               00 r[6]=t0.c1
REG[6] =  i:2
  12 Column           0    0    7               00 r[7]=t0.c0
REG[7] =  i:1
  13 Sequence         1    8    0               00 r[8]=cursor[1].ctr++
REG[8] =  i:0
  14 IfNotZero        5   18    0               00 if r[5]!=0 then r[5]--, goto 18
REG[5] =  i:1
  18 MakeRecord       6    3    9               00 r[9]=mkrec(r[6..8])
REG[9] =  s5[0401090802.....]
  19 IdxInsert        1    9    6 3             00 key=r[9]
REG[9] =  s5[0401090802.....]
  20 Next             0   11    0               01 
  11 Column           0    1    6               00 r[6]=t0.c1
REG[6] =  i:6
  12 Column           0    0    7               00 r[7]=t0.c0
REG[7] =  i:3
  13 Sequence         1    8    0               00 r[8]=cursor[1].ctr++
REG[8] =  i:1
  14 IfNotZero        5   18    0               00 if r[5]!=0 then r[5]--, goto 18
REG[5] =  i:0
  15 Last             1    0    0               00 
  16 IdxLE            1   20    6 2             00 key=r[6..7]
REG[6] =  i:6
REG[7] =  i:3
  17 Delete           1    0    0               00 
  18 MakeRecord       6    3    9               00 r[9]=mkrec(r[6..8])
REG[9] =  s6[040101090603......]
  19 IdxInsert        1    9    6 3             00 key=r[9]
REG[9] =  s6[040101090603......]
  20 Next             0   11    0               01 
  21 Explain         21    4    0 USE TEMP B-TREE FOR ORDER BY 00 
  22 Sort             1   26    0               00 
  23 Column           1    0    4               00 r[4]=c1
REG[4] =  i:6
  24 Column           1    1    3               00 r[3]=c0
REG[3] =  i:3
  25 Next             1   23    0               00 
  26 Return           2    0    0               00 
REG[2] =  i:26
  27 Eq               3    1   10 (BINARY)      61 r[1] = (r[10]==r[3])
REG[3] =  i:3
REG[10] =  i:3
REG[1] =  i:1
  28 IfNot            1   30    0               00 
REG[1] =  i:1
  29 Eq               4    1   11 (BINARY)      69 r[1] = (r[11]==r[4])
REG[4] =  i:6
REG[11] =  i:6
  30 ResultRow        1    1    0               00 output=r[1]
REG[1] =  i:1
  31 Halt             0    0    0               00 
SQL: [SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c1 DESC, c0 DESC)
  
;]
VDBE Trace:
   0 Init             0   42    0               00 Start at 42
  42 Transaction      0    0    1 0             01 usesStmtJournal=0
  43 Goto             0    1    0               00 
   1 Explain          1    0    0 SCAN CONSTANT ROW 00 
   2 Integer         11    2    0               00 r[2]=11; return address
REG[2] =  i:11
   3 Once             0   11    0               00 
   4 Explain          4    0    0 SCALAR SUBQUERY 1 00 
   5 Null             0    3    4               00 r[3..4]=NULL; Init subquery result
REG[3] =  NULL
   6 Integer          1    5    0               00 r[5]=1; LIMIT counter
REG[5] =  i:1
   7 Explain          7    4    0 SCAN CONSTANT ROW 00 
   8 Integer          0    3    0               00 r[3]=0
REG[3] =  i:0
   9 Integer          0    4    0               00 r[4]=0
REG[4] =  i:0
  10 DecrJumpZero     5   11    0               00 if (--r[5])==0 goto 11
REG[5] =  i:1
  11 Return           2    0    0               00 
REG[2] =  i:11
  12 Integer         36    6    0               00 r[6]=36; return address
REG[6] =  i:36
  13 Once             0   36    0               00 
  14 Explain         14    0    0 SCALAR SUBQUERY 2 00 
  15 Null             0    7    8               00 r[7..8]=NULL; Init subquery result
REG[7] =  NULL
  16 OpenEphemeral    1    5    0 k(2,-B,-B)    00 nColumn=5
  17 Integer          1    9    0               00 r[9]=1; LIMIT counter
REG[9] =  i:1
  18 OpenRead         0    2    0 2             00 root=2 iDb=0; t0
  19 Explain         19   14    0 SCAN TABLE t0 00 
  20 Rewind           0   31    0               00 
  21 Column           0    1   10               00 r[10]=t0.c1
REG[10] =  i:2
  22 Column           0    0   11               00 r[11]=t0.c0
REG[11] =  i:1
  23 Sequence         1   12    0               00 r[12]=cursor[1].ctr++
REG[12] =  i:0
  24 IfNotZero        9   28    0               00 if r[9]!=0 then r[9]--, goto 28
REG[9] =  i:1
  28 MakeRecord      10    3   13               00 r[13]=mkrec(r[10..12])
REG[13] =  s5[0401090802.....]
  29 IdxInsert        1   13   10 3             00 key=r[13]
REG[13] =  s5[0401090802.....]
  30 Next             0   21    0               01 
  21 Column           0    1   10               00 r[10]=t0.c1
REG[10] =  i:6
  22 Column           0    0   11               00 r[11]=t0.c0
REG[11] =  i:3
  23 Sequence         1   12    0               00 r[12]=cursor[1].ctr++
REG[12] =  i:1
  24 IfNotZero        9   28    0               00 if r[9]!=0 then r[9]--, goto 28
REG[9] =  i:0
  25 Last             1    0    0               00 
  26 IdxLE            1   30   10 2             00 key=r[10..11]
REG[10] =  i:6
REG[11] =  i:3
  27 Delete           1    0    0               00 
  28 MakeRecord      10    3   13               00 r[13]=mkrec(r[10..12])
REG[13] =  s6[040101090603......]
  29 IdxInsert        1   13   10 3             00 key=r[13]
REG[13] =  s6[040101090603......]
  30 Next             0   21    0               01 
  31 Explain         31   14    0 USE TEMP B-TREE FOR ORDER BY 00 
  32 Sort             1   36    0               00 
  33 Column           1    0    8               00 r[8]=c1
REG[8] =  i:6
  34 Column           1    1    7               00 r[7]=c0
REG[7] =  i:3
  35 Next             1   33    0               00 
  36 Return           6    0    0               00 
REG[6] =  i:36
  37 Eq               7    1    3 (BINARY)      61 r[1] = (r[3]==r[7])
REG[7] =  i:3
REG[3] =  i:0
REG[1] =  i:0
  38 IfNot            1   40    0               00 
REG[1] =  i:0
  40 ResultRow        1    1    0               00 output=r[1]
REG[1] =  i:0
  41 Halt             0    0    0               00 
SQL: [SELECT ((3, 5)) == (SELECT c1,c1 FROM t0 ORDER BY c1 DESC, c1)
;]
VDBE Trace:
   0 Init             0   34    0               00 Start at 34
  34 Transaction      0    0    1 0             01 usesStmtJournal=0
  35 Integer          3   11    0               00 r[11]=3
REG[11] =  i:3
  36 Integer          5   12    0               00 r[12]=5
REG[12] =  i:5
  37 Goto             0    1    0               00 
   1 Explain          1    0    0 SCAN CONSTANT ROW 00 
   2 Integer         28    2    0               00 r[2]=28; return address
REG[2] =  i:28
   3 Once             0   28    0               00 
   4 Explain          4    0    0 SCALAR SUBQUERY 1 00 
   5 Null             0    3    4               00 r[3..4]=NULL; Init subquery result
REG[3] =  NULL
   6 OpenEphemeral    1    5    0 k(2,-B,B)     00 nColumn=5
   7 Integer          1    5    0               00 r[5]=1; LIMIT counter
REG[5] =  i:1
   8 OpenRead         0    2    0 2             00 root=2 iDb=0; t0
   9 Explain          9    4    0 SCAN TABLE t0 00 
  10 Rewind           0   23    0               00 
  11 Column           0    1    3               00 r[3]=t0.c1
REG[3] =  i:2
  12 Column           0    1    6               00 r[6]=t0.c1
REG[6] =  i:2
  13 Column           0    1    7               00 r[7]=t0.c1
REG[7] =  i:2
  14 Sequence         1    8    0               00 r[8]=cursor[1].ctr++
REG[8] =  i:0
  15 Move             3    9    1               00 r[9]=r[3]
REG[9] =  i:2
  16 IfNotZero        5   20    0               00 if r[5]!=0 then r[5]--, goto 20
REG[5] =  i:1
  20 MakeRecord       6    4   10               00 r[10]=mkrec(r[6..9])
REG[10] =  s8[0501010801020202........]
  21 IdxInsert        1   10    6 4             00 key=r[10]
REG[10] =  s8[0501010801020202........]
  22 Next             0   11    0               01 
  11 Column           0    1    3               00 r[3]=t0.c1
REG[3] =  i:6
  12 Column           0    1    6               00 r[6]=t0.c1
REG[6] =  i:6
  13 Column           0    1    7               00 r[7]=t0.c1
REG[7] =  i:6
  14 Sequence         1    8    0               00 r[8]=cursor[1].ctr++
REG[8] =  i:1
  15 Move             3    9    1               00 r[9]=r[3]
REG[9] =  i:6
  16 IfNotZero        5   20    0               00 if r[5]!=0 then r[5]--, goto 20
REG[5] =  i:0
  17 Last             1    0    0               00 
  18 IdxLE            1   22    6 2             00 key=r[6..7]
REG[6] =  i:6
REG[7] =  i:6
  19 Delete           1    0    0               00 
  20 MakeRecord       6    4   10               00 r[10]=mkrec(r[6..9])
REG[10] =  s8[0501010901060606........]
  21 IdxInsert        1   10    6 4             00 key=r[10]
REG[10] =  s8[0501010901060606........]
  22 Next             0   11    0               01 
  23 Explain         23    4    0 USE TEMP B-TREE FOR ORDER BY 00 
  24 Sort             1   28    0               00 
  25 Column           1    1    4               00 r[4]=c1
REG[4] =  i:6
  26 Column           1    3    3               00 r[3]=c1
REG[3] =  i:6
  27 Next             1   25    0               00 
  28 Return           2    0    0               00 
REG[2] =  i:28
  29 Eq               3    1   11 (BINARY)      61 r[1] = (r[11]==r[3])
REG[3] =  i:6
REG[11] =  i:3
REG[1] =  i:0
  30 IfNot            1   32    0               00 
REG[1] =  i:0
  32 ResultRow        1    1    0               00 output=r[1]
REG[1] =  i:0
  33 Halt             0    0    0               00 
SQL: [SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c1 DESC, c1)
  
;]
VDBE Trace:
   0 Init             0   44    0               00 Start at 44
  44 Transaction      0    0    1 0             01 usesStmtJournal=0
  45 Goto             0    1    0               00 
   1 Explain          1    0    0 SCAN CONSTANT ROW 00 
   2 Integer         11    2    0               00 r[2]=11; return address
REG[2] =  i:11
   3 Once             0   11    0               00 
   4 Explain          4    0    0 SCALAR SUBQUERY 1 00 
   5 Null             0    3    4               00 r[3..4]=NULL; Init subquery result
REG[3] =  NULL
   6 Integer          1    5    0               00 r[5]=1; LIMIT counter
REG[5] =  i:1
   7 Explain          7    4    0 SCAN CONSTANT ROW 00 
   8 Integer          0    3    0               00 r[3]=0
REG[3] =  i:0
   9 Integer          0    4    0               00 r[4]=0
REG[4] =  i:0
  10 DecrJumpZero     5   11    0               00 if (--r[5])==0 goto 11
REG[5] =  i:1
  11 Return           2    0    0               00 
REG[2] =  i:11
  12 Integer         38    6    0               00 r[6]=38; return address
REG[6] =  i:38
  13 Once             0   38    0               00 
  14 Explain         14    0    0 SCALAR SUBQUERY 2 00 
  15 Null             0    7    8               00 r[7..8]=NULL; Init subquery result
REG[7] =  NULL
  16 OpenEphemeral    1    5    0 k(2,-B,B)     00 nColumn=5
  17 Integer          1    9    0               00 r[9]=1; LIMIT counter
REG[9] =  i:1
  18 OpenRead         0    2    0 2             00 root=2 iDb=0; t0
  19 Explain         19   14    0 SCAN TABLE t0 00 
  20 Rewind           0   33    0               00 
  21 Column           0    0    7               00 r[7]=t0.c0
REG[7] =  i:1
  22 Column           0    1   10               00 r[10]=t0.c1
REG[10] =  i:2
  23 Column           0    1   11               00 r[11]=t0.c1
REG[11] =  i:2
  24 Sequence         1   12    0               00 r[12]=cursor[1].ctr++
REG[12] =  i:0
  25 Move             7   13    1               00 r[13]=r[7]
REG[13] =  i:1
  26 IfNotZero        9   30    0               00 if r[9]!=0 then r[9]--, goto 30
REG[9] =  i:1
  30 MakeRecord      10    4   14               00 r[14]=mkrec(r[10..13])
REG[14] =  s7[05010108090202.......]
  31 IdxInsert        1   14   10 4             00 key=r[14]
REG[14] =  s7[05010108090202.......]
  32 Next             0   21    0               01 
  21 Column           0    0    7               00 r[7]=t0.c0
REG[7] =  i:3
  22 Column           0    1   10               00 r[10]=t0.c1
REG[10] =  i:6
  23 Column           0    1   11               00 r[11]=t0.c1
REG[11] =  i:6
  24 Sequence         1   12    0               00 r[12]=cursor[1].ctr++
REG[12] =  i:1
  25 Move             7   13    1               00 r[13]=r[7]
REG[13] =  i:3
  26 IfNotZero        9   30    0               00 if r[9]!=0 then r[9]--, goto 30
REG[9] =  i:0
  27 Last             1    0    0               00 
  28 IdxLE            1   32   10 2             00 key=r[10..11]
REG[10] =  i:6
REG[11] =  i:6
  29 Delete           1    0    0               00 
  30 MakeRecord      10    4   14               00 r[14]=mkrec(r[10..13])
REG[14] =  s8[0501010901060603........]
  31 IdxInsert        1   14   10 4             00 key=r[14]
REG[14] =  s8[0501010901060603........]
  32 Next             0   21    0               01 
  33 Explain         33   14    0 USE TEMP B-TREE FOR ORDER BY 00 
  34 Sort             1   38    0               00 
  35 Column           1    1    8               00 r[8]=c1
REG[8] =  i:6
  36 Column           1    3    7               00 r[7]=c0
REG[7] =  i:3
  37 Next             1   35    0               00 
  38 Return           6    0    0               00 
REG[6] =  i:38
  39 Eq               7    1    3 (BINARY)      61 r[1] = (r[3]==r[7])
REG[7] =  i:3
REG[3] =  i:0
REG[1] =  i:0
  40 IfNot            1   42    0               00 
REG[1] =  i:0
  42 ResultRow        1    1    0               00 output=r[1]
REG[1] =  i:0
  43 Halt             0    0    0               00 
SQL: [SELECT (SELECT 3, 5) == (SELECT * FROM t0 ORDER BY c0 DESC, c1)
;]
VDBE Trace:
   0 Init             0   42    0               00 Start at 42
  42 Transaction      0    0    1 0             01 usesStmtJournal=0
  43 Goto             0    1    0               00 
   1 Explain          1    0    0 SCAN CONSTANT ROW 00 
   2 Integer         11    2    0               00 r[2]=11; return address
REG[2] =  i:11
   3 Once             0   11    0               00 
   4 Explain          4    0    0 SCALAR SUBQUERY 1 00 
   5 Null             0    3    4               00 r[3..4]=NULL; Init subquery result
REG[3] =  NULL
   6 Integer          1    5    0               00 r[5]=1; LIMIT counter
REG[5] =  i:1
   7 Explain          7    4    0 SCAN CONSTANT ROW 00 
   8 Integer          3    3    0               00 r[3]=3
REG[3] =  i:3
   9 Integer          5    4    0               00 r[4]=5
REG[4] =  i:5
  10 DecrJumpZero     5   11    0               00 if (--r[5])==0 goto 11
REG[5] =  i:1
  11 Return           2    0    0               00 
REG[2] =  i:11
  12 Integer         36    6    0               00 r[6]=36; return address
REG[6] =  i:36
  13 Once             0   36    0               00 
  14 Explain         14    0    0 SCALAR SUBQUERY 2 00 
  15 Null             0    7    8               00 r[7..8]=NULL; Init subquery result
REG[7] =  NULL
  16 OpenEphemeral    1    5    0 k(2,-B,B)     00 nColumn=5
  17 Integer          1    9    0               00 r[9]=1; LIMIT counter
REG[9] =  i:1
  18 OpenRead         0    2    0 2             00 root=2 iDb=0; t0
  19 Explain         19   14    0 SCAN TABLE t0 00 
  20 Rewind           0   31    0               00 
  21 Column           0    0   10               00 r[10]=t0.c0
REG[10] =  i:1
  22 Column           0    1   11               00 r[11]=t0.c1
REG[11] =  i:2
  23 Sequence         1   12    0               00 r[12]=cursor[1].ctr++
REG[12] =  i:0
  24 IfNotZero        9   28    0               00 if r[9]!=0 then r[9]--, goto 28
REG[9] =  i:1
  28 MakeRecord      10    3   13               00 r[13]=mkrec(r[10..12])
REG[13] =  s5[0409010802.....]
  29 IdxInsert        1   13   10 3             00 key=r[13]
REG[13] =  s5[0409010802.....]
  30 Next             0   21    0               01 
  21 Column           0    0   10               00 r[10]=t0.c0
REG[10] =  i:3
  22 Column           0    1   11               00 r[11]=t0.c1
REG[11] =  i:6
  23 Sequence         1   12    0               00 r[12]=cursor[1].ctr++
REG[12] =  i:1
  24 IfNotZero        9   28    0               00 if r[9]!=0 then r[9]--, goto 28
REG[9] =  i:0
  25 Last             1    0    0               00 
  26 IdxLE            1   30   10 2             00 key=r[10..11]
REG[10] =  i:3
REG[11] =  i:6
  27 Delete           1    0    0               00 
  28 MakeRecord      10    3   13               00 r[13]=mkrec(r[10..12])
REG[13] =  s6[040101090306......]
  29 IdxInsert        1   13   10 3             00 key=r[13]
REG[13] =  s6[040101090306......]
  30 Next             0   21    0               01 
  31 Explain         31   14    0 USE TEMP B-TREE FOR ORDER BY 00 
  32 Sort             1   36    0               00 
  33 Column           1    1    8               00 r[8]=c1
REG[8] =  i:6
  34 Column           1    0    7               00 r[7]=c0
REG[7] =  i:3
  35 Next             1   33    0               00 
  36 Return           6    0    0               00 
REG[6] =  i:36
  37 Eq               7    1    3 (BINARY)      61 r[1] = (r[3]==r[7])
REG[7] =  i:3
REG[3] =  i:3
REG[1] =  i:1
  38 IfNot            1   40    0               00 
REG[1] =  i:1
  39 Eq               8    1    4 (BINARY)      69 r[1] = (r[4]==r[8])
REG[8] =  i:6
REG[4] =  i:5
REG[1] =  i:0
  40 ResultRow        1    1    0               00 output=r[1]
REG[1] =  i:0
  41 Halt             0    0    0               00 
SQL: [SELECT (SELECT 0, 0) == (SELECT * FROM t0 ORDER BY c1 DESC, c1)
  
;]
VDBE Trace:
   0 Init             0   44    0               00 Start at 44
  44 Transaction      0    0    1 0             01 usesStmtJournal=0
  45 Goto             0    1    0               00 
   1 Explain          1    0    0 SCAN CONSTANT ROW 00 
   2 Integer         11    2    0               00 r[2]=11; return address
REG[2] =  i:11
   3 Once             0   11    0               00 
   4 Explain          4    0    0 SCALAR SUBQUERY 1 00 
   5 Null             0    3    4               00 r[3..4]=NULL; Init subquery result
REG[3] =  NULL
   6 Integer          1    5    0               00 r[5]=1; LIMIT counter
REG[5] =  i:1
   7 Explain          7    4    0 SCAN CONSTANT ROW 00 
   8 Integer          0    3    0               00 r[3]=0
REG[3] =  i:0
   9 Integer          0    4    0               00 r[4]=0
REG[4] =  i:0
  10 DecrJumpZero     5   11    0               00 if (--r[5])==0 goto 11
REG[5] =  i:1
  11 Return           2    0    0               00 
REG[2] =  i:11
  12 Integer         38    6    0               00 r[6]=38; return address
REG[6] =  i:38
  13 Once             0   38    0               00 
  14 Explain         14    0    0 SCALAR SUBQUERY 2 00 
  15 Null             0    7    8               00 r[7..8]=NULL; Init subquery result
REG[7] =  NULL
  16 OpenEphemeral    1    5    0 k(2,-B,B)     00 nColumn=5
  17 Integer          1    9    0               00 r[9]=1; LIMIT counter
REG[9] =  i:1
  18 OpenRead         0    2    0 2             00 root=2 iDb=0; t0
  19 Explain         19   14    0 SCAN TABLE t0 00 
  20 Rewind           0   33    0               00 
  21 Column           0    0    7               00 r[7]=t0.c0
REG[7] =  i:1
  22 Column           0    1   10               00 r[10]=t0.c1
REG[10] =  i:2
  23 Column           0    1   11               00 r[11]=t0.c1
REG[11] =  i:2
  24 Sequence         1   12    0               00 r[12]=cursor[1].ctr++
REG[12] =  i:0
  25 Move             7   13    1               00 r[13]=r[7]
REG[13] =  i:1
  26 IfNotZero        9   30    0               00 if r[9]!=0 then r[9]--, goto 30
REG[9] =  i:1
  30 MakeRecord      10    4   14               00 r[14]=mkrec(r[10..13])
REG[14] =  s7[05010108090202.......]
  31 IdxInsert        1   14   10 4             00 key=r[14]
REG[14] =  s7[05010108090202.......]
  32 Next             0   21    0               01 
  21 Column           0    0    7               00 r[7]=t0.c0
REG[7] =  i:3
  22 Column           0    1   10               00 r[10]=t0.c1
REG[10] =  i:6
  23 Column           0    1   11               00 r[11]=t0.c1
REG[11] =  i:6
  24 Sequence         1   12    0               00 r[12]=cursor[1].ctr++
REG[12] =  i:1
  25 Move             7   13    1               00 r[13]=r[7]
REG[13] =  i:3
  26 IfNotZero        9   30    0               00 if r[9]!=0 then r[9]--, goto 30
REG[9] =  i:0
  27 Last             1    0    0               00 
  28 IdxLE            1   32   10 2             00 key=r[10..11]
REG[10] =  i:6
REG[11] =  i:6
  29 Delete           1    0    0               00 
  30 MakeRecord      10    4   14               00 r[14]=mkrec(r[10..13])
REG[14] =  s8[0501010901060603........]
  31 IdxInsert        1   14   10 4             00 key=r[14]
REG[14] =  s8[0501010901060603........]
  32 Next             0   21    0               01 
  33 Explain         33   14    0 USE TEMP B-TREE FOR ORDER BY 00 
  34 Sort             1   38    0               00 
  35 Column           1    1    8               00 r[8]=c1
REG[8] =  i:6
  36 Column           1    3    7               00 r[7]=c0
REG[7] =  i:3
  37 Next             1   35    0               00 
  38 Return           6    0    0               00 
REG[6] =  i:38
  39 Eq               7    1    3 (BINARY)      61 r[1] = (r[3]==r[7])
REG[7] =  i:3
REG[3] =  i:0
REG[1] =  i:0
  40 IfNot            1   42    0               00 
REG[1] =  i:0
  42 ResultRow        1    1    0               00 output=r[1]
REG[1] =  i:0
  43 Halt             0    0    0               00 
SQL: [SELECT (2, 4) IN (SELECT * FROM t0)
;]
VDBE Trace:
   0 Init             0   34    0               00 Start at 34
  34 Transaction      0    0    1 0             01 usesStmtJournal=0
  35 Integer          2    7    0               00 r[7]=2
REG[7] =  i:2
  36 Integer          4    8    0               00 r[8]=4
REG[8] =  i:4
  37 Goto             0    1    0               00 
   1 Explain          1    0    0 SCAN CONSTANT ROW 00 
   2 Null             0    1    0               00 r[1]=NULL
REG[1] =  NULL
   3 Noop             0    0    0               00 begin IN expr
   4 Integer         16    3    0               00 r[3]=16; return address
REG[3] =  i:16
   5 Once             0   16    0               00 
   6 OpenEphemeral    1    2    0 k(2,B,B)      00 nColumn=2; Result of SELECT 1
   7 Explain          7    0    0 LIST SUBQUERY 1 00 
   8 OpenRead         0    2    0 2             00 root=2 iDb=0; t0
   9 Explain          9    7    0 SCAN TABLE t0 00 
  10 Rewind           0   16    0               00 
  11 Column           0    0    4               00 r[4]=t0.c0
REG[4] =  i:1
  12 Column           0    1    5               00 r[5]=t0.c1
REG[5] =  i:2
  13 MakeRecord       4    2    6 AA            00 r[6]=mkrec(r[4..5])
REG[6] =  s4[03090102....]
  14 IdxInsert        1    6    4 2             00 key=r[6]
REG[6] =  s4[03090102....]
  15 Next             0   11    0               01 
  11 Column           0    0    4               00 r[4]=t0.c0
REG[4] =  i:3
  12 Column           0    1    5               00 r[5]=t0.c1
REG[5] =  i:6
  13 MakeRecord       4    2    6 AA            00 r[6]=mkrec(r[4..5])
REG[6] =  s5[0301010306.....]
  14 IdxInsert        1    6    4 2             00 key=r[6]
REG[6] =  s5[0301010306.....]
  15 Next             0   11    0               01 
  16 Return           3    0    0               00 
REG[3] =  i:16
  17 Integer          0    2    0               00 r[2]=0
REG[2] =  i:0
  18 Rewind           1   20    0               00 
  19 Column           1    0    2               80 r[2]=first_entry_in(1)
REG[2] =  i:1
  20 Affinity         7    2    0 AA            00 affinity(r[7..8])
  21 Found            1   30    7 2             00 key=r[7..8]
REG[7] =  i:2
REG[8] =  i:4
  22 Rewind           1   31    0               00 
  23 Column           1    0    6               00 r[6]=
REG[6] =  i:1
  24 Ne               7   28    6               00 if r[6]!=r[7] goto 28
REG[7] =  i:2
REG[6] =  i:1
  28 Next             1   23    0               00 
  23 Column           1    0    6               00 r[6]=
REG[6] =  i:3
  24 Ne               7   28    6               00 if r[6]!=r[7] goto 28
REG[7] =  i:2
REG[6] =  i:3
  28 Next             1   23    0               00 
  29 Goto             0   31    0               00 end IN expr
  31 AddImm           1    0    0               00 r[1]=r[1]+0
REG[1] =  NULL
  32 ResultRow        1    1    0               00 output=r[1]
REG[1] =  i:0
  33 Halt             0    0    0               00 
SQL: [SELECT (3, 4) IN (SELECT * FROM t0)
;]
VDBE Trace:
   0 Init             0   34    0               00 Start at 34
  34 Transaction      0    0    1 0             01 usesStmtJournal=0
  35 Integer          3    7    0               00 r[7]=3
REG[7] =  i:3
  36 Integer          4    8    0               00 r[8]=4
REG[8] =  i:4
  37 Goto             0    1    0               00 
   1 Explain          1    0    0 SCAN CONSTANT ROW 00 
   2 Null             0    1    0               00 r[1]=NULL
REG[1] =  NULL
   3 Noop             0    0    0               00 begin IN expr
   4 Integer         16    3    0               00 r[3]=16; return address
REG[3] =  i:16
   5 Once             0   16    0               00 
   6 OpenEphemeral    1    2    0 k(2,B,B)      00 nColumn=2; Result of SELECT 1
   7 Explain          7    0    0 LIST SUBQUERY 1 00 
   8 OpenRead         0    2    0 2             00 root=2 iDb=0; t0
   9 Explain          9    7    0 SCAN TABLE t0 00 
  10 Rewind           0   16    0               00 
  11 Column           0    0    4               00 r[4]=t0.c0
REG[4] =  i:1
  12 Column           0    1    5               00 r[5]=t0.c1
REG[5] =  i:2
  13 MakeRecord       4    2    6 AA            00 r[6]=mkrec(r[4..5])
REG[6] =  s4[03090102....]
  14 IdxInsert        1    6    4 2             00 key=r[6]
REG[6] =  s4[03090102....]
  15 Next             0   11    0               01 
  11 Column           0    0    4               00 r[4]=t0.c0
REG[4] =  i:3
  12 Column           0    1    5               00 r[5]=t0.c1
REG[5] =  i:6
  13 MakeRecord       4    2    6 AA            00 r[6]=mkrec(r[4..5])
REG[6] =  s5[0301010306.....]
  14 IdxInsert        1    6    4 2             00 key=r[6]
REG[6] =  s5[0301010306.....]
  15 Next             0   11    0               01 
  16 Return           3    0    0               00 
REG[3] =  i:16
  17 Integer          0    2    0               00 r[2]=0
REG[2] =  i:0
  18 Rewind           1   20    0               00 
  19 Column           1    0    2               80 r[2]=first_entry_in(1)
REG[2] =  i:1
  20 Affinity         7    2    0 AA            00 affinity(r[7..8])
  21 Found            1   30    7 2             00 key=r[7..8]
REG[7] =  i:3
REG[8] =  i:4
  22 Rewind           1   31    0               00 
  23 Column           1    0    6               00 r[6]=
REG[6] =  i:1
  24 Ne               7   28    6               00 if r[6]!=r[7] goto 28
REG[7] =  i:3
REG[6] =  i:1
  28 Next             1   23    0               00 
  23 Column           1    0    6               00 r[6]=
REG[6] =  i:3
  24 Ne               7   28    6               00 if r[6]!=r[7] goto 28
REG[7] =  i:3
REG[6] =  i:3
  25 Column           1    1    6               00 r[6]=
REG[6] =  i:6
  26 Ne               8   28    6               00 if r[6]!=r[8] goto 28
REG[8] =  i:4
REG[6] =  i:6
  28 Next             1   23    0               00 
  29 Goto             0   31    0               00 end IN expr
  31 AddImm           1    0    0               00 r[1]=r[1]+0
REG[1] =  NULL
  32 ResultRow        1    1    0               00 output=r[1]
REG[1] =  i:0
  33 Halt             0    0    0               00 
SQL: [SELECT (NULL, 4) IN (SELECT * FROM t0)
;]
VDBE Trace:
   0 Init             0   35    0               00 Start at 35
  35 Transaction      0    0    1 0             01 usesStmtJournal=0
  36 Null             0    7    0               00 r[7]=NULL
REG[7] =  NULL
  37 Integer          4    8    0               00 r[8]=4
REG[8] =  i:4
  38 Goto             0    1    0               00 
   1 Explain          1    0    0 SCAN CONSTANT ROW 00 
   2 Null             0    1    0               00 r[1]=NULL
REG[1] =  NULL
   3 Noop             0    0    0               00 begin IN expr
   4 Integer         16    3    0               00 r[3]=16; return address
REG[3] =  i:16
   5 Once             0   16    0               00 
   6 OpenEphemeral    1    2    0 k(2,B,B)      00 nColumn=2; Result of SELECT 1
   7 Explain          7    0    0 LIST SUBQUERY 1 00 
   8 OpenRead         0    2    0 2             00 root=2 iDb=0; t0
   9 Explain          9    7    0 SCAN TABLE t0 00 
  10 Rewind           0   16    0               00 
  11 Column           0    0    4               00 r[4]=t0.c0
REG[4] =  i:1
  12 Column           0    1    5               00 r[5]=t0.c1
REG[5] =  i:2
  13 MakeRecord       4    2    6 AA            00 r[6]=mkrec(r[4..5])
REG[6] =  s4[03090102....]
  14 IdxInsert        1    6    4 2             00 key=r[6]
REG[6] =  s4[03090102....]
  15 Next             0   11    0               01 
  11 Column           0    0    4               00 r[4]=t0.c0
REG[4] =  i:3
  12 Column           0    1    5               00 r[5]=t0.c1
REG[5] =  i:6
  13 MakeRecord       4    2    6 AA            00 r[6]=mkrec(r[4..5])
REG[6] =  s5[0301010306.....]
  14 IdxInsert        1    6    4 2             00 key=r[6]
REG[6] =  s5[0301010306.....]
  15 Next             0   11    0               01 
  16 Return           3    0    0               00 
REG[3] =  i:16
  17 Integer          0    2    0               00 r[2]=0
REG[2] =  i:0
  18 Rewind           1   20    0               00 
  19 Column           1    0    2               80 r[2]=first_entry_in(1)
REG[2] =  i:1
  20 IsNull           7   23    0               00 if r[7]==NULL goto 23
REG[7] =  NULL
  23 Rewind           1   32    0               00 
  24 Column           1    0    6               00 r[6]=
REG[6] =  i:1
  25 Ne               7   29    6               00 if r[6]!=r[7] goto 29
REG[7] =  NULL
REG[6] =  i:1
  26 Column           1    1    6               00 r[6]=
REG[6] =  i:2
  27 Ne               8   29    6               00 if r[6]!=r[8] goto 29
REG[8] =  i:4
REG[6] =  i:2
  29 Next             1   24    0               00 
  24 Column           1    0    6               00 r[6]=
REG[6] =  i:3
  25 Ne               7   29    6               00 if r[6]!=r[7] goto 29
REG[7] =  NULL
REG[6] =  i:3
  26 Column           1    1    6               00 r[6]=
REG[6] =  i:6
  27 Ne               8   29    6               00 if r[6]!=r[8] goto 29
REG[8] =  i:4
REG[6] =  i:6
  29 Next             1   24    0               00 
  30 Goto             0   32    0               00 end IN expr
  32 AddImm           1    0    0               00 r[1]=r[1]+0
REG[1] =  NULL
  33 ResultRow        1    1    0               00 output=r[1]
REG[1] =  i:0
  34 Halt             0    0    0               00 
SQL: [SELECT (NULL, 0) IN (SELECT * FROM t0)
;]
VDBE Trace:
   0 Init             0   35    0               00 Start at 35
  35 Transaction      0    0    1 0             01 usesStmtJournal=0
  36 Null             0    7    0               00 r[7]=NULL
REG[7] =  NULL
  37 Integer          0    8    0               00 r[8]=0
REG[8] =  i:0
  38 Goto             0    1    0               00 
   1 Explain          1    0    0 SCAN CONSTANT ROW 00 
   2 Null             0    1    0               00 r[1]=NULL
REG[1] =  NULL
   3 Noop             0    0    0               00 begin IN expr
   4 Integer         16    3    0               00 r[3]=16; return address
REG[3] =  i:16
   5 Once             0   16    0               00 
   6 OpenEphemeral    1    2    0 k(2,B,B)      00 nColumn=2; Result of SELECT 1
   7 Explain          7    0    0 LIST SUBQUERY 1 00 
   8 OpenRead         0    2    0 2             00 root=2 iDb=0; t0
   9 Explain          9    7    0 SCAN TABLE t0 00 
  10 Rewind           0   16    0               00 
  11 Column           0    0    4               00 r[4]=t0.c0
REG[4] =  i:1
  12 Column           0    1    5               00 r[5]=t0.c1
REG[5] =  i:2
  13 MakeRecord       4    2    6 AA            00 r[6]=mkrec(r[4..5])
REG[6] =  s4[03090102....]
  14 IdxInsert        1    6    4 2             00 key=r[6]
REG[6] =  s4[03090102....]
  15 Next             0   11    0               01 
  11 Column           0    0    4               00 r[4]=t0.c0
REG[4] =  i:3
  12 Column           0    1    5               00 r[5]=t0.c1
REG[5] =  i:6
  13 MakeRecord       4    2    6 AA            00 r[6]=mkrec(r[4..5])
REG[6] =  s5[0301010306.....]
  14 IdxInsert        1    6    4 2             00 key=r[6]
REG[6] =  s5[0301010306.....]
  15 Next             0   11    0               01 
  16 Return           3    0    0               00 
REG[3] =  i:16
  17 Integer          0    2    0               00 r[2]=0
REG[2] =  i:0
  18 Rewind           1   20    0               00 
  19 Column           1    0    2               80 r[2]=first_entry_in(1)
REG[2] =  i:1
  20 IsNull           7   23    0               00 if r[7]==NULL goto 23
REG[7] =  NULL
  23 Rewind           1   32    0               00 
  24 Column           1    0    6               00 r[6]=
REG[6] =  i:1
  25 Ne               7   29    6               00 if r[6]!=r[7] goto 29
REG[7] =  NULL
REG[6] =  i:1
  26 Column           1    1    6               00 r[6]=
REG[6] =  i:2
  27 Ne               8   29    6               00 if r[6]!=r[8] goto 29
REG[8] =  i:0
REG[6] =  i:2
  29 Next             1   24    0               00 
  24 Column           1    0    6               00 r[6]=
REG[6] =  i:3
  25 Ne               7   29    6               00 if r[6]!=r[7] goto 29
REG[7] =  NULL
REG[6] =  i:3
  26 Column           1    1    6               00 r[6]=
REG[6] =  i:6
  27 Ne               8   29    6               00 if r[6]!=r[8] goto 29
REG[8] =  i:0
REG[6] =  i:6
  29 Next             1   24    0               00 
  30 Goto             0   32    0               00 end IN expr
  32 AddImm           1    0    0               00 r[1]=r[1]+0
REG[1] =  NULL
  33 ResultRow        1    1    0               00 output=r[1]
REG[1] =  i:0
  34 Halt             0    0    0               00 
SQL: [;CREATE INDEX t1 ON t0(c0, c0);]
VDBE Trace:
   0 Init             0   34    0               00 Start at 34
  34 Transaction      0    1    1 0             01 usesStmtJournal=0
  35 Goto             0    1    0               00 
   1 Noop             0   33    0               00 
   2 CreateBtree      0    1    2               00 r[1]=root iDb=0 flags=2
REG[1] =  i:3
   3 OpenWrite        0    1    0 5             00 root=1 iDb=0; sqlite_master
   4 NewRowid         0    2    0               00 r[2]=rowid
REG[2] =  i:2
   5 String8          0    3    0 index         00 r[3]='index'
REG[3] =   t5[index](8)
   6 String8          0    4    0 t1            00 r[4]='t1'
REG[4] =   t2[t1](8)
   7 String8          0    5    0 t0            00 r[5]='t0'
REG[5] =   t2[t0](8)
   8 Copy             1    6    0               00 r[6]=r[1]
REG[6] =  i:3
   9 String8          0    7    0 CREATE INDEX t1 ON t0(c0, c0) 00 r[7]='CREATE INDEX t1 ON t0(c0, c0)'
REG[7] =   t29[CREATE INDEX t1](8)
  10 MakeRecord       3    5    8 BBBDB         00 r[8]=mkrec(r[3..7])
REG[8] =  s45[061711110147696E6465787431743003.....Gindext1t0.]
  11 Insert           0    8    2               18 intkey=r[2] data=r[8]
REG[8] =  s45[061711110147696E6465787431743003.....Gindext1t0.]
REG[2] =  i:2
  12 SorterOpen       3    0    2 k(3,,,)       00 
  13 OpenRead         1    2    0 2             00 root=2 iDb=0; t0
  14 Rewind           1   21    0               00 
  15 Column           1    0   10               00 r[10]=t0.c0
REG[10] =  i:1
  16 Column           1    0   11               00 r[11]=t0.c0
REG[11] =  i:1
  17 Rowid            1   12    0               00 r[12]=rowid
REG[12] =  i:1
  18 MakeRecord      10    3    9               00 r[9]=mkrec(r[10..12])
REG[9] =  s4[04090909....]
  19 SorterInsert     3    9    0               00 key=r[9]
REG[9] =  s4[04090909....]
  20 Next             1   15    0               00 
  15 Column           1    0   10               00 r[10]=t0.c0
REG[10] =  i:3
  16 Column           1    0   11               00 r[11]=t0.c0
REG[11] =  i:3
  17 Rowid            1   12    0               00 r[12]=rowid
REG[12] =  i:2
  18 MakeRecord      10    3    9               00 r[9]=mkrec(r[10..12])
REG[9] =  s7[04010101030302.......]
  19 SorterInsert     3    9    0               00 key=r[9]
REG[9] =  s7[04010101030302.......]
  20 Next             1   15    0               00 
  21 OpenWrite        2    1    0 k(3,,,)       11 root=1 iDb=0
  22 SorterSort       3   27    0               00 
  23 SorterData       3    9    2               00 r[9]=data
  24 SeekEnd          2    0    0               00 
  25 IdxInsert        2    9    0               10 key=r[9]
REG[9] =  s4[04090909....]
  26 SorterNext       3   23    0               00 
  23 SorterData       3    9    2               00 r[9]=data
  24 SeekEnd          2    0    0               00 
  25 IdxInsert        2    9    0               10 key=r[9]
REG[9] =  s7[04010101030302.......]
  26 SorterNext       3   23    0               00 
  27 Close            1    0    0               00 
  28 Close            2    0    0               00 
  29 Close            3    0    0               00 
  30 SetCookie        0    1    2               00 
  31 ParseSchema      0    0    0 name='t1' AND type='index' 00 
VDBE Trace:
   0 Init             0   15    0               00 Start at 15
  15 Transaction      0    0    2 0             00 usesStmtJournal=0
  16 String8          0    2    0 t1            00 r[2]='t1'
REG[2] =   t2[t1](8)
  17 String8          0    3    0 index         00 r[3]='index'
REG[3] =   t5[index](8)
  18 Goto             0    1    0               00 
   1 Noop             1    5    0               00 
   2 OpenRead         0    1    0 5             00 root=1 iDb=0; sqlite_master
   3 Explain          3    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   14    0               00 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s2[t0](8)
   6 Ne               2   13    1 (BINARY)      52 if r[1]!=r[2] goto 13
REG[2] =   t2[t1](8)
REG[1] =   s2[t0](8)
  13 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s2[t1](8)
   6 Ne               2   13    1 (BINARY)      52 if r[1]!=r[2] goto 13
REG[2] =   t2[t1](8)
REG[1] =   s2[t1](8)
   7 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[index](8)
   8 Ne               3   13    1 (BINARY)      52 if r[1]!=r[3] goto 13
REG[3] =   t5[index](8)
REG[1] =   s5[index](8)
   9 Column           0    1    4               00 r[4]=sqlite_master.name
REG[4] =   s2[t1](8)
  10 Column           0    3    5               00 r[5]=sqlite_master.rootpage
REG[5] =  i:3
  11 Column           0    4    6               00 r[6]=sqlite_master.sql
REG[6] =   s29[CREATE INDEX t1](8)
  12 ResultRow        4    3    0               00 output=r[4..6]
REG[4] =   s2[t1](8)
REG[5] =  i:3
REG[6] =   s29[CREATE INDEX t1](8)
  13 Next             0    5    0               01 
  14 Halt             0    0    0               00 
  32 Expire           0    1    0               00 
  33 Halt             0    0    0               00 
SQL: [;
;SELECT c0 FROM t0 WHERE (c1, c0) = (SELECT 'abc', 1);]
VDBE Trace:
   0 Init             0   27    0               00 Start at 27
  27 Transaction      0    0    2 0             01 usesStmtJournal=0
  28 Goto             0    1    0               00 
   1 OpenRead         0    2    0 2             00 root=2 iDb=0; t0
   2 OpenRead         1    3    0 k(3,,,)       02 root=3 iDb=0; t1
   3 Explain          3    0    0 SEARCH TABLE t0 USING INDEX t1 (c0=? AND c0=?) 00 
   4 Integer         13    3    0               00 r[3]=13; return address
REG[3] =  i:13
   5 Once             0   13    0               00 
   6 Explain          6    0    0 SCALAR SUBQUERY 1 00 
   7 Null             0    4    5               00 r[4..5]=NULL; Init subquery result
REG[4] =  NULL
   8 Integer          1    6    0               00 r[6]=1; LIMIT counter
REG[6] =  i:1
   9 Explain          9    6    0 SCAN CONSTANT ROW 00 
  10 String8          0    4    0 abc           00 r[4]='abc'
REG[4] =   t3[abc](8)
  11 Integer          1    5    0               00 r[5]=1
REG[5] =  i:1
  12 DecrJumpZero     6   13    0               00 if (--r[6])==0 goto 13
REG[6] =  i:1
  13 Return           3    0    0               00 
REG[3] =  i:13
  14 SCopy            5    1    0               00 r[1]=r[5]
REG[1] =  i:1
  15 IsNull           1   26    0               00 if r[1]==NULL goto 26
REG[1] =  i:1
  16 SCopy            5    2    0               00 r[2]=r[5]
REG[2] =  i:1
  17 IsNull           2   26    0               00 if r[2]==NULL goto 26
REG[2] =  i:1
  18 SeekGE           1   26    1 2             00 key=r[1..2]
REG[1] =  i:1
  20 DeferredSeek     1    0    0               00 Move 0 to 1.rowid if needed
  21 Column           0    1    7               00 r[7]=t0.c1
REG[7] =  i:2
  22 Ne               4   25    7 (BINARY)      51 if r[7]!=r[4] goto 25
REG[4] =   t3[abc](8)
REG[7] =  i:2
  25 Next             1   19    1               00 
  19 IdxGT            1   26    1 2             00 key=r[1..2]
REG[1] =  i:1
REG[2] =  i:1
  26 Halt             0    0    0               00 
SQL: [
;SELECT c0 FROM t0 WHERE (c0 COLLATE nocase, c0) = (SELECT 'def', 2);]
VDBE Trace:
   0 Init             0   25    0               00 Start at 25
  25 Transaction      0    0    2 0             01 usesStmtJournal=0
  26 Goto             0    1    0               00 
   1 OpenRead         1    3    0 k(3,,,)       02 root=3 iDb=0; t1
   2 Explain          2    0    0 SEARCH TABLE t0 USING COVERING INDEX t1 (c0=? AND c0=?) 00 
   3 Integer         12    3    0               00 r[3]=12; return address
REG[3] =  i:12
   4 Once             0   12    0               00 
   5 Explain          5    0    0 SCALAR SUBQUERY 1 00 
   6 Null             0    4    5               00 r[4..5]=NULL; Init subquery result
REG[4] =  NULL
   7 Integer          1    6    0               00 r[6]=1; LIMIT counter
REG[6] =  i:1
   8 Explain          8    5    0 SCAN CONSTANT ROW 00 
   9 String8          0    4    0 def           00 r[4]='def'
REG[4] =   t3[def](8)
  10 Integer          2    5    0               00 r[5]=2
REG[5] =  i:2
  11 DecrJumpZero     6   12    0               00 if (--r[6])==0 goto 12
REG[6] =  i:1
  12 Return           3    0    0               00 
REG[3] =  i:12
  13 SCopy            5    1    0               00 r[1]=r[5]
REG[1] =  i:2
  14 IsNull           1   24    0               00 if r[1]==NULL goto 24
REG[1] =  i:2
  15 SCopy            5    2    0               00 r[2]=r[5]
REG[2] =  i:2
  16 IsNull           2   24    0               00 if r[2]==NULL goto 24
REG[2] =  i:2
  17 SeekGE           1   24    1 2             00 key=r[1..2]
REG[1] =  i:2
  24 Halt             0    0    0               00 
SQL: [;
;SELECT c0 FROM t0 WHERE (c1, c1) = (SELECT 2, 'def');]
VDBE Trace:
   0 Init             0   22    0               00 Start at 22
  22 Transaction      0    0    2 0             01 usesStmtJournal=0
  23 Goto             0    1    0               00 
   1 OpenRead         0    2    0 2             00 root=2 iDb=0; t0
   2 Explain          2    0    0 SCAN TABLE t0 00 
   3 Rewind           0   21    0               00 
   4 Column           0    1    1               00 r[1]=t0.c1
REG[1] =  i:2
   5 Integer         14    3    0               00 r[3]=14; return address
REG[3] =  i:14
   6 Once             0   14    0               00 
   7 Explain          7    0    0 SCALAR SUBQUERY 1 00 
   8 Null             0    4    5               00 r[4..5]=NULL; Init subquery result
REG[4] =  NULL
   9 Integer          1    6    0               00 r[6]=1; LIMIT counter
REG[6] =  i:1
  10 Explain         10    7    0 SCAN CONSTANT ROW 00 
  11 Integer          2    4    0               00 r[4]=2
REG[4] =  i:2
  12 String8          0    5    0 def           00 r[5]='def'
REG[5] =   t3[def](8)
  13 DecrJumpZero     6   14    0               00 if (--r[6])==0 goto 14
REG[6] =  i:1
  14 Return           3    0    0               00 
REG[3] =  i:14
  15 Ne               4   20    1 (BINARY)      51 if r[1]!=r[4] goto 20
REG[4] =  i:2
REG[1] =  i:2
  16 Column           0    1    1               00 r[1]=t0.c1
REG[1] =  i:2
  17 Ne               5   20    1 (BINARY)      51 if r[1]!=r[5] goto 20
REG[5] =   t3[def](8)
REG[1] =  i:2
  20 Next             0    4    0               01 
   4 Column           0    1    1               00 r[1]=t0.c1
REG[1] =  i:6
   5 Integer         14    3    0               00 r[3]=14; return address
REG[3] =  i:14
   6 Once             1   14    0               00 
  14 Return           3    0    0               00 
REG[3] =  i:14
  15 Ne               4   20    1 (BINARY)      51 if r[1]!=r[4] goto 20
REG[4] =  i:2
REG[1] =  i:6
  20 Next             0    4    0               01 
  21 Halt             0    0    0               00 
SQL: [SELECT * FROM t0 WHERE (c0, c1) IS (2, 2)
;]
VDBE Trace:
   0 Init             0   16    0               00 Start at 16
  16 Transaction      0    0    2 0             01 usesStmtJournal=0
  17 Integer          2    4    0               00 r[4]=2
REG[4] =  i:2
  18 Goto             0    1    0               00 
   1 OpenRead         0    2    0 2             00 root=2 iDb=0; t0
   2 OpenRead         1    3    0 k(3,,,)       02 root=3 iDb=0; t1
   3 Explain          3    0    0 SEARCH TABLE t0 USING INDEX t1 (c0=? AND c0=?) 00 
   4 Integer          2    1    0               00 r[1]=2
REG[1] =  i:2
   5 Integer          2    2    0               00 r[2]=2
REG[2] =  i:2
   6 SeekGE           1   15    1 2             00 key=r[1..2]
REG[1] =  i:2
  15 Halt             0    0    0               00 
SQL: [SELECT * FROM t0 WHERE (c0, c0) < (2, 3)
;]
VDBE Trace:
   0 Init             0   22    0               00 Start at 22
  22 Transaction      0    0    2 0             01 usesStmtJournal=0
  23 Integer          2    5    0               00 r[5]=2
REG[5] =  i:2
  24 Integer          3    6    0               00 r[6]=3
REG[6] =  i:3
  25 Goto             0    1    0               00 
   1 OpenRead         0    2    0 2             00 root=2 iDb=0; t0
   2 OpenRead         1    3    0 k(3,,,)       00 root=3 iDb=0; t1
   3 Explain          3    0    0 SEARCH TABLE t0 USING INDEX t1 ((c0,c0)<(?,?)) 00 
   4 Null             0    1    0               00 r[1]=NULL
REG[1] =  NULL
   5 SeekGT           1   21    1 1             00 key=r[1]
REG[1] =  NULL
   6 Integer          2    1    0               00 r[1]=2
REG[1] =  i:2
   7 Integer          3    2    0               00 r[2]=3
REG[2] =  i:3
   8 IsNull           1   21    0               00 if r[1]==NULL goto 21
REG[1] =  i:2
   9 IdxGT            1   21    1 2             00 key=r[1..2]
REG[1] =  i:2
REG[2] =  i:3
  10 DeferredSeek     1    0    0               00 Move 0 to 1.rowid if needed
  11 Column           1    0    4               00 r[4]=t0.c0
REG[4] =  i:1
  12 Lt               5    3    4 (BINARY)      61 r[3] = (r[4]<r[5])
REG[5] =  i:2
REG[4] =  i:1
REG[3] =  i:1
  13 ElseNotEq        0   16    0               00 
  16 IfNot            3   20    1               00 
REG[3] =  i:1
  17 Column           1    0    7               00 r[7]=t0.c0
REG[7] =  i:1
  18 Column           0    1    8               00 r[8]=t0.c1
REG[8] =  i:2
  19 ResultRow        7    2    0               00 output=r[7..8]
REG[7] =  i:1
REG[8] =  i:2
  20 Next             1    9    0               00 
   9 IdxGT            1   21    1 2             00 key=r[1..2]
REG[1] =  i:2
REG[2] =  i:3
  21 Halt             0    0    0               00 
SQL: [SELECT * FROM t0 WHERE (c1, c1) > (2, 1)
;]
VDBE Trace:
   0 Init             0   15    0               00 Start at 15
  15 Transaction      0    0    2 0             01 usesStmtJournal=0
  16 Integer          2    3    0               00 r[3]=2
REG[3] =  i:2
  17 Integer          1    4    0               00 r[4]=1
REG[4] =  i:1
  18 Goto             0    1    0               00 
   1 OpenRead         0    2    0 2             00 root=2 iDb=0; t0
   2 Explain          2    0    0 SCAN TABLE t0 00 
   3 Rewind           0   14    0               00 
   4 Column           0    1    2               00 r[2]=t0.c1
REG[2] =  i:2
   5 Gt               3    1    2 (BINARY)      61 r[1] = (r[2]>r[3])
REG[3] =  i:2
REG[2] =  i:2
REG[1] =  i:0
   6 ElseNotEq        0    9    0               00 
   7 Column           0    1    2               00 r[2]=t0.c1
REG[2] =  i:2
   8 Gt               4    1    2 (BINARY)      61 r[1] = (r[2]>r[4])
REG[4] =  i:1
REG[2] =  i:2
REG[1] =  i:1
   9 IfNot            1   13    1               00 
REG[1] =  i:1
  10 Column           0    0    5               00 r[5]=t0.c0
REG[5] =  i:1
  11 Column           0    1    6               00 r[6]=t0.c1
REG[6] =  i:2
  12 ResultRow        5    2    0               00 output=r[5..6]
REG[5] =  i:1
REG[6] =  i:2
  13 Next             0    4    0               01 
   4 Column           0    1    2               00 r[2]=t0.c1
REG[2] =  i:6
   5 Gt               3    1    2 (BINARY)      61 r[1] = (r[2]>r[3])
REG[3] =  i:2
REG[2] =  i:6
REG[1] =  i:1
   6 ElseNotEq        0    9    0               00 
   9 IfNot            1   13    1               00 
REG[1] =  i:1
  10 Column           0    0    5               00 r[5]=t0.c0
REG[5] =  i:3
  11 Column           0    1    6               00 r[6]=t0.c1
REG[6] =  i:6
  12 ResultRow        5    2    0               00 output=r[5..6]
REG[5] =  i:3
REG[6] =  i:6
  13 Next             0    4    0               01 
  14 Halt             0    0    0               00 
SQL: [SELECT * FROM t0 WHERE (c1, c1) > ('2', 1)
;]
VDBE Trace:
   0 Init             0   15    0               00 Start at 15
  15 Transaction      0    0    2 0             01 usesStmtJournal=0
  16 String8          0    3    0 2             00 r[3]='2'
REG[3] =   t1[2](8)
  17 Integer          1    4    0               00 r[4]=1
REG[4] =  i:1
  18 Goto             0    1    0               00 
   1 OpenRead         0    2    0 2             00 root=2 iDb=0; t0
   2 Explain          2    0    0 SCAN TABLE t0 00 
   3 Rewind           0   14    0               00 
   4 Column           0    1    2               00 r[2]=t0.c1
REG[2] =  i:2
   5 Gt               3    1    2 (BINARY)      61 r[1] = (r[2]>r[3])
REG[3] =   t1[2](8)
REG[2] =  i:2
REG[1] =  i:0
   6 ElseNotEq        0    9    0               00 
   9 IfNot            1   13    1               00 
REG[1] =  i:0
  13 Next             0    4    0               01 
   4 Column           0    1    2               00 r[2]=t0.c1
REG[2] =  i:6
   5 Gt               3    1    2 (BINARY)      61 r[1] = (r[2]>r[3])
REG[3] =   t1[2](8)
REG[2] =  i:6
REG[1] =  i:0
   6 ElseNotEq        0    9    0               00 
   9 IfNot            1   13    1               00 
REG[1] =  i:0
  13 Next             0    4    0               01 
  14 Halt             0    0    0               00 
SQL: [SELECT c1 FROM t0 WHERE (c0, c1) < (4, 5)
;]
VDBE Trace:
   0 Init             0   20    0               00 Start at 20
  20 Transaction      0    0    2 0             01 usesStmtJournal=0
  21 Integer          4    4    0               00 r[4]=4
REG[4] =  i:4
  22 Integer          5    5    0               00 r[5]=5
REG[5] =  i:5
  23 Goto             0    1    0               00 
   1 OpenRead         0    2    0 2             00 root=2 iDb=0; t0
   2 OpenRead         1    3    0 k(3,,,)       00 root=3 iDb=0; t1
   3 Explain          3    0    0 SEARCH TABLE t0 USING INDEX t1 (c0<?) 00 
   4 Null             0    1    0               00 r[1]=NULL
REG[1] =  NULL
   5 SeekGT           1   19    1 1             00 key=r[1]
REG[1] =  NULL
   6 Integer          4    1    0               00 r[1]=4
REG[1] =  i:4
   7 IsNull           1   19    0               00 if r[1]==NULL goto 19
REG[1] =  i:4
   8 IdxGT            1   19    1 1             00 key=r[1]
REG[1] =  i:4
   9 DeferredSeek     1    0    0               00 Move 0 to 1.rowid if needed
  10 Column           1    0    3               00 r[3]=t0.c0
REG[3] =  i:1
  11 Lt               4    2    3 (BINARY)      61 r[2] = (r[3]<r[4])
REG[4] =  i:4
REG[3] =  i:1
REG[2] =  i:1
  12 ElseNotEq        0   15    0               00 
  15 IfNot            2   18    1               00 
REG[2] =  i:1
  16 Column           0    1    6               00 r[6]=t0.c1
REG[6] =  i:2
  17 ResultRow        6    1    0               00 output=r[6]
REG[6] =  i:2
  18 Next             1    8    0               00 
   8 IdxGT            1   19    1 1             00 key=r[1]
REG[1] =  i:4
   9 DeferredSeek     1    0    0               00 Move 0 to 1.rowid if needed
  10 Column           1    0    3               00 r[3]=t0.c0
REG[3] =  i:3
  11 Lt               4    2    3 (BINARY)      61 r[2] = (r[3]<r[4])
REG[4] =  i:4
REG[3] =  i:3
REG[2] =  i:1
  12 ElseNotEq        0   15    0               00 
  15 IfNot            2   18    1               00 
REG[2] =  i:1
  16 Column           0    1    6               00 r[6]=t0.c1
REG[6] =  i:6
  17 ResultRow        6    1    0               00 output=r[6]
REG[6] =  i:6
  18 Next             1    8    0               00 
  19 Halt             0    0    0               00 
SQL: [SELECT c0 FROM t0 WHERE (c0, c0) < (4, 3)
;]
VDBE Trace:
   0 Init             0   19    0               00 Start at 19
  19 Transaction      0    0    2 0             01 usesStmtJournal=0
  20 Integer          4    5    0               00 r[5]=4
REG[5] =  i:4
  21 Integer          3    6    0               00 r[6]=3
REG[6] =  i:3
  22 Goto             0    1    0               00 
   1 OpenRead         1    3    0 k(3,,,)       00 root=3 iDb=0; t1
   2 Explain          2    0    0 SEARCH TABLE t0 USING COVERING INDEX t1 ((c0,c0)<(?,?)) 00 
   3 Null             0    1    0               00 r[1]=NULL
REG[1] =  NULL
   4 SeekGT           1   18    1 1             00 key=r[1]
REG[1] =  NULL
   5 Integer          4    1    0               00 r[1]=4
REG[1] =  i:4
   6 Integer          3    2    0               00 r[2]=3
REG[2] =  i:3
   7 IsNull           1   18    0               00 if r[1]==NULL goto 18
REG[1] =  i:4
   8 IdxGT            1   18    1 2             00 key=r[1..2]
REG[1] =  i:4
REG[2] =  i:3
   9 Column           1    0    4               00 r[4]=t0.c0
REG[4] =  i:1
  10 Lt               5    3    4 (BINARY)      61 r[3] = (r[4]<r[5])
REG[5] =  i:4
REG[4] =  i:1
REG[3] =  i:1
  11 ElseNotEq        0   14    0               00 
  14 IfNot            3   17    1               00 
REG[3] =  i:1
  15 Column           1    0    7               00 r[7]=t0.c0
REG[7] =  i:1
  16 ResultRow        7    1    0               00 output=r[7]
REG[7] =  i:1
  17 Next             1    8    0               00 
   8 IdxGT            1   18    1 2             00 key=r[1..2]
REG[1] =  i:4
REG[2] =  i:3
   9 Column           1    0    4               00 r[4]=t0.c0
REG[4] =  i:3
  10 Lt               5    3    4 (BINARY)      61 r[3] = (r[4]<r[5])
REG[5] =  i:4
REG[4] =  i:3
REG[3] =  i:1
  11 ElseNotEq        0   14    0               00 
  14 IfNot            3   17    1               00 
REG[3] =  i:1
  15 Column           1    0    7               00 r[7]=t0.c0
REG[7] =  i:3
  16 ResultRow        7    1    0               00 output=r[7]
REG[7] =  i:3
  17 Next             1    8    0               00 
  18 Halt             0    0    0               00 
SQL: [;INSERT INTO t0(c0) VALUES('X');]
VDBE Trace:
   0 Init             0   14    0               00 Start at 14
  14 Transaction      0    1    2 0             01 usesStmtJournal=0
  15 Null             0    3    0               00 r[3]=NULL
REG[3] =  NULL
  16 Goto             0    1    0               00 
   1 OpenWrite        0    2    0 2             00 root=2 iDb=0; t0
   2 OpenWrite        1    3    0 k(3,,,)       00 root=3 iDb=0; t1
   3 NewRowid         0    1    0               00 r[1]=rowid
REG[1] =  i:3
   4 String8          0    2    0 X             00 r[2]='X'
REG[2] =   t1[X](8)
   5 Noop             0    0    0               00 uniqueness check for t1
   6 SCopy            2    5    0               00 r[5]=r[2]; c0
REG[5] =   t1[X](8)
   7 SCopy            2    6    0               00 r[6]=r[2]; c0
REG[6] =   t1[X](8)
   8 IntCopy          1    7    0               00 r[7]=r[1]; rowid
REG[7] =  i:3
   9 MakeRecord       5    3    4               00 r[4]=mkrec(r[5..7]); for t1
REG[4] =  s7[040F0F01585803....XX.]
  10 IdxInsert        1    4    5 3             10 key=r[4]
REG[4] =  s7[040F0F01585803....XX.]
  11 MakeRecord       2    2    8               00 r[8]=mkrec(r[2..3])
REG[8] =  s4[030F0058...X]
  12 Insert           0    8    1 t0            39 intkey=r[1] data=r[8]
REG[8] =  s4[030F0058...X]
REG[1] =  i:3
  13 Halt             0    0    0               00 
SQL: [;CREATE INDEX a ON t0(c0,c1,c0,c1,c1);]
VDBE Trace:
   0 Init             0   37    0               00 Start at 37
  37 Transaction      0    1    2 0             01 usesStmtJournal=0
  38 Goto             0    1    0               00 
   1 Noop             0   36    0               00 
   2 CreateBtree      0    1    2               00 r[1]=root iDb=0 flags=2
REG[1] =  i:4
   3 OpenWrite        0    1    0 5             00 root=1 iDb=0; sqlite_master
   4 NewRowid         0    2    0               00 r[2]=rowid
REG[2] =  i:3
   5 String8          0    3    0 index         00 r[3]='index'
REG[3] =   t5[index](8)
   6 String8          0    4    0 a             00 r[4]='a'
REG[4] =   t1[a](8)
   7 String8          0    5    0 t0            00 r[5]='t0'
REG[5] =   t2[t0](8)
   8 Copy             1    6    0               00 r[6]=r[1]
REG[6] =  i:4
   9 String8          0    7    0 CREATE INDEX a ON t0(c0,c1,c0,c1,c1) 00 r[7]='CREATE INDEX a ON t0(c0,c1,c0,c1,c1)'
REG[7] =   t36[CREATE INDEX a ](8)
  10 MakeRecord       3    5    8 BBBDB         00 r[8]=mkrec(r[3..7])
REG[8] =  s51[06170F110155696E6465786174300443.....Uindexat0.C]
  11 Insert           0    8    2               18 intkey=r[2] data=r[8]
REG[8] =  s51[06170F110155696E6465786174300443.....Uindexat0.C]
REG[2] =  i:3
  12 SorterOpen       3    0    5 k(6,,,,,,)    00 
  13 OpenRead         1    2    0 2             00 root=2 iDb=0; t0
  14 Rewind           1   24    0               00 
  15 Column           1    0   10               00 r[10]=t0.c0
REG[10] =  i:1
  16 Column           1    1   11               00 r[11]=t0.c1
REG[11] =  i:2
  17 Column           1    0   12               00 r[12]=t0.c0
REG[12] =  i:1
  18 Column           1    1   13               00 r[13]=t0.c1
REG[13] =  i:2
  19 Column           1    1   14               00 r[14]=t0.c1
REG[14] =  i:2
  20 Rowid            1   15    0               00 r[15]=rowid
REG[15] =  i:1
  21 MakeRecord      10    6    9               00 r[9]=mkrec(r[10..15])
REG[9] =  s10[07090109010109020202..........]
  22 SorterInsert     3    9    0               00 key=r[9]
REG[9] =  s10[07090109010109020202..........]
  23 Next             1   15    0               00 
  15 Column           1    0   10               00 r[10]=t0.c0
REG[10] =  i:3
  16 Column           1    1   11               00 r[11]=t0.c1
REG[11] =  i:6
  17 Column           1    0   12               00 r[12]=t0.c0
REG[12] =  i:3
  18 Column           1    1   13               00 r[13]=t0.c1
REG[13] =  i:6
  19 Column           1    1   14               00 r[14]=t0.c1
REG[14] =  i:6
  20 Rowid            1   15    0               00 r[15]=rowid
REG[15] =  i:2
  21 MakeRecord      10    6    9               00 r[9]=mkrec(r[10..15])
REG[9] =  s13[07010101010101030603060602.............]
  22 SorterInsert     3    9    0               00 key=r[9]
REG[9] =  s13[07010101010101030603060602.............]
  23 Next             1   15    0               00 
  15 Column           1    0   10               00 r[10]=t0.c0
REG[10] =   s1[X](8)
  16 Column           1    1   11               00 r[11]=t0.c1
REG[11] =  NULL
  17 Column           1    0   12               00 r[12]=t0.c0
REG[12] =   s1[X](8)
  18 Column           1    1   13               00 r[13]=t0.c1
REG[13] =  NULL
  19 Column           1    1   14               00 r[14]=t0.c1
REG[14] =  NULL
  20 Rowid            1   15    0               00 r[15]=rowid
REG[15] =  i:3
  21 MakeRecord      10    6    9               00 r[9]=mkrec(r[10..15])
REG[9] =  s10[070F000F000001585803.......XX.]
  22 SorterInsert     3    9    0               00 key=r[9]
REG[9] =  s10[070F000F000001585803.......XX.]
  23 Next             1   15    0               00 
  24 OpenWrite        2    1    0 k(6,,,,,,)    11 root=1 iDb=0
  25 SorterSort       3   30    0               00 
  26 SorterData       3    9    2               00 r[9]=data
  27 SeekEnd          2    0    0               00 
  28 IdxInsert        2    9    0               10 key=r[9]
REG[9] =  s10[07090109010109020202..........]
  29 SorterNext       3   26    0               00 
  26 SorterData       3    9    2               00 r[9]=data
  27 SeekEnd          2    0    0               00 
  28 IdxInsert        2    9    0               10 key=r[9]
REG[9] =  s13[07010101010101030603060602.............]
  29 SorterNext       3   26    0               00 
  26 SorterData       3    9    2               00 r[9]=data
  27 SeekEnd          2    0    0               00 
  28 IdxInsert        2    9    0               10 key=r[9]
REG[9] =  s10[070F000F000001585803.......XX.]
  29 SorterNext       3   26    0               00 
  30 Close            1    0    0               00 
  31 Close            2    0    0               00 
  32 Close            3    0    0               00 
  33 SetCookie        0    1    3               00 
  34 ParseSchema      0    0    0 name='a' AND type='index' 00 
VDBE Trace:
   0 Init             0   15    0               00 Start at 15
  15 Transaction      0    0    3 0             00 usesStmtJournal=0
  16 String8          0    2    0 a             00 r[2]='a'
REG[2] =   t1[a](8)
  17 String8          0    3    0 index         00 r[3]='index'
REG[3] =   t5[index](8)
  18 Goto             0    1    0               00 
   1 Noop             1    5    0               00 
   2 OpenRead         0    1    0 5             00 root=1 iDb=0; sqlite_master
   3 Explain          3    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   14    0               00 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s2[t0](8)
   6 Ne               2   13    1 (BINARY)      52 if r[1]!=r[2] goto 13
REG[2] =   t1[a](8)
REG[1] =   s2[t0](8)
  13 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s2[t1](8)
   6 Ne               2   13    1 (BINARY)      52 if r[1]!=r[2] goto 13
REG[2] =   t1[a](8)
REG[1] =   s2[t1](8)
  13 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s1[a](8)
   6 Ne               2   13    1 (BINARY)      52 if r[1]!=r[2] goto 13
REG[2] =   t1[a](8)
REG[1] =   s1[a](8)
   7 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[index](8)
   8 Ne               3   13    1 (BINARY)      52 if r[1]!=r[3] goto 13
REG[3] =   t5[index](8)
REG[1] =   s5[index](8)
   9 Column           0    1    4               00 r[4]=sqlite_master.name
REG[4] =   s1[a](8)
  10 Column           0    3    5               00 r[5]=sqlite_master.rootpage
REG[5] =  i:4
  11 Column           0    4    6               00 r[6]=sqlite_master.sql
REG[6] =   s36[CREATE INDEX a ](8)
  12 ResultRow        4    3    0               00 output=r[4..6]
REG[4] =   s1[a](8)
REG[5] =  i:4
REG[6] =   s36[CREATE INDEX a ](8)
  13 Next             0    5    0               01 
  14 Halt             0    0    0               00 
  35 Expire           0    1    0               00 
  36 Halt             0    0    0               00 
SQL: [;CREATE TABLE b(c,t1a);]
VDBE Trace:
   0 Init             0   28    0               00 Start at 28
  28 Transaction      0    1    3 0             01 usesStmtJournal=0
  29 Goto             0    1    0               00 
   1 ReadCookie       0    3    2               00 
REG[3] =  i:4
   2 If               3    5    0               00 
REG[3] =  i:4
   5 CreateBtree      0    2    1               00 r[2]=root iDb=0 flags=1
REG[2] =  i:5
   6 OpenWrite        0    1    0 5             00 root=1 iDb=0
   7 NewRowid         0    1    0               00 r[1]=rowid
REG[1] =  i:4
   8 Blob             6    3    0              00 r[3]= (len=6)
REG[3] =  t6[060000000000......]
   9 Insert           0    3    1               08 intkey=r[1] data=r[3]
REG[3] =  t6[060000000000......]
REG[1] =  i:4
  10 Close            0    0    0               00 
  11 Close            0    0    0               00 
  12 Null             0    4    5               00 r[4..5]=NULL
REG[4] =  NULL
  13 OpenWrite        1    1    0 5             00 root=1 iDb=0; sqlite_master
  14 Explain         14    0    0 SEARCH TABLE sqlite_master USING INTEGER PRIMARY KEY (rowid=?) 00 
  15 SeekRowid        1   17    1               00 intkey=r[1]
REG[1] =  i:4
  16 Rowid            1    5    0               00 r[5]=rowid
REG[5] =  i:4
  17 IsNull           5   25    0               00 if r[5]==NULL goto 25
REG[5] =  i:4
  18 String8          0    6    0 table         00 r[6]='table'
REG[6] =   t5[table](8)
  19 String8          0    7    0 b             00 r[7]='b'
REG[7] =   t1[b](8)
  20 String8          0    8    0 b             00 r[8]='b'
REG[8] =   t1[b](8)
  21 Copy             2    9    0               00 r[9]=r[2]
REG[9] =  i:5
  22 String8          0   10    0 CREATE TABLE b(c,t1a) 00 r[10]='CREATE TABLE b(c,t1a)'
REG[10] =   t21[CREATE TABLE b(](8)
  23 MakeRecord       6    5   11 BBBDB         00 r[11]=mkrec(r[6..10])
REG[11] =  s35[06170F0F01377461626C656262054352.....7tablebb.CR]
  24 Insert           1   11    5               00 intkey=r[5] data=r[11]
REG[11] =  s35[06170F0F01377461626C656262054352.....7tablebb.CR]
REG[5] =  i:4
  25 SetCookie        0    1    4               00 
  26 ParseSchema      0    0    0 tbl_name='b' AND type!='trigger' 00 
VDBE Trace:
   0 Init             0   15    0               00 Start at 15
  15 Transaction      0    0    4 0             00 usesStmtJournal=0
  16 String8          0    2    0 b             00 r[2]='b'
REG[2] =   t1[b](8)
  17 String8          0    3    0 trigger       00 r[3]='trigger'
REG[3] =   t7[trigger](8)
  18 Goto             0    1    0               00 
   1 Noop             1    5    0               00 
   2 OpenRead         0    1    0 5             00 root=1 iDb=0; sqlite_master
   3 Explain          3    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   14    0               00 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[t0](8)
   6 Ne               2   13    1 (BINARY)      52 if r[1]!=r[2] goto 13
REG[2] =   t1[b](8)
REG[1] =   s2[t0](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[t0](8)
   6 Ne               2   13    1 (BINARY)      52 if r[1]!=r[2] goto 13
REG[2] =   t1[b](8)
REG[1] =   s2[t0](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[t0](8)
   6 Ne               2   13    1 (BINARY)      52 if r[1]!=r[2] goto 13
REG[2] =   t1[b](8)
REG[1] =   s2[t0](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s1[b](8)
   6 Ne               2   13    1 (BINARY)      52 if r[1]!=r[2] goto 13
REG[2] =   t1[b](8)
REG[1] =   s1[b](8)
   7 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[table](8)
   8 Eq               3   13    1 (BINARY)      52 if r[1]==r[3] goto 13
REG[3] =   t7[trigger](8)
REG[1] =   s5[table](8)
   9 Column           0    1    4               00 r[4]=sqlite_master.name
REG[4] =   s1[b](8)
  10 Column           0    3    5               00 r[5]=sqlite_master.rootpage
REG[5] =  i:5
  11 Column           0    4    6               00 r[6]=sqlite_master.sql
REG[6] =   s21[CREATE TABLE b(](8)
  12 ResultRow        4    3    0               00 output=r[4..6]
REG[4] =   s1[b](8)
REG[5] =  i:5
REG[6] =   s21[CREATE TABLE b(](8)
  13 Next             0    5    0               01 
  14 Halt             0    0    0               00 
  27 Halt             0    0    0               00 
SQL: [;DROP TABLE IF EXISTS b;]
VDBE Trace:
   0 Init             0   38    0               00 Start at 38
  38 Transaction      0    1    4 0             01 usesStmtJournal=1
  39 String8          0    3    0 b             00 r[3]='b'
REG[3] =   t1[b](8)
  40 String8          0    4    0 trigger       00 r[4]='trigger'
REG[4] =   t7[trigger](8)
  41 Goto             0    1    0               00 
   1 Null             0    1    0               00 r[1]=NULL
REG[1] =  NULL
   2 OpenWrite        0    1    0 5             00 root=1 iDb=0; sqlite_master
   3 Explain          3    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   13    0               00 
   5 Column           0    2    2               00 r[2]=sqlite_master.tbl_name
REG[2] =   s2[t0](8)
   6 Ne               3   12    2 (BINARY)      52 if r[2]!=r[3] goto 12
REG[3] =   t1[b](8)
REG[2] =   s2[t0](8)
  12 Next             0    5    0               01 
   5 Column           0    2    2               00 r[2]=sqlite_master.tbl_name
REG[2] =   s2[t0](8)
   6 Ne               3   12    2 (BINARY)      52 if r[2]!=r[3] goto 12
REG[3] =   t1[b](8)
REG[2] =   s2[t0](8)
  12 Next             0    5    0               01 
   5 Column           0    2    2               00 r[2]=sqlite_master.tbl_name
REG[2] =   s2[t0](8)
   6 Ne               3   12    2 (BINARY)      52 if r[2]!=r[3] goto 12
REG[3] =   t1[b](8)
REG[2] =   s2[t0](8)
  12 Next             0    5    0               01 
   5 Column           0    2    2               00 r[2]=sqlite_master.tbl_name
REG[2] =   s1[b](8)
   6 Ne               3   12    2 (BINARY)      52 if r[2]!=r[3] goto 12
REG[3] =   t1[b](8)
REG[2] =   s1[b](8)
   7 Column           0    0    2               00 r[2]=sqlite_master.type
REG[2] =   s5[table](8)
   8 Eq               4   12    2 (BINARY)      52 if r[2]==r[4] goto 12
REG[4] =   t7[trigger](8)
REG[2] =   s5[table](8)
   9 Rowid            0    5    0               00 r[5]=rowid
REG[5] =  i:4
  10 Once             0   11    0               00 
  11 Delete           0    0    0               02 
  12 Next             0    5    0               01 
  13 Destroy          5    2    0               00 
REG[2] =  i:0
  14 Null             0    6    7               00 r[6..7]=NULL
REG[6] =  NULL
  15 IfNot            2   24    1               00 
REG[2] =  i:0
  24 OpenWrite        1    1    0 5             00 root=1 iDb=0; sqlite_master
  25 RowSetRead       6   35    7               00 r[7]=rowset(6)
REG[6] =  NULL
REG[7] =  NULL
  35 DropTable        0    0    0 b             00 
  36 SetCookie        0    1    5               00 
  37 Halt             0    0    0               00 
SQL: [;CREATE TABLE b(c,t1a);]
VDBE Trace:
   0 Init             0   28    0               00 Start at 28
  28 Transaction      0    1    5 0             01 usesStmtJournal=0
  29 Goto             0    1    0               00 
   1 ReadCookie       0    3    2               00 
REG[3] =  i:4
   2 If               3    5    0               00 
REG[3] =  i:4
   5 CreateBtree      0    2    1               00 r[2]=root iDb=0 flags=1
REG[2] =  i:5
   6 OpenWrite        0    1    0 5             00 root=1 iDb=0
   7 NewRowid         0    1    0               00 r[1]=rowid
REG[1] =  i:4
   8 Blob             6    3    0              00 r[3]= (len=6)
REG[3] =  t6[060000000000......]
   9 Insert           0    3    1               08 intkey=r[1] data=r[3]
REG[3] =  t6[060000000000......]
REG[1] =  i:4
  10 Close            0    0    0               00 
  11 Close            0    0    0               00 
  12 Null             0    4    5               00 r[4..5]=NULL
REG[4] =  NULL
  13 OpenWrite        1    1    0 5             00 root=1 iDb=0; sqlite_master
  14 Explain         14    0    0 SEARCH TABLE sqlite_master USING INTEGER PRIMARY KEY (rowid=?) 00 
  15 SeekRowid        1   17    1               00 intkey=r[1]
REG[1] =  i:4
  16 Rowid            1    5    0               00 r[5]=rowid
REG[5] =  i:4
  17 IsNull           5   25    0               00 if r[5]==NULL goto 25
REG[5] =  i:4
  18 String8          0    6    0 table         00 r[6]='table'
REG[6] =   t5[table](8)
  19 String8          0    7    0 b             00 r[7]='b'
REG[7] =   t1[b](8)
  20 String8          0    8    0 b             00 r[8]='b'
REG[8] =   t1[b](8)
  21 Copy             2    9    0               00 r[9]=r[2]
REG[9] =  i:5
  22 String8          0   10    0 CREATE TABLE b(c,t1a) 00 r[10]='CREATE TABLE b(c,t1a)'
REG[10] =   t21[CREATE TABLE b(](8)
  23 MakeRecord       6    5   11 BBBDB         00 r[11]=mkrec(r[6..10])
REG[11] =  s35[06170F0F01377461626C656262054352.....7tablebb.CR]
  24 Insert           1   11    5               00 intkey=r[5] data=r[11]
REG[11] =  s35[06170F0F01377461626C656262054352.....7tablebb.CR]
REG[5] =  i:4
  25 SetCookie        0    1    6               00 
  26 ParseSchema      0    0    0 tbl_name='b' AND type!='trigger' 00 
VDBE Trace:
   0 Init             0   15    0               00 Start at 15
  15 Transaction      0    0    6 0             00 usesStmtJournal=0
  16 String8          0    2    0 b             00 r[2]='b'
REG[2] =   t1[b](8)
  17 String8          0    3    0 trigger       00 r[3]='trigger'
REG[3] =   t7[trigger](8)
  18 Goto             0    1    0               00 
   1 Noop             1    5    0               00 
   2 OpenRead         0    1    0 5             00 root=1 iDb=0; sqlite_master
   3 Explain          3    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   14    0               00 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[t0](8)
   6 Ne               2   13    1 (BINARY)      52 if r[1]!=r[2] goto 13
REG[2] =   t1[b](8)
REG[1] =   s2[t0](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[t0](8)
   6 Ne               2   13    1 (BINARY)      52 if r[1]!=r[2] goto 13
REG[2] =   t1[b](8)
REG[1] =   s2[t0](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[t0](8)
   6 Ne               2   13    1 (BINARY)      52 if r[1]!=r[2] goto 13
REG[2] =   t1[b](8)
REG[1] =   s2[t0](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s1[b](8)
   6 Ne               2   13    1 (BINARY)      52 if r[1]!=r[2] goto 13
REG[2] =   t1[b](8)
REG[1] =   s1[b](8)
   7 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[table](8)
   8 Eq               3   13    1 (BINARY)      52 if r[1]==r[3] goto 13
REG[3] =   t7[trigger](8)
REG[1] =   s5[table](8)
   9 Column           0    1    4               00 r[4]=sqlite_master.name
REG[4] =   s1[b](8)
  10 Column           0    3    5               00 r[5]=sqlite_master.rootpage
REG[5] =  i:5
  11 Column           0    4    6               00 r[6]=sqlite_master.sql
REG[6] =   s21[CREATE TABLE b(](8)
  12 ResultRow        4    3    0               00 output=r[4..6]
REG[4] =   s1[b](8)
REG[5] =  i:5
REG[6] =   s21[CREATE TABLE b(](8)
  13 Next             0    5    0               01 
  14 Halt             0    0    0               00 
  27 Halt             0    0    0               00 
SQL: [;INSERT INTO t0 VALUES(3,4);]
VDBE Trace:
   0 Init             0   25    0               00 Start at 25
  25 Transaction      0    1    6 0             01 usesStmtJournal=0
  26 Goto             0    1    0               00 
   1 OpenWrite        0    2    0 2             00 root=2 iDb=0; t0
   2 OpenWrite        1    4    0 k(6,,,,,,)    00 root=4 iDb=0; a
   3 OpenWrite        2    3    0 k(3,,,)       00 root=3 iDb=0; t1
   4 NewRowid         0    1    0               00 r[1]=rowid
REG[1] =  i:4
   5 Integer          3    2    0               00 r[2]=3
REG[2] =  i:3
   6 Integer          4    3    0               00 r[3]=4
REG[3] =  i:4
   7 Noop             0    0    0               00 uniqueness check for a
   8 SCopy            2    5    0               00 r[5]=r[2]; c0
REG[5] =  i:3
   9 SCopy            3    6    0               00 r[6]=r[3]; c1
REG[6] =  i:4
  10 SCopy            2    7    0               00 r[7]=r[2]; c0
REG[7] =  i:3
  11 SCopy            3    8    0               00 r[8]=r[3]; c1
REG[8] =  i:4
  12 SCopy            3    9    0               00 r[9]=r[3]; c1
REG[9] =  i:4
  13 IntCopy          1   10    0               00 r[10]=r[1]; rowid
REG[10] =  i:4
  14 MakeRecord       5    6    4               00 r[4]=mkrec(r[5..10]); for a
REG[4] =  s13[07010101010101030403040404.............]
  15 Noop             0    0    0               00 uniqueness check for t1
  16 SCopy            2   12    0               00 r[12]=r[2]; c0
REG[12] =  i:3
  17 SCopy            2   13    0               00 r[13]=r[2]; c0
REG[13] =  i:3
  18 IntCopy          1   14    0               00 r[14]=r[1]; rowid
REG[14] =  i:4
  19 MakeRecord      12    3   11               00 r[11]=mkrec(r[12..14]); for t1
REG[11] =  s7[04010101030304.......]
  20 IdxInsert        1    4    5 6             10 key=r[4]
REG[4] =  s13[07010101010101030403040404.............]
  21 IdxInsert        2   11   12 3             10 key=r[11]
REG[11] =  s7[04010101030304.......]
  22 MakeRecord       2    2   15               00 r[15]=mkrec(r[2..3])
REG[15] =  s5[0301010304.....]
  23 Insert           0   15    1 t0            39 intkey=r[1] data=r[15]
REG[15] =  s5[0301010304.....]
REG[1] =  i:4
  24 Halt             0    0    0               00 
SQL: [;
;SELECT 1 WHERE (2,2) BETWEEN (1,1) AND (3,3)
;]
VDBE Trace:
   0 Init             0   13    0               00 Start at 13
  13 Integer          2    1    0               00 r[1]=2
REG[1] =  i:2
  14 Integer          2    2    0               00 r[2]=2
REG[2] =  i:2
  15 Integer          1    4    0               00 r[4]=1
REG[4] =  i:1
  16 Integer          3    5    0               00 r[5]=3
REG[5] =  i:3
  17 Goto             0    1    0               00 
   1 Explain          1    0    0 SCAN CONSTANT ROW 00 
   2 Gt               4    3    1               61 r[3] = (r[1]>r[4])
REG[4] =  i:1
REG[1] =  i:2
REG[3] =  i:1
   3 ElseNotEq        0    5    0               00 
   5 IfNot            3   12    1               00 
REG[3] =  i:1
   6 Lt               5    3    1               61 r[3] = (r[1]<r[5])
REG[5] =  i:3
REG[1] =  i:2
REG[3] =  i:1
   7 ElseNotEq        0    9    0               00 
   9 IfNot            3   12    1               00 
REG[3] =  i:1
  10 Integer          1    6    0               00 r[6]=1
REG[6] =  i:1
  11 ResultRow        6    1    0               00 output=r[6]
REG[6] =  i:1
  12 Halt             0    0    0               00 
SQL: [SELECT CASE (SELECT 2,2) WHEN (1, 1) THEN 2 ELSE 1 END
;]
VDBE Trace:
   0 Init             0   21    0               00 Start at 21
  21 Integer          1    7    0               00 r[7]=1
REG[7] =  i:1
  22 Goto             0    1    0               00 
   1 Explain          1    0    0 SCAN CONSTANT ROW 00 
   2 Integer         11    2    0               00 r[2]=11; return address
REG[2] =  i:11
   3 Once             0   11    0               00 
   4 Explain          4    0    0 SCALAR SUBQUERY 1 00 
   5 Null             0    3    4               00 r[3..4]=NULL; Init subquery result
REG[3] =  NULL
   6 Integer          1    5    0               00 r[5]=1; LIMIT counter
REG[5] =  i:1
   7 Explain          7    4    0 SCAN CONSTANT ROW 00 
   8 Integer          2    3    0               00 r[3]=2
REG[3] =  i:2
   9 Integer          2    4    0               00 r[4]=2
REG[4] =  i:2
  10 DecrJumpZero     5   11    0               00 if (--r[5])==0 goto 11
REG[5] =  i:1
  11 Return           2    0    0               00 
REG[2] =  i:11
  12 Eq               7    6    3               61 r[6] = (r[3]==r[7])
REG[7] =  i:1
REG[3] =  i:2
REG[6] =  i:0
  13 IfNot            6   15    0               00 
REG[6] =  i:0
  15 IfNot            6   18    1               00 
REG[6] =  i:0
  18 Integer          1    1    0               00 r[1]=1
REG[1] =  i:1
  19 ResultRow        1    1    0               00 output=r[1]
REG[1] =  i:1
  20 Halt             0    0    0               00 
SQL: [;CREATE TABLE t1bc(t2 INTEGER PRIMARY KEY, d);]
VDBE Trace:
   0 Init             0   28    0               00 Start at 28
  28 Transaction      0    1    6 0             01 usesStmtJournal=0
  29 Goto             0    1    0               00 
   1 ReadCookie       0    3    2               00 
REG[3] =  i:4
   2 If               3    5    0               00 
REG[3] =  i:4
   5 CreateBtree      0    2    1               00 r[2]=root iDb=0 flags=1
REG[2] =  i:6
   6 OpenWrite        0    1    0 5             00 root=1 iDb=0
   7 NewRowid         0    1    0               00 r[1]=rowid
REG[1] =  i:5
   8 Blob             6    3    0              00 r[3]= (len=6)
REG[3] =  t6[060000000000......]
   9 Insert           0    3    1               08 intkey=r[1] data=r[3]
REG[3] =  t6[060000000000......]
REG[1] =  i:5
  10 Close            0    0    0               00 
  11 Close            0    0    0               00 
  12 Null             0    4    5               00 r[4..5]=NULL
REG[4] =  NULL
  13 OpenWrite        1    1    0 5             00 root=1 iDb=0; sqlite_master
  14 Explain         14    0    0 SEARCH TABLE sqlite_master USING INTEGER PRIMARY KEY (rowid=?) 00 
  15 SeekRowid        1   17    1               00 intkey=r[1]
REG[1] =  i:5
  16 Rowid            1    5    0               00 r[5]=rowid
REG[5] =  i:5
  17 IsNull           5   25    0               00 if r[5]==NULL goto 25
REG[5] =  i:5
  18 String8          0    6    0 table         00 r[6]='table'
REG[6] =   t5[table](8)
  19 String8          0    7    0 t1bc          00 r[7]='t1bc'
REG[7] =   t4[t1bc](8)
  20 String8          0    8    0 t1bc          00 r[8]='t1bc'
REG[8] =   t4[t1bc](8)
  21 Copy             2    9    0               00 r[9]=r[2]
REG[9] =  i:6
  22 String8          0   10    0 CREATE TABLE t1bc(t2 INTEGER PRIMARY KEY, d) 00 r[10]='CREATE TABLE t1bc(t2 INTEGER PRIMARY KEY, d)'
REG[10] =   t44[CREATE TABLE t1](8)
  23 MakeRecord       6    5   11 BBBDB         00 r[11]=mkrec(r[6..10])
REG[11] =  s64[0617151501657461626C657431626374.....etablet1bct]
  24 Insert           1   11    5               00 intkey=r[5] data=r[11]
REG[11] =  s64[0617151501657461626C657431626374.....etablet1bct]
REG[5] =  i:5
  25 SetCookie        0    1    7               00 
  26 ParseSchema      0    0    0 tbl_name='t1bc' AND type!='trigger' 00 
VDBE Trace:
   0 Init             0   15    0               00 Start at 15
  15 Transaction      0    0    7 0             00 usesStmtJournal=0
  16 String8          0    2    0 t1bc          00 r[2]='t1bc'
REG[2] =   t4[t1bc](8)
  17 String8          0    3    0 trigger       00 r[3]='trigger'
REG[3] =   t7[trigger](8)
  18 Goto             0    1    0               00 
   1 Noop             1    5    0               00 
   2 OpenRead         0    1    0 5             00 root=1 iDb=0; sqlite_master
   3 Explain          3    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   14    0               00 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[t0](8)
   6 Ne               2   13    1 (BINARY)      52 if r[1]!=r[2] goto 13
REG[2] =   t4[t1bc](8)
REG[1] =   s2[t0](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[t0](8)
   6 Ne               2   13    1 (BINARY)      52 if r[1]!=r[2] goto 13
REG[2] =   t4[t1bc](8)
REG[1] =   s2[t0](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[t0](8)
   6 Ne               2   13    1 (BINARY)      52 if r[1]!=r[2] goto 13
REG[2] =   t4[t1bc](8)
REG[1] =   s2[t0](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s1[b](8)
   6 Ne               2   13    1 (BINARY)      52 if r[1]!=r[2] goto 13
REG[2] =   t4[t1bc](8)
REG[1] =   s1[b](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s4[t1bc](8)
   6 Ne               2   13    1 (BINARY)      52 if r[1]!=r[2] goto 13
REG[2] =   t4[t1bc](8)
REG[1] =   s4[t1bc](8)
   7 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[table](8)
   8 Eq               3   13    1 (BINARY)      52 if r[1]==r[3] goto 13
REG[3] =   t7[trigger](8)
REG[1] =   s5[table](8)
   9 Column           0    1    4               00 r[4]=sqlite_master.name
REG[4] =   s4[t1bc](8)
  10 Column           0    3    5               00 r[5]=sqlite_master.rootpage
REG[5] =  i:6
  11 Column           0    4    6               00 r[6]=sqlite_master.sql
REG[6] =   s44[CREATE TABLE t1](8)
  12 ResultRow        4    3    0               00 output=r[4..6]
REG[4] =   s4[t1bc](8)
REG[5] =  i:6
REG[6] =   s44[CREATE TABLE t1](8)
  13 Next             0    5    0               01 
  14 Halt             0    0    0               00 
  27 Halt             0    0    0               00 
SQL: [;CREATE TABLE e(f);]
VDBE Trace:
   0 Init             0   28    0               00 Start at 28
  28 Transaction      0    1    7 0             01 usesStmtJournal=0
  29 Goto             0    1    0               00 
   1 ReadCookie       0    3    2               00 
REG[3] =  i:4
   2 If               3    5    0               00 
REG[3] =  i:4
   5 CreateBtree      0    2    1               00 r[2]=root iDb=0 flags=1
REG[2] =  i:7
   6 OpenWrite        0    1    0 5             00 root=1 iDb=0
   7 NewRowid         0    1    0               00 r[1]=rowid
REG[1] =  i:6
   8 Blob             6    3    0              00 r[3]= (len=6)
REG[3] =  t6[060000000000......]
   9 Insert           0    3    1               08 intkey=r[1] data=r[3]
REG[3] =  t6[060000000000......]
REG[1] =  i:6
  10 Close            0    0    0               00 
  11 Close            0    0    0               00 
  12 Null             0    4    5               00 r[4..5]=NULL
REG[4] =  NULL
  13 OpenWrite        1    1    0 5             00 root=1 iDb=0; sqlite_master
  14 Explain         14    0    0 SEARCH TABLE sqlite_master USING INTEGER PRIMARY KEY (rowid=?) 00 
  15 SeekRowid        1   17    1               00 intkey=r[1]
REG[1] =  i:6
  16 Rowid            1    5    0               00 r[5]=rowid
REG[5] =  i:6
  17 IsNull           5   25    0               00 if r[5]==NULL goto 25
REG[5] =  i:6
  18 String8          0    6    0 table         00 r[6]='table'
REG[6] =   t5[table](8)
  19 String8          0    7    0 e             00 r[7]='e'
REG[7] =   t1[e](8)
  20 String8          0    8    0 e             00 r[8]='e'
REG[8] =   t1[e](8)
  21 Copy             2    9    0               00 r[9]=r[2]
REG[9] =  i:7
  22 String8          0   10    0 CREATE TABLE e(f) 00 r[10]='CREATE TABLE e(f)'
REG[10] =   t17[CREATE TABLE e(](8)
  23 MakeRecord       6    5   11 BBBDB         00 r[11]=mkrec(r[6..10])
REG[11] =  s31[06170F0F012F7461626C656565074352...../tableee.CR]
  24 Insert           1   11    5               00 intkey=r[5] data=r[11]
REG[11] =  s31[06170F0F012F7461626C656565074352...../tableee.CR]
REG[5] =  i:6
  25 SetCookie        0    1    8               00 
  26 ParseSchema      0    0    0 tbl_name='e' AND type!='trigger' 00 
VDBE Trace:
   0 Init             0   15    0               00 Start at 15
  15 Transaction      0    0    8 0             00 usesStmtJournal=0
  16 String8          0    2    0 e             00 r[2]='e'
REG[2] =   t1[e](8)
  17 String8          0    3    0 trigger       00 r[3]='trigger'
REG[3] =   t7[trigger](8)
  18 Goto             0    1    0               00 
   1 Noop             1    5    0               00 
   2 OpenRead         0    1    0 5             00 root=1 iDb=0; sqlite_master
   3 Explain          3    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   14    0               00 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[t0](8)
   6 Ne               2   13    1 (BINARY)      52 if r[1]!=r[2] goto 13
REG[2] =   t1[e](8)
REG[1] =   s2[t0](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[t0](8)
   6 Ne               2   13    1 (BINARY)      52 if r[1]!=r[2] goto 13
REG[2] =   t1[e](8)
REG[1] =   s2[t0](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[t0](8)
   6 Ne               2   13    1 (BINARY)      52 if r[1]!=r[2] goto 13
REG[2] =   t1[e](8)
REG[1] =   s2[t0](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s1[b](8)
   6 Ne               2   13    1 (BINARY)      52 if r[1]!=r[2] goto 13
REG[2] =   t1[e](8)
REG[1] =   s1[b](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s4[t1bc](8)
   6 Ne               2   13    1 (BINARY)      52 if r[1]!=r[2] goto 13
REG[2] =   t1[e](8)
REG[1] =   s4[t1bc](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s1[e](8)
   6 Ne               2   13    1 (BINARY)      52 if r[1]!=r[2] goto 13
REG[2] =   t1[e](8)
REG[1] =   s1[e](8)
   7 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[table](8)
   8 Eq               3   13    1 (BINARY)      52 if r[1]==r[3] goto 13
REG[3] =   t7[trigger](8)
REG[1] =   s5[table](8)
   9 Column           0    1    4               00 r[4]=sqlite_master.name
REG[4] =   s1[e](8)
  10 Column           0    3    5               00 r[5]=sqlite_master.rootpage
REG[5] =  i:7
  11 Column           0    4    6               00 r[6]=sqlite_master.sql
REG[6] =   s17[CREATE TABLE e(](8)
  12 ResultRow        4    3    0               00 output=r[4..6]
REG[4] =   s1[e](8)
REG[5] =  i:7
REG[6] =   s17[CREATE TABLE e(](8)
  13 Next             0    5    0               01 
  14 Halt             0    0    0               00 
  27 Halt             0    0    0               00 
SQL: [;INSERT INTO t1bc(d) VALUES(1);]
VDBE Trace:
   0 Init             0    8    0               00 Start at 8
   8 Transaction      0    1    8 0             01 usesStmtJournal=0
   9 Goto             0    1    0               00 
   1 OpenWrite        0    6    0 2             00 root=6 iDb=0; t1bc
   2 NewRowid         0    1    0               00 r[1]=rowid
REG[1] =  i:1
   3 SoftNull         2    0    0               00 r[2]=NULL
   4 Integer          1    3    0               00 r[3]=1
REG[3] =  i:1
   5 MakeRecord       2    2    4 D             00 r[4]=mkrec(r[2..3])
REG[4] =  s3[030009...]
   6 Insert           0    4    1 t1bc          39 intkey=r[1] data=r[4]
REG[4] =  s3[030009...]
REG[1] =  i:1
   7 Halt             0    0    0               00 
SQL: [;UPDATE t1bc SET t2=7;]
VDBE Trace:
   0 Init             0   26    0               00 Start at 26
  26 Transaction      0    1    8 0             01 usesStmtJournal=1
  27 Goto             0    1    0               00 
   1 Null             0    1    2               00 r[1..2]=NULL
REG[1] =  NULL
   2 OpenRead         0    6    0 0             00 root=6 iDb=0; t1bc
   3 Explain          3    0    0 SCAN TABLE t1bc 00 
   4 Rewind           0    8    0               00 
   5 Rowid            0    2    0               00 r[2]=rowid
REG[2] =  i:1
   6 RowSetAdd        1    2    0               00 rowset(1)=r[2]
REG[1] =  NULL
REG[2] =  i:1
   7 Next             0    5    0               01 
   8 OpenWrite        0    6    0 2             00 root=6 iDb=0; t1bc
   9 RowSetRead       1   25    2               00 r[2]=rowset(1)
REG[1] =  (rowset)
REG[2] =  i:1
  10 NotExists        0    9    2               00 intkey=r[2]
REG[2] =  i:1
  11 Integer          7    3    0               00 r[3]=7
REG[3] =  i:7
  12 MustBeInt        3    0    0               00 
REG[3] =  i:7
  13 Null             0    4    0               00 r[4]=NULL
REG[4] =  NULL
  14 Column           0    1    5               00 r[5]=t1bc.d
REG[5] =  i:1
  15 Eq               3   20    2               90 if r[2]==r[3] goto 20
REG[3] =  i:7
REG[2] =  i:1
  16 Noop             0    0    0               00 uniqueness check for ROWID
  17 Abortable        0    0    0               00 
  18 NotExists        0   20    3               00 intkey=r[3]
REG[3] =  i:7
  20 NotExists        0   22    2               00 intkey=r[2]
REG[2] =  i:1
  21 Delete           0    0    0               00 
  22 MakeRecord       4    2    6 D             00 r[6]=mkrec(r[4..5])
REG[6] =  s3[030009...]
  23 Insert           0    6    3 t1bc          05 intkey=r[3] data=r[6]
REG[6] =  s3[030009...]
REG[3] =  i:7
  24 Goto             0    9    0               00 
   9 RowSetRead       1   25    2               00 r[2]=rowset(1)
REG[1] =  (rowset)
REG[2] =  i:1
  25 Halt             0    0    0               00 
SQL: [;
;UPDATE t0 SET c0=97;]
VDBE Trace:
   0 Init             0   41    0               00 Start at 41
  41 Transaction      0    1    8 0             01 usesStmtJournal=0
  42 Goto             0    1    0               00 
   1 Null             0   12   13               00 r[12..13]=NULL
REG[12] =  NULL
   2 OpenWrite        0    2    0 2             00 root=2 iDb=0; t0
   3 Explain          3    0    0 SCAN TABLE t0 00 
   4 Rewind           0   40    0               00 
   5 Rowid            0   13    0               00 r[13]=rowid
REG[13] =  i:1
   6 Once             0    9    0               00 
   7 OpenWrite        1    4    0 k(6,,,,,,)    00 root=4 iDb=0; a
   8 OpenWrite        2    3    0 k(3,,,)       00 root=3 iDb=0; t1
   9 IsNull          13   40    0               00 if r[13]==NULL goto 40
REG[13] =  i:1
  10 Integer         97   14    0               00 r[14]=97
REG[14] =  i:97
  11 Column           0    1   15               00 r[15]=t0.c1
REG[15] =  i:2
  12 Noop             0    0    0               00 uniqueness check for a
  13 SCopy           14    2    0               00 r[2]=r[14]; c0
REG[2] =  i:97
  14 SCopy           15    3    0               00 r[3]=r[15]; c1
REG[3] =  i:2
  15 SCopy           14    4    0               00 r[4]=r[14]; c0
REG[4] =  i:97
  16 SCopy           15    5    0               00 r[5]=r[15]; c1
REG[5] =  i:2
  17 SCopy           15    6    0               00 r[6]=r[15]; c1
REG[6] =  i:2
  18 IntCopy         13    7    0               00 r[7]=r[13]; rowid
REG[7] =  i:1
  19 MakeRecord       2    6    1               00 r[1]=mkrec(r[2..7]); for a
REG[1] =  s12[070101010101096102610202.......a.a..]
  20 Noop             0    0    0               00 uniqueness check for t1
  21 SCopy           14    9    0               00 r[9]=r[14]; c0
REG[9] =  i:97
  22 SCopy           14   10    0               00 r[10]=r[14]; c0
REG[10] =  i:97
  23 IntCopy         13   11    0               00 r[11]=r[13]; rowid
REG[11] =  i:1
  24 MakeRecord       9    3    8               00 r[8]=mkrec(r[9..11]); for t1
REG[8] =  s6[040101096161....aa]
  25 Column           0    0   16               00 r[16]=t0.c0
REG[16] =  i:1
  26 Column           0    1   17               00 r[17]=t0.c1
REG[17] =  i:2
  27 Column           0    0   18               00 r[18]=t0.c0
REG[18] =  i:1
  28 Column           0    1   19               00 r[19]=t0.c1
REG[19] =  i:2
  29 Column           0    1   20               00 r[20]=t0.c1
REG[20] =  i:2
  30 Rowid            0   21    0               00 r[21]=rowid
REG[21] =  i:1
  31 IdxDelete        1   16    6               00 key=r[16..21]
  32 Column           0    0   17               00 r[17]=t0.c0
REG[17] =  i:1
  33 Rowid            0   18    0               00 r[18]=rowid
REG[18] =  i:1
  34 IdxDelete        2   16    3               00 key=r[16..18]
  35 IdxInsert        1    1    2 6             00 key=r[1]
REG[1] =  s12[070101010101096102610202.......a.a..]
  36 IdxInsert        2    8    9 3             00 key=r[8]
REG[8] =  s6[040101096161....aa]
  37 MakeRecord      14    2   22               00 r[22]=mkrec(r[14..15])
REG[22] =  s5[0301016102...a.]
  38 Insert           0   22   13 t0            07 intkey=r[13] data=r[22]
REG[22] =  s5[0301016102...a.]
REG[13] =  i:1
  39 Next             0    5    0               01 
   5 Rowid            0   13    0               00 r[13]=rowid
REG[13] =  i:2
   6 Once             1    9    0               00 
   9 IsNull          13   40    0               00 if r[13]==NULL goto 40
REG[13] =  i:2
  10 Integer         97   14    0               00 r[14]=97
REG[14] =  i:97
  11 Column           0    1   15               00 r[15]=t0.c1
REG[15] =  i:6
  12 Noop             0    0    0               00 uniqueness check for a
  13 SCopy           14    2    0               00 r[2]=r[14]; c0
REG[2] =  i:97
  14 SCopy           15    3    0               00 r[3]=r[15]; c1
REG[3] =  i:6
  15 SCopy           14    4    0               00 r[4]=r[14]; c0
REG[4] =  i:97
  16 SCopy           15    5    0               00 r[5]=r[15]; c1
REG[5] =  i:6
  17 SCopy           15    6    0               00 r[6]=r[15]; c1
REG[6] =  i:6
  18 IntCopy         13    7    0               00 r[7]=r[13]; rowid
REG[7] =  i:2
  19 MakeRecord       2    6    1               00 r[1]=mkrec(r[2..7]); for a
REG[1] =  s13[07010101010101610661060602.......a.a...]
  20 Noop             0    0    0               00 uniqueness check for t1
  21 SCopy           14    9    0               00 r[9]=r[14]; c0
REG[9] =  i:97
  22 SCopy           14   10    0               00 r[10]=r[14]; c0
REG[10] =  i:97
  23 IntCopy         13   11    0               00 r[11]=r[13]; rowid
REG[11] =  i:2
  24 MakeRecord       9    3    8               00 r[8]=mkrec(r[9..11]); for t1
REG[8] =  s7[04010101616102....aa.]
  25 Column           0    0   16               00 r[16]=t0.c0
REG[16] =  i:3
  26 Column           0    1   17               00 r[17]=t0.c1
REG[17] =  i:6
  27 Column           0    0   18               00 r[18]=t0.c0
REG[18] =  i:3
  28 Column           0    1   19               00 r[19]=t0.c1
REG[19] =  i:6
  29 Column           0    1   20               00 r[20]=t0.c1
REG[20] =  i:6
  30 Rowid            0   21    0               00 r[21]=rowid
REG[21] =  i:2
  31 IdxDelete        1   16    6               00 key=r[16..21]
  32 Column           0    0   17               00 r[17]=t0.c0
REG[17] =  i:3
  33 Rowid            0   18    0               00 r[18]=rowid
REG[18] =  i:2
  34 IdxDelete        2   16    3               00 key=r[16..18]
  35 IdxInsert        1    1    2 6             00 key=r[1]
REG[1] =  s13[07010101010101610661060602.......a.a...]
  36 IdxInsert        2    8    9 3             00 key=r[8]
REG[8] =  s7[04010101616102....aa.]
  37 MakeRecord      14    2   22               00 r[22]=mkrec(r[14..15])
REG[22] =  s5[0301016106...a.]
  38 Insert           0   22   13 t0            07 intkey=r[13] data=r[22]
REG[22] =  s5[0301016106...a.]
REG[13] =  i:2
  39 Next             0    5    0               01 
   5 Rowid            0   13    0               00 r[13]=rowid
REG[13] =  i:3
   6 Once             1    9    0               00 
   9 IsNull          13   40    0               00 if r[13]==NULL goto 40
REG[13] =  i:3
  10 Integer         97   14    0               00 r[14]=97
REG[14] =  i:97
  11 Column           0    1   15               00 r[15]=t0.c1
REG[15] =  NULL
  12 Noop             0    0    0               00 uniqueness check for a
  13 SCopy           14    2    0               00 r[2]=r[14]; c0
REG[2] =  i:97
  14 SCopy           15    3    0               00 r[3]=r[15]; c1
REG[3] =  NULL
  15 SCopy           14    4    0               00 r[4]=r[14]; c0
REG[4] =  i:97
  16 SCopy           15    5    0               00 r[5]=r[15]; c1
REG[5] =  NULL
  17 SCopy           15    6    0               00 r[6]=r[15]; c1
REG[6] =  NULL
  18 IntCopy         13    7    0               00 r[7]=r[13]; rowid
REG[7] =  i:3
  19 MakeRecord       2    6    1               00 r[1]=mkrec(r[2..7]); for a
REG[1] =  s10[07010001000001616103.......aa.]
  20 Noop             0    0    0               00 uniqueness check for t1
  21 SCopy           14    9    0               00 r[9]=r[14]; c0
REG[9] =  i:97
  22 SCopy           14   10    0               00 r[10]=r[14]; c0
REG[10] =  i:97
  23 IntCopy         13   11    0               00 r[11]=r[13]; rowid
REG[11] =  i:3
  24 MakeRecord       9    3    8               00 r[8]=mkrec(r[9..11]); for t1
REG[8] =  s7[04010101616103....aa.]
  25 Column           0    0   16               00 r[16]=t0.c0
REG[16] =   s1[X](8)
  26 Column           0    1   17               00 r[17]=t0.c1
REG[17] =  NULL
  27 Column           0    0   18               00 r[18]=t0.c0
REG[18] =   s1[X](8)
  28 Column           0    1   19               00 r[19]=t0.c1
REG[19] =  NULL
  29 Column           0    1   20               00 r[20]=t0.c1
REG[20] =  NULL
  30 Rowid            0   21    0               00 r[21]=rowid
REG[21] =  i:3
  31 IdxDelete        1   16    6               00 key=r[16..21]
  32 Column           0    0   17               00 r[17]=t0.c0
REG[17] =   s1[X](8)
  33 Rowid            0   18    0               00 r[18]=rowid
REG[18] =  i:3
  34 IdxDelete        2   16    3               00 key=r[16..18]
  35 IdxInsert        1    1    2 6             00 key=r[1]
REG[1] =  s10[07010001000001616103.......aa.]
  36 IdxInsert        2    8    9 3             00 key=r[8]
REG[8] =  s7[04010101616103....aa.]
  37 MakeRecord      14    2   22               00 r[22]=mkrec(r[14..15])
REG[22] =  s4[03010061...a]
  38 Insert           0   22   13 t0            07 intkey=r[13] data=r[22]
REG[22] =  s4[03010061...a]
REG[13] =  i:3
  39 Next             0    5    0               01 
   5 Rowid            0   13    0               00 r[13]=rowid
REG[13] =  i:4
   6 Once             1    9    0               00 
   9 IsNull          13   40    0               00 if r[13]==NULL goto 40
REG[13] =  i:4
  10 Integer         97   14    0               00 r[14]=97
REG[14] =  i:97
  11 Column           0    1   15               00 r[15]=t0.c1
REG[15] =  i:4
  12 Noop             0    0    0               00 uniqueness check for a
  13 SCopy           14    2    0               00 r[2]=r[14]; c0
REG[2] =  i:97
  14 SCopy           15    3    0               00 r[3]=r[15]; c1
REG[3] =  i:4
  15 SCopy           14    4    0               00 r[4]=r[14]; c0
REG[4] =  i:97
  16 SCopy           15    5    0               00 r[5]=r[15]; c1
REG[5] =  i:4
  17 SCopy           15    6    0               00 r[6]=r[15]; c1
REG[6] =  i:4
  18 IntCopy         13    7    0               00 r[7]=r[13]; rowid
REG[7] =  i:4
  19 MakeRecord       2    6    1               00 r[1]=mkrec(r[2..7]); for a
REG[1] =  s13[07010101010101610461040404.......a.a...]
  20 Noop             0    0    0               00 uniqueness check for t1
  21 SCopy           14    9    0               00 r[9]=r[14]; c0
REG[9] =  i:97
  22 SCopy           14   10    0               00 r[10]=r[14]; c0
REG[10] =  i:97
  23 IntCopy         13   11    0               00 r[11]=r[13]; rowid
REG[11] =  i:4
  24 MakeRecord       9    3    8               00 r[8]=mkrec(r[9..11]); for t1
REG[8] =  s7[04010101616104....aa.]
  25 Column           0    0   16               00 r[16]=t0.c0
REG[16] =  i:3
  26 Column           0    1   17               00 r[17]=t0.c1
REG[17] =  i:4
  27 Column           0    0   18               00 r[18]=t0.c0
REG[18] =  i:3
  28 Column           0    1   19               00 r[19]=t0.c1
REG[19] =  i:4
  29 Column           0    1   20               00 r[20]=t0.c1
REG[20] =  i:4
  30 Rowid            0   21    0               00 r[21]=rowid
REG[21] =  i:4
  31 IdxDelete        1   16    6               00 key=r[16..21]
  32 Column           0    0   17               00 r[17]=t0.c0
REG[17] =  i:3
  33 Rowid            0   18    0               00 r[18]=rowid
REG[18] =  i:4
  34 IdxDelete        2   16    3               00 key=r[16..18]
  35 IdxInsert        1    1    2 6             00 key=r[1]
REG[1] =  s13[07010101010101610461040404.......a.a...]
  36 IdxInsert        2    8    9 3             00 key=r[8]
REG[8] =  s7[04010101616104....aa.]
  37 MakeRecord      14    2   22               00 r[22]=mkrec(r[14..15])
REG[22] =  s5[0301016104...a.]
  38 Insert           0   22   13 t0            07 intkey=r[13] data=r[22]
REG[22] =  s5[0301016104...a.]
REG[13] =  i:4
  39 Next             0    5    0               01 
  40 Halt             0    0    0               00 
SQL: [;CREATE TRIGGER t2def AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c1) = (SELECT 'c1', 'c1'), (c1, c1) = (SELECT 'c0', 'c1')
      WHERE c1 = new.c1-1;
  END;]
VDBE Trace:
   0 Init             0   13    0               00 Start at 13
  13 Transaction      0    1    8 0             01 usesStmtJournal=0
  14 Goto             0    1    0               00 
   1 OpenWrite        0    1    0 5             00 root=1 iDb=0; sqlite_master
   2 NewRowid         0    1    0               00 r[1]=rowid
REG[1] =  i:7
   3 String8          0    2    0 trigger       00 r[2]='trigger'
REG[2] =   t7[trigger](8)
   4 String8          0    3    0 t2def         00 r[3]='t2def'
REG[3] =   t5[t2def](8)
   5 String8          0    4    0 t0            00 r[4]='t0'
REG[4] =   t2[t0](8)
   6 Integer          0    5    0               00 r[5]=0
REG[5] =  i:0
   7 String8          0    6    0 CREATE TRIGGER t2def AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c1) = (SELECT 'c1', 'c1'), (c1, c1) = (SELECT 'c0', 'c1')
      WHERE c1 = new.c1-1;
  END 00 r[6]='CREATE TRIGGER t2def AFTER INSERT ON t0 BEGIN
    UPDATE t0 SET (c0, c1) = (SELECT 'c1', 'c1'
REG[6] =   t159[CREATE TRIGGER ](8)
   8 MakeRecord       2    5    7 BBBDB         00 r[7]=mkrec(r[2..6])
REG[7] =  s180[071B171108824B747269676765727432......Ktriggert2]
   9 Insert           0    7    1               18 intkey=r[1] data=r[7]
REG[7] =  s180[071B171108824B747269676765727432......Ktriggert2]
REG[1] =  i:7
  10 SetCookie        0    1    9               00 
  11 ParseSchema      0    0    0 type='trigger' AND name='t2def' 00 
VDBE Trace:
   0 Init             0   15    0               00 Start at 15
  15 Transaction      0    0    9 0             00 usesStmtJournal=0
  16 String8          0    2    0 trigger       00 r[2]='trigger'
REG[2] =   t7[trigger](8)
  17 String8          0    3    0 t2def         00 r[3]='t2def'
REG[3] =   t5[t2def](8)
  18 Goto             0    1    0               00 
   1 Noop             1    5    0               00 
   2 OpenRead         0    1    0 5             00 root=1 iDb=0; sqlite_master
   3 Explain          3    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   14    0               00 
   5 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[table](8)
   6 Ne               2   13    1 (BINARY)      52 if r[1]!=r[2] goto 13
REG[2] =   t7[trigger](8)
REG[1] =   s5[table](8)
  13 Next             0    5    0               01 
   5 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[index](8)
   6 Ne               2   13    1 (BINARY)      52 if r[1]!=r[2] goto 13
REG[2] =   t7[trigger](8)
REG[1] =   s5[index](8)
  13 Next             0    5    0               01 
   5 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[index](8)
   6 Ne               2   13    1 (BINARY)      52 if r[1]!=r[2] goto 13
REG[2] =   t7[trigger](8)
REG[1] =   s5[index](8)
  13 Next             0    5    0               01 
   5 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[table](8)
   6 Ne               2   13    1 (BINARY)      52 if r[1]!=r[2] goto 13
REG[2] =   t7[trigger](8)
REG[1] =   s5[table](8)
  13 Next             0    5    0               01 
   5 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[table](8)
   6 Ne               2   13    1 (BINARY)      52 if r[1]!=r[2] goto 13
REG[2] =   t7[trigger](8)
REG[1] =   s5[table](8)
  13 Next             0    5    0               01 
   5 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[table](8)
   6 Ne               2   13    1 (BINARY)      52 if r[1]!=r[2] goto 13
REG[2] =   t7[trigger](8)
REG[1] =   s5[table](8)
  13 Next             0    5    0               01 
   5 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s7[trigger](8)
   6 Ne               2   13    1 (BINARY)      52 if r[1]!=r[2] goto 13
REG[2] =   t7[trigger](8)
REG[1] =   s7[trigger](8)
   7 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s5[t2def](8)
   8 Ne               3   13    1 (BINARY)      52 if r[1]!=r[3] goto 13
REG[3] =   t5[t2def](8)
REG[1] =   s5[t2def](8)
   9 Column           0    1    4               00 r[4]=sqlite_master.name
REG[4] =   s5[t2def](8)
  10 Column           0    3    5               00 r[5]=sqlite_master.rootpage
REG[5] =  i:0
  11 Column           0    4    6               00 r[6]=sqlite_master.sql
REG[6] =   s159[CREATE TRIGGER ](8)
  12 ResultRow        4    3    0               00 output=r[4..6]
REG[4] =   s5[t2def](8)
REG[5] =  i:0
REG[6] =   s159[CREATE TRIGGER ](8)
  13 Next             0    5    0               01 
  14 Halt             0    0    0               00 
  12 Halt             0    0    0               00 
SQL: [;SELECT * FROM e;]
VDBE Trace:
   0 Init             0    8    0               00 Start at 8
   8 Transaction      0    0    9 0             01 usesStmtJournal=0
   9 Goto             0    1    0               00 
   1 OpenRead         0    7    0 1             00 root=7 iDb=0; e
   2 Explain          2    0    0 SCAN TABLE e  00 
   3 Rewind           0    7    0               00 
   7 Halt             0    0    0               00 
SQL: [;
;DROP TRIGGER t2def;]
VDBE Trace:
   0 Init             0   16    0               00 Start at 16
  16 Transaction      0    1    9 0             01 usesStmtJournal=0
  17 String8          0    3    0 t2def         00 r[3]='t2def'
REG[3] =   t5[t2def](8)
  18 String8          0    4    0 trigger       00 r[4]='trigger'
REG[4] =   t7[trigger](8)
  19 Goto             0    1    0               00 
   1 Null             0    1    0               00 r[1]=NULL
REG[1] =  NULL
   2 OpenWrite        0    1    0 5             00 root=1 iDb=0; sqlite_master
   3 Explain          3    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   13    0               00 
   5 Column           0    1    2               00 r[2]=sqlite_master.name
REG[2] =   s2[t0](8)
   6 Ne               3   12    2 (BINARY)      52 if r[2]!=r[3] goto 12
REG[3] =   t5[t2def](8)
REG[2] =   s2[t0](8)
  12 Next             0    5    0               01 
   5 Column           0    1    2               00 r[2]=sqlite_master.name
REG[2] =   s2[t1](8)
   6 Ne               3   12    2 (BINARY)      52 if r[2]!=r[3] goto 12
REG[3] =   t5[t2def](8)
REG[2] =   s2[t1](8)
  12 Next             0    5    0               01 
   5 Column           0    1    2               00 r[2]=sqlite_master.name
REG[2] =   s1[a](8)
   6 Ne               3   12    2 (BINARY)      52 if r[2]!=r[3] goto 12
REG[3] =   t5[t2def](8)
REG[2] =   s1[a](8)
  12 Next             0    5    0               01 
   5 Column           0    1    2               00 r[2]=sqlite_master.name
REG[2] =   s1[b](8)
   6 Ne               3   12    2 (BINARY)      52 if r[2]!=r[3] goto 12
REG[3] =   t5[t2def](8)
REG[2] =   s1[b](8)
  12 Next             0    5    0               01 
   5 Column           0    1    2               00 r[2]=sqlite_master.name
REG[2] =   s4[t1bc](8)
   6 Ne               3   12    2 (BINARY)      52 if r[2]!=r[3] goto 12
REG[3] =   t5[t2def](8)
REG[2] =   s4[t1bc](8)
  12 Next             0    5    0               01 
   5 Column           0    1    2               00 r[2]=sqlite_master.name
REG[2] =   s1[e](8)
   6 Ne               3   12    2 (BINARY)      52 if r[2]!=r[3] goto 12
REG[3] =   t5[t2def](8)
REG[2] =   s1[e](8)
  12 Next             0    5    0               01 
   5 Column           0    1    2               00 r[2]=sqlite_master.name
REG[2] =   s5[t2def](8)
   6 Ne               3   12    2 (BINARY)      52 if r[2]!=r[3] goto 12
REG[3] =   t5[t2def](8)
REG[2] =   s5[t2def](8)
   7 Column           0    0    2               00 r[2]=sqlite_master.type
REG[2] =   s7[trigger](8)
   8 Ne               4   12    2 (BINARY)      52 if r[2]!=r[4] goto 12
REG[4] =   t7[trigger](8)
REG[2] =   s7[trigger](8)
   9 Rowid            0    5    0               00 r[5]=rowid
REG[5] =  i:7
  10 Once             0   11    0               00 
  11 Delete           0    0    0               02 
  12 Next             0    5    0               01 
  13 SetCookie        0    1   10               00 
  14 DropTrigger      0    0    0 t2def         00 
  15 Halt             0    0    0               00 
SQL: [;PRAGMA recursive_triggers = 1;]
VDBE Trace:
   0 Init             0    1    0               00 Start at 1
   1 Expire           0    0    0               00 
   2 Halt             0    0    0               00 
SQL: [;
;SELECT * FROM b CROSS JOIN t0 
  WHERE b.t1a=t0.c1 AND (t0.c1, 2) 
  IN (VALUES(1, 2));]
VDBE Trace:
   0 Init             0   42    0               00 Start at 42
  42 Transaction      0    0   10 0             01 usesStmtJournal=0
  43 Integer          2   10    0               00 r[10]=2
REG[10] =  i:2
  44 Goto             0    1    0               00 
   1 OpenRead         0    5    0 2             00 root=5 iDb=0; b
   2 OpenRead         1    2    0 2             00 root=2 iDb=0; t0
   3 Explain          3    0    0 SCAN TABLE b  00 
   4 Rewind           0   41    0               00 
  41 Halt             0    0    0               00 
SQL: [;
;CREATE TABLE t2def ( t3, x, PRIMARY KEY (t3, x) );]
VDBE Trace:
   0 Init             0   39    0               00 Start at 39
  39 Transaction      0    1   10 0             01 usesStmtJournal=0
  40 Goto             0    1    0               00 
   1 ReadCookie       0    3    2               00 
REG[3] =  i:4
   2 If               3    5    0               00 
REG[3] =  i:4
   5 CreateBtree      0    2    1               00 r[2]=root iDb=0 flags=1
REG[2] =  i:8
   6 OpenWrite        0    1    0 5             00 root=1 iDb=0
   7 NewRowid         0    1    0               00 r[1]=rowid
REG[1] =  i:7
   8 Blob             6    3    0              00 r[3]= (len=6)
REG[3] =  t6[060000000000......]
   9 Insert           0    3    1               08 intkey=r[1] data=r[3]
REG[3] =  t6[060000000000......]
REG[1] =  i:7
  10 Close            0    0    0               00 
  11 Noop             0   22    0               00 
  12 CreateBtree      0    4    2               00 r[4]=root iDb=0 flags=2
REG[4] =  i:9
  13 OpenWrite        1    1    0 5             00 root=1 iDb=0; sqlite_master
  14 NewRowid         1    5    0               00 r[5]=rowid
REG[5] =  i:8
  15 String8          0    6    0 index         00 r[6]='index'
REG[6] =   t5[index](8)
  16 String8          0    7    0 sqlite_autoindex_t2def_1 00 r[7]='sqlite_autoindex_t2def_1'
REG[7] =   t24[sqlite_autoinde](8)
  17 String8          0    8    0 t2def         00 r[8]='t2def'
REG[8] =   t5[t2def](8)
  18 Copy             4    9    0               00 r[9]=r[4]
REG[9] =  i:9
  19 Null             0   10    0               00 r[10]=NULL
REG[10] =  NULL
  20 MakeRecord       6    5   11 BBBDB         00 r[11]=mkrec(r[6..10])
REG[11] =  s41[06173D170100696E64657873716C6974..=...indexsqlit]
  21 Insert           1   11    5               18 intkey=r[5] data=r[11]
REG[11] =  s41[06173D170100696E64657873716C6974..=...indexsqlit]
REG[5] =  i:8
  22 Close            0    0    0               00 
  23 Null             0   12   13               00 r[12..13]=NULL
REG[12] =  NULL
  24 OpenWrite        2    1    0 5             00 root=1 iDb=0; sqlite_master
  25 Explain         25    0    0 SEARCH TABLE sqlite_master USING INTEGER PRIMARY KEY (rowid=?) 00 
  26 SeekRowid        2   28    1               00 intkey=r[1]
REG[1] =  i:7
  27 Rowid            2   13    0               00 r[13]=rowid
REG[13] =  i:7
  28 IsNull          13   36    0               00 if r[13]==NULL goto 36
REG[13] =  i:7
  29 String8          0   14    0 table         00 r[14]='table'
REG[14] =   t5[table](8)
  30 String8          0   15    0 t2def         00 r[15]='t2def'
REG[15] =   t5[t2def](8)
  31 String8          0   16    0 t2def         00 r[16]='t2def'
REG[16] =   t5[t2def](8)
  32 Copy             2   17    0               00 r[17]=r[2]
REG[17] =  i:8
  33 String8          0   18    0 CREATE TABLE t2def ( t3, x, PRIMARY KEY (t3, x) ) 00 r[18]='CREATE TABLE t2def ( t3, x, PRIMARY KEY (t3, x) )'
REG[18] =   t49[CREATE TABLE t2](8)
  34 MakeRecord      14    5   19 BBBDB         00 r[19]=mkrec(r[14..18])
REG[19] =  s71[06171717016F7461626C657432646566.....otablet2def]
  35 Insert           2   19   13               00 intkey=r[13] data=r[19]
REG[19] =  s71[06171717016F7461626C657432646566.....otablet2def]
REG[13] =  i:7
  36 SetCookie        0    1   11               00 
  37 ParseSchema      0    0    0 tbl_name='t2def' AND type!='trigger' 00 
VDBE Trace:
   0 Init             0   15    0               00 Start at 15
  15 Transaction      0    0   11 0             00 usesStmtJournal=0
  16 String8          0    2    0 t2def         00 r[2]='t2def'
REG[2] =   t5[t2def](8)
  17 String8          0    3    0 trigger       00 r[3]='trigger'
REG[3] =   t7[trigger](8)
  18 Goto             0    1    0               00 
   1 Noop             1    5    0               00 
   2 OpenRead         0    1    0 5             00 root=1 iDb=0; sqlite_master
   3 Explain          3    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   14    0               00 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[t0](8)
   6 Ne               2   13    1 (BINARY)      52 if r[1]!=r[2] goto 13
REG[2] =   t5[t2def](8)
REG[1] =   s2[t0](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[t0](8)
   6 Ne               2   13    1 (BINARY)      52 if r[1]!=r[2] goto 13
REG[2] =   t5[t2def](8)
REG[1] =   s2[t0](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[t0](8)
   6 Ne               2   13    1 (BINARY)      52 if r[1]!=r[2] goto 13
REG[2] =   t5[t2def](8)
REG[1] =   s2[t0](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s1[b](8)
   6 Ne               2   13    1 (BINARY)      52 if r[1]!=r[2] goto 13
REG[2] =   t5[t2def](8)
REG[1] =   s1[b](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s4[t1bc](8)
   6 Ne               2   13    1 (BINARY)      52 if r[1]!=r[2] goto 13
REG[2] =   t5[t2def](8)
REG[1] =   s4[t1bc](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s1[e](8)
   6 Ne               2   13    1 (BINARY)      52 if r[1]!=r[2] goto 13
REG[2] =   t5[t2def](8)
REG[1] =   s1[e](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s5[t2def](8)
   6 Ne               2   13    1 (BINARY)      52 if r[1]!=r[2] goto 13
REG[2] =   t5[t2def](8)
REG[1] =   s5[t2def](8)
   7 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[table](8)
   8 Eq               3   13    1 (BINARY)      52 if r[1]==r[3] goto 13
REG[3] =   t7[trigger](8)
REG[1] =   s5[table](8)
   9 Column           0    1    4               00 r[4]=sqlite_master.name
REG[4] =   s5[t2def](8)
  10 Column           0    3    5               00 r[5]=sqlite_master.rootpage
REG[5] =  i:8
  11 Column           0    4    6               00 r[6]=sqlite_master.sql
REG[6] =   s49[CREATE TABLE t2](8)
  12 ResultRow        4    3    0               00 output=r[4..6]
REG[4] =   s5[t2def](8)
REG[5] =  i:8
REG[6] =   s49[CREATE TABLE t2](8)
  13 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s5[t2def](8)
   6 Ne               2   13    1 (BINARY)      52 if r[1]!=r[2] goto 13
REG[2] =   t5[t2def](8)
REG[1] =   s5[t2def](8)
   7 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[index](8)
   8 Eq               3   13    1 (BINARY)      52 if r[1]==r[3] goto 13
REG[3] =   t7[trigger](8)
REG[1] =   s5[index](8)
   9 Column           0    1    4               00 r[4]=sqlite_master.name
REG[4] =   s24[sqlite_autoinde](8)
  10 Column           0    3    5               00 r[5]=sqlite_master.rootpage
REG[5] =  i:9
  11 Column           0    4    6               00 r[6]=sqlite_master.sql
REG[6] =  NULL
  12 ResultRow        4    3    0               00 output=r[4..6]
REG[4] =   s24[sqlite_autoinde](8)
REG[5] =  i:9
REG[6] =  NULL
  13 Next             0    5    0               01 
  14 Halt             0    0    0               00 
  38 Halt             0    0    0               00 
SQL: [;INSERT INTO t0 VALUES (1, 1), (1, 2);]
VDBE Trace:
   0 Init             0   34    0               00 Start at 34
  34 Transaction      0    1   11 0             01 usesStmtJournal=0
  35 Goto             0    1    0               00 
   1 InitCoroutine    4   10    2               00 
  10 OpenWrite        0    2    0 2             00 root=2 iDb=0; t0
  11 OpenWrite        1    4    0 k(6,,,,,,)    00 root=4 iDb=0; a
  12 OpenWrite        2    3    0 k(3,,,)       00 root=3 iDb=0; t1
  13 Yield            4   33    0               00 
REG[4] =  i:1
REG[4] =  i:13
   2 Explain          2    0    0 SCAN 2 CONSTANT ROWS 00 
   3 Integer          1    2    0               00 r[2]=1
REG[2] =  i:1
   4 Integer          1    3    0               00 r[3]=1
REG[3] =  i:1
   5 Yield            4    0    0               00 
REG[4] =  i:13
REG[4] =  i:5
  14 NewRowid         0    1    0               00 r[1]=rowid
REG[1] =  i:5
  15 Noop             0    0    0               00 uniqueness check for a
  16 SCopy            2    6    0               00 r[6]=r[2]; c0
REG[6] =  i:1
  17 SCopy            3    7    0               00 r[7]=r[3]; c1
REG[7] =  i:1
  18 SCopy            2    8    0               00 r[8]=r[2]; c0
REG[8] =  i:1
  19 SCopy            3    9    0               00 r[9]=r[3]; c1
REG[9] =  i:1
  20 SCopy            3   10    0               00 r[10]=r[3]; c1
REG[10] =  i:1
  21 IntCopy          1   11    0               00 r[11]=r[1]; rowid
REG[11] =  i:5
  22 MakeRecord       6    6    5               00 r[5]=mkrec(r[6..11]); for a
REG[5] =  s8[0709090909090105........]
  23 Noop             0    0    0               00 uniqueness check for t1
  24 SCopy            2   13    0               00 r[13]=r[2]; c0
REG[13] =  i:1
  25 SCopy            2   14    0               00 r[14]=r[2]; c0
REG[14] =  i:1
  26 IntCopy          1   15    0               00 r[15]=r[1]; rowid
REG[15] =  i:5
  27 MakeRecord      13    3   12               00 r[12]=mkrec(r[13..15]); for t1
REG[12] =  s5[0409090105.....]
  28 IdxInsert        1    5    6 6             10 key=r[5]
REG[5] =  s8[0709090909090105........]
  29 IdxInsert        2   12   13 3             10 key=r[12]
REG[12] =  s5[0409090105.....]
  30 MakeRecord       2    2   16               00 r[16]=mkrec(r[2..3])
REG[16] =  s3[030909...]
  31 Insert           0   16    1 t0            39 intkey=r[1] data=r[16]
REG[16] =  s3[030909...]
REG[1] =  i:5
  32 Goto             0   13    0               00 
  13 Yield            4   33    0               00 
REG[4] =  i:5
REG[4] =  i:13
   6 Integer          1    2    0               00 r[2]=1
REG[2] =  i:1
   7 Integer          2    3    0               00 r[3]=2
REG[3] =  i:2
   8 Yield            4    0    0               00 
REG[4] =  i:13
REG[4] =  i:8
  14 NewRowid         0    1    0               00 r[1]=rowid
REG[1] =  i:6
  15 Noop             0    0    0               00 uniqueness check for a
  16 SCopy            2    6    0               00 r[6]=r[2]; c0
REG[6] =  i:1
  17 SCopy            3    7    0               00 r[7]=r[3]; c1
REG[7] =  i:2
  18 SCopy            2    8    0               00 r[8]=r[2]; c0
REG[8] =  i:1
  19 SCopy            3    9    0               00 r[9]=r[3]; c1
REG[9] =  i:2
  20 SCopy            3   10    0               00 r[10]=r[3]; c1
REG[10] =  i:2
  21 IntCopy          1   11    0               00 r[11]=r[1]; rowid
REG[11] =  i:6
  22 MakeRecord       6    6    5               00 r[5]=mkrec(r[6..11]); for a
REG[5] =  s11[0709010901010102020206...........]
  23 Noop             0    0    0               00 uniqueness check for t1
  24 SCopy            2   13    0               00 r[13]=r[2]; c0
REG[13] =  i:1
  25 SCopy            2   14    0               00 r[14]=r[2]; c0
REG[14] =  i:1
  26 IntCopy          1   15    0               00 r[15]=r[1]; rowid
REG[15] =  i:6
  27 MakeRecord      13    3   12               00 r[12]=mkrec(r[13..15]); for t1
REG[12] =  s5[0409090106.....]
  28 IdxInsert        1    5    6 6             10 key=r[5]
REG[5] =  s11[0709010901010102020206...........]
  29 IdxInsert        2   12   13 3             10 key=r[12]
REG[12] =  s5[0409090106.....]
  30 MakeRecord       2    2   16               00 r[16]=mkrec(r[2..3])
REG[16] =  s4[03090102....]
  31 Insert           0   16    1 t0            39 intkey=r[1] data=r[16]
REG[16] =  s4[03090102....]
REG[1] =  i:6
  32 Goto             0   13    0               00 
  13 Yield            4   33    0               00 
REG[4] =  i:8
REG[4] =  i:13
   9 EndCoroutine     4    0    0               00 
REG[4] =  i:13
  33 Halt             0    0    0               00 
SQL: [;
;DROP TABLE IF EXISTS e;]
VDBE Trace:
   0 Init             0   38    0               00 Start at 38
  38 Transaction      0    1   11 0             01 usesStmtJournal=1
  39 String8          0    3    0 e             00 r[3]='e'
REG[3] =   t1[e](8)
  40 String8          0    4    0 trigger       00 r[4]='trigger'
REG[4] =   t7[trigger](8)
  41 Goto             0    1    0               00 
   1 Null             0    1    0               00 r[1]=NULL
REG[1] =  NULL
   2 OpenWrite        0    1    0 5             00 root=1 iDb=0; sqlite_master
   3 Explain          3    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   13    0               00 
   5 Column           0    2    2               00 r[2]=sqlite_master.tbl_name
REG[2] =   s2[t0](8)
   6 Ne               3   12    2 (BINARY)      52 if r[2]!=r[3] goto 12
REG[3] =   t1[e](8)
REG[2] =   s2[t0](8)
  12 Next             0    5    0               01 
   5 Column           0    2    2               00 r[2]=sqlite_master.tbl_name
REG[2] =   s2[t0](8)
   6 Ne               3   12    2 (BINARY)      52 if r[2]!=r[3] goto 12
REG[3] =   t1[e](8)
REG[2] =   s2[t0](8)
  12 Next             0    5    0               01 
   5 Column           0    2    2               00 r[2]=sqlite_master.tbl_name
REG[2] =   s2[t0](8)
   6 Ne               3   12    2 (BINARY)      52 if r[2]!=r[3] goto 12
REG[3] =   t1[e](8)
REG[2] =   s2[t0](8)
  12 Next             0    5    0               01 
   5 Column           0    2    2               00 r[2]=sqlite_master.tbl_name
REG[2] =   s1[b](8)
   6 Ne               3   12    2 (BINARY)      52 if r[2]!=r[3] goto 12
REG[3] =   t1[e](8)
REG[2] =   s1[b](8)
  12 Next             0    5    0               01 
   5 Column           0    2    2               00 r[2]=sqlite_master.tbl_name
REG[2] =   s4[t1bc](8)
   6 Ne               3   12    2 (BINARY)      52 if r[2]!=r[3] goto 12
REG[3] =   t1[e](8)
REG[2] =   s4[t1bc](8)
  12 Next             0    5    0               01 
   5 Column           0    2    2               00 r[2]=sqlite_master.tbl_name
REG[2] =   s1[e](8)
   6 Ne               3   12    2 (BINARY)      52 if r[2]!=r[3] goto 12
REG[3] =   t1[e](8)
REG[2] =   s1[e](8)
   7 Column           0    0    2               00 r[2]=sqlite_master.type
REG[2] =   s5[table](8)
   8 Eq               4   12    2 (BINARY)      52 if r[2]==r[4] goto 12
REG[4] =   t7[trigger](8)
REG[2] =   s5[table](8)
   9 Rowid            0    5    0               00 r[5]=rowid
REG[5] =  i:6
  10 Once             0   11    0               00 
  11 Delete           0    0    0               02 
  12 Next             0    5    0               01 
   5 Column           0    2    2               00 r[2]=sqlite_master.tbl_name
REG[2] =   s5[t2def](8)
   6 Ne               3   12    2 (BINARY)      52 if r[2]!=r[3] goto 12
REG[3] =   t1[e](8)
REG[2] =   s5[t2def](8)
  12 Next             0    5    0               01 
   5 Column           0    2    2               00 r[2]=sqlite_master.tbl_name
REG[2] =   s5[t2def](8)
   6 Ne               3   12    2 (BINARY)      52 if r[2]!=r[3] goto 12
REG[3] =   t1[e](8)
REG[2] =   s5[t2def](8)
  12 Next             0    5    0               01 
  13 Destroy          7    2    0               00 
REG[2] =  i:0
  14 Null             0    6    7               00 r[6..7]=NULL
REG[6] =  NULL
  15 IfNot            2   24    1               00 
REG[2] =  i:0
  24 OpenWrite        1    1    0 5             00 root=1 iDb=0; sqlite_master
  25 RowSetRead       6   35    7               00 r[7]=rowset(6)
REG[6] =  NULL
REG[7] =  NULL
  35 DropTable        0    0    0 e             00 
  36 SetCookie        0    1   12               00 
  37 Halt             0    0    0               00 
SQL: [;
;SELECT * FROM b WHERE (c,c)<=(5,0) ORDER BY c DESC;]
VDBE Trace:
   0 Init             0   25    0               00 Start at 25
  25 Transaction      0    0   12 0             01 usesStmtJournal=0
  26 Integer          5    3    0               00 r[3]=5
REG[3] =  i:5
  27 Integer          0    4    0               00 r[4]=0
REG[4] =  i:0
  28 Goto             0    1    0               00 
   1 SorterOpen       1    4    0 k(1,-B)       00 
   2 OpenRead         0    5    0 2             00 root=5 iDb=0; b
   3 Explain          3    0    0 SCAN TABLE b  00 
   4 Rewind           0   16    0               00 
  16 Explain         16    0    0 USE TEMP B-TREE FOR ORDER BY 00 
  17 OpenPseudo       2    9    4               00 4 columns in r[9]
  18 SorterSort       1   24    0               00 
  24 Halt             0    0    0               00 
SQL: [;
;SELECT * FROM t1bc WHERE (d,t2)>(3,0) ORDER BY d;]
VDBE Trace:
   0 Init             0   25    0               00 Start at 25
  25 Transaction      0    0   12 0             01 usesStmtJournal=0
  26 Integer          3    3    0               00 r[3]=3
REG[3] =  i:3
  27 Integer          0    4    0               00 r[4]=0
REG[4] =  i:0
  28 Goto             0    1    0               00 
   1 SorterOpen       1    4    0 k(1,B)        00 
   2 OpenRead         0    6    0 2             00 root=6 iDb=0; t1bc
   3 Explain          3    0    0 SCAN TABLE t1bc 00 
   4 Rewind           0   16    0               00 
   5 Column           0    1    2               00 r[2]=t1bc.d
REG[2] =  i:1
   6 Gt               3    1    2 (BINARY)      61 r[1] = (r[2]>r[3])
REG[3] =  i:3
REG[2] =  i:1
REG[1] =  i:0
   7 ElseNotEq        0   10    0               00 
  10 IfNot            1   15    1               00 
REG[1] =  i:0
  15 Next             0    5    0               01 
  16 Explain         16    0    0 USE TEMP B-TREE FOR ORDER BY 00 
  17 OpenPseudo       2    9    4               00 4 columns in r[9]
  18 SorterSort       1   24    0               00 
  24 Halt             0    0    0               00 
SQL: [;
;SELECT * FROM t2def WHERE (x,t3)>=(3,0) ORDER BY x;]
VDBE Trace:
   0 Init             0   25    0               00 Start at 25
  25 Transaction      0    0   12 0             01 usesStmtJournal=0
  26 Integer          3    3    0               00 r[3]=3
REG[3] =  i:3
  27 Integer          0    4    0               00 r[4]=0
REG[4] =  i:0
  28 Goto             0    1    0               00 
   1 SorterOpen       1    4    0 k(1,B)        00 
   2 OpenRead         0    8    0 2             00 root=8 iDb=0; t2def
   3 Explain          3    0    0 SCAN TABLE t2def 00 
   4 Rewind           0   16    0               00 
  16 Explain         16    0    0 USE TEMP B-TREE FOR ORDER BY 00 
  17 OpenPseudo       2    9    4               00 4 columns in r[9]
  18 SorterSort       1   24    0               00 
  24 Halt             0    0    0               00 
SQL: [;
;SELECT * FROM b WHERE (c,t1a)<=(3,0) ORDER BY c DESC;]
VDBE Trace:
   0 Init             0   25    0               00 Start at 25
  25 Transaction      0    0   12 0             01 usesStmtJournal=0
  26 Integer          3    3    0               00 r[3]=3
REG[3] =  i:3
  27 Integer          0    4    0               00 r[4]=0
REG[4] =  i:0
  28 Goto             0    1    0               00 
   1 SorterOpen       1    4    0 k(1,-B)       00 
   2 OpenRead         0    5    0 2             00 root=5 iDb=0; b
   3 Explain          3    0    0 SCAN TABLE b  00 
   4 Rewind           0   16    0               00 
  16 Explain         16    0    0 USE TEMP B-TREE FOR ORDER BY 00 
  17 OpenPseudo       2    9    4               00 4 columns in r[9]
  18 SorterSort       1   24    0               00 
  24 Halt             0    0    0               00 
SQL: [;
;SELECT * FROM t1bc WHERE (d,d)>=(3,33) ORDER BY d;]
VDBE Trace:
   0 Init             0   25    0               00 Start at 25
  25 Transaction      0    0   12 0             01 usesStmtJournal=0
  26 Integer          3    3    0               00 r[3]=3
REG[3] =  i:3
  27 Integer         33    4    0               00 r[4]=33
REG[4] =  i:33
  28 Goto             0    1    0               00 
   1 SorterOpen       1    4    0 k(1,B)        00 
   2 OpenRead         0    6    0 2             00 root=6 iDb=0; t1bc
   3 Explain          3    0    0 SCAN TABLE t1bc 00 
   4 Rewind           0   16    0               00 
   5 Column           0    1    2               00 r[2]=t1bc.d
REG[2] =  i:1
   6 Gt               3    1    2 (BINARY)      61 r[1] = (r[2]>r[3])
REG[3] =  i:3
REG[2] =  i:1
REG[1] =  i:0
   7 ElseNotEq        0   10    0               00 
  10 IfNot            1   15    1               00 
REG[1] =  i:0
  15 Next             0    5    0               01 
  16 Explain         16    0    0 USE TEMP B-TREE FOR ORDER BY 00 
  17 OpenPseudo       2    9    4               00 4 columns in r[9]
  18 SorterSort       1   24    0               00 
  24 Halt             0    0    0               00 
SQL: [;
;SELECT * FROM b WHERE (c,c)>=(3,34) ORDER BY c;]
VDBE Trace:
   0 Init             0   25    0               00 Start at 25
  25 Transaction      0    0   12 0             01 usesStmtJournal=0
  26 Integer          3    3    0               00 r[3]=3
REG[3] =  i:3
  27 Integer         34    4    0               00 r[4]=34
REG[4] =  i:34
  28 Goto             0    1    0               00 
   1 SorterOpen       1    4    0 k(1,B)        00 
   2 OpenRead         0    5    0 2             00 root=5 iDb=0; b
   3 Explain          3    0    0 SCAN TABLE b  00 
   4 Rewind           0   16    0               00 
  16 Explain         16    0    0 USE TEMP B-TREE FOR ORDER BY 00 
  17 OpenPseudo       2    9    4               00 4 columns in r[9]
  18 SorterSort       1   24    0               00 
  24 Halt             0    0    0               00 
SQL: [;
;SELECT * FROM t0 WHERE (c0,c0)<(3,34) ORDER BY c0 DESC;]
VDBE Trace:
   0 Init             0   20    0               00 Start at 20
  20 Transaction      0    0   12 0             01 usesStmtJournal=0
  21 Integer          3    4    0               00 r[4]=3
REG[4] =  i:3
  22 Integer         34    5    0               00 r[5]=34
REG[5] =  i:34
  23 Goto             0    1    0               00 
   1 Noop             1    4    0               00 
   2 OpenRead         2    4    0 k(6,,,,,,)    00 root=4 iDb=0; a
   3 Explain          3    0    0 SEARCH TABLE t0 USING COVERING INDEX a (c0<?) 00 
   4 Integer          3    1    0               00 r[1]=3
REG[1] =  i:3
   5 IsNull           1   19    0               00 if r[1]==NULL goto 19
REG[1] =  i:3
   6 SeekLE           2   19    1 1             00 key=r[1]
REG[1] =  i:3
   7 Null             0    1    0               00 r[1]=NULL
REG[1] =  NULL
   8 IdxLE            2   19    1 1             00 key=r[1]
REG[1] =  NULL
   9 Column           2    0    3               00 r[3]=t0.c0
REG[3] =  i:1
  10 Lt               4    2    3 (BINARY)      61 r[2] = (r[3]<r[4])
REG[4] =  i:3
REG[3] =  i:1
REG[2] =  i:1
  11 ElseNotEq        0   14    0               00 
  14 IfNot            2   18    1               00 
REG[2] =  i:1
  15 Column           2    0    6               00 r[6]=t0.c0
REG[6] =  i:1
  16 Column           2    1    7               00 r[7]=t0.c1
REG[7] =  i:2
  17 ResultRow        6    2    0               00 output=r[6..7]
REG[6] =  i:1
REG[7] =  i:2
  18 Prev             2    8    0               00 
   8 IdxLE            2   19    1 1             00 key=r[1]
REG[1] =  NULL
   9 Column           2    0    3               00 r[3]=t0.c0
REG[3] =  i:1
  10 Lt               4    2    3 (BINARY)      61 r[2] = (r[3]<r[4])
REG[4] =  i:3
REG[3] =  i:1
REG[2] =  i:1
  11 ElseNotEq        0   14    0               00 
  14 IfNot            2   18    1               00 
REG[2] =  i:1
  15 Column           2    0    6               00 r[6]=t0.c0
REG[6] =  i:1
  16 Column           2    1    7               00 r[7]=t0.c1
REG[7] =  i:1
  17 ResultRow        6    2    0               00 output=r[6..7]
REG[6] =  i:1
REG[7] =  i:1
  18 Prev             2    8    0               00 
  19 Halt             0    0    0               00 
SQL: [;
;SELECT * FROM b WHERE (0,0)<(t1a,t1a) ORDER BY t1a;]
VDBE Trace:
   0 Init             0   25    0               00 Start at 25
  25 Transaction      0    0   12 0             01 usesStmtJournal=0
  26 Integer          0    3    0               00 r[3]=0
REG[3] =  i:0
  27 Goto             0    1    0               00 
   1 SorterOpen       1    4    0 k(1,B)        00 
   2 OpenRead         0    5    0 2             00 root=5 iDb=0; b
   3 Explain          3    0    0 SCAN TABLE b  00 
   4 Rewind           0   16    0               00 
  16 Explain         16    0    0 USE TEMP B-TREE FOR ORDER BY 00 
  17 OpenPseudo       2    8    4               00 4 columns in r[8]
  18 SorterSort       1   24    0               00 
  24 Halt             0    0    0               00 
SQL: [;
;SELECT * FROM t0 WHERE (5,0)>=(c0,c1) ORDER BY c0 DESC;]
VDBE Trace:
   0 Init             0   21    0               00 Start at 21
  21 Transaction      0    0   12 0             01 usesStmtJournal=0
  22 Integer          5    5    0               00 r[5]=5
REG[5] =  i:5
  23 Integer          0    6    0               00 r[6]=0
REG[6] =  i:0
  24 Goto             0    1    0               00 
   1 Noop             1    4    0               00 
   2 OpenRead         2    4    0 k(6,,,,,,)    00 root=4 iDb=0; a
   3 Explain          3    0    0 SEARCH TABLE t0 USING COVERING INDEX a ((c0,c1)<(?,?)) 00 
   4 Integer          5    1    0               00 r[1]=5
REG[1] =  i:5
   5 Integer          0    2    0               00 r[2]=0
REG[2] =  i:0
   6 IsNull           1   20    0               00 if r[1]==NULL goto 20
REG[1] =  i:5
   7 SeekLE           2   20    1 2             00 key=r[1..2]
REG[1] =  i:5
   8 Null             0    1    0               00 r[1]=NULL
REG[1] =  NULL
   9 IdxLE            2   20    1 1             00 key=r[1]
REG[1] =  NULL
  10 Column           2    0    4               00 r[4]=t0.c0
REG[4] =  i:1
  11 Lt               5    3    4 (BINARY)      61 r[3] = (r[4]<r[5])
REG[5] =  i:5
REG[4] =  i:1
REG[3] =  i:1
  12 ElseNotEq        0   15    0               00 
  15 IfNot            3   19    1               00 
REG[3] =  i:1
  16 Column           2    0    7               00 r[7]=t0.c0
REG[7] =  i:1
  17 Column           2    1    8               00 r[8]=t0.c1
REG[8] =  i:2
  18 ResultRow        7    2    0               00 output=r[7..8]
REG[7] =  i:1
REG[8] =  i:2
  19 Prev             2    9    0               00 
   9 IdxLE            2   20    1 1             00 key=r[1]
REG[1] =  NULL
  10 Column           2    0    4               00 r[4]=t0.c0
REG[4] =  i:1
  11 Lt               5    3    4 (BINARY)      61 r[3] = (r[4]<r[5])
REG[5] =  i:5
REG[4] =  i:1
REG[3] =  i:1
  12 ElseNotEq        0   15    0               00 
  15 IfNot            3   19    1               00 
REG[3] =  i:1
  16 Column           2    0    7               00 r[7]=t0.c0
REG[7] =  i:1
  17 Column           2    1    8               00 r[8]=t0.c1
REG[8] =  i:1
  18 ResultRow        7    2    0               00 output=r[7..8]
REG[7] =  i:1
REG[8] =  i:1
  19 Prev             2    9    0               00 
  20 Halt             0    0    0               00 
SQL: [;
;SELECT * FROM b WHERE (3,0)<=(c,t1a) ORDER BY c;]
VDBE Trace:
   0 Init             0   25    0               00 Start at 25
  25 Transaction      0    0   12 0             01 usesStmtJournal=0
  26 Integer          3    3    0               00 r[3]=3
REG[3] =  i:3
  27 Integer          0    4    0               00 r[4]=0
REG[4] =  i:0
  28 Goto             0    1    0               00 
   1 SorterOpen       1    4    0 k(1,B)        00 
   2 OpenRead         0    5    0 2             00 root=5 iDb=0; b
   3 Explain          3    0    0 SCAN TABLE b  00 
   4 Rewind           0   16    0               00 
  16 Explain         16    0    0 USE TEMP B-TREE FOR ORDER BY 00 
  17 OpenPseudo       2    9    4               00 4 columns in r[9]
  18 SorterSort       1   24    0               00 
  24 Halt             0    0    0               00 
SQL: [;
;SELECT * FROM t0 WHERE (3,0)>(c0,c1) ORDER BY c0 DESC;]
VDBE Trace:
   0 Init             0   21    0               00 Start at 21
  21 Transaction      0    0   12 0             01 usesStmtJournal=0
  22 Integer          3    5    0               00 r[5]=3
REG[5] =  i:3
  23 Integer          0    6    0               00 r[6]=0
REG[6] =  i:0
  24 Goto             0    1    0               00 
   1 Noop             1    4    0               00 
   2 OpenRead         2    4    0 k(6,,,,,,)    00 root=4 iDb=0; a
   3 Explain          3    0    0 SEARCH TABLE t0 USING COVERING INDEX a ((c0,c1)<(?,?)) 00 
   4 Integer          3    1    0               00 r[1]=3
REG[1] =  i:3
   5 Integer          0    2    0               00 r[2]=0
REG[2] =  i:0
   6 IsNull           1   20    0               00 if r[1]==NULL goto 20
REG[1] =  i:3
   7 SeekLE           2   20    1 2             00 key=r[1..2]
REG[1] =  i:3
   8 Null             0    1    0               00 r[1]=NULL
REG[1] =  NULL
   9 IdxLE            2   20    1 1             00 key=r[1]
REG[1] =  NULL
  10 Column           2    0    4               00 r[4]=t0.c0
REG[4] =  i:1
  11 Lt               5    3    4 (BINARY)      61 r[3] = (r[4]<r[5])
REG[5] =  i:3
REG[4] =  i:1
REG[3] =  i:1
  12 ElseNotEq        0   15    0               00 
  15 IfNot            3   19    1               00 
REG[3] =  i:1
  16 Column           2    0    7               00 r[7]=t0.c0
REG[7] =  i:1
  17 Column           2    1    8               00 r[8]=t0.c1
REG[8] =  i:2
  18 ResultRow        7    2    0               00 output=r[7..8]
REG[7] =  i:1
REG[8] =  i:2
  19 Prev             2    9    0               00 
   9 IdxLE            2   20    1 1             00 key=r[1]
REG[1] =  NULL
  10 Column           2    0    4               00 r[4]=t0.c0
REG[4] =  i:1
  11 Lt               5    3    4 (BINARY)      61 r[3] = (r[4]<r[5])
REG[5] =  i:3
REG[4] =  i:1
REG[3] =  i:1
  12 ElseNotEq        0   15    0               00 
  15 IfNot            3   19    1               00 
REG[3] =  i:1
  16 Column           2    0    7               00 r[7]=t0.c0
REG[7] =  i:1
  17 Column           2    1    8               00 r[8]=t0.c1
REG[8] =  i:1
  18 ResultRow        7    2    0               00 output=r[7..8]
REG[7] =  i:1
REG[8] =  i:1
  19 Prev             2    9    0               00 
  20 Halt             0    0    0               00 
SQL: [;
;SELECT * FROM b WHERE (3,0)>=(t1a,t1a) ORDER BY t1a DESC;]
VDBE Trace:
   0 Init             0   25    0               00 Start at 25
  25 Transaction      0    0   12 0             01 usesStmtJournal=0
  26 Integer          3    3    0               00 r[3]=3
REG[3] =  i:3
  27 Integer          0    4    0               00 r[4]=0
REG[4] =  i:0
  28 Goto             0    1    0               00 
   1 SorterOpen       1    4    0 k(1,-B)       00 
   2 OpenRead         0    5    0 2             00 root=5 iDb=0; b
   3 Explain          3    0    0 SCAN TABLE b  00 
   4 Rewind           0   16    0               00 
  16 Explain         16    0    0 USE TEMP B-TREE FOR ORDER BY 00 
  17 OpenPseudo       2    9    4               00 4 columns in r[9]
  18 SorterSort       1   24    0               00 
  24 Halt             0    0    0               00 
SQL: [;
;SELECT * FROM b WHERE (3,32)<(t1a,c) ORDER BY t1a;]
VDBE Trace:
   0 Init             0   25    0               00 Start at 25
  25 Transaction      0    0   12 0             01 usesStmtJournal=0
  26 Integer          3    3    0               00 r[3]=3
REG[3] =  i:3
  27 Integer         32    4    0               00 r[4]=32
REG[4] =  i:32
  28 Goto             0    1    0               00 
   1 SorterOpen       1    4    0 k(1,B)        00 
   2 OpenRead         0    5    0 2             00 root=5 iDb=0; b
   3 Explain          3    0    0 SCAN TABLE b  00 
   4 Rewind           0   16    0               00 
  16 Explain         16    0    0 USE TEMP B-TREE FOR ORDER BY 00 
  17 OpenPseudo       2    9    4               00 4 columns in r[9]
  18 SorterSort       1   24    0               00 
  24 Halt             0    0    0               00 
SQL: [;
;SELECT * FROM t2def WHERE (3,33)<=(x,x) ORDER BY x;]
VDBE Trace:
   0 Init             0   25    0               00 Start at 25
  25 Transaction      0    0   12 0             01 usesStmtJournal=0
  26 Integer          3    3    0               00 r[3]=3
REG[3] =  i:3
  27 Integer         33    4    0               00 r[4]=33
REG[4] =  i:33
  28 Goto             0    1    0               00 
   1 SorterOpen       1    4    0 k(1,B)        00 
   2 OpenRead         0    8    0 2             00 root=8 iDb=0; t2def
   3 Explain          3    0    0 SCAN TABLE t2def 00 
   4 Rewind           0   16    0               00 
  16 Explain         16    0    0 USE TEMP B-TREE FOR ORDER BY 00 
  17 OpenPseudo       2    9    4               00 4 columns in r[9]
  18 SorterSort       1   24    0               00 
  24 Halt             0    0    0               00 
SQL: [;
;SELECT * FROM t1bc WHERE (3,34)<=(d,t2) ORDER BY d;]
VDBE Trace:
   0 Init             0   25    0               00 Start at 25
  25 Transaction      0    0   12 0             01 usesStmtJournal=0
  26 Integer          3    3    0               00 r[3]=3
REG[3] =  i:3
  27 Integer         34    4    0               00 r[4]=34
REG[4] =  i:34
  28 Goto             0    1    0               00 
   1 SorterOpen       1    4    0 k(1,B)        00 
   2 OpenRead         0    6    0 2             00 root=6 iDb=0; t1bc
   3 Explain          3    0    0 SCAN TABLE t1bc 00 
   4 Rewind           0   16    0               00 
   5 Column           0    1    2               00 r[2]=t1bc.d
REG[2] =  i:1
   6 Gt               3    1    2 (BINARY)      61 r[1] = (r[2]>r[3])
REG[3] =  i:3
REG[2] =  i:1
REG[1] =  i:0
   7 ElseNotEq        0   10    0               00 
  10 IfNot            1   15    1               00 
REG[1] =  i:0
  15 Next             0    5    0               01 
  16 Explain         16    0    0 USE TEMP B-TREE FOR ORDER BY 00 
  17 OpenPseudo       2    9    4               00 4 columns in r[9]
  18 SorterSort       1   24    0               00 
  24 Halt             0    0    0               00 
SQL: [;
;SELECT * FROM t1bc WHERE (3,34)>(d,t2) ORDER BY d DESC;]
VDBE Trace:
   0 Init             0   25    0               00 Start at 25
  25 Transaction      0    0   12 0             01 usesStmtJournal=0
  26 Integer          3    3    0               00 r[3]=3
REG[3] =  i:3
  27 Integer         34    4    0               00 r[4]=34
REG[4] =  i:34
  28 Goto             0    1    0               00 
   1 SorterOpen       1    4    0 k(1,-B)       00 
   2 OpenRead         0    6    0 2             00 root=6 iDb=0; t1bc
   3 Explain          3    0    0 SCAN TABLE t1bc 00 
   4 Rewind           0   16    0               00 
   5 Column           0    1    2               00 r[2]=t1bc.d
REG[2] =  i:1
   6 Lt               3    1    2 (BINARY)      61 r[1] = (r[2]<r[3])
REG[3] =  i:3
REG[2] =  i:1
REG[1] =  i:1
   7 ElseNotEq        0   10    0               00 
  10 IfNot            1   15    1               00 
REG[1] =  i:1
  11 Rowid            0    6    0               00 r[6]=rowid
REG[6] =  i:7
  12 Column           0    1    5               00 r[5]=t1bc.d
REG[5] =  i:1
  13 MakeRecord       5    2    8               00 r[8]=mkrec(r[5..6])
REG[8] =  s4[03090107....]
  14 SorterInsert     1    8    5 2             00 key=r[8]
REG[8] =  s4[03090107....]
  15 Next             0    5    0               01 
  16 Explain         16    0    0 USE TEMP B-TREE FOR ORDER BY 00 
  17 OpenPseudo       2    9    4               00 4 columns in r[9]
  18 SorterSort       1   24    0               00 
  19 SorterData       1    9    2               00 r[9]=data
  20 Column           2    0    7               00 r[7]=d
REG[7] =  i:1
  21 Column           2    1    6               00 r[6]=t2
REG[6] =  i:7
  22 ResultRow        6    2    0               00 output=r[6..7]
REG[6] =  i:7
REG[7] =  i:1
  23 SorterNext       1   19    0               00 
  24 Halt             0    0    0               00 
SQL: [;
;SELECT * FROM t1bc WHERE (3,33)>=(d,t2) ORDER BY d DESC;]
VDBE Trace:
   0 Init             0   25    0               00 Start at 25
  25 Transaction      0    0   12 0             01 usesStmtJournal=0
  26 Integer          3    3    0               00 r[3]=3
REG[3] =  i:3
  27 Integer         33    4    0               00 r[4]=33
REG[4] =  i:33
  28 Goto             0    1    0               00 
   1 SorterOpen       1    4    0 k(1,-B)       00 
   2 OpenRead         0    6    0 2             00 root=6 iDb=0; t1bc
   3 Explain          3    0    0 SCAN TABLE t1bc 00 
   4 Rewind           0   16    0               00 
   5 Column           0    1    2               00 r[2]=t1bc.d
REG[2] =  i:1
   6 Lt               3    1    2 (BINARY)      61 r[1] = (r[2]<r[3])
REG[3] =  i:3
REG[2] =  i:1
REG[1] =  i:1
   7 ElseNotEq        0   10    0               00 
  10 IfNot            1   15    1               00 
REG[1] =  i:1
  11 Rowid            0    6    0               00 r[6]=rowid
REG[6] =  i:7
  12 Column           0    1    5               00 r[5]=t1bc.d
REG[5] =  i:1
  13 MakeRecord       5    2    8               00 r[8]=mkrec(r[5..6])
REG[8] =  s4[03090107....]
  14 SorterInsert     1    8    5 2             00 key=r[8]
REG[8] =  s4[03090107....]
  15 Next             0    5    0               01 
  16 Explain         16    0    0 USE TEMP B-TREE FOR ORDER BY 00 
  17 OpenPseudo       2    9    4               00 4 columns in r[9]
  18 SorterSort       1   24    0               00 
  19 SorterData       1    9    2               00 r[9]=data
  20 Column           2    0    7               00 r[7]=d
REG[7] =  i:1
  21 Column           2    1    6               00 r[6]=t2
REG[6] =  i:7
  22 ResultRow        6    2    0               00 output=r[6..7]
REG[6] =  i:7
REG[7] =  i:1
  23 SorterNext       1   19    0               00 
  24 Halt             0    0    0               00 
SQL: [;
;SELECT * FROM t2def WHERE (3,32)>=(x,t3) ORDER BY x DESC;]
VDBE Trace:
   0 Init             0   25    0               00 Start at 25
  25 Transaction      0    0   12 0             01 usesStmtJournal=0
  26 Integer          3    3    0               00 r[3]=3
REG[3] =  i:3
  27 Integer         32    4    0               00 r[4]=32
REG[4] =  i:32
  28 Goto             0    1    0               00 
   1 SorterOpen       1    4    0 k(1,-B)       00 
   2 OpenRead         0    8    0 2             00 root=8 iDb=0; t2def
   3 Explain          3    0    0 SCAN TABLE t2def 00 
   4 Rewind           0   16    0               00 
  16 Explain         16    0    0 USE TEMP B-TREE FOR ORDER BY 00 
  17 OpenPseudo       2    9    4               00 4 columns in r[9]
  18 SorterSort       1   24    0               00 
  24 Halt             0    0    0               00 
SQL: [;INSERT INTO t2def VALUES(1,2),(3,4),(5,6);]
VDBE Trace:
   0 Init             0   30    0               00 Start at 30
  30 Transaction      0    1   12 0             01 usesStmtJournal=1
  31 Goto             0    1    0               00 
   1 InitCoroutine    4   13    2               00 
  13 OpenWrite        0    8    0 2             00 root=8 iDb=0; t2def
  14 OpenWrite        1    9    0 k(3,,,)       00 root=9 iDb=0; sqlite_autoindex_t2def_1
  15 Yield            4   29    0               00 
REG[4] =  i:1
REG[4] =  i:15
   2 Explain          2    0    0 SCAN 3 CONSTANT ROWS 00 
   3 Integer          1    2    0               00 r[2]=1
REG[2] =  i:1
   4 Integer          2    3    0               00 r[3]=2
REG[3] =  i:2
   5 Yield            4    0    0               00 
REG[4] =  i:15
REG[4] =  i:5
  16 NewRowid         0    1    0               00 r[1]=rowid
REG[1] =  i:1
  17 Noop             0    0    0               00 uniqueness check for sqlite_autoindex_t2def_1
  18 SCopy            2    6    0               00 r[6]=r[2]; t3
REG[6] =  i:1
  19 SCopy            3    7    0               00 r[7]=r[3]; x
REG[7] =  i:2
  20 IntCopy          1    8    0               00 r[8]=r[1]; rowid
REG[8] =  i:1
  21 MakeRecord       6    3    5               00 r[5]=mkrec(r[6..8]); for sqlite_autoindex_t2def_1
REG[5] =  s5[0409010902.....]
  22 Abortable        0    0    0               00 
  23 NoConflict       1   25    6 2             00 key=r[6..7]
REG[6] =  i:1
REG[7] =  i:2
  25 IdxInsert        1    5    6 3             10 key=r[5]
REG[5] =  s5[0409010902.....]
  26 MakeRecord       2    2    9               00 r[9]=mkrec(r[2..3])
REG[9] =  s4[03090102....]
  27 Insert           0    9    1 t2def         39 intkey=r[1] data=r[9]
REG[9] =  s4[03090102....]
REG[1] =  i:1
  28 Goto             0   15    0               00 
  15 Yield            4   29    0               00 
REG[4] =  i:5
REG[4] =  i:15
   6 Integer          3    2    0               00 r[2]=3
REG[2] =  i:3
   7 Integer          4    3    0               00 r[3]=4
REG[3] =  i:4
   8 Yield            4    0    0               00 
REG[4] =  i:15
REG[4] =  i:8
  16 NewRowid         0    1    0               00 r[1]=rowid
REG[1] =  i:2
  17 Noop             0    0    0               00 uniqueness check for sqlite_autoindex_t2def_1
  18 SCopy            2    6    0               00 r[6]=r[2]; t3
REG[6] =  i:3
  19 SCopy            3    7    0               00 r[7]=r[3]; x
REG[7] =  i:4
  20 IntCopy          1    8    0               00 r[8]=r[1]; rowid
REG[8] =  i:2
  21 MakeRecord       6    3    5               00 r[5]=mkrec(r[6..8]); for sqlite_autoindex_t2def_1
REG[5] =  s7[04010101030402.......]
  22 Abortable        0    0    0               00 
  23 NoConflict       1   25    6 2             00 key=r[6..7]
REG[6] =  i:3
REG[7] =  i:4
  25 IdxInsert        1    5    6 3             10 key=r[5]
REG[5] =  s7[04010101030402.......]
  26 MakeRecord       2    2    9               00 r[9]=mkrec(r[2..3])
REG[9] =  s5[0301010304.....]
  27 Insert           0    9    1 t2def         39 intkey=r[1] data=r[9]
REG[9] =  s5[0301010304.....]
REG[1] =  i:2
  28 Goto             0   15    0               00 
  15 Yield            4   29    0               00 
REG[4] =  i:8
REG[4] =  i:15
   9 Integer          5    2    0               00 r[2]=5
REG[2] =  i:5
  10 Integer          6    3    0               00 r[3]=6
REG[3] =  i:6
  11 Yield            4    0    0               00 
REG[4] =  i:15
REG[4] =  i:11
  16 NewRowid         0    1    0               00 r[1]=rowid
REG[1] =  i:3
  17 Noop             0    0    0               00 uniqueness check for sqlite_autoindex_t2def_1
  18 SCopy            2    6    0               00 r[6]=r[2]; t3
REG[6] =  i:5
  19 SCopy            3    7    0               00 r[7]=r[3]; x
REG[7] =  i:6
  20 IntCopy          1    8    0               00 r[8]=r[1]; rowid
REG[8] =  i:3
  21 MakeRecord       6    3    5               00 r[5]=mkrec(r[6..8]); for sqlite_autoindex_t2def_1
REG[5] =  s7[04010101050603.......]
  22 Abortable        0    0    0               00 
  23 NoConflict       1   25    6 2             00 key=r[6..7]
REG[6] =  i:5
REG[7] =  i:6
  25 IdxInsert        1    5    6 3             10 key=r[5]
REG[5] =  s7[04010101050603.......]
  26 MakeRecord       2    2    9               00 r[9]=mkrec(r[2..3])
REG[9] =  s5[0301010506.....]
  27 Insert           0    9    1 t2def         39 intkey=r[1] data=r[9]
REG[9] =  s5[0301010506.....]
REG[1] =  i:3
  28 Goto             0   15    0               00 
  15 Yield            4   29    0               00 
REG[4] =  i:11
REG[4] =  i:15
  12 EndCoroutine     4    0    0               00 
REG[4] =  i:15
  29 Halt             0    0    0               00 
SQL: [;SELECT * FROM t1bc WHERE (d,d) IN (VALUES(1,2));]
VDBE Trace:
   0 Init             0   26    0               00 Start at 26
  26 Transaction      0    0   12 0             01 usesStmtJournal=0
  27 Goto             0    1    0               00 
   1 OpenRead         0    6    0 2             00 root=6 iDb=0; t1bc
   2 Explain          2    0    0 SCAN TABLE t1bc 00 
   3 Rewind           0   25    0               00 
   4 Noop             0    0    0               00 begin IN expr
   5 Integer         14    1    0               00 r[1]=14; return address
REG[1] =  i:14
   6 Once             0   14    0               00 
   7 OpenEphemeral    1    2    0 k(2,B,B)      00 nColumn=2; Result of SELECT 1
   8 Explain          8    0    0 LIST SUBQUERY 1 00 
   9 Explain          9    8    0 SCAN CONSTANT ROW 00 
  10 Integer          1    2    0               00 r[2]=1
REG[2] =  i:1
  11 Integer          2    3    0               00 r[3]=2
REG[3] =  i:2
  12 MakeRecord       2    2    4 AA            00 r[4]=mkrec(r[2..3])
REG[4] =  s4[03090102....]
  13 IdxInsert        1    4    2 2             00 key=r[4]
REG[4] =  s4[03090102....]
  14 Return           1    0    0               00 
REG[1] =  i:14
  15 Column           0    1    5               00 r[5]=t1bc.d
REG[5] =  i:1
  16 Column           0    1    6               00 r[6]=t1bc.d
REG[6] =  i:1
  17 IsNull           5   24    0               00 if r[5]==NULL goto 24
REG[5] =  i:1
  18 IsNull           6   24    0               00 if r[6]==NULL goto 24
REG[6] =  i:1
  19 Affinity         5    2    0 AA            00 affinity(r[5..6])
  20 NotFound         1   24    5 2             00 key=r[5..6]; end IN expr
REG[5] =  i:1
REG[6] =  i:1
  24 Next             0    4    0               01 
  25 Halt             0    0    0               00 

Program received signal SIGABRT, Aborted.
__GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:50
(gdb) #0  __GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:50
#1  0x00007f676dbbe859 in __GI_abort () at abort.c:79
#2  0x00007f676dbbe729 in __assert_fail_base (fmt=0x7f676dd54588 "%s%s%s:%u: %s%sAssertion `%s' failed.\n%n", assertion=0x2122b4 "pIn->nSdst==1 || pParse->nErr>0", file=0x22873d "sqlite3.c", line=127594, 
    function=<optimized out>) at assert.c:92
#3  0x00007f676dbcffd6 in __GI___assert_fail (assertion=0x2122b4 "pIn->nSdst==1 || pParse->nErr>0", file=0x22873d "sqlite3.c", line=127594, 
    function=0x213784 "int generateOutputSubroutine(Parse *, Select *, SelectDest *, SelectDest *, int, int, KeyInfo *, int)") at assert.c:101
#4  0x00000000003b5d8b in generateOutputSubroutine (pParse=0x7fff0249e360, p=0xf0e0e0, pIn=0x7fff0249c9e0, pDest=0x7fff0249cf38, regReturn=15, regPrev=9, pKeyInfo=0xefe870, iBreak=-7) at sqlite3.c:127594
#5  0x00000000003b4e37 in multiSelectOrderBy (pParse=0x7fff0249e360, p=0xf0e0e0, pDest=0x7fff0249cf38) at sqlite3.c:127921
#6  0x00000000003a3d1c in multiSelect (pParse=0x7fff0249e360, p=0xf0e0e0, pDest=0x7fff0249cf38) at sqlite3.c:127207
#7  0x00000000002fccf5 in sqlite3Select (pParse=0x7fff0249e360, p=0xf0e0e0, pDest=0x7fff0249cf38) at sqlite3.c:130384
#8  0x000000000034f659 in sqlite3CodeSubselect (pParse=0x7fff0249e360, pExpr=0xf04f90) at sqlite3.c:99820
#9  0x0000000000350b1c in exprCodeVector (pParse=0x7fff0249e360, p=0xf04f90, piFreeable=0x7fff0249cffc) at sqlite3.c:100296
#10 0x000000000034fbdb in sqlite3ExprCodeIN (pParse=0x7fff0249e360, pExpr=0xefa220, destIfFalse=-3, destIfNull=-4) at sqlite3.c:99952
#11 0x000000000034be9e in sqlite3ExprCodeTarget (pParse=0x7fff0249e360, pExpr=0xefa220, target=1) at sqlite3.c:100792
#12 0x000000000034e9ee in sqlite3ExprCodeExprList (pParse=0x7fff0249e360, pList=0xefdf10, target=1, srcReg=0, flags=1 '\001') at sqlite3.c:101202
#13 0x00000000003addca in innerLoopLoadRow (pParse=0x7fff0249e360, pSelect=0xf03370, pInfo=0x7fff0249d3a0) at sqlite3.c:125172
#14 0x00000000003a92ea in selectInnerLoop (pParse=0x7fff0249e360, p=0xf03370, srcTab=-1, pSort=0x0, pDistinct=0x7fff0249d640, pDest=0x7fff0249d750, iContinue=-2, iBreak=-2) at sqlite3.c:125624
#15 0x00000000002fe191 in sqlite3Select (pParse=0x7fff0249e360, p=0xf03370, pDest=0x7fff0249d750) at sqlite3.c:130743
#16 0x00000000002ecaa8 in yy_reduce (yypParser=0x7fff0249d980, yyruleno=79, yyLookahead=1, yyLookaheadToken=..., pParse=0x7fff0249e360) at sqlite3.c:151581
#17 0x00000000002e92f8 in sqlite3Parser (yyp=0x7fff0249d980, yymajor=1, yyminor=...) at sqlite3.c:152877
#18 0x00000000002a68b3 in sqlite3RunParser (pParse=0x7fff0249e360, 
    zSql=0xf0c050 ";;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;\n;DROP TABLE IF EXISTS t0;;SELECT 2 FROM t2def WHERE (+x,1) >= (t3,1);;\n;SELECT (SELECT +t2,1) >= (d, 1), (d,1)<=(SELECT +t2,1) "..., pzErrMsg=0x7fff0249e540) at sqlite3.c:154013
#19 0x00000000002a1683 in sqlite3Prepare (db=0xeee5a0, 
    zSql=0xef1396 ";SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;\n;DROP TABLE IF EXISTS t0;;SELECT 2 FROM t2def WHERE (+x,1) >= ("..., nBytes=766, prepFlags=128, pReprepare=0x0, ppStmt=0x7fff0249e678, pzTail=0x7fff0249e660) at sqlite3.c:124303
#20 0x00000000002a0d4e in sqlite3LockAndPrepare (db=0xeee5a0, 
    zSql=0xef1396 ";SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;\n;DROP TABLE IF EXISTS t0;;SELECT 2 FROM t2def WHERE (+x,1) >= ("..., nBytes=766, prepFlags=128, pOld=0x0, ppStmt=0x7fff0249e678, pzTail=0x7fff0249e660) at sqlite3.c:124403
#21 0x000000000029247f in sqlite3_prepare_v2 (db=0xeee5a0, 
    zSql=0xef1396 ";SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1) IN (SELECT 3,4);;SELECT (SELECT 5,6 UNION SELECT 3,4 ORDER BY 1 DESC) IN (SELECT 3,4);;\n;DROP TABLE IF EXISTS t0;;SELECT 2 FROM t2def WHERE (+x,1) >= ("..., nBytes=766, ppStmt=0x7fff0249e678, pzTail=0x7fff0249e660) at sqlite3.c:124487
#22 0x0000000000256bd0 in main (argc=1, argv=0x7fff0249e828) at target.cc:106
(gdb) quit
A debugging session is active.

	Inferior 1 [process 53831] will be killed.

Quit anyway? (y or n) [answered Y; input not from terminal]
